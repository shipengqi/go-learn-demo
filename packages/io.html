<!DOCTYPE html>
<html lang="en">
  <head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">

    <title>Golang learning |  </title>
    <meta name="description" content>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    

    <!-- fonts -->
    <link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700" rel="stylesheet">
    <link href="//fonts.googleapis.com/css?family=Ubuntu:300,400,500,600,700" rel="stylesheet">

    <!-- stylesheets -->
    <link rel="stylesheet" href="/golang-learn/style/doc.css">

    <!-- favicon -->
    <link rel="icon" href="/golang-learn/images/favicon.ico">

    

  </head>
  <body>

   <script>window.__INITIAL_STATE__ = {"page":{"path":"packages/io.html","title":""},"data":{"navigation":{"logo":{"text":"Golang Learn","type":"link","path":"index.html"},"main":[{"text":"Golang 基础","type":"label"},{"text":"Go 环境配置","type":"link","path":"basic/env_config.html"},{"text":"包","type":"link","path":"basic/package.html"},{"text":"基础数据类型","type":"link","path":"basic/basic_data.html"},{"text":"变量","type":"link","path":"basic/var.html"},{"text":"常量","type":"link","path":"basic/constant.html"},{"text":"控制语句","type":"link","path":"basic/flow.html"},{"text":"运算符","type":"link","path":"basic/operator.html"},{"text":"作用域","type":"link","path":"basic/scope.html"},{"text":"指针","type":"link","path":"basic/pointer.html"},{"text":"数组","type":"link","path":"basic/array.html"},{"text":"切片","type":"link","path":"basic/slice.html"},{"text":"字典","type":"link","path":"basic/map.html"},{"text":"函数","type":"link","path":"basic/function.html"},{"text":"结构体","type":"link","path":"basic/struct.html"},{"text":"接口","type":"link","path":"basic/interface.html"},{"text":"面向对象","type":"link","path":"basic/oop.html"},{"text":"错误","type":"link","path":"basic/error.html"},{"text":"序列化","type":"link","path":"basic/json.html"},{"text":"反射","type":"link","path":"basic/reflect.html"},{"text":"测试","type":"link","path":"basic/test.html"},{"text":"并发编程","type":"label"},{"text":"goroutine","type":"link","path":"concurrent/goroutine.html"},{"text":"channel","type":"link","path":"concurrent/channel.html"},{"text":"同步和锁","type":"link","path":"concurrent/sync_lock.html"},{"text":"内存分配","type":"label"},{"text":"内存分配","type":"link","path":"advance/mm.html"},{"text":"垃圾回收","type":"label"},{"text":"垃圾回收","type":"link","path":"advance/gc.html"},{"text":"THEME","type":"label"},{"text":"使用文档主题","type":"link","path":"theme/theme-usage.html"},{"text":"SUPPORT AND FEEDBACK","type":"label"},{"text":"Raise an Issue on Github","type":"link","path":"https://github.com/shipengqi/golang-learn/issues/new"}]}},"config":{"timezone":"UTC","root":"/golang-learn/","time_format":"HH:mm:ss","theme":"../node_modules/hexo-theme-doc","theme_config":{"swagger_ui":{"version":2,"permalinks":true,"api_explorer":true,"download":"Download specification","show_extensions":false,"deep_linking":true,"display_operation_id":false,"doc_expansion":"none"},"search":{"skip":false,"background":false,"route":"/lunr.json"},"favicon":"images/favicon.ico"}}}</script>

    <div id="react-navigation-root"><div class="doc-navigation" data-reactroot><nav class="doc-navbar"><a href="/golang-learn/index.html" class="doc-navbar__logo"><img src="/golang-learn/images/logo.png" class="doc-navbar__logo__img"><span class="doc-navbar__logo__text">Golang Learn</span></a><i class="dc-icon dc-icon--close dc-icon--interactive doc-sidebar-close doc-navbar__sidebar-close doc-navbar__sidebar-close--desktop"></i><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-navbar__sidebar-toggle"></i></nav><nav class="doc-sidebar"><div class="doc-sidebar__vertical-menu"><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-sidebar-toggle--primary doc-sidebar__vertical-menu__item"></i><i class="dc-icon dc-icon--search dc-icon--interactive doc-sidebar__vertical-menu__item doc-sidebar__vertical-menu__item--primary"></i></div><div class="doc-sidebar-content"><div class="doc-sidebar__search-form"></div><ul class="doc-sidebar-list"></ul></div></nav></div></div>
    <div class="doc-content">
  <div class="dc-page">
    <div class="dc-card">
      <div id="react-search-results-root"></div>
      <div id="page-content" class="doc-formatting">
        <h2 id="io包中的接口和工具"><a href="#io包中的接口和工具" class="headerlink" title="io包中的接口和工具"></a>io包中的接口和工具</h2><p><code>strings.Reader</code>类型主要用于读取字符串，它的指针类型实现的接口比较多，包括：</p>
<ul>
<li>io.Reader；</li>
<li>io.ReaderAt；</li>
<li>io.ByteReader；</li>
<li>io.RuneReader；</li>
<li>io.Seeker；</li>
<li>io.ByteScanner；</li>
<li>io.RuneScanner；</li>
<li>io.WriterTo；</li>
</ul>
<p><code>io.ByteScanner</code>是<code>io.ByteReader</code>的扩展接口，而<code>io.RuneScanner</code>又是<code>io.RuneReader</code>的扩展接口。</p>
<p><code>bytes.Buffer</code>该指针类型实现的读取相关的接口有下面几个：</p>
<ul>
<li>io.Reader；</li>
<li>io.ByteReader；</li>
<li>io.RuneReader；</li>
<li>io.ByteScanner；</li>
<li>io.RuneScanner；</li>
<li>io.WriterTo；</li>
</ul>
<p>实现的写入相关的接口：</p>
<ul>
<li>io.Writer；</li>
<li>io.ByteWriter；</li>
<li>io.stringWriter；</li>
<li>io.ReaderFrom；</li>
</ul>
<p>这些类型实现了这么多的接口，目的是什么？</p>
<p>为了提高不同程序实体之间的互操作性。以io包中的一些函数为例。</p>
<p>io包中，有这样几个用于拷贝数据的函数，它们是：<code>io.Copy</code>、<code>io.CopyBuffer</code>和<code>io.CopyN</code>。这几个函数在功能上都略有差别，但是它们都首先会接受两个参数，即：<br>用于代表<strong>数据目的地、<code>io.Writer</code>类型的参数<code>dst</code></strong>，以及用于代表<strong>数据来源的、<code>io.Reader</code>类型的参数<code>src</code></strong>。大致上都是把数据从<code>src</code>拷贝到<code>dst</code>。</p>
<p><strong>不论第一个参数值是什么类型的，只要这个类型实现了<code>io.Writer</code>接口即可</strong>。同样的第二个参数值只要该类型实现了<code>io.Reader</code>接口就行。</p>
<p>很多数据类型实现了<code>io.Reader</code>接口，是因为它们提供了从某处读取数据的功能。类似的，许多能够把数据写入某处的数据类型，也都会去实现<code>io.Writer</code>接口。</p>
<h3 id="io-Reader的扩展接口和实现类型"><a href="#io-Reader的扩展接口和实现类型" class="headerlink" title="io.Reader的扩展接口和实现类型"></a>io.Reader的扩展接口和实现类型</h3><p><code>io.Reader</code>的扩展接口：</p>
<ul>
<li><code>io.ReadWriter</code>：此接口既是<code>io.Reader</code>的扩展接口，也是<code>io.Writer</code>的扩展接口。</li>
<li><code>io.ReadCloser</code>：此接口除了包含基本的字节序列读取方法之外，还拥有一个基本的关闭方法<code>Close</code>。后者一般用于关闭数据读写的通路。这个接口其实是<code>io.Reader</code>接口和<code>io.Closer</code>接口的组合。</li>
<li><code>io.ReadWriteCloser</code>：<code>io.Reader</code>、<code>io.Writer</code>和<code>io.Closer</code>这三个接口的组合。</li>
<li><code>io.ReadSeeker</code>：此接口的特点是拥有一个用于寻找读写位置的基本方法<code>Seek</code>。更具体地说，该方法可以根据给定的偏移量基于数据的起始位置、末尾位置，或者当前读写<br>位置去寻找新的读写位置。这个新的读写位置用于表明下一次读或写时的起始索引。<code>Seek</code>是<code>io.Seeker</code>接口唯一拥有的方法。</li>
<li><code>io.ReadWriteSeeker</code>：<code>io.Reader</code>、<code>io.Writer</code>和<code>io.Seeker</code>的组合。</li>
</ul>
<p><code>io.Reader</code>接口的实现类型：</p>
<ul>
<li><code>*io.LimitedReader</code>：此类型的基本类型会包装<code>io.Reader</code>类型的值，并提供一个额外的受限读取的功能。。</li>
<li><code>*io.SectionReader</code>：此类型的基本类型可以包装<code>io.ReaderAt</code>类型的值，并且会限制它的<code>Read</code>方法，只能够读取原始数据中的某一个部分（或者说某一段）。</li>
<li><code>*io.teeReader</code>：此类型是一个包级私有的数据类型，也是io.TeeReader函数结果值的实际类型。这个函数接受两个参数r和w，类型分别是<code>io.Reader</code>和<code>io.Writer</code>。</li>
<li><code>io.multiReader</code>：此类型也是一个包级私有的数据类型。类似的，io包中有一个名为<code>MultiReader</code>的函数，它可以接受若干个<code>io.Reader</code>类型的参数值，并返回一个实<br>际类型为<code>io.multiReader</code>的结果值。</li>
<li><code>io.pipe</code>：此类型为一个包级私有的数据类型，它比上述类型都要复杂得多。它不但实现了<code>io.Reader</code>接口，而且还实现了<code>io.Writer</code>接口。<br>实际上，<code>io.PipeReader</code>类型和<code>io.PipeWriter</code>类型拥有的所有指针方法都是以它为基础的。这些方法都只是代理了<code>io.pipe</code>类型值所拥有的某一个方法而已。<br>又因为<code>io.Pipe</code>函数会返回这两个类型的指针值并分别把它们作为其生成的同步内存管道的两端，所以可以说，<code>*io.pipe</code>类型就是io包提供的同步内存管道的核心实现。</li>
<li><code>io.PipeReader</code>：此类型可以被视为<code>io.pipe</code>类型的代理类型。</li>
</ul>
<h2 id="bufio包中的数据类型"><a href="#bufio包中的数据类型" class="headerlink" title="bufio包中的数据类型"></a>bufio包中的数据类型</h2><p>bufio包中的数据类型主要有：</p>
<ul>
<li><code>Reader</code>；</li>
<li><code>Scanner</code>；</li>
<li><code>Writer</code>和<code>ReadWriter</code>。</li>
</ul>
<h3 id="bufio-Reader类型值中的缓冲区的作用"><a href="#bufio-Reader类型值中的缓冲区的作用" class="headerlink" title="bufio.Reader类型值中的缓冲区的作用"></a><code>bufio.Reader</code>类型值中的缓冲区的作用</h3><p>缓冲区其实就是一个<strong>数据存储中介，它介于底层读取器与读取方法及其调用方之间</strong>。所谓的底层读取器，就是在初始化此类值的时候传入的<code>io.Reader</code>类型的参数值。</p>
<p>Reader值的读取方法一般都会先从其所属值的缓冲区中读取数据。同时，在必要的时候，它们还会预先从底层读取器那里读出一部分数据，并暂存于缓冲区之中以备后用。</p>
<p>缓冲区的好处是，可以在大多数的时候降低读取方法的执行时间。</p>
<p><code>bufio.Reader</code>类型并不是开箱即用的，因为它包含了一些需要显式初始化的字段。一些字段：</p>
<ul>
<li><code>buf</code>：<code>[]byte</code>类型的字段，即字节切片，代表缓冲区。虽然它是切片类型的，但是其长度却会在初始化的时候指定，并在之后保持不变。</li>
<li><code>rd</code>：<code>io.Reader</code>类型的字段，代表底层读取器。缓冲区中的数据就是从这里拷贝来的。</li>
<li><code>r</code>：<code>int</code>类型的字段，代表对缓冲区进行下一次读取时的开始索引。我们可以称它为已读计数。</li>
<li><code>w</code>：<code>int</code>类型的字段，代表对缓冲区进行下一次写入时的开始索引。我们可以称之为已写计数。</li>
<li><code>err</code>：<code>error</code>类型的字段。它的值用于表示在从底层读取器获得数据时发生的错误。这里的值在被读取或忽略之后，该字段会被置为<code>nil</code>。</li>
<li><code>lastByte</code>：<code>int</code>类型的字段，用于记录缓冲区中最后一个被读取的字节。读回退时会用到它的值。</li>
<li><code>lastRuneSize</code>：<code>int</code>类型的字段，用于记录缓冲区中最后一个被读取的 Unicode 字符所占用的字节数。读回退的时候会用到它的值。这个字段只会在其所<br>属值的<code>ReadRune</code>方法中才会被赋予有意义的值。在其他情况下，它都会被置为<code>-1</code>。</li>
</ul>
<p>两个用于初始化<code>Reader</code>值的函数，分别叫<code>NewReader</code>和<code>NewReaderSize</code>，它们都会返回一个<code>*bufio.Reader</code>类型的值。</p>
<ul>
<li><code>NewReader</code>函数初始化的<code>Reade</code>r值会拥有一个默认尺寸的缓冲区。这个默认尺寸是 4096 个字节，即：4 KB。</li>
<li><code>NewReaderSize</code>函数则将缓冲区尺寸的决定权抛给了使用方。</li>
</ul>
<h3 id="bufio-Writer类型值中缓冲的数据什么时候会被写到它的底层写入器"><a href="#bufio-Writer类型值中缓冲的数据什么时候会被写到它的底层写入器" class="headerlink" title="bufio.Writer类型值中缓冲的数据什么时候会被写到它的底层写入器"></a>bufio.Writer类型值中缓冲的数据什么时候会被写到它的底层写入器</h3><p><code>bufio.Writer</code>类型的字段:</p>
<ul>
<li><code>err</code>：<code>error</code>类型的字段。它的值用于表示在向底层写入器写数据时发生的错误。</li>
<li><code>buf</code>：<code>[]byte</code>类型的字段，代表缓冲区。在初始化之后，它的长度会保持不变。</li>
<li><code>n</code>：<code>int</code>类型的字段，代表对缓冲区进行下一次写入时的开始索引。我们可以称之为已写计数。</li>
<li><code>wr</code>：<code>io.Writer</code>类型的字段，代表底层写入器。</li>
</ul>
<p><code>bufio.Writer</code>类型有一个名为<code>Flush</code>的方法，它的主要功能是把相应缓冲区中暂存的所有数据，都写到底层写入器中。数据一旦被写进底层写入器，该方法就会把它们<br>从缓冲区中删除掉。</p>
<p><code>bufio.Writer</code>类型值（以下简称Writer值）拥有的所有数据写入方法都会在必要的时候调用它的<code>Flush</code>方法。</p>
<p>比如，<code>Write</code>方法有时候会在把数据写进缓冲区之后，调用<code>Flush</code>方法，以便为后续的新数据腾出空间。<code>WriteString</code>方法的行为与之类似。</p>
<p><code>WriteByte</code>方法和<code>WriteRune</code>方法，都会在发现缓冲区中的可写空间不足以容纳新的字节，或 Unicode 字符的时候，调用<code>Flush</code>方法。</p>
<p>在<strong>通常情况下，只要缓冲区中的可写空间无法容纳需要写入的新数据，<code>Flush</code>方法就一定会被调用</strong>。</p>
<h3 id="bufio-Reader类型读取方法"><a href="#bufio-Reader类型读取方法" class="headerlink" title="bufio.Reader类型读取方法"></a>bufio.Reader类型读取方法</h3><p><code>bufio.Reader</code>类型拥有很多用于读取数据的指针方法，这里面有 4 个方法可以作为不同读取流程的代表，它们是：<code>Peek</code>、<code>Read</code>、<code>ReadSlice</code>和<code>ReadBytes</code>。</p>
<ul>
<li><code>Peek</code>方法的特点是即使读取了缓冲区中的数据，也不会更改已读计数的值。而<code>Read</code>方法会在参数值的长度过大，且缓冲区中已无未读字节时，跨过缓冲区并直接向底层读取器索要数据。<br><code>Peek</code>方法有一个鲜明的特点，那就是：即使它读取了缓冲区中的数据，也不会更改已读计数的值。</li>
<li><code>ReadSlice</code>方法会在缓冲区的未读部分中寻找给定的分隔符，并在必要时对缓冲区进行填充。如果在填满缓冲区之后仍然未能找到分隔符，那么该方法就会把整个缓冲区作为第一个结果值返回，<br>同时返回缓冲区已满的错误。</li>
<li><code>ReadBytes</code>方法会通过调用<code>ReadSlice</code>方法，一次又一次地填充缓冲区，并在其中寻找分隔符。除非发生了未预料到的错误或者找到了分隔符，否则这一过程将会一直进行下去。</li>
<li>Reader值的<code>ReadLine</code>方法会依赖于它的<code>ReadSlice</code>方法，而其<code>ReadString</code>方法则完全依赖于<code>ReadBytes</code>方法。</li>
</ul>
<p><strong><code>Peek</code>方法、<code>ReadSlice</code>方法和<code>ReadLine</code>方法都有可能会造成内容泄露。这主要是因为它们在正常的情况下都会返回直接基于缓冲区的字节切片</strong>。</p>

        <div id="react-support-footer-root"></div>
      </div>
    </div>
  </div>
</div>

    


    

    <!-- js vendors -->
    <script src="//code.jquery.com/jquery-3.2.1.min.js" crossorigin="anonymous"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/lunr.js/2.1.0/lunr.min.js"></script>

    <!-- js source  -->
    <script src="/golang-learn/script/doc.js"></script>

    

  </body>
</html>
