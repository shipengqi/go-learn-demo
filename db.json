{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/images/logo.png","path":"images/logo.png","modified":1,"renderable":0},{"_id":"source/imgs/goroutine-scheduler-model.png","path":"imgs/goroutine-scheduler-model.png","modified":1,"renderable":0},{"_id":"source/images/favicon.ico","path":"images/favicon.ico","modified":1,"renderable":0},{"_id":"node_modules/hexo-theme-doc/source/fonts/DressCodeIcons.eot","path":"fonts/DressCodeIcons.eot","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-doc/source/fonts/DressCodeIcons.ttf","path":"fonts/DressCodeIcons.ttf","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-doc/source/fonts/DressCodeIcons.woff","path":"fonts/DressCodeIcons.woff","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-doc/source/fonts/DressCodeIcons.svg","path":"fonts/DressCodeIcons.svg","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-doc/source/style/swagger-ui-v3.css","path":"style/swagger-ui-v3.css","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-doc/source/style/doc.css","path":"style/doc.css","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-doc/source/script/doc.js","path":"script/doc.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-doc/source/style/swagger-ui-v2.css","path":"style/swagger-ui-v2.css","modified":1,"renderable":1}],"Cache":[{"_id":"node_modules/hexo-theme-doc/index.js","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/MAINTAINERS","hash":"a25e07bb5f096bc4ba1894dc9dbb5dc33f9bc201","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/CHANGELOG.md","hash":"055a102a94140925ff934468a72c3be0c1fc3596","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/package.json","hash":"fe5bf5e1c11a90167b1ab1ee8e77dd31a57121bb","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/LICENSE","hash":"a6cac4c12431fb45cd9040351fdca0c5008f0304","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/README.md","hash":"4b20d9c0f9fb875efdf6922e40cf300b19ebc792","modified":1562583788474},{"_id":"source/index.md","hash":"7a7afe4b43173f53229e65469e68ac6b4846e754","modified":1571492415173},{"_id":"source/commands/doc.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1566607782148},{"_id":"source/commands/env.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1566607782148},{"_id":"source/commands/get.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1566607782148},{"_id":"source/commands/install.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1566607782148},{"_id":"source/commands/test.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1566607782149},{"_id":"source/commands/mod.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1566607782149},{"_id":"source/commands/run.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1566607782149},{"_id":"node_modules/hexo-theme-doc/_doc.scss","hash":"359a51a19c8738610ad396c20a0eed4528b93c8c","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/layout/page.ejs","hash":"8dd780f66587b4faa3aa4e3104cb09e6c2ebecbe","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/plugins/favicon.js","hash":"09c81f787ea56cdd9cae1b75b620d8250a3a1eaa","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/plugins/project-partial.js","hash":"5b8f0f737f5290e9552ac87d6cd6d4fd3dbb523b","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/plugins/react-initial-state.js","hash":"b1c91c782e09c208f542a911f411a31bbdd69d95","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/plugins/react.js","hash":"61a7abb9b9733f3d8880422514eec4e0c8bf50e3","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/plugins/search.js","hash":"bea9810bedb094715f320887b9409def54146ca6","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/plugins/support.js","hash":"a683095a1fd44c07db8d369ec068612528a82ad5","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/plugins/swagger-routes.js","hash":"665b727bf6a507b371214ea947331e37a02649d1","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/plugins/swagger-ui.js","hash":"afc5a071a8e817c33a0541e93f84f7fa9cf947b5","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/plugins/swagger-to-html.js","hash":"bdaeb6ec81da7fc201c305c9076ad80018aca075","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/scripts/all.js","hash":"1a3130bdbd571b6a481012bd93e145bed4ca98e8","modified":1562583788474},{"_id":"source/_data/navigation.yaml","hash":"a145ae9ef5f54e3126ab708d083d08d347c9dfee","modified":1571492415168},{"_id":"node_modules/hexo-theme-doc/layout/layout.ejs","hash":"8103dc36f49f3d9dc1ec78be73a807202dd14ca3","modified":1562583788474},{"_id":"source/advance/mm.md","hash":"9d6ffae16c7f61caac1e12e9352c52d07d663a74","modified":1567297100646},{"_id":"source/advance/gc.md","hash":"bd504c4a3ebd0a431cade0eddb41f9e11fc61fa6","modified":1567297100645},{"_id":"source/basic/error.md","hash":"1bb3a5df86ad302887feaffc17fca35f323000c6","modified":1571492415169},{"_id":"source/basic/array.md","hash":"86dfba182fe584322c15401215dc8902605382e8","modified":1566612508355},{"_id":"source/basic/env_config.md","hash":"207caa204e7af6a18ca84162e1f7f25a94b8292e","modified":1566612508505},{"_id":"source/commands/build.md","hash":"9ec10d5fdf7a62420641369f97ff90391eaec9c5","modified":1566612508685},{"_id":"source/basic/flow.md","hash":"3023291be45da042ca4086836d3f6d6326283350","modified":1566620640839},{"_id":"source/basic/basic_data.md","hash":"423d20f6172f679c844825c011be9aec078bb722","modified":1566951307506},{"_id":"source/basic/oop.md","hash":"b28f943487838d9f0265c7225c9726887c1adcf7","modified":1571492415170},{"_id":"source/basic/constant.md","hash":"3eb6bddcf941dc53f554665a8625391dacf883f1","modified":1566621297521},{"_id":"source/basic/map.md","hash":"3d09fe597456f1047d0beaa5ea1a849c8c2d93e9","modified":1566612508380},{"_id":"source/basic/json.md","hash":"29a83754cec953a2ffbd29837b31988bfebc3c07","modified":1566614060535},{"_id":"source/basic/pointer.md","hash":"a439d7da94140767f84b9f1eb764dad2e0cd7c2b","modified":1566951307511},{"_id":"source/basic/operator.md","hash":"6c8f1189805fedd337f7f52c6c86cc7a1349847f","modified":1566612508337},{"_id":"source/basic/slice.md","hash":"b2c7583fbbb43dbec00946a4a037a421759489fe","modified":1571492415171},{"_id":"source/basic/struct.md","hash":"793c5c7175c2482dbeef9f1250949a3dd5e995b3","modified":1571492415171},{"_id":"source/basic/package.md","hash":"f5b5de3146db1a2da61763077ddf8f6023f2f257","modified":1566612508801},{"_id":"source/concurrent/channel.md","hash":"6a604cc52e3d61571712a1f100cb45e4969462c4","modified":1571492415172},{"_id":"source/basic/scope.md","hash":"3cefc2124b82832d07988711c37074dbb6662820","modified":1566610729972},{"_id":"source/basic/function.md","hash":"a775947b9ca35c944113e33adda1766cba4bdc10","modified":1566951307507},{"_id":"source/concurrent/sync_lock.md","hash":"3862fbc203fc27a4fb9bf788032b958726fd60d8","modified":1566951307515},{"_id":"source/basic/interface.md","hash":"0d674b4110ad4d0055ba26daade019102af5ec84","modified":1566951307509},{"_id":"source/images/logo.png","hash":"2e66d864f104f6d95ccaace4fd524c9f67a0477a","modified":1566607782152},{"_id":"source/basic/var.md","hash":"9c7e0ca11c043d048f24c24a88fd69e897e99ad9","modified":1566951307512},{"_id":"source/standards/log.md","hash":"50cbf6d9683a4be01912f0eafb91c2cb65902ee5","modified":1571492415180},{"_id":"source/standards/time.md","hash":"52f65c75bb6fc1d406ade3b55847cafe278dc2a5","modified":1571492415184},{"_id":"source/theme/theme-usage.md","hash":"1a4a31405e11cc4baad779ef822904dbf1562a7a","modified":1566607782157},{"_id":"source/imgs/goroutine-scheduler-model.png","hash":"de981cc4eac805d6ab88567fc66c135d589b01c9","modified":1566607782153},{"_id":"source/basic/test.md","hash":"083240600cb38c274bc026c6eb20f2a96608dcb4","modified":1566621610864},{"_id":"node_modules/hexo-theme-doc/lib/browser/swagger-to-html.js","hash":"fc08649a27fa9ca735a97ff9c1a73455e5fe1d3b","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/lib/browser/utils.js","hash":"ba08d2f1c1e1ea2b6f1a9b2eaf8cc7c48d4601e1","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/lib/nodejs/hexo-util.js","hash":"09c7767dd1d929fc6562e29639eba802cea0899b","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/lib/nodejs/swagger-store.js","hash":"c4a326d4f838b7222e141d7c5c833808bc1ea17f","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/layout/_partial/google_analytics.ejs","hash":"6356c8080a9098b2508361402e0e25e9047f8544","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/layout/_partial/navigation.ejs","hash":"6dbf914becd41d974f5d1253d843ab23b4cfbea6","modified":1562583788474},{"_id":"source/images/favicon.ico","hash":"5ab669012ef87df6c155dfe538765a5126b5049b","modified":1566607782152},{"_id":"node_modules/hexo-theme-doc/lib/browser/polyfills.js","hash":"fecb9f27f9061540c0bf1183a97f5cec44afdc59","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/source/fonts/DressCodeIcons.eot","hash":"1fb99e1a74b9ece713d4a99cb87952a9a14e2df4","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/source/fonts/DressCodeIcons.ttf","hash":"5080fa65ffd44ff51931f4487178a5206776177f","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/source/fonts/DressCodeIcons.woff","hash":"31cd14356ed54a4bbe11442b191a1045b1e73fb2","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/source/fonts/DressCodeIcons.svg","hash":"f0694aea42a00aa3814bf54a7b8a33aa56a5efc5","modified":1562583788474},{"_id":"source/concurrent/goroutine.md","hash":"36dd0fbe8f45fa0cec90dec87dc552295d397f2e","modified":1567297100654},{"_id":"node_modules/hexo-theme-doc/source/style/swagger-ui-v3.css","hash":"5def137d48ef1a017eac23a63575585f308591d9","modified":1562583788474},{"_id":"source/standards/data/big.md","hash":"bb002389d1e888c8e84a08bf1a8dfa1bd53c62fa","modified":1571492415174},{"_id":"source/standards/data/container.md","hash":"079c02e4a438663bb03dc5d7827abfe15b36a506","modified":1571492415175},{"_id":"node_modules/hexo-theme-doc/lib/browser/index.js","hash":"07f5d4f052d851760945387ed16a6916d5f0a227","modified":1562583788474},{"_id":"source/standards/database/sql.md","hash":"cdfd1842c03d6c5984e6b065a7b5c03faf9aab6c","modified":1571492415176},{"_id":"source/standards/io/bufio.md","hash":"1aabf5473db8d593bfb54000c1f9bc1782327455","modified":1571492415177},{"_id":"source/standards/io/fmt.md","hash":"f77d5769d0aa2123508dce5dada9490c22253674","modified":1571492415178},{"_id":"source/standards/io/ioutil.md","hash":"859a24da32f72d24554b658eb99999e821de3eac","modified":1571492415179},{"_id":"source/standards/io/io.md","hash":"7c4f2b4e1c0c15067ad71eb2c23f6d8213c38445","modified":1571492415178},{"_id":"source/standards/net/http.md","hash":"0f075a38c7f96214c6ebca609a99abbb78bae661","modified":1571492415181},{"_id":"source/standards/os/filepath.md","hash":"f4eb7f5d29306fd342d8bc0b2a127d405212b566","modified":1571492415182},{"_id":"source/standards/os/os.md","hash":"f6a4769150c7264d6f84fcc9239a26c61b0ec31d","modified":1571492415183},{"_id":"source/standards/text/strconv.md","hash":"f53217352fa1cf8856615dbbf2df9b0229014e6b","modified":1567297496494},{"_id":"source/standards/text/strings.md","hash":"5662095b207685d12b2e7196f5b12b51d8c2249c","modified":1567297496524},{"_id":"source/basic/reflect.md","hash":"8280631a4b18b399b6f61cad611f70c0d055f0d9","modified":1566633169252},{"_id":"source/standards/text/unicode.md","hash":"40d4d569425bd2cbd38599fc94decd2e06996626","modified":1567297496449},{"_id":"node_modules/hexo-theme-doc/source/style/doc.css","hash":"dd2158505dbf9e08415da6c7a717096877c41648","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/lib/browser/navigation/components.jsx","hash":"a71681b5f1d74defd18d1ef0ecdaebff4ef1df52","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/lib/browser/navigation/containers.jsx","hash":"b85ecfd69b0d16843de0343a7a7f86211b93c331","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/lib/browser/search/actions.js","hash":"5d02008c525698b668774bf4ae997422fb4e62b7","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/lib/browser/search/components.jsx","hash":"859a65271a0ccf30071cf9eeed667034ad2228c1","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/lib/browser/search/load.js","hash":"dd4458a832ed414624055668946fc1afd7605e24","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/lib/browser/support/components.jsx","hash":"8dc2d9f5770f2a0bddbf31061dbd1050b0612860","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/lib/browser/support/containers.jsx","hash":"9840d7baf32cc0b8ff31ef28801fc6815b895cd2","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/lib/nodejs/project-partial/index.js","hash":"7a03d1be17bc686c7c7454251465f7b1a38805f7","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/lib/nodejs/search/build.js","hash":"9e3e04475806f135baaae5fa44105fe9470f1211","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/lib/nodejs/search/child-on-message.js","hash":"32e892e89332560245fe9a00029a552a214ae813","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/lib/nodejs/search/child.js","hash":"a62d18f8b093efca99b319d50ff2b5042cc27bb6","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/lib/nodejs/search/generator.js","hash":"077e1724c938ef7c5a25bb61bfd18979682e527b","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/lib/nodejs/search/searcher.js","hash":"ac1d655fe2a2f65c8bb5e55219a54daf23969107","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/lib/nodejs/support/index.js","hash":"d8d3d484c25cb702d65c5ba87b11b2ffcb758163","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/lib/nodejs/swagger/index.js","hash":"694ec985054b08aebb13c198223030c5b236d87d","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/lib/nodejs/swagger/swagger.js","hash":"677670a658555e975d9ff2986e500e1964d38e05","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/lib/nodejs/swagger-to-html/core.js","hash":"415afdcd242ff1e6872ce12dfaf72e326032be7a","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/lib/nodejs/swagger-to-html/index.js","hash":"5fb4ac962a62d836cff492ffe9fbabac902f8cfb","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/lib/nodejs/swagger-ui/index.js","hash":"f5d55d29195efc0fc49978854bebf08a5e156d15","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/lib/nodejs/swagger-ui/parse-schema-file-error.js","hash":"05b3ebcad4717ac64f8047929eadd6c1852cb668","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/lib/nodejs/swagger-ui/parse-schema-file.js","hash":"b847e85d2ed797e2a4a29e24012b854ca843f6dd","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/lib/browser/search/containers.jsx","hash":"acc5e65576468e43fc49d753bef5350cf60c077e","modified":1562583788474},{"_id":"source/standards/data/math.md","hash":"2798748d11959fcd18a46c4f751ce186c0c0a728","modified":1567297100668},{"_id":"node_modules/hexo-theme-doc/source/style/_swagger/swagger-ui-v2.scss","hash":"b7ed10a4ad5070838b2ecb057bed19faa8464058","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/source/style/_swagger/swagger-ui-v3.scss","hash":"7d0465858deae467a06c7bf1a41c0080936438fa","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/source/script/doc.js","hash":"404cbdd42bc5c70f5a28064fad4d6cf19ebac78a","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/source/style/_doc/content.scss","hash":"49bcd72cd553278f7d1a1f4d9576ba5f395f91ec","modified":1562583788474},{"_id":"source/standards/data/sort.md","hash":"ae5e98519132988106900e5e4a416ff9e772c321","modified":1567332296939},{"_id":"node_modules/hexo-theme-doc/source/style/_doc/layout.scss","hash":"c4db472ea60b36e5a55a6b1bdf46dd9f10f4305b","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/source/style/_doc/index.scss","hash":"bc92af085aff473e578eb33432f9cc5880823c15","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/source/style/_doc/mixins.scss","hash":"7a0ef654dba60cd3c5bf2b7d974fbfd56b26f63f","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/source/style/_swagger/swagger-ui-v3-vendors.scss","hash":"061b90e819bce5bf8bb6215e0756d564cd76e9a0","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/source/style/_doc/search.scss","hash":"db59ce2772dd027041da84b6ea2bd16437b1613a","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/source/style/_doc/support.scss","hash":"2a1461f7500337ead164560a87a38f4f5a63f7fb","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/source/style/_doc/typography.scss","hash":"426c0284dcaf181ec1970eab24cedf551d213659","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/source/style/_doc/swagger-to-html.scss","hash":"6cbd8c3c5c5bc3967025617d102d35184a05f815","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/source/style/_doc/vars.scss","hash":"a4723cf85572de0fe33551d97cc51e38ef301a01","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/source/style/swagger-ui-v2.css","hash":"da587391034b8bcc0a1f58d1489ee62560e76cd3","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/lib/nodejs/swagger/decorators/host.js","hash":"4f37d328015b6bd2233a45a0c583fd9e94ed1ebd","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/lib/nodejs/swagger/decorators/index.js","hash":"f68c09375e7988f19e9f044d7c1ae81a0fc69cce","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/lib/nodejs/swagger-to-html/helpers/index.js","hash":"71d0c9ebe918e9f75fe16f07f60830b2a69bab0b","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/lib/nodejs/swagger-to-html/helpers/utils.js","hash":"23b9253456b4d3e2350043d5077a768239d55618","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/lib/nodejs/swagger-to-html/modules/index.js","hash":"d36eedc9b091ee82739c9276690f1da17a4665cf","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/source/style/_doc/navigation.scss","hash":"2db62ace25a12844aae4c906a77c83365dd8621e","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/source/style/_swagger/swagger-ui-v2-vendors.scss","hash":"3bd0e1b3eec046b5feb2b88ccb17287629b6c7ae","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/source/style/_doc/formatting.scss","hash":"494ddda3eb17155016010b8918b26a88aa2e83f9","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/lib/nodejs/swagger/decorators/docExclude/index.js","hash":"942ac283b91be1a6843a273dcfbcc241bcd92fdd","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/lib/nodejs/swagger/decorators/docExclude/utils.js","hash":"63012993acdc320d1188e5d17cf472874951b96a","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/lib/nodejs/swagger-to-html/helpers/parser/index.js","hash":"156cdce96e8ac524fa1c3112fb8d95de2fa45b19","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/lib/nodejs/swagger-to-html/modules/controllers/index.js","hash":"892f50667b5802e53e165bb61976b81ec0241eff","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/lib/nodejs/swagger-to-html/modules/controllers/operation.js","hash":"519985c0b16b82c0268e5060c8a5961cbaedf937","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/lib/nodejs/swagger-to-html/modules/controllers/operations.js","hash":"1c5f5ed67c50a3df37f634d76d239624945837b5","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/lib/nodejs/swagger-to-html/modules/controllers/request.js","hash":"61df1daad2467078711ce3e0e2a4ad7f5952c91b","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/lib/nodejs/swagger-to-html/modules/controllers/requestBody.js","hash":"6ee9c8cc87d2b3243dec2eb958682c8ac9304b89","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/lib/nodejs/swagger-to-html/modules/controllers/requestSample.js","hash":"e2eabba310a87c7c84be892a923318cdc6272339","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/lib/nodejs/swagger-to-html/modules/controllers/response.js","hash":"f53e510c73758585bf84114f19f8a83190e00ec2","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/lib/nodejs/swagger-to-html/modules/controllers/responseSample.js","hash":"8118b1a3f2419fd6e4ccb0240f09a9f39f6c97ec","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/lib/nodejs/swagger-to-html/modules/controllers/responses.js","hash":"4c4441124432497d95c3ef28afae1fbc80db8e3e","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/lib/nodejs/swagger-to-html/modules/controllers/security.js","hash":"27452679756cdaca83b8a8f67daba093be4ed3f7","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/lib/nodejs/swagger-to-html/modules/templates/head.ejs","hash":"b3e9353c36b7926b4ba34febc123003b34f86e0d","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/lib/nodejs/swagger-to-html/modules/templates/operations.ejs","hash":"d2043b22a7b52196c34e2e987974630a267aea63","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/lib/nodejs/swagger-to-html/modules/templates/formData.ejs","hash":"bb18aa5ed3fecd3f053bae119717df115351a071","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/lib/nodejs/swagger-to-html/modules/templates/emptyResponse.ejs","hash":"e2e0b77892b4d14a5157268b319478b9faab9bf5","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/lib/nodejs/swagger-to-html/modules/templates/header.ejs","hash":"e606cfa2be93ca438a2ec57f989a8e9b61191a93","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/lib/nodejs/swagger-to-html/modules/templates/operation.ejs","hash":"14825d0878b43f5a2f8c85a28a8001e2fe989905","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/lib/nodejs/swagger-to-html/modules/templates/request.ejs","hash":"9337ec99b6a91a6d96911ab15054f0b2e069b382","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/lib/nodejs/swagger-to-html/modules/templates/requestBody.ejs","hash":"803ee22a1f22943a9c8a62f554670354ee4f9e88","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/lib/nodejs/swagger-to-html/modules/templates/requestSample.ejs","hash":"b8ec7ab91829718d9ce891b62fcf5e8c0d5751a6","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/lib/nodejs/swagger-to-html/modules/templates/requestContent.ejs","hash":"a72596c37855f904427139c8c7830e859debadf7","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/lib/nodejs/swagger-to-html/modules/templates/responseSample.ejs","hash":"f4f2ecfe083b74f821d214868a60a18d3dcac880","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/lib/nodejs/swagger-to-html/modules/templates/responses.ejs","hash":"f244d22e560d8445774abea8095e92a0663f442a","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/lib/nodejs/swagger-to-html/modules/templates/responseBody.ejs","hash":"cce1907e6717ea0d86943b7cabeda6dbd2d8a9e7","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/lib/nodejs/swagger-ui/partials/v2/libs.ejs","hash":"1d2bd50b96409e50e56219e922dab9c54939cffc","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/lib/nodejs/swagger-to-html/modules/templates/requestParams.ejs","hash":"f4a05c954c126072cc847d3831fe9905e03acd65","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/lib/nodejs/swagger-to-html/modules/templates/security.ejs","hash":"2f3b795a905a24d54c2e0708ee67cf574a81d418","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/lib/nodejs/swagger-to-html/modules/templates/response.ejs","hash":"99b30e56dee41cd68e69310616f86ab826b1e63e","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/lib/nodejs/swagger-ui/partials/v3/snippet.ejs","hash":"8d90b0165f06324f2238e5fdf398d4ee76cac89a","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/lib/nodejs/swagger-ui/partials/v3/libs.ejs","hash":"209135eeae225812cdd9b42fded9cd10457f9b09","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/lib/nodejs/swagger-ui/partials/v2/snippet.ejs","hash":"db76d87e93511cdfb2f3fc9f71bbce6d03f9aa0c","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/lib/nodejs/swagger-to-html/modules/templates/securityDefinition.ejs","hash":"23ed45e7329c74a000be80cfddd2467bf6853435","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/lib/nodejs/swagger-to-html/modules/templates/securityRequirement.ejs","hash":"8db24764c43c08882664732de8c830147abed7d3","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/lib/nodejs/swagger/decorators/docExclude/filters/index.js","hash":"7b5ca36e68c4ba120f6e2e7167f882ac4d7e1783","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/lib/nodejs/swagger/decorators/docExclude/filters/parameters.js","hash":"bdd09db4850e2f783e70643e3b09bf70dcdc9c4f","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/lib/nodejs/swagger/decorators/docExclude/filters/operations.js","hash":"64fd58b8d2e57b37ea438c0cc34f236a5bcf6517","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/lib/nodejs/swagger/decorators/docExclude/filters/security.js","hash":"4b052575c796448e2bba65ec8c1103573908f4dd","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/lib/nodejs/swagger/decorators/docExclude/filters/paths.js","hash":"1d18fae6c6b2b738ee3e5a0cbafb96e0cbec20cd","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/lib/nodejs/swagger-to-html/helpers/parser/lib/init.js","hash":"fbfdd851b2dbc6135a9816f648cef58b6f24b837","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/lib/nodejs/swagger-to-html/helpers/parser/lib/parseBody.js","hash":"f9f8b9bcb700e015ed90ee910616a7b624ad05a0","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/lib/nodejs/swagger-to-html/helpers/parser/lib/parseResponse.js","hash":"b07497593fbea9feb345bb97440fa2f6785954d4","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/lib/nodejs/swagger-to-html/helpers/parser/lib/traverse.js","hash":"06324fef88a76f6c327c9c7aada80062846c63c0","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/lib/nodejs/swagger-to-html/helpers/parser/lib/updateResult.js","hash":"f836097c56d9c3665a785b4d0db6d2208b246a30","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/lib/nodejs/swagger-to-html/helpers/parser/lib/processItems/array.js","hash":"2af81552af0fa15b2162cb3477dc7ebc9072135a","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/lib/nodejs/swagger-to-html/helpers/parser/lib/processItems/default.js","hash":"b65c0604121d420d73b6661ac4f01f7e71255167","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/lib/nodejs/swagger-to-html/helpers/parser/lib/processItems/enum.js","hash":"4a747d9b704262073cf3b14fb32c5fc362f52824","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/lib/nodejs/swagger-to-html/helpers/parser/lib/processItems/object.js","hash":"ee8a1b8e526078a63fa112bee95fc3635ca747e9","modified":1562583788474},{"_id":"node_modules/hexo-theme-doc/lib/nodejs/swagger-to-html/helpers/parser/lib/processItems/index.js","hash":"189364a93de57b96f15ec18d90afb50a3a81e4e4","modified":1562583788474},{"_id":"public/lunr.json","hash":"25cde1f207bf653e97fb63f396d8421f063f7f95","modified":1571492455740},{"_id":"public/commands/doc.html","hash":"179fbe8cda20bb8fb99a2d1d756b0f587734c1a1","modified":1571492455999},{"_id":"public/commands/env.html","hash":"3f9b49dcccfb003f63eb17e3fb33e1672440ec3d","modified":1571492455999},{"_id":"public/commands/get.html","hash":"5b2701f35ce7faa6b3170fa4b18e419a3eaac08f","modified":1571492455999},{"_id":"public/commands/test.html","hash":"e0943233bdeffcc4ebb1834d988e7b0181ee0e73","modified":1571492455999},{"_id":"public/commands/install.html","hash":"d6afdadf5c51e73015c79b007ddc5a83be9b1229","modified":1571492455999},{"_id":"public/commands/mod.html","hash":"34dec177a2e98f312216b3fb228afab2cb76c2c8","modified":1571492455999},{"_id":"public/commands/run.html","hash":"1f51b05242089820bce9801ae3884116cfe0adf9","modified":1571492455999},{"_id":"public/advance/mm.html","hash":"0d8819cd3fadbbffdea11a12bd201f89331e0e3e","modified":1571492455999},{"_id":"public/basic/array.html","hash":"412f7b78fbeb7816297ec7a74b887efc1677ff52","modified":1571492455999},{"_id":"public/basic/env_config.html","hash":"0cf75ca85bbfe9ee545e2f7c4c641edbb2b5da7d","modified":1571492455999},{"_id":"public/basic/constant.html","hash":"107d118c4f7bcba731595324a08a27d33b7ce970","modified":1571492455999},{"_id":"public/basic/map.html","hash":"57f705d4417657953c9e7c1dde5ef71484b42db1","modified":1571492455999},{"_id":"public/basic/operator.html","hash":"502b6537af19780ee2f4079f393f586bb856320a","modified":1571492455999},{"_id":"public/basic/scope.html","hash":"002b29dabbe9e7aee315ac89b03476536c8c160f","modified":1571492455999},{"_id":"public/basic/var.html","hash":"c14c4acb576049b1fa794439e9f7fdc98316c5d0","modified":1571492455999},{"_id":"public/standards/log.html","hash":"27035db3dd3540dac1a991b8244e44a8940bf2be","modified":1571492456000},{"_id":"public/theme/theme-usage.html","hash":"bdb9ac05a3caa257ddd5bd085562f5400131fafc","modified":1571492456000},{"_id":"public/standards/data/big.html","hash":"e88a57f1a660b4b467ecc7d2541d9f457a47f9ce","modified":1571492456000},{"_id":"public/standards/io/ioutil.html","hash":"5b76cbcee0f1d96363a1ae9e30ac957f34f2cad9","modified":1571492456000},{"_id":"public/basic/reflect.html","hash":"2aea91f96e30879cd36abc3c09e0a54176189298","modified":1571492456000},{"_id":"public/standards/text/unicode.html","hash":"0dba7ff3a9a4cab0a793f4691162d554042384fd","modified":1571492456000},{"_id":"public/standards/data/math.html","hash":"94f8b36c99055a4f0b1a14d92c6ad3b79fb0812a","modified":1571492456000},{"_id":"public/index.html","hash":"ddbd77f046249bdb1b20b9857622b563ffa5e84d","modified":1571492456000},{"_id":"public/advance/gc.html","hash":"24f750789afefcd98a28c2c2f8a9b9a2b64ac2b0","modified":1571492456000},{"_id":"public/basic/error.html","hash":"145242fd9ba6401e1c095e3a9bf7d8e5e0fb2d03","modified":1571492456000},{"_id":"public/basic/flow.html","hash":"4b08690c649cd27fca895fd1c8f93a71ff34a413","modified":1571492456000},{"_id":"public/basic/oop.html","hash":"18882949bd62af18b96bbc605c9a771a3bd80870","modified":1571492456000},{"_id":"public/basic/json.html","hash":"8c955bca641fcc88b24fed6d702c0266f4f5f675","modified":1571492456000},{"_id":"public/basic/pointer.html","hash":"797ebc510eeb69bd393d4a1758c626e4c774d9ec","modified":1571492456000},{"_id":"public/basic/slice.html","hash":"9d45acdea399d902635dd2141e8b5ba58b1e84c3","modified":1571492456000},{"_id":"public/basic/struct.html","hash":"0cad025430d70bbf6ce74b59750015044c6509f6","modified":1571492456000},{"_id":"public/basic/package.html","hash":"5c789ee3a10fc3c0e1bef4f515975f17f3ed5b44","modified":1571492456000},{"_id":"public/basic/interface.html","hash":"6b9b0dea1c2d00f4e9e5e92677c79dafdcc98497","modified":1571492456000},{"_id":"public/commands/build.html","hash":"c167f3447d802063cc9fe9c4e6670248c8a6b0b5","modified":1571492456000},{"_id":"public/concurrent/channel.html","hash":"bf1c2ef2fd5f3747d662d06350993f2fedc3e065","modified":1571492456001},{"_id":"public/basic/function.html","hash":"6b6502c2f3677833412d3881f447f913381b9290","modified":1571492456001},{"_id":"public/standards/time.html","hash":"78ce35d923c3e71659052dcc385f15c1d6c101cc","modified":1571492456001},{"_id":"public/basic/basic_data.html","hash":"fd7e372aaedc1abfcf285bc41b4e05d53950f8af","modified":1571492456001},{"_id":"public/basic/test.html","hash":"6d2e8ad5791a81581aa5fb88c9b21a14928e06bc","modified":1571492456001},{"_id":"public/standards/database/sql.html","hash":"82f6012ac8c18a37bbe706f31d274ced75443ba7","modified":1571492456001},{"_id":"public/standards/io/fmt.html","hash":"34bce516284b6675655329e9d6d214fcd0314380","modified":1571492456001},{"_id":"public/standards/text/strconv.html","hash":"411fc26392cb118a65c1b97e7421af7f1bc125e0","modified":1571492456001},{"_id":"public/standards/data/container.html","hash":"5c7198bb6c85ced58e22b2531d514e0d643b0e3e","modified":1571492456001},{"_id":"public/standards/io/bufio.html","hash":"74f608a96eb69e17d3de44568d5b7b0afa2b0174","modified":1571492456001},{"_id":"public/standards/os/filepath.html","hash":"4e4669694d2d302680e346b9983f2f98a9652655","modified":1571492456001},{"_id":"public/standards/text/strings.html","hash":"83efb0daacf64a7faddc888ec320f0a87e300db0","modified":1571492456001},{"_id":"public/concurrent/goroutine.html","hash":"fab23105db15d2bd2f72173956036565f87158f0","modified":1571492456001},{"_id":"public/standards/io/io.html","hash":"f6309ed5cee695aaae3228862f494512faacab75","modified":1571492456001},{"_id":"public/standards/os/os.html","hash":"4a2778c29c83eaaf7ecd16218e7306542ffdfbe7","modified":1571492456001},{"_id":"public/concurrent/sync_lock.html","hash":"2647f06e2b7cd16ad8dfe4c475ea4d9b4736c4bf","modified":1571492456001},{"_id":"public/standards/net/http.html","hash":"21b0210bb587238a7115f7cb212132f6f39bb610","modified":1571492456001},{"_id":"public/standards/data/sort.html","hash":"f071caad9fff5284ee70bb47f05c1c2fd446aad8","modified":1571492456002},{"_id":"public/images/logo.png","hash":"2e66d864f104f6d95ccaace4fd524c9f67a0477a","modified":1571492456009},{"_id":"public/fonts/DressCodeIcons.eot","hash":"1fb99e1a74b9ece713d4a99cb87952a9a14e2df4","modified":1571492456009},{"_id":"public/images/favicon.ico","hash":"5ab669012ef87df6c155dfe538765a5126b5049b","modified":1571492456010},{"_id":"public/fonts/DressCodeIcons.woff","hash":"31cd14356ed54a4bbe11442b191a1045b1e73fb2","modified":1571492456010},{"_id":"public/fonts/DressCodeIcons.ttf","hash":"5080fa65ffd44ff51931f4487178a5206776177f","modified":1571492456010},{"_id":"public/imgs/goroutine-scheduler-model.png","hash":"de981cc4eac805d6ab88567fc66c135d589b01c9","modified":1571492456012},{"_id":"public/fonts/DressCodeIcons.svg","hash":"f0694aea42a00aa3814bf54a7b8a33aa56a5efc5","modified":1571492456012},{"_id":"public/style/swagger-ui-v3.css","hash":"5def137d48ef1a017eac23a63575585f308591d9","modified":1571492456026},{"_id":"public/style/doc.css","hash":"dd2158505dbf9e08415da6c7a717096877c41648","modified":1571492456040},{"_id":"public/script/doc.js","hash":"404cbdd42bc5c70f5a28064fad4d6cf19ebac78a","modified":1571492456042},{"_id":"public/style/swagger-ui-v2.css","hash":"da587391034b8bcc0a1f58d1489ee62560e76cd3","modified":1571492456045}],"Category":[],"Data":[{"_id":"navigation","data":{"logo":{"text":"Golang Learn","type":"link","path":"index.html"},"main":[{"text":"Golang 基础","type":"label"},{"text":"Go 环境配置","type":"link","path":"basic/env_config.html"},{"text":"包","type":"link","path":"basic/package.html"},{"text":"基础数据类型","type":"link","path":"basic/basic_data.html"},{"text":"变量","type":"link","path":"basic/var.html"},{"text":"常量","type":"link","path":"basic/constant.html"},{"text":"控制语句","type":"link","path":"basic/flow.html"},{"text":"运算符","type":"link","path":"basic/operator.html"},{"text":"作用域","type":"link","path":"basic/scope.html"},{"text":"指针","type":"link","path":"basic/pointer.html"},{"text":"数组","type":"link","path":"basic/array.html"},{"text":"切片","type":"link","path":"basic/slice.html"},{"text":"字典","type":"link","path":"basic/map.html"},{"text":"函数","type":"link","path":"basic/function.html"},{"text":"结构体","type":"link","path":"basic/struct.html"},{"text":"接口","type":"link","path":"basic/interface.html"},{"text":"面向对象","type":"link","path":"basic/oop.html"},{"text":"错误","type":"link","path":"basic/error.html"},{"text":"序列化","type":"link","path":"basic/json.html"},{"text":"反射","type":"link","path":"basic/reflect.html"},{"text":"测试","type":"link","path":"basic/test.html"},{"text":"并发编程","type":"label"},{"text":"goroutine","type":"link","path":"concurrent/goroutine.html"},{"text":"channel","type":"link","path":"concurrent/channel.html"},{"text":"同步和锁","type":"link","path":"concurrent/sync_lock.html"},{"text":"内存分配","type":"label"},{"text":"内存分配","type":"link","path":"advance/mm.html"},{"text":"垃圾回收","type":"label"},{"text":"垃圾回收","type":"link","path":"advance/gc.html"},{"text":"标准库","type":"label"},{"text":"fmt","type":"link","path":"standards/io/fmt.html"},{"text":"io","type":"link","path":"standards/io/io.html"},{"text":"ioutil","type":"link","path":"standards/io/ioutil.html"},{"text":"bufio","type":"link","path":"standards/io/bufio.html"},{"text":"os","type":"link","path":"standards/os/os.html"},{"text":"filepath","type":"link","path":"standards/os/filepath.html"},{"text":"strings","type":"link","path":"standards/text/strings.html"},{"text":"strconv","type":"link","path":"standards/text/strconv.html"},{"text":"unicode","type":"link","path":"standards/text/unicode.html"},{"text":"log","type":"link","path":"standards/log.html"},{"text":"time","type":"link","path":"standards/time.html"},{"text":"http","type":"link","path":"standards/net/http.html"},{"text":"math","type":"link","path":"standards/data/math.html"},{"text":"sort","type":"link","path":"standards/data/sort.html"},{"text":"big","type":"link","path":"standards/data/big.html"},{"text":"container","type":"link","path":"standards/data/container.html"},{"text":"sql","type":"link","path":"standards/database/sql.html"},{"text":"THEME","type":"label"},{"text":"使用文档主题","type":"link","path":"theme/theme-usage.html"},{"text":"SUPPORT AND FEEDBACK","type":"label"},{"text":"Raise an Issue on Github","type":"link","path":"https://github.com/shipengqi/golang-learn/issues/new"}]}}],"Page":[{"_content":"","source":"commands/doc.md","raw":"","date":"2019-08-24T00:49:42.148Z","updated":"2019-08-24T00:49:42.148Z","path":"commands/doc.html","title":"","comments":1,"layout":"page","_id":"ck1xm14jp0000fcw2mnf47ruk","content":"","site":{"data":{"navigation":{"logo":{"text":"Golang Learn","type":"link","path":"index.html"},"main":[{"text":"Golang 基础","type":"label"},{"text":"Go 环境配置","type":"link","path":"basic/env_config.html"},{"text":"包","type":"link","path":"basic/package.html"},{"text":"基础数据类型","type":"link","path":"basic/basic_data.html"},{"text":"变量","type":"link","path":"basic/var.html"},{"text":"常量","type":"link","path":"basic/constant.html"},{"text":"控制语句","type":"link","path":"basic/flow.html"},{"text":"运算符","type":"link","path":"basic/operator.html"},{"text":"作用域","type":"link","path":"basic/scope.html"},{"text":"指针","type":"link","path":"basic/pointer.html"},{"text":"数组","type":"link","path":"basic/array.html"},{"text":"切片","type":"link","path":"basic/slice.html"},{"text":"字典","type":"link","path":"basic/map.html"},{"text":"函数","type":"link","path":"basic/function.html"},{"text":"结构体","type":"link","path":"basic/struct.html"},{"text":"接口","type":"link","path":"basic/interface.html"},{"text":"面向对象","type":"link","path":"basic/oop.html"},{"text":"错误","type":"link","path":"basic/error.html"},{"text":"序列化","type":"link","path":"basic/json.html"},{"text":"反射","type":"link","path":"basic/reflect.html"},{"text":"测试","type":"link","path":"basic/test.html"},{"text":"并发编程","type":"label"},{"text":"goroutine","type":"link","path":"concurrent/goroutine.html"},{"text":"channel","type":"link","path":"concurrent/channel.html"},{"text":"同步和锁","type":"link","path":"concurrent/sync_lock.html"},{"text":"内存分配","type":"label"},{"text":"内存分配","type":"link","path":"advance/mm.html"},{"text":"垃圾回收","type":"label"},{"text":"垃圾回收","type":"link","path":"advance/gc.html"},{"text":"标准库","type":"label"},{"text":"fmt","type":"link","path":"standards/io/fmt.html"},{"text":"io","type":"link","path":"standards/io/io.html"},{"text":"ioutil","type":"link","path":"standards/io/ioutil.html"},{"text":"bufio","type":"link","path":"standards/io/bufio.html"},{"text":"os","type":"link","path":"standards/os/os.html"},{"text":"filepath","type":"link","path":"standards/os/filepath.html"},{"text":"strings","type":"link","path":"standards/text/strings.html"},{"text":"strconv","type":"link","path":"standards/text/strconv.html"},{"text":"unicode","type":"link","path":"standards/text/unicode.html"},{"text":"log","type":"link","path":"standards/log.html"},{"text":"time","type":"link","path":"standards/time.html"},{"text":"http","type":"link","path":"standards/net/http.html"},{"text":"math","type":"link","path":"standards/data/math.html"},{"text":"sort","type":"link","path":"standards/data/sort.html"},{"text":"big","type":"link","path":"standards/data/big.html"},{"text":"container","type":"link","path":"standards/data/container.html"},{"text":"sql","type":"link","path":"standards/database/sql.html"},{"text":"THEME","type":"label"},{"text":"使用文档主题","type":"link","path":"theme/theme-usage.html"},{"text":"SUPPORT AND FEEDBACK","type":"label"},{"text":"Raise an Issue on Github","type":"link","path":"https://github.com/shipengqi/golang-learn/issues/new"}]}}},"excerpt":"","more":""},{"_content":"","source":"commands/env.md","raw":"","date":"2019-08-24T00:49:42.148Z","updated":"2019-08-24T00:49:42.148Z","path":"commands/env.html","title":"","comments":1,"layout":"page","_id":"ck1xm14ju0001fcw27r5kxqkd","content":"","site":{"data":{"navigation":{"logo":{"text":"Golang Learn","type":"link","path":"index.html"},"main":[{"text":"Golang 基础","type":"label"},{"text":"Go 环境配置","type":"link","path":"basic/env_config.html"},{"text":"包","type":"link","path":"basic/package.html"},{"text":"基础数据类型","type":"link","path":"basic/basic_data.html"},{"text":"变量","type":"link","path":"basic/var.html"},{"text":"常量","type":"link","path":"basic/constant.html"},{"text":"控制语句","type":"link","path":"basic/flow.html"},{"text":"运算符","type":"link","path":"basic/operator.html"},{"text":"作用域","type":"link","path":"basic/scope.html"},{"text":"指针","type":"link","path":"basic/pointer.html"},{"text":"数组","type":"link","path":"basic/array.html"},{"text":"切片","type":"link","path":"basic/slice.html"},{"text":"字典","type":"link","path":"basic/map.html"},{"text":"函数","type":"link","path":"basic/function.html"},{"text":"结构体","type":"link","path":"basic/struct.html"},{"text":"接口","type":"link","path":"basic/interface.html"},{"text":"面向对象","type":"link","path":"basic/oop.html"},{"text":"错误","type":"link","path":"basic/error.html"},{"text":"序列化","type":"link","path":"basic/json.html"},{"text":"反射","type":"link","path":"basic/reflect.html"},{"text":"测试","type":"link","path":"basic/test.html"},{"text":"并发编程","type":"label"},{"text":"goroutine","type":"link","path":"concurrent/goroutine.html"},{"text":"channel","type":"link","path":"concurrent/channel.html"},{"text":"同步和锁","type":"link","path":"concurrent/sync_lock.html"},{"text":"内存分配","type":"label"},{"text":"内存分配","type":"link","path":"advance/mm.html"},{"text":"垃圾回收","type":"label"},{"text":"垃圾回收","type":"link","path":"advance/gc.html"},{"text":"标准库","type":"label"},{"text":"fmt","type":"link","path":"standards/io/fmt.html"},{"text":"io","type":"link","path":"standards/io/io.html"},{"text":"ioutil","type":"link","path":"standards/io/ioutil.html"},{"text":"bufio","type":"link","path":"standards/io/bufio.html"},{"text":"os","type":"link","path":"standards/os/os.html"},{"text":"filepath","type":"link","path":"standards/os/filepath.html"},{"text":"strings","type":"link","path":"standards/text/strings.html"},{"text":"strconv","type":"link","path":"standards/text/strconv.html"},{"text":"unicode","type":"link","path":"standards/text/unicode.html"},{"text":"log","type":"link","path":"standards/log.html"},{"text":"time","type":"link","path":"standards/time.html"},{"text":"http","type":"link","path":"standards/net/http.html"},{"text":"math","type":"link","path":"standards/data/math.html"},{"text":"sort","type":"link","path":"standards/data/sort.html"},{"text":"big","type":"link","path":"standards/data/big.html"},{"text":"container","type":"link","path":"standards/data/container.html"},{"text":"sql","type":"link","path":"standards/database/sql.html"},{"text":"THEME","type":"label"},{"text":"使用文档主题","type":"link","path":"theme/theme-usage.html"},{"text":"SUPPORT AND FEEDBACK","type":"label"},{"text":"Raise an Issue on Github","type":"link","path":"https://github.com/shipengqi/golang-learn/issues/new"}]}}},"excerpt":"","more":""},{"_content":"","source":"commands/get.md","raw":"","date":"2019-08-24T00:49:42.148Z","updated":"2019-08-24T00:49:42.148Z","path":"commands/get.html","title":"","comments":1,"layout":"page","_id":"ck1xm14jv0002fcw2g04qzu04","content":"","site":{"data":{"navigation":{"logo":{"text":"Golang Learn","type":"link","path":"index.html"},"main":[{"text":"Golang 基础","type":"label"},{"text":"Go 环境配置","type":"link","path":"basic/env_config.html"},{"text":"包","type":"link","path":"basic/package.html"},{"text":"基础数据类型","type":"link","path":"basic/basic_data.html"},{"text":"变量","type":"link","path":"basic/var.html"},{"text":"常量","type":"link","path":"basic/constant.html"},{"text":"控制语句","type":"link","path":"basic/flow.html"},{"text":"运算符","type":"link","path":"basic/operator.html"},{"text":"作用域","type":"link","path":"basic/scope.html"},{"text":"指针","type":"link","path":"basic/pointer.html"},{"text":"数组","type":"link","path":"basic/array.html"},{"text":"切片","type":"link","path":"basic/slice.html"},{"text":"字典","type":"link","path":"basic/map.html"},{"text":"函数","type":"link","path":"basic/function.html"},{"text":"结构体","type":"link","path":"basic/struct.html"},{"text":"接口","type":"link","path":"basic/interface.html"},{"text":"面向对象","type":"link","path":"basic/oop.html"},{"text":"错误","type":"link","path":"basic/error.html"},{"text":"序列化","type":"link","path":"basic/json.html"},{"text":"反射","type":"link","path":"basic/reflect.html"},{"text":"测试","type":"link","path":"basic/test.html"},{"text":"并发编程","type":"label"},{"text":"goroutine","type":"link","path":"concurrent/goroutine.html"},{"text":"channel","type":"link","path":"concurrent/channel.html"},{"text":"同步和锁","type":"link","path":"concurrent/sync_lock.html"},{"text":"内存分配","type":"label"},{"text":"内存分配","type":"link","path":"advance/mm.html"},{"text":"垃圾回收","type":"label"},{"text":"垃圾回收","type":"link","path":"advance/gc.html"},{"text":"标准库","type":"label"},{"text":"fmt","type":"link","path":"standards/io/fmt.html"},{"text":"io","type":"link","path":"standards/io/io.html"},{"text":"ioutil","type":"link","path":"standards/io/ioutil.html"},{"text":"bufio","type":"link","path":"standards/io/bufio.html"},{"text":"os","type":"link","path":"standards/os/os.html"},{"text":"filepath","type":"link","path":"standards/os/filepath.html"},{"text":"strings","type":"link","path":"standards/text/strings.html"},{"text":"strconv","type":"link","path":"standards/text/strconv.html"},{"text":"unicode","type":"link","path":"standards/text/unicode.html"},{"text":"log","type":"link","path":"standards/log.html"},{"text":"time","type":"link","path":"standards/time.html"},{"text":"http","type":"link","path":"standards/net/http.html"},{"text":"math","type":"link","path":"standards/data/math.html"},{"text":"sort","type":"link","path":"standards/data/sort.html"},{"text":"big","type":"link","path":"standards/data/big.html"},{"text":"container","type":"link","path":"standards/data/container.html"},{"text":"sql","type":"link","path":"standards/database/sql.html"},{"text":"THEME","type":"label"},{"text":"使用文档主题","type":"link","path":"theme/theme-usage.html"},{"text":"SUPPORT AND FEEDBACK","type":"label"},{"text":"Raise an Issue on Github","type":"link","path":"https://github.com/shipengqi/golang-learn/issues/new"}]}}},"excerpt":"","more":""},{"_content":"","source":"commands/test.md","raw":"","date":"2019-08-24T00:49:42.149Z","updated":"2019-08-24T00:49:42.149Z","path":"commands/test.html","title":"","comments":1,"layout":"page","_id":"ck1xm14jw0003fcw2nn2r6u7a","content":"","site":{"data":{"navigation":{"logo":{"text":"Golang Learn","type":"link","path":"index.html"},"main":[{"text":"Golang 基础","type":"label"},{"text":"Go 环境配置","type":"link","path":"basic/env_config.html"},{"text":"包","type":"link","path":"basic/package.html"},{"text":"基础数据类型","type":"link","path":"basic/basic_data.html"},{"text":"变量","type":"link","path":"basic/var.html"},{"text":"常量","type":"link","path":"basic/constant.html"},{"text":"控制语句","type":"link","path":"basic/flow.html"},{"text":"运算符","type":"link","path":"basic/operator.html"},{"text":"作用域","type":"link","path":"basic/scope.html"},{"text":"指针","type":"link","path":"basic/pointer.html"},{"text":"数组","type":"link","path":"basic/array.html"},{"text":"切片","type":"link","path":"basic/slice.html"},{"text":"字典","type":"link","path":"basic/map.html"},{"text":"函数","type":"link","path":"basic/function.html"},{"text":"结构体","type":"link","path":"basic/struct.html"},{"text":"接口","type":"link","path":"basic/interface.html"},{"text":"面向对象","type":"link","path":"basic/oop.html"},{"text":"错误","type":"link","path":"basic/error.html"},{"text":"序列化","type":"link","path":"basic/json.html"},{"text":"反射","type":"link","path":"basic/reflect.html"},{"text":"测试","type":"link","path":"basic/test.html"},{"text":"并发编程","type":"label"},{"text":"goroutine","type":"link","path":"concurrent/goroutine.html"},{"text":"channel","type":"link","path":"concurrent/channel.html"},{"text":"同步和锁","type":"link","path":"concurrent/sync_lock.html"},{"text":"内存分配","type":"label"},{"text":"内存分配","type":"link","path":"advance/mm.html"},{"text":"垃圾回收","type":"label"},{"text":"垃圾回收","type":"link","path":"advance/gc.html"},{"text":"标准库","type":"label"},{"text":"fmt","type":"link","path":"standards/io/fmt.html"},{"text":"io","type":"link","path":"standards/io/io.html"},{"text":"ioutil","type":"link","path":"standards/io/ioutil.html"},{"text":"bufio","type":"link","path":"standards/io/bufio.html"},{"text":"os","type":"link","path":"standards/os/os.html"},{"text":"filepath","type":"link","path":"standards/os/filepath.html"},{"text":"strings","type":"link","path":"standards/text/strings.html"},{"text":"strconv","type":"link","path":"standards/text/strconv.html"},{"text":"unicode","type":"link","path":"standards/text/unicode.html"},{"text":"log","type":"link","path":"standards/log.html"},{"text":"time","type":"link","path":"standards/time.html"},{"text":"http","type":"link","path":"standards/net/http.html"},{"text":"math","type":"link","path":"standards/data/math.html"},{"text":"sort","type":"link","path":"standards/data/sort.html"},{"text":"big","type":"link","path":"standards/data/big.html"},{"text":"container","type":"link","path":"standards/data/container.html"},{"text":"sql","type":"link","path":"standards/database/sql.html"},{"text":"THEME","type":"label"},{"text":"使用文档主题","type":"link","path":"theme/theme-usage.html"},{"text":"SUPPORT AND FEEDBACK","type":"label"},{"text":"Raise an Issue on Github","type":"link","path":"https://github.com/shipengqi/golang-learn/issues/new"}]}}},"excerpt":"","more":""},{"_content":"","source":"commands/install.md","raw":"","date":"2019-08-24T00:49:42.148Z","updated":"2019-08-24T00:49:42.148Z","path":"commands/install.html","title":"","comments":1,"layout":"page","_id":"ck1xm14jw0004fcw23jd25859","content":"","site":{"data":{"navigation":{"logo":{"text":"Golang Learn","type":"link","path":"index.html"},"main":[{"text":"Golang 基础","type":"label"},{"text":"Go 环境配置","type":"link","path":"basic/env_config.html"},{"text":"包","type":"link","path":"basic/package.html"},{"text":"基础数据类型","type":"link","path":"basic/basic_data.html"},{"text":"变量","type":"link","path":"basic/var.html"},{"text":"常量","type":"link","path":"basic/constant.html"},{"text":"控制语句","type":"link","path":"basic/flow.html"},{"text":"运算符","type":"link","path":"basic/operator.html"},{"text":"作用域","type":"link","path":"basic/scope.html"},{"text":"指针","type":"link","path":"basic/pointer.html"},{"text":"数组","type":"link","path":"basic/array.html"},{"text":"切片","type":"link","path":"basic/slice.html"},{"text":"字典","type":"link","path":"basic/map.html"},{"text":"函数","type":"link","path":"basic/function.html"},{"text":"结构体","type":"link","path":"basic/struct.html"},{"text":"接口","type":"link","path":"basic/interface.html"},{"text":"面向对象","type":"link","path":"basic/oop.html"},{"text":"错误","type":"link","path":"basic/error.html"},{"text":"序列化","type":"link","path":"basic/json.html"},{"text":"反射","type":"link","path":"basic/reflect.html"},{"text":"测试","type":"link","path":"basic/test.html"},{"text":"并发编程","type":"label"},{"text":"goroutine","type":"link","path":"concurrent/goroutine.html"},{"text":"channel","type":"link","path":"concurrent/channel.html"},{"text":"同步和锁","type":"link","path":"concurrent/sync_lock.html"},{"text":"内存分配","type":"label"},{"text":"内存分配","type":"link","path":"advance/mm.html"},{"text":"垃圾回收","type":"label"},{"text":"垃圾回收","type":"link","path":"advance/gc.html"},{"text":"标准库","type":"label"},{"text":"fmt","type":"link","path":"standards/io/fmt.html"},{"text":"io","type":"link","path":"standards/io/io.html"},{"text":"ioutil","type":"link","path":"standards/io/ioutil.html"},{"text":"bufio","type":"link","path":"standards/io/bufio.html"},{"text":"os","type":"link","path":"standards/os/os.html"},{"text":"filepath","type":"link","path":"standards/os/filepath.html"},{"text":"strings","type":"link","path":"standards/text/strings.html"},{"text":"strconv","type":"link","path":"standards/text/strconv.html"},{"text":"unicode","type":"link","path":"standards/text/unicode.html"},{"text":"log","type":"link","path":"standards/log.html"},{"text":"time","type":"link","path":"standards/time.html"},{"text":"http","type":"link","path":"standards/net/http.html"},{"text":"math","type":"link","path":"standards/data/math.html"},{"text":"sort","type":"link","path":"standards/data/sort.html"},{"text":"big","type":"link","path":"standards/data/big.html"},{"text":"container","type":"link","path":"standards/data/container.html"},{"text":"sql","type":"link","path":"standards/database/sql.html"},{"text":"THEME","type":"label"},{"text":"使用文档主题","type":"link","path":"theme/theme-usage.html"},{"text":"SUPPORT AND FEEDBACK","type":"label"},{"text":"Raise an Issue on Github","type":"link","path":"https://github.com/shipengqi/golang-learn/issues/new"}]}}},"excerpt":"","more":""},{"_content":"","source":"commands/mod.md","raw":"","date":"2019-08-24T00:49:42.149Z","updated":"2019-08-24T00:49:42.149Z","path":"commands/mod.html","title":"","comments":1,"layout":"page","_id":"ck1xm14jx0005fcw277bw49pe","content":"","site":{"data":{"navigation":{"logo":{"text":"Golang Learn","type":"link","path":"index.html"},"main":[{"text":"Golang 基础","type":"label"},{"text":"Go 环境配置","type":"link","path":"basic/env_config.html"},{"text":"包","type":"link","path":"basic/package.html"},{"text":"基础数据类型","type":"link","path":"basic/basic_data.html"},{"text":"变量","type":"link","path":"basic/var.html"},{"text":"常量","type":"link","path":"basic/constant.html"},{"text":"控制语句","type":"link","path":"basic/flow.html"},{"text":"运算符","type":"link","path":"basic/operator.html"},{"text":"作用域","type":"link","path":"basic/scope.html"},{"text":"指针","type":"link","path":"basic/pointer.html"},{"text":"数组","type":"link","path":"basic/array.html"},{"text":"切片","type":"link","path":"basic/slice.html"},{"text":"字典","type":"link","path":"basic/map.html"},{"text":"函数","type":"link","path":"basic/function.html"},{"text":"结构体","type":"link","path":"basic/struct.html"},{"text":"接口","type":"link","path":"basic/interface.html"},{"text":"面向对象","type":"link","path":"basic/oop.html"},{"text":"错误","type":"link","path":"basic/error.html"},{"text":"序列化","type":"link","path":"basic/json.html"},{"text":"反射","type":"link","path":"basic/reflect.html"},{"text":"测试","type":"link","path":"basic/test.html"},{"text":"并发编程","type":"label"},{"text":"goroutine","type":"link","path":"concurrent/goroutine.html"},{"text":"channel","type":"link","path":"concurrent/channel.html"},{"text":"同步和锁","type":"link","path":"concurrent/sync_lock.html"},{"text":"内存分配","type":"label"},{"text":"内存分配","type":"link","path":"advance/mm.html"},{"text":"垃圾回收","type":"label"},{"text":"垃圾回收","type":"link","path":"advance/gc.html"},{"text":"标准库","type":"label"},{"text":"fmt","type":"link","path":"standards/io/fmt.html"},{"text":"io","type":"link","path":"standards/io/io.html"},{"text":"ioutil","type":"link","path":"standards/io/ioutil.html"},{"text":"bufio","type":"link","path":"standards/io/bufio.html"},{"text":"os","type":"link","path":"standards/os/os.html"},{"text":"filepath","type":"link","path":"standards/os/filepath.html"},{"text":"strings","type":"link","path":"standards/text/strings.html"},{"text":"strconv","type":"link","path":"standards/text/strconv.html"},{"text":"unicode","type":"link","path":"standards/text/unicode.html"},{"text":"log","type":"link","path":"standards/log.html"},{"text":"time","type":"link","path":"standards/time.html"},{"text":"http","type":"link","path":"standards/net/http.html"},{"text":"math","type":"link","path":"standards/data/math.html"},{"text":"sort","type":"link","path":"standards/data/sort.html"},{"text":"big","type":"link","path":"standards/data/big.html"},{"text":"container","type":"link","path":"standards/data/container.html"},{"text":"sql","type":"link","path":"standards/database/sql.html"},{"text":"THEME","type":"label"},{"text":"使用文档主题","type":"link","path":"theme/theme-usage.html"},{"text":"SUPPORT AND FEEDBACK","type":"label"},{"text":"Raise an Issue on Github","type":"link","path":"https://github.com/shipengqi/golang-learn/issues/new"}]}}},"excerpt":"","more":""},{"_content":"","source":"commands/run.md","raw":"","date":"2019-08-24T00:49:42.149Z","updated":"2019-08-24T00:49:42.149Z","path":"commands/run.html","title":"","comments":1,"layout":"page","_id":"ck1xm14jy0006fcw2anvgh78a","content":"","site":{"data":{"navigation":{"logo":{"text":"Golang Learn","type":"link","path":"index.html"},"main":[{"text":"Golang 基础","type":"label"},{"text":"Go 环境配置","type":"link","path":"basic/env_config.html"},{"text":"包","type":"link","path":"basic/package.html"},{"text":"基础数据类型","type":"link","path":"basic/basic_data.html"},{"text":"变量","type":"link","path":"basic/var.html"},{"text":"常量","type":"link","path":"basic/constant.html"},{"text":"控制语句","type":"link","path":"basic/flow.html"},{"text":"运算符","type":"link","path":"basic/operator.html"},{"text":"作用域","type":"link","path":"basic/scope.html"},{"text":"指针","type":"link","path":"basic/pointer.html"},{"text":"数组","type":"link","path":"basic/array.html"},{"text":"切片","type":"link","path":"basic/slice.html"},{"text":"字典","type":"link","path":"basic/map.html"},{"text":"函数","type":"link","path":"basic/function.html"},{"text":"结构体","type":"link","path":"basic/struct.html"},{"text":"接口","type":"link","path":"basic/interface.html"},{"text":"面向对象","type":"link","path":"basic/oop.html"},{"text":"错误","type":"link","path":"basic/error.html"},{"text":"序列化","type":"link","path":"basic/json.html"},{"text":"反射","type":"link","path":"basic/reflect.html"},{"text":"测试","type":"link","path":"basic/test.html"},{"text":"并发编程","type":"label"},{"text":"goroutine","type":"link","path":"concurrent/goroutine.html"},{"text":"channel","type":"link","path":"concurrent/channel.html"},{"text":"同步和锁","type":"link","path":"concurrent/sync_lock.html"},{"text":"内存分配","type":"label"},{"text":"内存分配","type":"link","path":"advance/mm.html"},{"text":"垃圾回收","type":"label"},{"text":"垃圾回收","type":"link","path":"advance/gc.html"},{"text":"标准库","type":"label"},{"text":"fmt","type":"link","path":"standards/io/fmt.html"},{"text":"io","type":"link","path":"standards/io/io.html"},{"text":"ioutil","type":"link","path":"standards/io/ioutil.html"},{"text":"bufio","type":"link","path":"standards/io/bufio.html"},{"text":"os","type":"link","path":"standards/os/os.html"},{"text":"filepath","type":"link","path":"standards/os/filepath.html"},{"text":"strings","type":"link","path":"standards/text/strings.html"},{"text":"strconv","type":"link","path":"standards/text/strconv.html"},{"text":"unicode","type":"link","path":"standards/text/unicode.html"},{"text":"log","type":"link","path":"standards/log.html"},{"text":"time","type":"link","path":"standards/time.html"},{"text":"http","type":"link","path":"standards/net/http.html"},{"text":"math","type":"link","path":"standards/data/math.html"},{"text":"sort","type":"link","path":"standards/data/sort.html"},{"text":"big","type":"link","path":"standards/data/big.html"},{"text":"container","type":"link","path":"standards/data/container.html"},{"text":"sql","type":"link","path":"standards/database/sql.html"},{"text":"THEME","type":"label"},{"text":"使用文档主题","type":"link","path":"theme/theme-usage.html"},{"text":"SUPPORT AND FEEDBACK","type":"label"},{"text":"Raise an Issue on Github","type":"link","path":"https://github.com/shipengqi/golang-learn/issues/new"}]}}},"excerpt":"","more":""},{"title":"Golang 介绍","_content":"\n# Golang 介绍\nGo 语言非常简单，只有 25 个关键字：\n\n- `var` 和 `const` 声明变量和常量\n- `package` 和 `import` 声明所属包名和导入包。\n- `func` 用于定义函数和方法\n- `return` 用于从函数返回\n- `defer` 用于类似析构函数\n- `go` 用于并发\n- `select` 用于选择不同类型的通讯\n- `interface` 用于定义接口\n- `struct` 用于定义抽象数据类型\n- `break`、`case`、`continue`、`for`、`fallthrough`、`else`、`if`、`switch`、`goto`、`default` 流程控制语句\n- `chan` 用于 `channel` 通讯\n- `type` 用于声明自定义类型\n- `map` 用于声明 `map` 类型数据\n- `range` 用于读取 `slice`、`map`、`channel` 数据\n\n## 数据类型\nGo 语言的四类数据类型\n- 基础类型，数值、字符串和布尔型\n- 复合类型，数组和结构体\n- 引用类型，指针、切片、字典、函数、通道\n- 接口类型\n\n## 三种文件\n- 命令源码文件，如果一个源码文件声明属于 `main` 包，并且包含一个无参数声明且无结果声明的 `main` 函数，那么它就是命令源码文件。\n- 库源码文件，库源码文件是不能被直接运行的源码文件，它仅用于存放程序实体，这些程序实体可以被其他代码使用\n- 测试源码文件\n\n\n## package\n在写 Go 语言的代码时，每个文件的头部都有一行 `package` 声明语句。比如 `package main`。这个声明表示这个源\n文件属于哪个包（类似其他语言的 `modules` 或者 `libraries`）。 Go 语言的代码就是通过这个 `package` 来组织。\n\n## 注释\n使用 `//` 添加注释。一般我们会在包声明前添加注释，来对整个包挥着程序做整体的描述。\n\n## 行分隔符\nGo 中，一行代表一个语句结束，不需要以分号 `;` 结尾。多个语句写在同一行，则必须使用 `;`（不推荐使用）。 \n\n## os.Args\n程序的命令行参数可使用 `os.Args` 访问。`os.Args` 是一个字符串的切片。我们打印看一下：\n```go\npackage main\n\nimport (\n  \"fmt\"\n  \"os\"\n)\n\n// ++ 和 -- 都只能放在变量名,如 i ++\nfunc main() {\n  for i := 1; i < len(os.Args); i ++ {\n  \tfmt.Println(os.Args[i])\n  }\n}\n```\n然后运行：\n```bash\ngo run args1.go arg1 arg2 arg3\n```\n\n## 空标识符\n`_` 代表空标识符，**Go 不允许有无用的变量，空标识符可以作为忽略占位符**，比如：\n```go\nvar s, sep string\nfor _, arg := range os.Args[1:] {\n\ts += sep + arg\n\tsep = \" \"\n}\n```\n\n\n## 命名\n所有命名只能以字母或者 `_` 开头，可以包含字母，数字或者 `_`。区分大小写。\n关键字不能定义变量名，如 `func`，`default`。\n\n**注意：函数内部定义的，只能在函数内部使用（函数级），在函数外部定义的（包级），可以在当前包的所有文件中是使用。\n并且，是在函数外定义的名字，如果以大写字母开头，那么会被导出，也就是在包的外部也可以访问，所以定义名字时，要注意大小写。**\n\n## 声明\n- `var` 声明变量\n- `const` 声明常量\n- `type` 声明类型\n- `func` 声明函数\n\n每个文件以 `package` 声明语句。比如 `package main`。\n\n## make 和 new\n1. **`make` 只能用于内建类型（`map`、`slice` 和`channel`）的内存分配。`new` 用于各种类型的内存分配**。\n2. **`make` 返回初始化后的（非零）值，`new` 返回指针**。\n3. **`new` 函数可以为引用类型分配内存，但这是不完整的创建。比如 `map`，它仅分配了字典本身需要的内存，但是并没有为\n字典内的健值对分配内存，因此无法正常工作**。\n\n## 类型转换\n**Go 强制使用显示类型转换**。这样可以确定语句和表达式的明确含义。**类型转换在编译期完成，包括强制转换和隐式转换**。\n\n```go\na := 10\nb := byte(a)\nc := a + int(b) // 混合类型表达式必须保证类型一致\n```\n类型转换用于将一种数据类型的变量转换为另外一种类型的变量：\n```go\n类型名(表达式)\n```\n\n实例：\n```go\nvar sum int = 17\nvar count int = 5\nvar mean float32\n\nmean = float32(sum)/float32(count)\nfmt.Printf(\"mean 的值为: %f\\n\",mean)\n```\n\n对于整数类型值、整数常量之间的类型转换，原则上只要源值在目标类型的可表示范围内就是合法的。比如，`uint8(255)` \n可以把无类型的常量 255 转换为 `uint8` 类型的值，是因为 255 在 `[0, 255]` 的范围内。\n\n这种类型转换主要在**切换同一基础类型不同精度范围**时使用，比如我们要将 `int` 型转为 `int64` 类型时。\n\n```go\na := 100\nb := byte(a)\nc := a + int(b) // 混合类型表达式，类型必须保持一致\n```\n在 Go 中，非布尔值不能当做 `true/false` 使用，这点和我常用的js不同：\n```go\nx := 100\n\nif x { // 错误 x 不是布尔值\n\n}\n```\n\n如果**要转换为指针类型，或者单向 `channel`，或者函数，要给类型加上 `()`，避免编译器分析错误**，如：\n```go\nx := 100\n(*int)(&x) // *int 加括号，否则会被解析为*(int(&x))\n\n(<- channel int)(c)\n(func())(f)\n(func()int)(f) // 有返回值的函数其实可以不加括号，但是加括号的话，语义清晰\n```\n\n## 自定义类型\n使用 `type` 自定义类型，一般出现在包一级，与变量一样，如果类型名字的首字母是大写，则在包外部也可以使用：\n```go\ntype 类型名字 底层类型\n```\n\n如不同温度单位分别定义为不同的类型：\n```go\ntype Celsius float64    // 摄氏温度\ntype Fahrenheit float64 // 华氏温度\n\nconst (\n\tAbsoluteZeroC Celsius = -273.15 // 绝对零度\n\tFreezingC     Celsius = 0       // 结冰点温度\n\tBoilingC      Celsius = 100     // 沸水温度\n)\n\nfunc CToF(c Celsius) Fahrenheit { return Fahrenheit(c*9/5 + 32) }\n\nfunc FToC(f Fahrenheit) Celsius { return Celsius((f - 32) * 5 / 9) }\n```\n\n**自定义类型虽然置顶了底层类型，但是只是底层数据结构相同，不会继承底层类型的其他信息，比如（方法）。\n不能隐式转换，不能直接用于比较表达式**。\n\n```go\ntype data int\nvar d data = 10\n\nvar x int = d       // 错误：cannot use d (type data) as type int in assignment\n\nfmt.Println(d == x) // 错误：invalid operation: d == x (mismatched types data and int)\n```\n\n## 未命名类型\n比如数组，切片，字典，通道等类型与内部具体的元素类型和长度等属性有关，所以叫做**未命名类型**（unnamed type）。\n## 类型断言\n\n断言，顾名思义就是果断的去猜测一个未知的事物。在 go 语言中，`interface{}` 就是这个神秘的未知类型，其**断言操作就是用来\n判断 `interface{}` 的类型**。因为 `interface{}` 是个未知类型，在编译时无法确定，所以类型断言在运行时确定。\n\nGo 语言里面有一个语法，可以直接**判断是否是该类型的变量：`value, ok = x.(T)`**，这里 `value` 就是变量的值，`ok` 是\n一个 `bool` 类型，`x` 是 `interface{}` 变量，`T` 是断言的类型。\n\n该语法返回两个参数，第一个参数是 `x` 转化为 `T` 类型后的变量，第二个值是一个布尔值，若为 `true` 则表示断言成功，\n`false` 则表示断言失败。\n\n```go\n// comma-ok\nfor index, element := range list {\n\tif value, ok := element.(int); ok {\n\t\tfmt.Printf(\"list[%d] is an int and its value is %d\\n\", index, value)\n\t} else if value, ok := element.(string); ok {\n\t\tfmt.Printf(\"list[%d] is a string and its value is %s\\n\", index, value)\n\t} else if value, ok := element.(Person); ok {\n\t\tfmt.Printf(\"list[%d] is a Person and its value is %s\\n\", index, value)\n\t} else {\n\t\tfmt.Printf(\"list[%d] is of a different type\\n\", index)\n\t}\n}\n\n\n// 或者 使用 switch\nfor index, element := range list{\n\tswitch value := element.(type) {\n\t\tcase int:\n\t\t\tfmt.Printf(\"list[%d] is an int and its value is %d\\n\", index, value)\n\t\tcase string:\n\t\t\tfmt.Printf(\"list[%d] is a string and its value is %s\\n\", index, value)\n\t\tcase Person:\n\t\t\tfmt.Printf(\"list[%d] is a Person and its value is %s\\n\", index, value)\n\t\tdefault:\n\t\t\tfmt.Println(\"list[%d] is of a different type\", index)\n\t}\n}\n```\n\n**注意，`x.(type)` 语法不能在 `switch` 外的任何逻辑里面使用，如果你要在 `switch` 外面判断一个类型就使用 `comma-ok`**。\n\n### 生命周期\n对于在包一级声明的变量，它们的生命周期和程序的运行周期是一致的。\n局部变量（包括函数的参数和返回值也是局部变量）的生命周期则是动态的：每次从创建一个新变量的声明语句开始，\n直到该变量不再被引用为止，然后变量的存储空间可能被回收。\n\n## 编码\nGo 语言的源码文件必须使用 UTF-8 编码格式进行存储。如果源码文件中出现了非 UTF-8 编码的字符，那么在构建、安装以及运行的时候，\ngo 命令就会报告错误“illegal UTF-8 encoding”。\n\n### ASCII 编码\nASCII 是英文“American Standard Code for Information Interchange”的缩写，中文译为美国信息交换标准代码。\n\nASCII 编码方案使用单个字节（byte）的二进制数来编码一个字符。标准的 ASCII 编码用一个字节的最高比特（bit）位作为奇偶校验位，\n而扩展的 ASCII 编码则将此位也用于表示字符。ASCII 编码支持的可打印字符和控制字符的集合也被叫做 ASCII 编码集。\n\n### unicode 编码\n**unicode 编码规范，实际上是另一个更加通用的、针对书面字符和文本的字符编码标准。它为世界上现存的所有自然语言中的每一个字符，\n都设定了一个唯一的二进制编码**。它定义了不同自然语言的文本数据在国际间交换的统一方式，并为全球化软件创建了一个重要的基础。\n\nUnicode 编码规范通常使用十六进制表示法来表示 Unicode 代码点的整数值，并使用“U+”作为前缀。比如，英文字母字符“a”的 Unicode\n代码点是`U+0061`。在 Unicode 编码规范中，一个字符能且只能由与它对应的那个代码点表示。\n\nUnicode 编码规范提供了三种不同的编码格式，即：`UTF-8`、`UTF-16`和`UTF-32`。其中的 UTF 是 UCS Transformation Format 的缩写。\n而 UCS 又是 Universal Character Set 的缩写，但也可以代表 Unicode Character Set。所以，UTF 也可以被翻译为 Unicode 转换格式。\n它代表的是字符与字节序列之间的转换方式。\n\n在这几种编码格式的名称中，**“-”右边的整数的含义是，以多少个比特位作为一个编码单元**。以`UTF-8`为例，它会以 8 个比特，也就是一个字节，\n作为一个编码单元。它与标准的 ASCII 编码是完全兼容的。也就是说，在`[0x00, 0x7F]`的范围内，这两种编码表示的字符都是相同的。\n这也是 UTF-8 编码格式的一个巨大优势。\n\n**UTF-8 是一种可变宽的编码方案**。换句话说，**它会用一个或多个字节的二进制数来表示某个字符，最多使用四个字节**。比如，对于一个英文字符，\n它仅用一个字节的二进制数就可以表示，而对于一个中文字符，它需要使用三个字节才能够表示。不论怎样，一个受支持的字符总是可以由 UTF-8 编码\n为一个字节序列。以下会简称后者为 UTF-8 编码值。","source":"index.md","raw":"---\ntitle: Golang 介绍\n---\n\n# Golang 介绍\nGo 语言非常简单，只有 25 个关键字：\n\n- `var` 和 `const` 声明变量和常量\n- `package` 和 `import` 声明所属包名和导入包。\n- `func` 用于定义函数和方法\n- `return` 用于从函数返回\n- `defer` 用于类似析构函数\n- `go` 用于并发\n- `select` 用于选择不同类型的通讯\n- `interface` 用于定义接口\n- `struct` 用于定义抽象数据类型\n- `break`、`case`、`continue`、`for`、`fallthrough`、`else`、`if`、`switch`、`goto`、`default` 流程控制语句\n- `chan` 用于 `channel` 通讯\n- `type` 用于声明自定义类型\n- `map` 用于声明 `map` 类型数据\n- `range` 用于读取 `slice`、`map`、`channel` 数据\n\n## 数据类型\nGo 语言的四类数据类型\n- 基础类型，数值、字符串和布尔型\n- 复合类型，数组和结构体\n- 引用类型，指针、切片、字典、函数、通道\n- 接口类型\n\n## 三种文件\n- 命令源码文件，如果一个源码文件声明属于 `main` 包，并且包含一个无参数声明且无结果声明的 `main` 函数，那么它就是命令源码文件。\n- 库源码文件，库源码文件是不能被直接运行的源码文件，它仅用于存放程序实体，这些程序实体可以被其他代码使用\n- 测试源码文件\n\n\n## package\n在写 Go 语言的代码时，每个文件的头部都有一行 `package` 声明语句。比如 `package main`。这个声明表示这个源\n文件属于哪个包（类似其他语言的 `modules` 或者 `libraries`）。 Go 语言的代码就是通过这个 `package` 来组织。\n\n## 注释\n使用 `//` 添加注释。一般我们会在包声明前添加注释，来对整个包挥着程序做整体的描述。\n\n## 行分隔符\nGo 中，一行代表一个语句结束，不需要以分号 `;` 结尾。多个语句写在同一行，则必须使用 `;`（不推荐使用）。 \n\n## os.Args\n程序的命令行参数可使用 `os.Args` 访问。`os.Args` 是一个字符串的切片。我们打印看一下：\n```go\npackage main\n\nimport (\n  \"fmt\"\n  \"os\"\n)\n\n// ++ 和 -- 都只能放在变量名,如 i ++\nfunc main() {\n  for i := 1; i < len(os.Args); i ++ {\n  \tfmt.Println(os.Args[i])\n  }\n}\n```\n然后运行：\n```bash\ngo run args1.go arg1 arg2 arg3\n```\n\n## 空标识符\n`_` 代表空标识符，**Go 不允许有无用的变量，空标识符可以作为忽略占位符**，比如：\n```go\nvar s, sep string\nfor _, arg := range os.Args[1:] {\n\ts += sep + arg\n\tsep = \" \"\n}\n```\n\n\n## 命名\n所有命名只能以字母或者 `_` 开头，可以包含字母，数字或者 `_`。区分大小写。\n关键字不能定义变量名，如 `func`，`default`。\n\n**注意：函数内部定义的，只能在函数内部使用（函数级），在函数外部定义的（包级），可以在当前包的所有文件中是使用。\n并且，是在函数外定义的名字，如果以大写字母开头，那么会被导出，也就是在包的外部也可以访问，所以定义名字时，要注意大小写。**\n\n## 声明\n- `var` 声明变量\n- `const` 声明常量\n- `type` 声明类型\n- `func` 声明函数\n\n每个文件以 `package` 声明语句。比如 `package main`。\n\n## make 和 new\n1. **`make` 只能用于内建类型（`map`、`slice` 和`channel`）的内存分配。`new` 用于各种类型的内存分配**。\n2. **`make` 返回初始化后的（非零）值，`new` 返回指针**。\n3. **`new` 函数可以为引用类型分配内存，但这是不完整的创建。比如 `map`，它仅分配了字典本身需要的内存，但是并没有为\n字典内的健值对分配内存，因此无法正常工作**。\n\n## 类型转换\n**Go 强制使用显示类型转换**。这样可以确定语句和表达式的明确含义。**类型转换在编译期完成，包括强制转换和隐式转换**。\n\n```go\na := 10\nb := byte(a)\nc := a + int(b) // 混合类型表达式必须保证类型一致\n```\n类型转换用于将一种数据类型的变量转换为另外一种类型的变量：\n```go\n类型名(表达式)\n```\n\n实例：\n```go\nvar sum int = 17\nvar count int = 5\nvar mean float32\n\nmean = float32(sum)/float32(count)\nfmt.Printf(\"mean 的值为: %f\\n\",mean)\n```\n\n对于整数类型值、整数常量之间的类型转换，原则上只要源值在目标类型的可表示范围内就是合法的。比如，`uint8(255)` \n可以把无类型的常量 255 转换为 `uint8` 类型的值，是因为 255 在 `[0, 255]` 的范围内。\n\n这种类型转换主要在**切换同一基础类型不同精度范围**时使用，比如我们要将 `int` 型转为 `int64` 类型时。\n\n```go\na := 100\nb := byte(a)\nc := a + int(b) // 混合类型表达式，类型必须保持一致\n```\n在 Go 中，非布尔值不能当做 `true/false` 使用，这点和我常用的js不同：\n```go\nx := 100\n\nif x { // 错误 x 不是布尔值\n\n}\n```\n\n如果**要转换为指针类型，或者单向 `channel`，或者函数，要给类型加上 `()`，避免编译器分析错误**，如：\n```go\nx := 100\n(*int)(&x) // *int 加括号，否则会被解析为*(int(&x))\n\n(<- channel int)(c)\n(func())(f)\n(func()int)(f) // 有返回值的函数其实可以不加括号，但是加括号的话，语义清晰\n```\n\n## 自定义类型\n使用 `type` 自定义类型，一般出现在包一级，与变量一样，如果类型名字的首字母是大写，则在包外部也可以使用：\n```go\ntype 类型名字 底层类型\n```\n\n如不同温度单位分别定义为不同的类型：\n```go\ntype Celsius float64    // 摄氏温度\ntype Fahrenheit float64 // 华氏温度\n\nconst (\n\tAbsoluteZeroC Celsius = -273.15 // 绝对零度\n\tFreezingC     Celsius = 0       // 结冰点温度\n\tBoilingC      Celsius = 100     // 沸水温度\n)\n\nfunc CToF(c Celsius) Fahrenheit { return Fahrenheit(c*9/5 + 32) }\n\nfunc FToC(f Fahrenheit) Celsius { return Celsius((f - 32) * 5 / 9) }\n```\n\n**自定义类型虽然置顶了底层类型，但是只是底层数据结构相同，不会继承底层类型的其他信息，比如（方法）。\n不能隐式转换，不能直接用于比较表达式**。\n\n```go\ntype data int\nvar d data = 10\n\nvar x int = d       // 错误：cannot use d (type data) as type int in assignment\n\nfmt.Println(d == x) // 错误：invalid operation: d == x (mismatched types data and int)\n```\n\n## 未命名类型\n比如数组，切片，字典，通道等类型与内部具体的元素类型和长度等属性有关，所以叫做**未命名类型**（unnamed type）。\n## 类型断言\n\n断言，顾名思义就是果断的去猜测一个未知的事物。在 go 语言中，`interface{}` 就是这个神秘的未知类型，其**断言操作就是用来\n判断 `interface{}` 的类型**。因为 `interface{}` 是个未知类型，在编译时无法确定，所以类型断言在运行时确定。\n\nGo 语言里面有一个语法，可以直接**判断是否是该类型的变量：`value, ok = x.(T)`**，这里 `value` 就是变量的值，`ok` 是\n一个 `bool` 类型，`x` 是 `interface{}` 变量，`T` 是断言的类型。\n\n该语法返回两个参数，第一个参数是 `x` 转化为 `T` 类型后的变量，第二个值是一个布尔值，若为 `true` 则表示断言成功，\n`false` 则表示断言失败。\n\n```go\n// comma-ok\nfor index, element := range list {\n\tif value, ok := element.(int); ok {\n\t\tfmt.Printf(\"list[%d] is an int and its value is %d\\n\", index, value)\n\t} else if value, ok := element.(string); ok {\n\t\tfmt.Printf(\"list[%d] is a string and its value is %s\\n\", index, value)\n\t} else if value, ok := element.(Person); ok {\n\t\tfmt.Printf(\"list[%d] is a Person and its value is %s\\n\", index, value)\n\t} else {\n\t\tfmt.Printf(\"list[%d] is of a different type\\n\", index)\n\t}\n}\n\n\n// 或者 使用 switch\nfor index, element := range list{\n\tswitch value := element.(type) {\n\t\tcase int:\n\t\t\tfmt.Printf(\"list[%d] is an int and its value is %d\\n\", index, value)\n\t\tcase string:\n\t\t\tfmt.Printf(\"list[%d] is a string and its value is %s\\n\", index, value)\n\t\tcase Person:\n\t\t\tfmt.Printf(\"list[%d] is a Person and its value is %s\\n\", index, value)\n\t\tdefault:\n\t\t\tfmt.Println(\"list[%d] is of a different type\", index)\n\t}\n}\n```\n\n**注意，`x.(type)` 语法不能在 `switch` 外的任何逻辑里面使用，如果你要在 `switch` 外面判断一个类型就使用 `comma-ok`**。\n\n### 生命周期\n对于在包一级声明的变量，它们的生命周期和程序的运行周期是一致的。\n局部变量（包括函数的参数和返回值也是局部变量）的生命周期则是动态的：每次从创建一个新变量的声明语句开始，\n直到该变量不再被引用为止，然后变量的存储空间可能被回收。\n\n## 编码\nGo 语言的源码文件必须使用 UTF-8 编码格式进行存储。如果源码文件中出现了非 UTF-8 编码的字符，那么在构建、安装以及运行的时候，\ngo 命令就会报告错误“illegal UTF-8 encoding”。\n\n### ASCII 编码\nASCII 是英文“American Standard Code for Information Interchange”的缩写，中文译为美国信息交换标准代码。\n\nASCII 编码方案使用单个字节（byte）的二进制数来编码一个字符。标准的 ASCII 编码用一个字节的最高比特（bit）位作为奇偶校验位，\n而扩展的 ASCII 编码则将此位也用于表示字符。ASCII 编码支持的可打印字符和控制字符的集合也被叫做 ASCII 编码集。\n\n### unicode 编码\n**unicode 编码规范，实际上是另一个更加通用的、针对书面字符和文本的字符编码标准。它为世界上现存的所有自然语言中的每一个字符，\n都设定了一个唯一的二进制编码**。它定义了不同自然语言的文本数据在国际间交换的统一方式，并为全球化软件创建了一个重要的基础。\n\nUnicode 编码规范通常使用十六进制表示法来表示 Unicode 代码点的整数值，并使用“U+”作为前缀。比如，英文字母字符“a”的 Unicode\n代码点是`U+0061`。在 Unicode 编码规范中，一个字符能且只能由与它对应的那个代码点表示。\n\nUnicode 编码规范提供了三种不同的编码格式，即：`UTF-8`、`UTF-16`和`UTF-32`。其中的 UTF 是 UCS Transformation Format 的缩写。\n而 UCS 又是 Universal Character Set 的缩写，但也可以代表 Unicode Character Set。所以，UTF 也可以被翻译为 Unicode 转换格式。\n它代表的是字符与字节序列之间的转换方式。\n\n在这几种编码格式的名称中，**“-”右边的整数的含义是，以多少个比特位作为一个编码单元**。以`UTF-8`为例，它会以 8 个比特，也就是一个字节，\n作为一个编码单元。它与标准的 ASCII 编码是完全兼容的。也就是说，在`[0x00, 0x7F]`的范围内，这两种编码表示的字符都是相同的。\n这也是 UTF-8 编码格式的一个巨大优势。\n\n**UTF-8 是一种可变宽的编码方案**。换句话说，**它会用一个或多个字节的二进制数来表示某个字符，最多使用四个字节**。比如，对于一个英文字符，\n它仅用一个字节的二进制数就可以表示，而对于一个中文字符，它需要使用三个字节才能够表示。不论怎样，一个受支持的字符总是可以由 UTF-8 编码\n为一个字节序列。以下会简称后者为 UTF-8 编码值。","date":"2019-10-19T13:40:15.173Z","updated":"2019-10-19T13:40:15.173Z","path":"index.html","comments":1,"layout":"page","_id":"ck1xm14jz0007fcw2pwwdujcn","content":"<h1 id=\"Golang-介绍\"><a href=\"#Golang-介绍\" class=\"headerlink\" title=\"Golang 介绍\"></a>Golang 介绍</h1><p>Go 语言非常简单，只有 25 个关键字：</p>\n<ul>\n<li><code>var</code> 和 <code>const</code> 声明变量和常量</li>\n<li><code>package</code> 和 <code>import</code> 声明所属包名和导入包。</li>\n<li><code>func</code> 用于定义函数和方法</li>\n<li><code>return</code> 用于从函数返回</li>\n<li><code>defer</code> 用于类似析构函数</li>\n<li><code>go</code> 用于并发</li>\n<li><code>select</code> 用于选择不同类型的通讯</li>\n<li><code>interface</code> 用于定义接口</li>\n<li><code>struct</code> 用于定义抽象数据类型</li>\n<li><code>break</code>、<code>case</code>、<code>continue</code>、<code>for</code>、<code>fallthrough</code>、<code>else</code>、<code>if</code>、<code>switch</code>、<code>goto</code>、<code>default</code> 流程控制语句</li>\n<li><code>chan</code> 用于 <code>channel</code> 通讯</li>\n<li><code>type</code> 用于声明自定义类型</li>\n<li><code>map</code> 用于声明 <code>map</code> 类型数据</li>\n<li><code>range</code> 用于读取 <code>slice</code>、<code>map</code>、<code>channel</code> 数据</li>\n</ul>\n<h2 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h2><p>Go 语言的四类数据类型</p>\n<ul>\n<li>基础类型，数值、字符串和布尔型</li>\n<li>复合类型，数组和结构体</li>\n<li>引用类型，指针、切片、字典、函数、通道</li>\n<li>接口类型</li>\n</ul>\n<h2 id=\"三种文件\"><a href=\"#三种文件\" class=\"headerlink\" title=\"三种文件\"></a>三种文件</h2><ul>\n<li>命令源码文件，如果一个源码文件声明属于 <code>main</code> 包，并且包含一个无参数声明且无结果声明的 <code>main</code> 函数，那么它就是命令源码文件。</li>\n<li>库源码文件，库源码文件是不能被直接运行的源码文件，它仅用于存放程序实体，这些程序实体可以被其他代码使用</li>\n<li>测试源码文件</li>\n</ul>\n<h2 id=\"package\"><a href=\"#package\" class=\"headerlink\" title=\"package\"></a>package</h2><p>在写 Go 语言的代码时，每个文件的头部都有一行 <code>package</code> 声明语句。比如 <code>package main</code>。这个声明表示这个源<br>文件属于哪个包（类似其他语言的 <code>modules</code> 或者 <code>libraries</code>）。 Go 语言的代码就是通过这个 <code>package</code> 来组织。</p>\n<h2 id=\"注释\"><a href=\"#注释\" class=\"headerlink\" title=\"注释\"></a>注释</h2><p>使用 <code>//</code> 添加注释。一般我们会在包声明前添加注释，来对整个包挥着程序做整体的描述。</p>\n<h2 id=\"行分隔符\"><a href=\"#行分隔符\" class=\"headerlink\" title=\"行分隔符\"></a>行分隔符</h2><p>Go 中，一行代表一个语句结束，不需要以分号 <code>;</code> 结尾。多个语句写在同一行，则必须使用 <code>;</code>（不推荐使用）。 </p>\n<h2 id=\"os-Args\"><a href=\"#os-Args\" class=\"headerlink\" title=\"os.Args\"></a>os.Args</h2><p>程序的命令行参数可使用 <code>os.Args</code> 访问。<code>os.Args</code> 是一个字符串的切片。我们打印看一下：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">  <span class=\"string\">\"fmt\"</span></span><br><span class=\"line\">  <span class=\"string\">\"os\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ++ 和 -- 都只能放在变量名,如 i ++</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> i := <span class=\"number\">1</span>; i &lt; <span class=\"built_in\">len</span>(os.Args); i ++ &#123;</span><br><span class=\"line\">  \tfmt.Println(os.Args[i])</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>然后运行：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go run args1.go arg1 arg2 arg3</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"空标识符\"><a href=\"#空标识符\" class=\"headerlink\" title=\"空标识符\"></a>空标识符</h2><p><code>_</code> 代表空标识符，<strong>Go 不允许有无用的变量，空标识符可以作为忽略占位符</strong>，比如：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> s, sep <span class=\"keyword\">string</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> _, arg := <span class=\"keyword\">range</span> os.Args[<span class=\"number\">1</span>:] &#123;</span><br><span class=\"line\">\ts += sep + arg</span><br><span class=\"line\">\tsep = <span class=\"string\">\" \"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"命名\"><a href=\"#命名\" class=\"headerlink\" title=\"命名\"></a>命名</h2><p>所有命名只能以字母或者 <code>_</code> 开头，可以包含字母，数字或者 <code>_</code>。区分大小写。<br>关键字不能定义变量名，如 <code>func</code>，<code>default</code>。</p>\n<p><strong>注意：函数内部定义的，只能在函数内部使用（函数级），在函数外部定义的（包级），可以在当前包的所有文件中是使用。<br>并且，是在函数外定义的名字，如果以大写字母开头，那么会被导出，也就是在包的外部也可以访问，所以定义名字时，要注意大小写。</strong></p>\n<h2 id=\"声明\"><a href=\"#声明\" class=\"headerlink\" title=\"声明\"></a>声明</h2><ul>\n<li><code>var</code> 声明变量</li>\n<li><code>const</code> 声明常量</li>\n<li><code>type</code> 声明类型</li>\n<li><code>func</code> 声明函数</li>\n</ul>\n<p>每个文件以 <code>package</code> 声明语句。比如 <code>package main</code>。</p>\n<h2 id=\"make-和-new\"><a href=\"#make-和-new\" class=\"headerlink\" title=\"make 和 new\"></a>make 和 new</h2><ol>\n<li><strong><code>make</code> 只能用于内建类型（<code>map</code>、<code>slice</code> 和<code>channel</code>）的内存分配。<code>new</code> 用于各种类型的内存分配</strong>。</li>\n<li><strong><code>make</code> 返回初始化后的（非零）值，<code>new</code> 返回指针</strong>。</li>\n<li><strong><code>new</code> 函数可以为引用类型分配内存，但这是不完整的创建。比如 <code>map</code>，它仅分配了字典本身需要的内存，但是并没有为<br>字典内的健值对分配内存，因此无法正常工作</strong>。</li>\n</ol>\n<h2 id=\"类型转换\"><a href=\"#类型转换\" class=\"headerlink\" title=\"类型转换\"></a>类型转换</h2><p><strong>Go 强制使用显示类型转换</strong>。这样可以确定语句和表达式的明确含义。<strong>类型转换在编译期完成，包括强制转换和隐式转换</strong>。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a := <span class=\"number\">10</span></span><br><span class=\"line\">b := <span class=\"keyword\">byte</span>(a)</span><br><span class=\"line\">c := a + <span class=\"keyword\">int</span>(b) <span class=\"comment\">// 混合类型表达式必须保证类型一致</span></span><br></pre></td></tr></table></figure>\n<p>类型转换用于将一种数据类型的变量转换为另外一种类型的变量：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">类型名(表达式)</span><br></pre></td></tr></table></figure></p>\n<p>实例：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> sum <span class=\"keyword\">int</span> = <span class=\"number\">17</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> count <span class=\"keyword\">int</span> = <span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> mean <span class=\"keyword\">float32</span></span><br><span class=\"line\"></span><br><span class=\"line\">mean = <span class=\"keyword\">float32</span>(sum)/<span class=\"keyword\">float32</span>(count)</span><br><span class=\"line\">fmt.Printf(<span class=\"string\">\"mean 的值为: %f\\n\"</span>,mean)</span><br></pre></td></tr></table></figure></p>\n<p>对于整数类型值、整数常量之间的类型转换，原则上只要源值在目标类型的可表示范围内就是合法的。比如，<code>uint8(255)</code><br>可以把无类型的常量 255 转换为 <code>uint8</code> 类型的值，是因为 255 在 <code>[0, 255]</code> 的范围内。</p>\n<p>这种类型转换主要在<strong>切换同一基础类型不同精度范围</strong>时使用，比如我们要将 <code>int</code> 型转为 <code>int64</code> 类型时。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a := <span class=\"number\">100</span></span><br><span class=\"line\">b := <span class=\"keyword\">byte</span>(a)</span><br><span class=\"line\">c := a + <span class=\"keyword\">int</span>(b) <span class=\"comment\">// 混合类型表达式，类型必须保持一致</span></span><br></pre></td></tr></table></figure>\n<p>在 Go 中，非布尔值不能当做 <code>true/false</code> 使用，这点和我常用的js不同：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x := <span class=\"number\">100</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> x &#123; <span class=\"comment\">// 错误 x 不是布尔值</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>如果<strong>要转换为指针类型，或者单向 <code>channel</code>，或者函数，要给类型加上 <code>()</code>，避免编译器分析错误</strong>，如：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x := <span class=\"number\">100</span></span><br><span class=\"line\">(*<span class=\"keyword\">int</span>)(&amp;x) <span class=\"comment\">// *int 加括号，否则会被解析为*(int(&amp;x))</span></span><br><span class=\"line\"></span><br><span class=\"line\">(&lt;- channel <span class=\"keyword\">int</span>)(c)</span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span>)<span class=\"params\">(f)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">(<span class=\"keyword\">func</span>()</span><span class=\"title\">int</span>)<span class=\"params\">(f)</span> // 有返回值的函数其实可以不加括号，但是加括号的话，语义清晰</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"自定义类型\"><a href=\"#自定义类型\" class=\"headerlink\" title=\"自定义类型\"></a>自定义类型</h2><p>使用 <code>type</code> 自定义类型，一般出现在包一级，与变量一样，如果类型名字的首字母是大写，则在包外部也可以使用：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> 类型名字 底层类型</span><br></pre></td></tr></table></figure></p>\n<p>如不同温度单位分别定义为不同的类型：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Celsius <span class=\"keyword\">float64</span>    <span class=\"comment\">// 摄氏温度</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Fahrenheit <span class=\"keyword\">float64</span> <span class=\"comment\">// 华氏温度</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">\tAbsoluteZeroC Celsius = <span class=\"number\">-273.15</span> <span class=\"comment\">// 绝对零度</span></span><br><span class=\"line\">\tFreezingC     Celsius = <span class=\"number\">0</span>       <span class=\"comment\">// 结冰点温度</span></span><br><span class=\"line\">\tBoilingC      Celsius = <span class=\"number\">100</span>     <span class=\"comment\">// 沸水温度</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">CToF</span><span class=\"params\">(c Celsius)</span> <span class=\"title\">Fahrenheit</span></span> &#123; <span class=\"keyword\">return</span> Fahrenheit(c*<span class=\"number\">9</span>/<span class=\"number\">5</span> + <span class=\"number\">32</span>) &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">FToC</span><span class=\"params\">(f Fahrenheit)</span> <span class=\"title\">Celsius</span></span> &#123; <span class=\"keyword\">return</span> Celsius((f - <span class=\"number\">32</span>) * <span class=\"number\">5</span> / <span class=\"number\">9</span>) &#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>自定义类型虽然置顶了底层类型，但是只是底层数据结构相同，不会继承底层类型的其他信息，比如（方法）。<br>不能隐式转换，不能直接用于比较表达式</strong>。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> data <span class=\"keyword\">int</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> d data = <span class=\"number\">10</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> x <span class=\"keyword\">int</span> = d       <span class=\"comment\">// 错误：cannot use d (type data) as type int in assignment</span></span><br><span class=\"line\"></span><br><span class=\"line\">fmt.Println(d == x) <span class=\"comment\">// 错误：invalid operation: d == x (mismatched types data and int)</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"未命名类型\"><a href=\"#未命名类型\" class=\"headerlink\" title=\"未命名类型\"></a>未命名类型</h2><p>比如数组，切片，字典，通道等类型与内部具体的元素类型和长度等属性有关，所以叫做<strong>未命名类型</strong>（unnamed type）。</p>\n<h2 id=\"类型断言\"><a href=\"#类型断言\" class=\"headerlink\" title=\"类型断言\"></a>类型断言</h2><p>断言，顾名思义就是果断的去猜测一个未知的事物。在 go 语言中，<code>interface{}</code> 就是这个神秘的未知类型，其<strong>断言操作就是用来<br>判断 <code>interface{}</code> 的类型</strong>。因为 <code>interface{}</code> 是个未知类型，在编译时无法确定，所以类型断言在运行时确定。</p>\n<p>Go 语言里面有一个语法，可以直接<strong>判断是否是该类型的变量：<code>value, ok = x.(T)</code></strong>，这里 <code>value</code> 就是变量的值，<code>ok</code> 是<br>一个 <code>bool</code> 类型，<code>x</code> 是 <code>interface{}</code> 变量，<code>T</code> 是断言的类型。</p>\n<p>该语法返回两个参数，第一个参数是 <code>x</code> 转化为 <code>T</code> 类型后的变量，第二个值是一个布尔值，若为 <code>true</code> 则表示断言成功，<br><code>false</code> 则表示断言失败。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// comma-ok</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> index, element := <span class=\"keyword\">range</span> list &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> value, ok := element.(<span class=\"keyword\">int</span>); ok &#123;</span><br><span class=\"line\">\t\tfmt.Printf(<span class=\"string\">\"list[%d] is an int and its value is %d\\n\"</span>, index, value)</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> value, ok := element.(<span class=\"keyword\">string</span>); ok &#123;</span><br><span class=\"line\">\t\tfmt.Printf(<span class=\"string\">\"list[%d] is a string and its value is %s\\n\"</span>, index, value)</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> value, ok := element.(Person); ok &#123;</span><br><span class=\"line\">\t\tfmt.Printf(<span class=\"string\">\"list[%d] is a Person and its value is %s\\n\"</span>, index, value)</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\tfmt.Printf(<span class=\"string\">\"list[%d] is of a different type\\n\"</span>, index)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 或者 使用 switch</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> index, element := <span class=\"keyword\">range</span> list&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">switch</span> value := element.(<span class=\"keyword\">type</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"keyword\">int</span>:</span><br><span class=\"line\">\t\t\tfmt.Printf(<span class=\"string\">\"list[%d] is an int and its value is %d\\n\"</span>, index, value)</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"keyword\">string</span>:</span><br><span class=\"line\">\t\t\tfmt.Printf(<span class=\"string\">\"list[%d] is a string and its value is %s\\n\"</span>, index, value)</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> Person:</span><br><span class=\"line\">\t\t\tfmt.Printf(<span class=\"string\">\"list[%d] is a Person and its value is %s\\n\"</span>, index, value)</span><br><span class=\"line\">\t\t<span class=\"keyword\">default</span>:</span><br><span class=\"line\">\t\t\tfmt.Println(<span class=\"string\">\"list[%d] is of a different type\"</span>, index)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>注意，<code>x.(type)</code> 语法不能在 <code>switch</code> 外的任何逻辑里面使用，如果你要在 <code>switch</code> 外面判断一个类型就使用 <code>comma-ok</code></strong>。</p>\n<h3 id=\"生命周期\"><a href=\"#生命周期\" class=\"headerlink\" title=\"生命周期\"></a>生命周期</h3><p>对于在包一级声明的变量，它们的生命周期和程序的运行周期是一致的。<br>局部变量（包括函数的参数和返回值也是局部变量）的生命周期则是动态的：每次从创建一个新变量的声明语句开始，<br>直到该变量不再被引用为止，然后变量的存储空间可能被回收。</p>\n<h2 id=\"编码\"><a href=\"#编码\" class=\"headerlink\" title=\"编码\"></a>编码</h2><p>Go 语言的源码文件必须使用 UTF-8 编码格式进行存储。如果源码文件中出现了非 UTF-8 编码的字符，那么在构建、安装以及运行的时候，<br>go 命令就会报告错误“illegal UTF-8 encoding”。</p>\n<h3 id=\"ASCII-编码\"><a href=\"#ASCII-编码\" class=\"headerlink\" title=\"ASCII 编码\"></a>ASCII 编码</h3><p>ASCII 是英文“American Standard Code for Information Interchange”的缩写，中文译为美国信息交换标准代码。</p>\n<p>ASCII 编码方案使用单个字节（byte）的二进制数来编码一个字符。标准的 ASCII 编码用一个字节的最高比特（bit）位作为奇偶校验位，<br>而扩展的 ASCII 编码则将此位也用于表示字符。ASCII 编码支持的可打印字符和控制字符的集合也被叫做 ASCII 编码集。</p>\n<h3 id=\"unicode-编码\"><a href=\"#unicode-编码\" class=\"headerlink\" title=\"unicode 编码\"></a>unicode 编码</h3><p><strong>unicode 编码规范，实际上是另一个更加通用的、针对书面字符和文本的字符编码标准。它为世界上现存的所有自然语言中的每一个字符，<br>都设定了一个唯一的二进制编码</strong>。它定义了不同自然语言的文本数据在国际间交换的统一方式，并为全球化软件创建了一个重要的基础。</p>\n<p>Unicode 编码规范通常使用十六进制表示法来表示 Unicode 代码点的整数值，并使用“U+”作为前缀。比如，英文字母字符“a”的 Unicode<br>代码点是<code>U+0061</code>。在 Unicode 编码规范中，一个字符能且只能由与它对应的那个代码点表示。</p>\n<p>Unicode 编码规范提供了三种不同的编码格式，即：<code>UTF-8</code>、<code>UTF-16</code>和<code>UTF-32</code>。其中的 UTF 是 UCS Transformation Format 的缩写。<br>而 UCS 又是 Universal Character Set 的缩写，但也可以代表 Unicode Character Set。所以，UTF 也可以被翻译为 Unicode 转换格式。<br>它代表的是字符与字节序列之间的转换方式。</p>\n<p>在这几种编码格式的名称中，<strong>“-”右边的整数的含义是，以多少个比特位作为一个编码单元</strong>。以<code>UTF-8</code>为例，它会以 8 个比特，也就是一个字节，<br>作为一个编码单元。它与标准的 ASCII 编码是完全兼容的。也就是说，在<code>[0x00, 0x7F]</code>的范围内，这两种编码表示的字符都是相同的。<br>这也是 UTF-8 编码格式的一个巨大优势。</p>\n<p><strong>UTF-8 是一种可变宽的编码方案</strong>。换句话说，<strong>它会用一个或多个字节的二进制数来表示某个字符，最多使用四个字节</strong>。比如，对于一个英文字符，<br>它仅用一个字节的二进制数就可以表示，而对于一个中文字符，它需要使用三个字节才能够表示。不论怎样，一个受支持的字符总是可以由 UTF-8 编码<br>为一个字节序列。以下会简称后者为 UTF-8 编码值。</p>\n","site":{"data":{"navigation":{"logo":{"text":"Golang Learn","type":"link","path":"index.html"},"main":[{"text":"Golang 基础","type":"label"},{"text":"Go 环境配置","type":"link","path":"basic/env_config.html"},{"text":"包","type":"link","path":"basic/package.html"},{"text":"基础数据类型","type":"link","path":"basic/basic_data.html"},{"text":"变量","type":"link","path":"basic/var.html"},{"text":"常量","type":"link","path":"basic/constant.html"},{"text":"控制语句","type":"link","path":"basic/flow.html"},{"text":"运算符","type":"link","path":"basic/operator.html"},{"text":"作用域","type":"link","path":"basic/scope.html"},{"text":"指针","type":"link","path":"basic/pointer.html"},{"text":"数组","type":"link","path":"basic/array.html"},{"text":"切片","type":"link","path":"basic/slice.html"},{"text":"字典","type":"link","path":"basic/map.html"},{"text":"函数","type":"link","path":"basic/function.html"},{"text":"结构体","type":"link","path":"basic/struct.html"},{"text":"接口","type":"link","path":"basic/interface.html"},{"text":"面向对象","type":"link","path":"basic/oop.html"},{"text":"错误","type":"link","path":"basic/error.html"},{"text":"序列化","type":"link","path":"basic/json.html"},{"text":"反射","type":"link","path":"basic/reflect.html"},{"text":"测试","type":"link","path":"basic/test.html"},{"text":"并发编程","type":"label"},{"text":"goroutine","type":"link","path":"concurrent/goroutine.html"},{"text":"channel","type":"link","path":"concurrent/channel.html"},{"text":"同步和锁","type":"link","path":"concurrent/sync_lock.html"},{"text":"内存分配","type":"label"},{"text":"内存分配","type":"link","path":"advance/mm.html"},{"text":"垃圾回收","type":"label"},{"text":"垃圾回收","type":"link","path":"advance/gc.html"},{"text":"标准库","type":"label"},{"text":"fmt","type":"link","path":"standards/io/fmt.html"},{"text":"io","type":"link","path":"standards/io/io.html"},{"text":"ioutil","type":"link","path":"standards/io/ioutil.html"},{"text":"bufio","type":"link","path":"standards/io/bufio.html"},{"text":"os","type":"link","path":"standards/os/os.html"},{"text":"filepath","type":"link","path":"standards/os/filepath.html"},{"text":"strings","type":"link","path":"standards/text/strings.html"},{"text":"strconv","type":"link","path":"standards/text/strconv.html"},{"text":"unicode","type":"link","path":"standards/text/unicode.html"},{"text":"log","type":"link","path":"standards/log.html"},{"text":"time","type":"link","path":"standards/time.html"},{"text":"http","type":"link","path":"standards/net/http.html"},{"text":"math","type":"link","path":"standards/data/math.html"},{"text":"sort","type":"link","path":"standards/data/sort.html"},{"text":"big","type":"link","path":"standards/data/big.html"},{"text":"container","type":"link","path":"standards/data/container.html"},{"text":"sql","type":"link","path":"standards/database/sql.html"},{"text":"THEME","type":"label"},{"text":"使用文档主题","type":"link","path":"theme/theme-usage.html"},{"text":"SUPPORT AND FEEDBACK","type":"label"},{"text":"Raise an Issue on Github","type":"link","path":"https://github.com/shipengqi/golang-learn/issues/new"}]}}},"excerpt":"","more":"<h1 id=\"Golang-介绍\"><a href=\"#Golang-介绍\" class=\"headerlink\" title=\"Golang 介绍\"></a>Golang 介绍</h1><p>Go 语言非常简单，只有 25 个关键字：</p>\n<ul>\n<li><code>var</code> 和 <code>const</code> 声明变量和常量</li>\n<li><code>package</code> 和 <code>import</code> 声明所属包名和导入包。</li>\n<li><code>func</code> 用于定义函数和方法</li>\n<li><code>return</code> 用于从函数返回</li>\n<li><code>defer</code> 用于类似析构函数</li>\n<li><code>go</code> 用于并发</li>\n<li><code>select</code> 用于选择不同类型的通讯</li>\n<li><code>interface</code> 用于定义接口</li>\n<li><code>struct</code> 用于定义抽象数据类型</li>\n<li><code>break</code>、<code>case</code>、<code>continue</code>、<code>for</code>、<code>fallthrough</code>、<code>else</code>、<code>if</code>、<code>switch</code>、<code>goto</code>、<code>default</code> 流程控制语句</li>\n<li><code>chan</code> 用于 <code>channel</code> 通讯</li>\n<li><code>type</code> 用于声明自定义类型</li>\n<li><code>map</code> 用于声明 <code>map</code> 类型数据</li>\n<li><code>range</code> 用于读取 <code>slice</code>、<code>map</code>、<code>channel</code> 数据</li>\n</ul>\n<h2 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h2><p>Go 语言的四类数据类型</p>\n<ul>\n<li>基础类型，数值、字符串和布尔型</li>\n<li>复合类型，数组和结构体</li>\n<li>引用类型，指针、切片、字典、函数、通道</li>\n<li>接口类型</li>\n</ul>\n<h2 id=\"三种文件\"><a href=\"#三种文件\" class=\"headerlink\" title=\"三种文件\"></a>三种文件</h2><ul>\n<li>命令源码文件，如果一个源码文件声明属于 <code>main</code> 包，并且包含一个无参数声明且无结果声明的 <code>main</code> 函数，那么它就是命令源码文件。</li>\n<li>库源码文件，库源码文件是不能被直接运行的源码文件，它仅用于存放程序实体，这些程序实体可以被其他代码使用</li>\n<li>测试源码文件</li>\n</ul>\n<h2 id=\"package\"><a href=\"#package\" class=\"headerlink\" title=\"package\"></a>package</h2><p>在写 Go 语言的代码时，每个文件的头部都有一行 <code>package</code> 声明语句。比如 <code>package main</code>。这个声明表示这个源<br>文件属于哪个包（类似其他语言的 <code>modules</code> 或者 <code>libraries</code>）。 Go 语言的代码就是通过这个 <code>package</code> 来组织。</p>\n<h2 id=\"注释\"><a href=\"#注释\" class=\"headerlink\" title=\"注释\"></a>注释</h2><p>使用 <code>//</code> 添加注释。一般我们会在包声明前添加注释，来对整个包挥着程序做整体的描述。</p>\n<h2 id=\"行分隔符\"><a href=\"#行分隔符\" class=\"headerlink\" title=\"行分隔符\"></a>行分隔符</h2><p>Go 中，一行代表一个语句结束，不需要以分号 <code>;</code> 结尾。多个语句写在同一行，则必须使用 <code>;</code>（不推荐使用）。 </p>\n<h2 id=\"os-Args\"><a href=\"#os-Args\" class=\"headerlink\" title=\"os.Args\"></a>os.Args</h2><p>程序的命令行参数可使用 <code>os.Args</code> 访问。<code>os.Args</code> 是一个字符串的切片。我们打印看一下：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">  <span class=\"string\">\"fmt\"</span></span><br><span class=\"line\">  <span class=\"string\">\"os\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ++ 和 -- 都只能放在变量名,如 i ++</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> i := <span class=\"number\">1</span>; i &lt; <span class=\"built_in\">len</span>(os.Args); i ++ &#123;</span><br><span class=\"line\">  \tfmt.Println(os.Args[i])</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>然后运行：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go run args1.go arg1 arg2 arg3</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"空标识符\"><a href=\"#空标识符\" class=\"headerlink\" title=\"空标识符\"></a>空标识符</h2><p><code>_</code> 代表空标识符，<strong>Go 不允许有无用的变量，空标识符可以作为忽略占位符</strong>，比如：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> s, sep <span class=\"keyword\">string</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> _, arg := <span class=\"keyword\">range</span> os.Args[<span class=\"number\">1</span>:] &#123;</span><br><span class=\"line\">\ts += sep + arg</span><br><span class=\"line\">\tsep = <span class=\"string\">\" \"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"命名\"><a href=\"#命名\" class=\"headerlink\" title=\"命名\"></a>命名</h2><p>所有命名只能以字母或者 <code>_</code> 开头，可以包含字母，数字或者 <code>_</code>。区分大小写。<br>关键字不能定义变量名，如 <code>func</code>，<code>default</code>。</p>\n<p><strong>注意：函数内部定义的，只能在函数内部使用（函数级），在函数外部定义的（包级），可以在当前包的所有文件中是使用。<br>并且，是在函数外定义的名字，如果以大写字母开头，那么会被导出，也就是在包的外部也可以访问，所以定义名字时，要注意大小写。</strong></p>\n<h2 id=\"声明\"><a href=\"#声明\" class=\"headerlink\" title=\"声明\"></a>声明</h2><ul>\n<li><code>var</code> 声明变量</li>\n<li><code>const</code> 声明常量</li>\n<li><code>type</code> 声明类型</li>\n<li><code>func</code> 声明函数</li>\n</ul>\n<p>每个文件以 <code>package</code> 声明语句。比如 <code>package main</code>。</p>\n<h2 id=\"make-和-new\"><a href=\"#make-和-new\" class=\"headerlink\" title=\"make 和 new\"></a>make 和 new</h2><ol>\n<li><strong><code>make</code> 只能用于内建类型（<code>map</code>、<code>slice</code> 和<code>channel</code>）的内存分配。<code>new</code> 用于各种类型的内存分配</strong>。</li>\n<li><strong><code>make</code> 返回初始化后的（非零）值，<code>new</code> 返回指针</strong>。</li>\n<li><strong><code>new</code> 函数可以为引用类型分配内存，但这是不完整的创建。比如 <code>map</code>，它仅分配了字典本身需要的内存，但是并没有为<br>字典内的健值对分配内存，因此无法正常工作</strong>。</li>\n</ol>\n<h2 id=\"类型转换\"><a href=\"#类型转换\" class=\"headerlink\" title=\"类型转换\"></a>类型转换</h2><p><strong>Go 强制使用显示类型转换</strong>。这样可以确定语句和表达式的明确含义。<strong>类型转换在编译期完成，包括强制转换和隐式转换</strong>。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a := <span class=\"number\">10</span></span><br><span class=\"line\">b := <span class=\"keyword\">byte</span>(a)</span><br><span class=\"line\">c := a + <span class=\"keyword\">int</span>(b) <span class=\"comment\">// 混合类型表达式必须保证类型一致</span></span><br></pre></td></tr></table></figure>\n<p>类型转换用于将一种数据类型的变量转换为另外一种类型的变量：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">类型名(表达式)</span><br></pre></td></tr></table></figure></p>\n<p>实例：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> sum <span class=\"keyword\">int</span> = <span class=\"number\">17</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> count <span class=\"keyword\">int</span> = <span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> mean <span class=\"keyword\">float32</span></span><br><span class=\"line\"></span><br><span class=\"line\">mean = <span class=\"keyword\">float32</span>(sum)/<span class=\"keyword\">float32</span>(count)</span><br><span class=\"line\">fmt.Printf(<span class=\"string\">\"mean 的值为: %f\\n\"</span>,mean)</span><br></pre></td></tr></table></figure></p>\n<p>对于整数类型值、整数常量之间的类型转换，原则上只要源值在目标类型的可表示范围内就是合法的。比如，<code>uint8(255)</code><br>可以把无类型的常量 255 转换为 <code>uint8</code> 类型的值，是因为 255 在 <code>[0, 255]</code> 的范围内。</p>\n<p>这种类型转换主要在<strong>切换同一基础类型不同精度范围</strong>时使用，比如我们要将 <code>int</code> 型转为 <code>int64</code> 类型时。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a := <span class=\"number\">100</span></span><br><span class=\"line\">b := <span class=\"keyword\">byte</span>(a)</span><br><span class=\"line\">c := a + <span class=\"keyword\">int</span>(b) <span class=\"comment\">// 混合类型表达式，类型必须保持一致</span></span><br></pre></td></tr></table></figure>\n<p>在 Go 中，非布尔值不能当做 <code>true/false</code> 使用，这点和我常用的js不同：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x := <span class=\"number\">100</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> x &#123; <span class=\"comment\">// 错误 x 不是布尔值</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>如果<strong>要转换为指针类型，或者单向 <code>channel</code>，或者函数，要给类型加上 <code>()</code>，避免编译器分析错误</strong>，如：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x := <span class=\"number\">100</span></span><br><span class=\"line\">(*<span class=\"keyword\">int</span>)(&amp;x) <span class=\"comment\">// *int 加括号，否则会被解析为*(int(&amp;x))</span></span><br><span class=\"line\"></span><br><span class=\"line\">(&lt;- channel <span class=\"keyword\">int</span>)(c)</span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span>)<span class=\"params\">(f)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">(<span class=\"keyword\">func</span>()</span><span class=\"title\">int</span>)<span class=\"params\">(f)</span> // 有返回值的函数其实可以不加括号，但是加括号的话，语义清晰</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"自定义类型\"><a href=\"#自定义类型\" class=\"headerlink\" title=\"自定义类型\"></a>自定义类型</h2><p>使用 <code>type</code> 自定义类型，一般出现在包一级，与变量一样，如果类型名字的首字母是大写，则在包外部也可以使用：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> 类型名字 底层类型</span><br></pre></td></tr></table></figure></p>\n<p>如不同温度单位分别定义为不同的类型：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Celsius <span class=\"keyword\">float64</span>    <span class=\"comment\">// 摄氏温度</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Fahrenheit <span class=\"keyword\">float64</span> <span class=\"comment\">// 华氏温度</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">\tAbsoluteZeroC Celsius = <span class=\"number\">-273.15</span> <span class=\"comment\">// 绝对零度</span></span><br><span class=\"line\">\tFreezingC     Celsius = <span class=\"number\">0</span>       <span class=\"comment\">// 结冰点温度</span></span><br><span class=\"line\">\tBoilingC      Celsius = <span class=\"number\">100</span>     <span class=\"comment\">// 沸水温度</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">CToF</span><span class=\"params\">(c Celsius)</span> <span class=\"title\">Fahrenheit</span></span> &#123; <span class=\"keyword\">return</span> Fahrenheit(c*<span class=\"number\">9</span>/<span class=\"number\">5</span> + <span class=\"number\">32</span>) &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">FToC</span><span class=\"params\">(f Fahrenheit)</span> <span class=\"title\">Celsius</span></span> &#123; <span class=\"keyword\">return</span> Celsius((f - <span class=\"number\">32</span>) * <span class=\"number\">5</span> / <span class=\"number\">9</span>) &#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>自定义类型虽然置顶了底层类型，但是只是底层数据结构相同，不会继承底层类型的其他信息，比如（方法）。<br>不能隐式转换，不能直接用于比较表达式</strong>。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> data <span class=\"keyword\">int</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> d data = <span class=\"number\">10</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> x <span class=\"keyword\">int</span> = d       <span class=\"comment\">// 错误：cannot use d (type data) as type int in assignment</span></span><br><span class=\"line\"></span><br><span class=\"line\">fmt.Println(d == x) <span class=\"comment\">// 错误：invalid operation: d == x (mismatched types data and int)</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"未命名类型\"><a href=\"#未命名类型\" class=\"headerlink\" title=\"未命名类型\"></a>未命名类型</h2><p>比如数组，切片，字典，通道等类型与内部具体的元素类型和长度等属性有关，所以叫做<strong>未命名类型</strong>（unnamed type）。</p>\n<h2 id=\"类型断言\"><a href=\"#类型断言\" class=\"headerlink\" title=\"类型断言\"></a>类型断言</h2><p>断言，顾名思义就是果断的去猜测一个未知的事物。在 go 语言中，<code>interface{}</code> 就是这个神秘的未知类型，其<strong>断言操作就是用来<br>判断 <code>interface{}</code> 的类型</strong>。因为 <code>interface{}</code> 是个未知类型，在编译时无法确定，所以类型断言在运行时确定。</p>\n<p>Go 语言里面有一个语法，可以直接<strong>判断是否是该类型的变量：<code>value, ok = x.(T)</code></strong>，这里 <code>value</code> 就是变量的值，<code>ok</code> 是<br>一个 <code>bool</code> 类型，<code>x</code> 是 <code>interface{}</code> 变量，<code>T</code> 是断言的类型。</p>\n<p>该语法返回两个参数，第一个参数是 <code>x</code> 转化为 <code>T</code> 类型后的变量，第二个值是一个布尔值，若为 <code>true</code> 则表示断言成功，<br><code>false</code> 则表示断言失败。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// comma-ok</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> index, element := <span class=\"keyword\">range</span> list &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> value, ok := element.(<span class=\"keyword\">int</span>); ok &#123;</span><br><span class=\"line\">\t\tfmt.Printf(<span class=\"string\">\"list[%d] is an int and its value is %d\\n\"</span>, index, value)</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> value, ok := element.(<span class=\"keyword\">string</span>); ok &#123;</span><br><span class=\"line\">\t\tfmt.Printf(<span class=\"string\">\"list[%d] is a string and its value is %s\\n\"</span>, index, value)</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> value, ok := element.(Person); ok &#123;</span><br><span class=\"line\">\t\tfmt.Printf(<span class=\"string\">\"list[%d] is a Person and its value is %s\\n\"</span>, index, value)</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\tfmt.Printf(<span class=\"string\">\"list[%d] is of a different type\\n\"</span>, index)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 或者 使用 switch</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> index, element := <span class=\"keyword\">range</span> list&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">switch</span> value := element.(<span class=\"keyword\">type</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"keyword\">int</span>:</span><br><span class=\"line\">\t\t\tfmt.Printf(<span class=\"string\">\"list[%d] is an int and its value is %d\\n\"</span>, index, value)</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"keyword\">string</span>:</span><br><span class=\"line\">\t\t\tfmt.Printf(<span class=\"string\">\"list[%d] is a string and its value is %s\\n\"</span>, index, value)</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> Person:</span><br><span class=\"line\">\t\t\tfmt.Printf(<span class=\"string\">\"list[%d] is a Person and its value is %s\\n\"</span>, index, value)</span><br><span class=\"line\">\t\t<span class=\"keyword\">default</span>:</span><br><span class=\"line\">\t\t\tfmt.Println(<span class=\"string\">\"list[%d] is of a different type\"</span>, index)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>注意，<code>x.(type)</code> 语法不能在 <code>switch</code> 外的任何逻辑里面使用，如果你要在 <code>switch</code> 外面判断一个类型就使用 <code>comma-ok</code></strong>。</p>\n<h3 id=\"生命周期\"><a href=\"#生命周期\" class=\"headerlink\" title=\"生命周期\"></a>生命周期</h3><p>对于在包一级声明的变量，它们的生命周期和程序的运行周期是一致的。<br>局部变量（包括函数的参数和返回值也是局部变量）的生命周期则是动态的：每次从创建一个新变量的声明语句开始，<br>直到该变量不再被引用为止，然后变量的存储空间可能被回收。</p>\n<h2 id=\"编码\"><a href=\"#编码\" class=\"headerlink\" title=\"编码\"></a>编码</h2><p>Go 语言的源码文件必须使用 UTF-8 编码格式进行存储。如果源码文件中出现了非 UTF-8 编码的字符，那么在构建、安装以及运行的时候，<br>go 命令就会报告错误“illegal UTF-8 encoding”。</p>\n<h3 id=\"ASCII-编码\"><a href=\"#ASCII-编码\" class=\"headerlink\" title=\"ASCII 编码\"></a>ASCII 编码</h3><p>ASCII 是英文“American Standard Code for Information Interchange”的缩写，中文译为美国信息交换标准代码。</p>\n<p>ASCII 编码方案使用单个字节（byte）的二进制数来编码一个字符。标准的 ASCII 编码用一个字节的最高比特（bit）位作为奇偶校验位，<br>而扩展的 ASCII 编码则将此位也用于表示字符。ASCII 编码支持的可打印字符和控制字符的集合也被叫做 ASCII 编码集。</p>\n<h3 id=\"unicode-编码\"><a href=\"#unicode-编码\" class=\"headerlink\" title=\"unicode 编码\"></a>unicode 编码</h3><p><strong>unicode 编码规范，实际上是另一个更加通用的、针对书面字符和文本的字符编码标准。它为世界上现存的所有自然语言中的每一个字符，<br>都设定了一个唯一的二进制编码</strong>。它定义了不同自然语言的文本数据在国际间交换的统一方式，并为全球化软件创建了一个重要的基础。</p>\n<p>Unicode 编码规范通常使用十六进制表示法来表示 Unicode 代码点的整数值，并使用“U+”作为前缀。比如，英文字母字符“a”的 Unicode<br>代码点是<code>U+0061</code>。在 Unicode 编码规范中，一个字符能且只能由与它对应的那个代码点表示。</p>\n<p>Unicode 编码规范提供了三种不同的编码格式，即：<code>UTF-8</code>、<code>UTF-16</code>和<code>UTF-32</code>。其中的 UTF 是 UCS Transformation Format 的缩写。<br>而 UCS 又是 Universal Character Set 的缩写，但也可以代表 Unicode Character Set。所以，UTF 也可以被翻译为 Unicode 转换格式。<br>它代表的是字符与字节序列之间的转换方式。</p>\n<p>在这几种编码格式的名称中，<strong>“-”右边的整数的含义是，以多少个比特位作为一个编码单元</strong>。以<code>UTF-8</code>为例，它会以 8 个比特，也就是一个字节，<br>作为一个编码单元。它与标准的 ASCII 编码是完全兼容的。也就是说，在<code>[0x00, 0x7F]</code>的范围内，这两种编码表示的字符都是相同的。<br>这也是 UTF-8 编码格式的一个巨大优势。</p>\n<p><strong>UTF-8 是一种可变宽的编码方案</strong>。换句话说，<strong>它会用一个或多个字节的二进制数来表示某个字符，最多使用四个字节</strong>。比如，对于一个英文字符，<br>它仅用一个字节的二进制数就可以表示，而对于一个中文字符，它需要使用三个字节才能够表示。不论怎样，一个受支持的字符总是可以由 UTF-8 编码<br>为一个字节序列。以下会简称后者为 UTF-8 编码值。</p>\n"},{"title":"内存分配","_content":"# 内存分配\n## 基本策略\n1. 每次从操作系统申请一大块内存（如 1MB），以减少系统调用。\n2. 将申请到的大块内存按照特定大小切分成小块，够成链表。\n3. 为对象分配内存时，只需从大小合适的链表提取一小块即可。\n4. 回收对象内存时，将小块内存还给原链表，以便复用。\n5. 如果闲置内存过多，则尝试把部分内存还给操作系统，降低开销。\n\n> **内存分配器**只管理内存，不关心对象的状态，并且它不会主动回收内存，需要**垃圾回收器**在完成清理操作后，\n触发内存分配器的回收操作。\n\n## 内存块\n内存分配器管理的内存分为两种：\n- **span**：多个地址连续的**页**（page）组成的大块内存。\n- **object**：将 span 按特定大小切分成多个小块，每个小块可存储一个对象。\n\n分配器按页数区分大小不同的 span。例如，以页数为单位将 span 存放到管理数组中，需要时就以页数为索引进行查找。\nspan 的大小不是固定不变的。在获取闲置 span 时，如果没有找到大小合适的，那么会选择页数更多的 span，此时\n就会引发**裁剪**，将 span 多余的部分构成一个新的小的 span 放回管理数组。另外，分配器还会把相邻的空闲的\n span 合并构建更大的内存块，减少碎片。\n \n## tcmalloc\nGo 的内存分配器采用的是 tcmalloc 架构。\n \n由三种组件组成：\n- **cache**：运行期的每个线程都会绑定一个 cache，用于给没有锁的 object 的分配。\n- **central**：为所有 cache 提供切分好的后备 sapn 资源。\n- **heap**：管理闲置的 span，需要的时候向操作系统申请新的内存。\n\n## 回收\n**内存回收的源头是垃圾清理操作**。**回收不是释放**，因为内存分配器的核心是**内存复用**。不再使用的内存，放到合适的位置等待再次\n分配时使用。只有闲置内存过多时，才考虑释放。\n\n回收操作以 span 为单位。\n\n## 释放\n监控线程 sysmon 每隔一段时间就会检查 heap 里的闲置内存块，如果闲置时间超过阈值，则释放其关联的物理内存。","source":"advance/mm.md","raw":"---\ntitle: 内存分配\n---\n# 内存分配\n## 基本策略\n1. 每次从操作系统申请一大块内存（如 1MB），以减少系统调用。\n2. 将申请到的大块内存按照特定大小切分成小块，够成链表。\n3. 为对象分配内存时，只需从大小合适的链表提取一小块即可。\n4. 回收对象内存时，将小块内存还给原链表，以便复用。\n5. 如果闲置内存过多，则尝试把部分内存还给操作系统，降低开销。\n\n> **内存分配器**只管理内存，不关心对象的状态，并且它不会主动回收内存，需要**垃圾回收器**在完成清理操作后，\n触发内存分配器的回收操作。\n\n## 内存块\n内存分配器管理的内存分为两种：\n- **span**：多个地址连续的**页**（page）组成的大块内存。\n- **object**：将 span 按特定大小切分成多个小块，每个小块可存储一个对象。\n\n分配器按页数区分大小不同的 span。例如，以页数为单位将 span 存放到管理数组中，需要时就以页数为索引进行查找。\nspan 的大小不是固定不变的。在获取闲置 span 时，如果没有找到大小合适的，那么会选择页数更多的 span，此时\n就会引发**裁剪**，将 span 多余的部分构成一个新的小的 span 放回管理数组。另外，分配器还会把相邻的空闲的\n span 合并构建更大的内存块，减少碎片。\n \n## tcmalloc\nGo 的内存分配器采用的是 tcmalloc 架构。\n \n由三种组件组成：\n- **cache**：运行期的每个线程都会绑定一个 cache，用于给没有锁的 object 的分配。\n- **central**：为所有 cache 提供切分好的后备 sapn 资源。\n- **heap**：管理闲置的 span，需要的时候向操作系统申请新的内存。\n\n## 回收\n**内存回收的源头是垃圾清理操作**。**回收不是释放**，因为内存分配器的核心是**内存复用**。不再使用的内存，放到合适的位置等待再次\n分配时使用。只有闲置内存过多时，才考虑释放。\n\n回收操作以 span 为单位。\n\n## 释放\n监控线程 sysmon 每隔一段时间就会检查 heap 里的闲置内存块，如果闲置时间超过阈值，则释放其关联的物理内存。","date":"2019-09-01T00:18:20.646Z","updated":"2019-09-01T00:18:20.646Z","path":"advance/mm.html","comments":1,"layout":"page","_id":"ck1xm14kd0008fcw284s2euzm","content":"<h1 id=\"内存分配\"><a href=\"#内存分配\" class=\"headerlink\" title=\"内存分配\"></a>内存分配</h1><h2 id=\"基本策略\"><a href=\"#基本策略\" class=\"headerlink\" title=\"基本策略\"></a>基本策略</h2><ol>\n<li>每次从操作系统申请一大块内存（如 1MB），以减少系统调用。</li>\n<li>将申请到的大块内存按照特定大小切分成小块，够成链表。</li>\n<li>为对象分配内存时，只需从大小合适的链表提取一小块即可。</li>\n<li>回收对象内存时，将小块内存还给原链表，以便复用。</li>\n<li>如果闲置内存过多，则尝试把部分内存还给操作系统，降低开销。</li>\n</ol>\n<blockquote>\n<p><strong>内存分配器</strong>只管理内存，不关心对象的状态，并且它不会主动回收内存，需要<strong>垃圾回收器</strong>在完成清理操作后，<br>触发内存分配器的回收操作。</p>\n</blockquote>\n<h2 id=\"内存块\"><a href=\"#内存块\" class=\"headerlink\" title=\"内存块\"></a>内存块</h2><p>内存分配器管理的内存分为两种：</p>\n<ul>\n<li><strong>span</strong>：多个地址连续的<strong>页</strong>（page）组成的大块内存。</li>\n<li><strong>object</strong>：将 span 按特定大小切分成多个小块，每个小块可存储一个对象。</li>\n</ul>\n<p>分配器按页数区分大小不同的 span。例如，以页数为单位将 span 存放到管理数组中，需要时就以页数为索引进行查找。<br>span 的大小不是固定不变的。在获取闲置 span 时，如果没有找到大小合适的，那么会选择页数更多的 span，此时<br>就会引发<strong>裁剪</strong>，将 span 多余的部分构成一个新的小的 span 放回管理数组。另外，分配器还会把相邻的空闲的<br> span 合并构建更大的内存块，减少碎片。</p>\n<h2 id=\"tcmalloc\"><a href=\"#tcmalloc\" class=\"headerlink\" title=\"tcmalloc\"></a>tcmalloc</h2><p>Go 的内存分配器采用的是 tcmalloc 架构。</p>\n<p>由三种组件组成：</p>\n<ul>\n<li><strong>cache</strong>：运行期的每个线程都会绑定一个 cache，用于给没有锁的 object 的分配。</li>\n<li><strong>central</strong>：为所有 cache 提供切分好的后备 sapn 资源。</li>\n<li><strong>heap</strong>：管理闲置的 span，需要的时候向操作系统申请新的内存。</li>\n</ul>\n<h2 id=\"回收\"><a href=\"#回收\" class=\"headerlink\" title=\"回收\"></a>回收</h2><p><strong>内存回收的源头是垃圾清理操作</strong>。<strong>回收不是释放</strong>，因为内存分配器的核心是<strong>内存复用</strong>。不再使用的内存，放到合适的位置等待再次<br>分配时使用。只有闲置内存过多时，才考虑释放。</p>\n<p>回收操作以 span 为单位。</p>\n<h2 id=\"释放\"><a href=\"#释放\" class=\"headerlink\" title=\"释放\"></a>释放</h2><p>监控线程 sysmon 每隔一段时间就会检查 heap 里的闲置内存块，如果闲置时间超过阈值，则释放其关联的物理内存。</p>\n","site":{"data":{"navigation":{"logo":{"text":"Golang Learn","type":"link","path":"index.html"},"main":[{"text":"Golang 基础","type":"label"},{"text":"Go 环境配置","type":"link","path":"basic/env_config.html"},{"text":"包","type":"link","path":"basic/package.html"},{"text":"基础数据类型","type":"link","path":"basic/basic_data.html"},{"text":"变量","type":"link","path":"basic/var.html"},{"text":"常量","type":"link","path":"basic/constant.html"},{"text":"控制语句","type":"link","path":"basic/flow.html"},{"text":"运算符","type":"link","path":"basic/operator.html"},{"text":"作用域","type":"link","path":"basic/scope.html"},{"text":"指针","type":"link","path":"basic/pointer.html"},{"text":"数组","type":"link","path":"basic/array.html"},{"text":"切片","type":"link","path":"basic/slice.html"},{"text":"字典","type":"link","path":"basic/map.html"},{"text":"函数","type":"link","path":"basic/function.html"},{"text":"结构体","type":"link","path":"basic/struct.html"},{"text":"接口","type":"link","path":"basic/interface.html"},{"text":"面向对象","type":"link","path":"basic/oop.html"},{"text":"错误","type":"link","path":"basic/error.html"},{"text":"序列化","type":"link","path":"basic/json.html"},{"text":"反射","type":"link","path":"basic/reflect.html"},{"text":"测试","type":"link","path":"basic/test.html"},{"text":"并发编程","type":"label"},{"text":"goroutine","type":"link","path":"concurrent/goroutine.html"},{"text":"channel","type":"link","path":"concurrent/channel.html"},{"text":"同步和锁","type":"link","path":"concurrent/sync_lock.html"},{"text":"内存分配","type":"label"},{"text":"内存分配","type":"link","path":"advance/mm.html"},{"text":"垃圾回收","type":"label"},{"text":"垃圾回收","type":"link","path":"advance/gc.html"},{"text":"标准库","type":"label"},{"text":"fmt","type":"link","path":"standards/io/fmt.html"},{"text":"io","type":"link","path":"standards/io/io.html"},{"text":"ioutil","type":"link","path":"standards/io/ioutil.html"},{"text":"bufio","type":"link","path":"standards/io/bufio.html"},{"text":"os","type":"link","path":"standards/os/os.html"},{"text":"filepath","type":"link","path":"standards/os/filepath.html"},{"text":"strings","type":"link","path":"standards/text/strings.html"},{"text":"strconv","type":"link","path":"standards/text/strconv.html"},{"text":"unicode","type":"link","path":"standards/text/unicode.html"},{"text":"log","type":"link","path":"standards/log.html"},{"text":"time","type":"link","path":"standards/time.html"},{"text":"http","type":"link","path":"standards/net/http.html"},{"text":"math","type":"link","path":"standards/data/math.html"},{"text":"sort","type":"link","path":"standards/data/sort.html"},{"text":"big","type":"link","path":"standards/data/big.html"},{"text":"container","type":"link","path":"standards/data/container.html"},{"text":"sql","type":"link","path":"standards/database/sql.html"},{"text":"THEME","type":"label"},{"text":"使用文档主题","type":"link","path":"theme/theme-usage.html"},{"text":"SUPPORT AND FEEDBACK","type":"label"},{"text":"Raise an Issue on Github","type":"link","path":"https://github.com/shipengqi/golang-learn/issues/new"}]}}},"excerpt":"","more":"<h1 id=\"内存分配\"><a href=\"#内存分配\" class=\"headerlink\" title=\"内存分配\"></a>内存分配</h1><h2 id=\"基本策略\"><a href=\"#基本策略\" class=\"headerlink\" title=\"基本策略\"></a>基本策略</h2><ol>\n<li>每次从操作系统申请一大块内存（如 1MB），以减少系统调用。</li>\n<li>将申请到的大块内存按照特定大小切分成小块，够成链表。</li>\n<li>为对象分配内存时，只需从大小合适的链表提取一小块即可。</li>\n<li>回收对象内存时，将小块内存还给原链表，以便复用。</li>\n<li>如果闲置内存过多，则尝试把部分内存还给操作系统，降低开销。</li>\n</ol>\n<blockquote>\n<p><strong>内存分配器</strong>只管理内存，不关心对象的状态，并且它不会主动回收内存，需要<strong>垃圾回收器</strong>在完成清理操作后，<br>触发内存分配器的回收操作。</p>\n</blockquote>\n<h2 id=\"内存块\"><a href=\"#内存块\" class=\"headerlink\" title=\"内存块\"></a>内存块</h2><p>内存分配器管理的内存分为两种：</p>\n<ul>\n<li><strong>span</strong>：多个地址连续的<strong>页</strong>（page）组成的大块内存。</li>\n<li><strong>object</strong>：将 span 按特定大小切分成多个小块，每个小块可存储一个对象。</li>\n</ul>\n<p>分配器按页数区分大小不同的 span。例如，以页数为单位将 span 存放到管理数组中，需要时就以页数为索引进行查找。<br>span 的大小不是固定不变的。在获取闲置 span 时，如果没有找到大小合适的，那么会选择页数更多的 span，此时<br>就会引发<strong>裁剪</strong>，将 span 多余的部分构成一个新的小的 span 放回管理数组。另外，分配器还会把相邻的空闲的<br> span 合并构建更大的内存块，减少碎片。</p>\n<h2 id=\"tcmalloc\"><a href=\"#tcmalloc\" class=\"headerlink\" title=\"tcmalloc\"></a>tcmalloc</h2><p>Go 的内存分配器采用的是 tcmalloc 架构。</p>\n<p>由三种组件组成：</p>\n<ul>\n<li><strong>cache</strong>：运行期的每个线程都会绑定一个 cache，用于给没有锁的 object 的分配。</li>\n<li><strong>central</strong>：为所有 cache 提供切分好的后备 sapn 资源。</li>\n<li><strong>heap</strong>：管理闲置的 span，需要的时候向操作系统申请新的内存。</li>\n</ul>\n<h2 id=\"回收\"><a href=\"#回收\" class=\"headerlink\" title=\"回收\"></a>回收</h2><p><strong>内存回收的源头是垃圾清理操作</strong>。<strong>回收不是释放</strong>，因为内存分配器的核心是<strong>内存复用</strong>。不再使用的内存，放到合适的位置等待再次<br>分配时使用。只有闲置内存过多时，才考虑释放。</p>\n<p>回收操作以 span 为单位。</p>\n<h2 id=\"释放\"><a href=\"#释放\" class=\"headerlink\" title=\"释放\"></a>释放</h2><p>监控线程 sysmon 每隔一段时间就会检查 heap 里的闲置内存块，如果闲置时间超过阈值，则释放其关联的物理内存。</p>\n"},{"title":"垃圾回收","_content":"# 垃圾回收\nGo 语言中使用的垃圾回收使用的是**标记清扫算法**。标记清理最典型的做法是三⾊标记。进行垃圾回收时会 STW(stop the world），\n就是 **runtime 把所有的线程全部冻结掉，意味着⽤户逻辑都是暂停的，所有的⽤户对象都不会被修改了**，这时候去扫描肯定是安全的，\n对象要么活着要么死着，所以会造成中间暂停时间可能会很⻓，⽤户逻辑对于⽤户的反应就中⽌了。\n\nGo GC 的基本特征：非分代，非紧缩，写屏障，并发标记清理。\n## 三色标记和写屏障\n三色标记算法原理如下：\n1. 起初所有对象都是白色。\n2. 从根出发扫描所有可达对象，标记为灰色，放入待处理队列。\n3. 从队列取出灰色对象，将其引用对象标记为灰色放入队列，自身标记为黑色。\n4. 重复 3，直到灰色对象队列为空。\n\n扫描和标记完成后，只剩下白色（待回收）和黑色（活跃对象）的对象，清理操作将白色对象内存回收。\n\n## 何时触发 GC\n垃圾回收器在初始化时，设置 `gcpercent` 和 `next_gc` 阈值。\n### 自动垃圾回收\n为对象分配内存以后，`mallocgc` 函数会检查 GC 触发条件。\n**在堆上分配大于 `maxSmallSize` （32K byte）的对象时进行检测此时是否满足垃圾回收条件，如果满足则进行垃圾回收**。\n```go\nfunc mallocgc(size uintptr, typ *_type, needzero bool) unsafe.Pointer {\n    ...\n    shouldhelpgc := false\n    // 分配的对象小于 maxSmallSize (32K byte)\n    if size <= maxSmallSize {\n        ...\n    } else {\n        shouldhelpgc = true\n        ...\n    }\n    ...\n    // gcShouldStart() 函数进行触发条件检测\n    if shouldhelpgc && gcShouldStart(false) {\n        // gcStart() 函数进行垃圾回收\n        gcStart(gcBackgroundMode, false)\n    }\n}\n```\n\n#### GC 触发条件\n触发条件主要关注下面代码中的中间部分：`forceTrigger || memstats.heap_live >= memstats.gc_trigger`。\n`forceTrigger` 是 `forceGC` 的标志；后面半句的意思是当前堆上的活跃对象大于我们初始化时候设置的 GC 触发阈值。\n在 malloc 以及 free 的时候 `heap_live` 会一直进行更新。\n```go\n// gcShouldStart returns true if the exit condition for the _GCoff\n// phase has been met. The exit condition should be tested when\n// allocating.\n//\n// If forceTrigger is true, it ignores the current heap size, but\n// checks all other conditions. In general this should be false.\nfunc gcShouldStart(forceTrigger bool) bool {\n    return gcphase == _GCoff && (forceTrigger || memstats.heap_live >= memstats.gc_trigger) && memstats.enablegc && panicking == 0 && gcpercent >= 0\n}\n\n// 初始化的时候设置 GC 的触发阈值\nfunc gcinit() {\n    _ = setGCPercent(readgogc())\n    memstats.gc_trigger = heapminimum\n    ...\n}\n// 启动的时候通过 GOGC 传递百分比 x\n// 触发阈值等于 x * defaultHeapMinimum (defaultHeapMinimum 默认是 4M)\nfunc readgogc() int32 {\n    p := gogetenv(\"GOGC\")\n    if p == \"off\" {\n        return -1\n    }\n    if n, ok := atoi32(p); ok {\n        return n\n    }\n    return 100\n}\n```\n`heap_live` 是活跃对象总量。\n\n### 主动垃圾回收\n主动垃圾回收，通过调用 `runtime.GC()`，这是阻塞式的。\n```go\n// GC runs a garbage collection and blocks the caller until the\n// garbage collection is complete. It may also block the entire\n// program.\nfunc GC() {\n    gcStart(gcForceBlockMode, false)\n}\n```\n\n## 监控\n在一个场景中：服务重启，海量的客户端接入，瞬间分配了大量对象，这会将 GC 的触发条件 `next_gc` 推到一个很大的值。\n在服务正常以后，由于活跃对象远远小于改阈值，会导致 GC 无法触发，大量白色对象不能被回收，最终造成内存泄露。\n\n所以 GC 的最后一道保险，就是监控线程 sysmon，sysmon 每隔 2 分钟会检查一次 GC 状态，超过 2 分钟则强制执行。\n","source":"advance/gc.md","raw":"---\ntitle: 垃圾回收\n---\n# 垃圾回收\nGo 语言中使用的垃圾回收使用的是**标记清扫算法**。标记清理最典型的做法是三⾊标记。进行垃圾回收时会 STW(stop the world），\n就是 **runtime 把所有的线程全部冻结掉，意味着⽤户逻辑都是暂停的，所有的⽤户对象都不会被修改了**，这时候去扫描肯定是安全的，\n对象要么活着要么死着，所以会造成中间暂停时间可能会很⻓，⽤户逻辑对于⽤户的反应就中⽌了。\n\nGo GC 的基本特征：非分代，非紧缩，写屏障，并发标记清理。\n## 三色标记和写屏障\n三色标记算法原理如下：\n1. 起初所有对象都是白色。\n2. 从根出发扫描所有可达对象，标记为灰色，放入待处理队列。\n3. 从队列取出灰色对象，将其引用对象标记为灰色放入队列，自身标记为黑色。\n4. 重复 3，直到灰色对象队列为空。\n\n扫描和标记完成后，只剩下白色（待回收）和黑色（活跃对象）的对象，清理操作将白色对象内存回收。\n\n## 何时触发 GC\n垃圾回收器在初始化时，设置 `gcpercent` 和 `next_gc` 阈值。\n### 自动垃圾回收\n为对象分配内存以后，`mallocgc` 函数会检查 GC 触发条件。\n**在堆上分配大于 `maxSmallSize` （32K byte）的对象时进行检测此时是否满足垃圾回收条件，如果满足则进行垃圾回收**。\n```go\nfunc mallocgc(size uintptr, typ *_type, needzero bool) unsafe.Pointer {\n    ...\n    shouldhelpgc := false\n    // 分配的对象小于 maxSmallSize (32K byte)\n    if size <= maxSmallSize {\n        ...\n    } else {\n        shouldhelpgc = true\n        ...\n    }\n    ...\n    // gcShouldStart() 函数进行触发条件检测\n    if shouldhelpgc && gcShouldStart(false) {\n        // gcStart() 函数进行垃圾回收\n        gcStart(gcBackgroundMode, false)\n    }\n}\n```\n\n#### GC 触发条件\n触发条件主要关注下面代码中的中间部分：`forceTrigger || memstats.heap_live >= memstats.gc_trigger`。\n`forceTrigger` 是 `forceGC` 的标志；后面半句的意思是当前堆上的活跃对象大于我们初始化时候设置的 GC 触发阈值。\n在 malloc 以及 free 的时候 `heap_live` 会一直进行更新。\n```go\n// gcShouldStart returns true if the exit condition for the _GCoff\n// phase has been met. The exit condition should be tested when\n// allocating.\n//\n// If forceTrigger is true, it ignores the current heap size, but\n// checks all other conditions. In general this should be false.\nfunc gcShouldStart(forceTrigger bool) bool {\n    return gcphase == _GCoff && (forceTrigger || memstats.heap_live >= memstats.gc_trigger) && memstats.enablegc && panicking == 0 && gcpercent >= 0\n}\n\n// 初始化的时候设置 GC 的触发阈值\nfunc gcinit() {\n    _ = setGCPercent(readgogc())\n    memstats.gc_trigger = heapminimum\n    ...\n}\n// 启动的时候通过 GOGC 传递百分比 x\n// 触发阈值等于 x * defaultHeapMinimum (defaultHeapMinimum 默认是 4M)\nfunc readgogc() int32 {\n    p := gogetenv(\"GOGC\")\n    if p == \"off\" {\n        return -1\n    }\n    if n, ok := atoi32(p); ok {\n        return n\n    }\n    return 100\n}\n```\n`heap_live` 是活跃对象总量。\n\n### 主动垃圾回收\n主动垃圾回收，通过调用 `runtime.GC()`，这是阻塞式的。\n```go\n// GC runs a garbage collection and blocks the caller until the\n// garbage collection is complete. It may also block the entire\n// program.\nfunc GC() {\n    gcStart(gcForceBlockMode, false)\n}\n```\n\n## 监控\n在一个场景中：服务重启，海量的客户端接入，瞬间分配了大量对象，这会将 GC 的触发条件 `next_gc` 推到一个很大的值。\n在服务正常以后，由于活跃对象远远小于改阈值，会导致 GC 无法触发，大量白色对象不能被回收，最终造成内存泄露。\n\n所以 GC 的最后一道保险，就是监控线程 sysmon，sysmon 每隔 2 分钟会检查一次 GC 状态，超过 2 分钟则强制执行。\n","date":"2019-09-01T00:18:20.645Z","updated":"2019-09-01T00:18:20.645Z","path":"advance/gc.html","comments":1,"layout":"page","_id":"ck1xm14ke0009fcw2ba9cyll3","content":"<h1 id=\"垃圾回收\"><a href=\"#垃圾回收\" class=\"headerlink\" title=\"垃圾回收\"></a>垃圾回收</h1><p>Go 语言中使用的垃圾回收使用的是<strong>标记清扫算法</strong>。标记清理最典型的做法是三⾊标记。进行垃圾回收时会 STW(stop the world），<br>就是 <strong>runtime 把所有的线程全部冻结掉，意味着⽤户逻辑都是暂停的，所有的⽤户对象都不会被修改了</strong>，这时候去扫描肯定是安全的，<br>对象要么活着要么死着，所以会造成中间暂停时间可能会很⻓，⽤户逻辑对于⽤户的反应就中⽌了。</p>\n<p>Go GC 的基本特征：非分代，非紧缩，写屏障，并发标记清理。</p>\n<h2 id=\"三色标记和写屏障\"><a href=\"#三色标记和写屏障\" class=\"headerlink\" title=\"三色标记和写屏障\"></a>三色标记和写屏障</h2><p>三色标记算法原理如下：</p>\n<ol>\n<li>起初所有对象都是白色。</li>\n<li>从根出发扫描所有可达对象，标记为灰色，放入待处理队列。</li>\n<li>从队列取出灰色对象，将其引用对象标记为灰色放入队列，自身标记为黑色。</li>\n<li>重复 3，直到灰色对象队列为空。</li>\n</ol>\n<p>扫描和标记完成后，只剩下白色（待回收）和黑色（活跃对象）的对象，清理操作将白色对象内存回收。</p>\n<h2 id=\"何时触发-GC\"><a href=\"#何时触发-GC\" class=\"headerlink\" title=\"何时触发 GC\"></a>何时触发 GC</h2><p>垃圾回收器在初始化时，设置 <code>gcpercent</code> 和 <code>next_gc</code> 阈值。</p>\n<h3 id=\"自动垃圾回收\"><a href=\"#自动垃圾回收\" class=\"headerlink\" title=\"自动垃圾回收\"></a>自动垃圾回收</h3><p>为对象分配内存以后，<code>mallocgc</code> 函数会检查 GC 触发条件。<br><strong>在堆上分配大于 <code>maxSmallSize</code> （32K byte）的对象时进行检测此时是否满足垃圾回收条件，如果满足则进行垃圾回收</strong>。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">mallocgc</span><span class=\"params\">(size <span class=\"keyword\">uintptr</span>, typ *_type, needzero <span class=\"keyword\">bool</span>)</span> <span class=\"title\">unsafe</span>.<span class=\"title\">Pointer</span></span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    shouldhelpgc := <span class=\"literal\">false</span></span><br><span class=\"line\">    <span class=\"comment\">// 分配的对象小于 maxSmallSize (32K byte)</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> size &lt;= maxSmallSize &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        shouldhelpgc = <span class=\"literal\">true</span></span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">// gcShouldStart() 函数进行触发条件检测</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> shouldhelpgc &amp;&amp; gcShouldStart(<span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// gcStart() 函数进行垃圾回收</span></span><br><span class=\"line\">        gcStart(gcBackgroundMode, <span class=\"literal\">false</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"GC-触发条件\"><a href=\"#GC-触发条件\" class=\"headerlink\" title=\"GC 触发条件\"></a>GC 触发条件</h4><p>触发条件主要关注下面代码中的中间部分：<code>forceTrigger || memstats.heap_live &gt;= memstats.gc_trigger</code>。<br><code>forceTrigger</code> 是 <code>forceGC</code> 的标志；后面半句的意思是当前堆上的活跃对象大于我们初始化时候设置的 GC 触发阈值。<br>在 malloc 以及 free 的时候 <code>heap_live</code> 会一直进行更新。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// gcShouldStart returns true if the exit condition for the _GCoff</span></span><br><span class=\"line\"><span class=\"comment\">// phase has been met. The exit condition should be tested when</span></span><br><span class=\"line\"><span class=\"comment\">// allocating.</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// If forceTrigger is true, it ignores the current heap size, but</span></span><br><span class=\"line\"><span class=\"comment\">// checks all other conditions. In general this should be false.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">gcShouldStart</span><span class=\"params\">(forceTrigger <span class=\"keyword\">bool</span>)</span> <span class=\"title\">bool</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> gcphase == _GCoff &amp;&amp; (forceTrigger || memstats.heap_live &gt;= memstats.gc_trigger) &amp;&amp; memstats.enablegc &amp;&amp; panicking == <span class=\"number\">0</span> &amp;&amp; gcpercent &gt;= <span class=\"number\">0</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 初始化的时候设置 GC 的触发阈值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">gcinit</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    _ = setGCPercent(readgogc())</span><br><span class=\"line\">    memstats.gc_trigger = heapminimum</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 启动的时候通过 GOGC 传递百分比 x</span></span><br><span class=\"line\"><span class=\"comment\">// 触发阈值等于 x * defaultHeapMinimum (defaultHeapMinimum 默认是 4M)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">readgogc</span><span class=\"params\">()</span> <span class=\"title\">int32</span></span> &#123;</span><br><span class=\"line\">    p := gogetenv(<span class=\"string\">\"GOGC\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> p == <span class=\"string\">\"off\"</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> n, ok := atoi32(p); ok &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> n</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">100</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>heap_live</code> 是活跃对象总量。</p>\n<h3 id=\"主动垃圾回收\"><a href=\"#主动垃圾回收\" class=\"headerlink\" title=\"主动垃圾回收\"></a>主动垃圾回收</h3><p>主动垃圾回收，通过调用 <code>runtime.GC()</code>，这是阻塞式的。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// GC runs a garbage collection and blocks the caller until the</span></span><br><span class=\"line\"><span class=\"comment\">// garbage collection is complete. It may also block the entire</span></span><br><span class=\"line\"><span class=\"comment\">// program.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">GC</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    gcStart(gcForceBlockMode, <span class=\"literal\">false</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"监控\"><a href=\"#监控\" class=\"headerlink\" title=\"监控\"></a>监控</h2><p>在一个场景中：服务重启，海量的客户端接入，瞬间分配了大量对象，这会将 GC 的触发条件 <code>next_gc</code> 推到一个很大的值。<br>在服务正常以后，由于活跃对象远远小于改阈值，会导致 GC 无法触发，大量白色对象不能被回收，最终造成内存泄露。</p>\n<p>所以 GC 的最后一道保险，就是监控线程 sysmon，sysmon 每隔 2 分钟会检查一次 GC 状态，超过 2 分钟则强制执行。</p>\n","site":{"data":{"navigation":{"logo":{"text":"Golang Learn","type":"link","path":"index.html"},"main":[{"text":"Golang 基础","type":"label"},{"text":"Go 环境配置","type":"link","path":"basic/env_config.html"},{"text":"包","type":"link","path":"basic/package.html"},{"text":"基础数据类型","type":"link","path":"basic/basic_data.html"},{"text":"变量","type":"link","path":"basic/var.html"},{"text":"常量","type":"link","path":"basic/constant.html"},{"text":"控制语句","type":"link","path":"basic/flow.html"},{"text":"运算符","type":"link","path":"basic/operator.html"},{"text":"作用域","type":"link","path":"basic/scope.html"},{"text":"指针","type":"link","path":"basic/pointer.html"},{"text":"数组","type":"link","path":"basic/array.html"},{"text":"切片","type":"link","path":"basic/slice.html"},{"text":"字典","type":"link","path":"basic/map.html"},{"text":"函数","type":"link","path":"basic/function.html"},{"text":"结构体","type":"link","path":"basic/struct.html"},{"text":"接口","type":"link","path":"basic/interface.html"},{"text":"面向对象","type":"link","path":"basic/oop.html"},{"text":"错误","type":"link","path":"basic/error.html"},{"text":"序列化","type":"link","path":"basic/json.html"},{"text":"反射","type":"link","path":"basic/reflect.html"},{"text":"测试","type":"link","path":"basic/test.html"},{"text":"并发编程","type":"label"},{"text":"goroutine","type":"link","path":"concurrent/goroutine.html"},{"text":"channel","type":"link","path":"concurrent/channel.html"},{"text":"同步和锁","type":"link","path":"concurrent/sync_lock.html"},{"text":"内存分配","type":"label"},{"text":"内存分配","type":"link","path":"advance/mm.html"},{"text":"垃圾回收","type":"label"},{"text":"垃圾回收","type":"link","path":"advance/gc.html"},{"text":"标准库","type":"label"},{"text":"fmt","type":"link","path":"standards/io/fmt.html"},{"text":"io","type":"link","path":"standards/io/io.html"},{"text":"ioutil","type":"link","path":"standards/io/ioutil.html"},{"text":"bufio","type":"link","path":"standards/io/bufio.html"},{"text":"os","type":"link","path":"standards/os/os.html"},{"text":"filepath","type":"link","path":"standards/os/filepath.html"},{"text":"strings","type":"link","path":"standards/text/strings.html"},{"text":"strconv","type":"link","path":"standards/text/strconv.html"},{"text":"unicode","type":"link","path":"standards/text/unicode.html"},{"text":"log","type":"link","path":"standards/log.html"},{"text":"time","type":"link","path":"standards/time.html"},{"text":"http","type":"link","path":"standards/net/http.html"},{"text":"math","type":"link","path":"standards/data/math.html"},{"text":"sort","type":"link","path":"standards/data/sort.html"},{"text":"big","type":"link","path":"standards/data/big.html"},{"text":"container","type":"link","path":"standards/data/container.html"},{"text":"sql","type":"link","path":"standards/database/sql.html"},{"text":"THEME","type":"label"},{"text":"使用文档主题","type":"link","path":"theme/theme-usage.html"},{"text":"SUPPORT AND FEEDBACK","type":"label"},{"text":"Raise an Issue on Github","type":"link","path":"https://github.com/shipengqi/golang-learn/issues/new"}]}}},"excerpt":"","more":"<h1 id=\"垃圾回收\"><a href=\"#垃圾回收\" class=\"headerlink\" title=\"垃圾回收\"></a>垃圾回收</h1><p>Go 语言中使用的垃圾回收使用的是<strong>标记清扫算法</strong>。标记清理最典型的做法是三⾊标记。进行垃圾回收时会 STW(stop the world），<br>就是 <strong>runtime 把所有的线程全部冻结掉，意味着⽤户逻辑都是暂停的，所有的⽤户对象都不会被修改了</strong>，这时候去扫描肯定是安全的，<br>对象要么活着要么死着，所以会造成中间暂停时间可能会很⻓，⽤户逻辑对于⽤户的反应就中⽌了。</p>\n<p>Go GC 的基本特征：非分代，非紧缩，写屏障，并发标记清理。</p>\n<h2 id=\"三色标记和写屏障\"><a href=\"#三色标记和写屏障\" class=\"headerlink\" title=\"三色标记和写屏障\"></a>三色标记和写屏障</h2><p>三色标记算法原理如下：</p>\n<ol>\n<li>起初所有对象都是白色。</li>\n<li>从根出发扫描所有可达对象，标记为灰色，放入待处理队列。</li>\n<li>从队列取出灰色对象，将其引用对象标记为灰色放入队列，自身标记为黑色。</li>\n<li>重复 3，直到灰色对象队列为空。</li>\n</ol>\n<p>扫描和标记完成后，只剩下白色（待回收）和黑色（活跃对象）的对象，清理操作将白色对象内存回收。</p>\n<h2 id=\"何时触发-GC\"><a href=\"#何时触发-GC\" class=\"headerlink\" title=\"何时触发 GC\"></a>何时触发 GC</h2><p>垃圾回收器在初始化时，设置 <code>gcpercent</code> 和 <code>next_gc</code> 阈值。</p>\n<h3 id=\"自动垃圾回收\"><a href=\"#自动垃圾回收\" class=\"headerlink\" title=\"自动垃圾回收\"></a>自动垃圾回收</h3><p>为对象分配内存以后，<code>mallocgc</code> 函数会检查 GC 触发条件。<br><strong>在堆上分配大于 <code>maxSmallSize</code> （32K byte）的对象时进行检测此时是否满足垃圾回收条件，如果满足则进行垃圾回收</strong>。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">mallocgc</span><span class=\"params\">(size <span class=\"keyword\">uintptr</span>, typ *_type, needzero <span class=\"keyword\">bool</span>)</span> <span class=\"title\">unsafe</span>.<span class=\"title\">Pointer</span></span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    shouldhelpgc := <span class=\"literal\">false</span></span><br><span class=\"line\">    <span class=\"comment\">// 分配的对象小于 maxSmallSize (32K byte)</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> size &lt;= maxSmallSize &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        shouldhelpgc = <span class=\"literal\">true</span></span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">// gcShouldStart() 函数进行触发条件检测</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> shouldhelpgc &amp;&amp; gcShouldStart(<span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// gcStart() 函数进行垃圾回收</span></span><br><span class=\"line\">        gcStart(gcBackgroundMode, <span class=\"literal\">false</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"GC-触发条件\"><a href=\"#GC-触发条件\" class=\"headerlink\" title=\"GC 触发条件\"></a>GC 触发条件</h4><p>触发条件主要关注下面代码中的中间部分：<code>forceTrigger || memstats.heap_live &gt;= memstats.gc_trigger</code>。<br><code>forceTrigger</code> 是 <code>forceGC</code> 的标志；后面半句的意思是当前堆上的活跃对象大于我们初始化时候设置的 GC 触发阈值。<br>在 malloc 以及 free 的时候 <code>heap_live</code> 会一直进行更新。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// gcShouldStart returns true if the exit condition for the _GCoff</span></span><br><span class=\"line\"><span class=\"comment\">// phase has been met. The exit condition should be tested when</span></span><br><span class=\"line\"><span class=\"comment\">// allocating.</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// If forceTrigger is true, it ignores the current heap size, but</span></span><br><span class=\"line\"><span class=\"comment\">// checks all other conditions. In general this should be false.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">gcShouldStart</span><span class=\"params\">(forceTrigger <span class=\"keyword\">bool</span>)</span> <span class=\"title\">bool</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> gcphase == _GCoff &amp;&amp; (forceTrigger || memstats.heap_live &gt;= memstats.gc_trigger) &amp;&amp; memstats.enablegc &amp;&amp; panicking == <span class=\"number\">0</span> &amp;&amp; gcpercent &gt;= <span class=\"number\">0</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 初始化的时候设置 GC 的触发阈值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">gcinit</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    _ = setGCPercent(readgogc())</span><br><span class=\"line\">    memstats.gc_trigger = heapminimum</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 启动的时候通过 GOGC 传递百分比 x</span></span><br><span class=\"line\"><span class=\"comment\">// 触发阈值等于 x * defaultHeapMinimum (defaultHeapMinimum 默认是 4M)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">readgogc</span><span class=\"params\">()</span> <span class=\"title\">int32</span></span> &#123;</span><br><span class=\"line\">    p := gogetenv(<span class=\"string\">\"GOGC\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> p == <span class=\"string\">\"off\"</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> n, ok := atoi32(p); ok &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> n</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">100</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>heap_live</code> 是活跃对象总量。</p>\n<h3 id=\"主动垃圾回收\"><a href=\"#主动垃圾回收\" class=\"headerlink\" title=\"主动垃圾回收\"></a>主动垃圾回收</h3><p>主动垃圾回收，通过调用 <code>runtime.GC()</code>，这是阻塞式的。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// GC runs a garbage collection and blocks the caller until the</span></span><br><span class=\"line\"><span class=\"comment\">// garbage collection is complete. It may also block the entire</span></span><br><span class=\"line\"><span class=\"comment\">// program.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">GC</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    gcStart(gcForceBlockMode, <span class=\"literal\">false</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"监控\"><a href=\"#监控\" class=\"headerlink\" title=\"监控\"></a>监控</h2><p>在一个场景中：服务重启，海量的客户端接入，瞬间分配了大量对象，这会将 GC 的触发条件 <code>next_gc</code> 推到一个很大的值。<br>在服务正常以后，由于活跃对象远远小于改阈值，会导致 GC 无法触发，大量白色对象不能被回收，最终造成内存泄露。</p>\n<p>所以 GC 的最后一道保险，就是监控线程 sysmon，sysmon 每隔 2 分钟会检查一次 GC 状态，超过 2 分钟则强制执行。</p>\n"},{"title":"错误","_content":"# 错误\n\n## error 类型\n`error` 类型是内置的接口类型。`error` 类型可能是 `nil` 或者 `non-nil`，`nil` 表示成功。\n\n### 错误处理\n当函数调用返回错误时，最常用的处理方式是**传播错误**，如。\n```go\nresp, err := http.Get(url)\nif err != nil{ // 将这个HTTP错误返回给调用者\n    return nil, err\n}\n\n\ndoc, err := html.Parse(resp.Body)\nresp.Body.Close()\nif err != nil {\n\t// fmt.Errorf函数使用fmt.Sprintf格式化错误信息并返回\n\t// 使用该函数前缀添加额外的上下文信息到原始错误信息。\n  return nil, fmt.Errorf(\"parsing %s as HTML: %v\", url,err)\n}\n```\n由于错误信息经常是以链式组合在一起的，所以错误信息中应避免大写和换行符。\n\n编写错误信息时，我们要确保错误信息对问题细节的描述是详尽的。尤其是要注意错误信息表达的一致性，即相同的函数或同包内\n的同一组函数返回的错误在构成和处理方式上是相似的。\n\n根据不同的场景，我们可能要对错误做些特殊处理，比如错误重试机制，或者打印错误日志，或者直接忽略错误。\n\n### 文件结尾错误\n`io` 包在任何由文件结束引起的读取失败都返回同一个错误 `io.EOF`：\n```go\nin := bufio.NewReader(os.Stdin)\nfor {\n    r, _, err := in.ReadRune()\n    if err == io.EOF {\n        break // finished reading\n    }\n    if err != nil {\n        return fmt.Errorf(\"read failed:%v\", err)\n    }\n    // ...use r…\n}\n```\n\n## Panic 异常\nGo 运行时错误会引起 `painc` 异常。\n一般而言，当 `panic` 异常发生时，程序会中断运行，并立即执行在该 `goroutine` 中被延迟的函数（`defer` 机制）。随后，程序崩溃\n并输出日志信息。\n\n由于 `panic` 会引起程序的崩溃，因此 `panic` 一般用于严重错误，如程序内部的逻辑不一致。但是对于大部分漏洞，我们应该使\n用 Go 提供的错误机制，而不是 `panic`，尽量避免程序的崩溃。\n\n### panic 函数\n`panic` 函数接受任何值作为参数。当某些不应该发生的场景发生时，我们就应该调用 `panic`。\n\n### panic 详情中都有什么\n```sh\npanic: runtime error: index out of range\n\ngoroutine 1 [running]:\nmain.main()\n/Users/haolin/GeekTime/Golang_Puzzlers/src/puzzlers/article19/q0/demo47.go:5 +0x3d\nexit status 2\n```\n第一行是 `panic: runtime error: index out of range`。其中的 `runtime error` 的含义是，这是一个 `runtime` 代码包中\n抛出的` panic`。\n\n`goroutine 1 [running]`，它表示有一个 ID 为1的 `goroutine` 在此 `panic` 被引发的时候正在运行。这里的 ID 其实并不重要。\n\n`main.main()` 表明了这个 `goroutine` 包装的 go 函数就是命令源码文件中的那个`main`函数，也就是说这里的 `goroutine` 正\n是**主 goroutine**。\n\n再下面的一行，指出的就是这个 `goroutine` 中的哪一行代码在此 panic 被引发时正在执行。含了此行代码在其所属的源码文件中的行数，\n以及这个源码文件的绝对路径。\n\n`+0x3d` 代表的是：此行代码相对于其所属函数的入口程序计数偏移量。用处并不大。\n\n`exit status 2` 表明我的这个程序是以退出状态码2结束运行的。**在大多数操作系统中，只要退出状态码不是 0，都意味着程序运行的非正\n常结束**。在 Go 语言中，**因 panic 导致程序结束运行的退出状态码一般都会是 2**。\n\n\n### 从 panic 被引发到程序终止运行的大致过程是什么\n\n此行代码所属函数的执行随即终止。紧接着，控制权并不会在此有片刻停留，它又会立即转移至再上一级的调用代码处。控制权如此一级一\n级地沿着调用栈的反方向传播至顶端，\n也就是我们编写的最外层函数那里。\n\n这里的最外层函数指的是go函数，对于主 goroutine 来说就是 `main` 函数。但是控制权也不会停留在那里，而是被 Go 语言运行时系统收回。\n\n随后，程序崩溃并终止运行，承载程序这次运行的进程也会随之死亡并消失。与此同时，在这个控制权传播的过程中，panic 详情会被逐\n渐地积累和完善，并会在程序终止之前被打印出来。\n\n### 怎样让 panic 包含一个值，以及应该让它包含什么样的值\n其实很简单，在调用 `panic` 函数时，把某个值作为参数传给该函数就可以了。`panic` 函数的唯一一个参数是空接口\n（也就是`interface{}`）类型的，所以从语法上讲，它可以接受任何类型的值。\n\n但是，我们**最好传入 `error` 类型的错误值，或者其他的可以被有效序列化的值。这里的“有效序列化”指的是，可以更易读地去表示\n形式转换**。\n\n## Recover 捕获异常\n一般情况下，我们不能因为某个处理函数引发的 `panic` 异常，杀掉整个进程，可以使用 `recover` 函数恢复 `panic` 异常。\n\n`panic` 时会调用 `recover`，但是 `recover` 不能滥用，可能会引起资源泄漏或者其他问题。我们可以将 `panic value` 设置成特\n殊类型，来标识某个 `panic` 是否应该被恢复。**`recover` 只能在 `defer` 修饰的函数中使用**:\n```go\nfunc soleTitle(doc *html.Node) (title string, err error) {\n\ttype bailout struct{}\n\tdefer func() {\n\t\tswitch p := recover(); p {\n            case nil:       // no panic\n            case bailout{}: // \"expected\" panic\n                err = fmt.Errorf(\"multiple title elements\")\n            default:\n                panic(p) // unexpected panic; carry on panicking\n\t\t}\n\t}()\n    panic(bailout{}) \n}\n```\n\n上面的代码，`deferred` 函数调用 `recover`，并检查 `panic value`。当 `panic value` 是 `bailout{}` 类型时，`deferred` 函数生\n成一个 `error` 返回给调用者。\n当 `panic value` 是其他 `non-nil` 值时，表示发生了未知的 `panic` 异常。\n\n### 正确调用 recover 函数\n```go\npackage main\n\nimport (\n    \"fmt\"\n    \"errors\"\n)\n\nfunc main() {\n    fmt.Println(\"Enter function main.\")\n    // 引发 panic。\n    panic(errors.New(\"something wrong\"))\n    p := recover()\n    fmt.Printf(\"panic: %s\\n\", p)\n    fmt.Println(\"Exit function main.\")\n}\n```\n上面的代码，`recover` 函数调用并不会起到任何作用，甚至都没有机会执行。因为 panic 一旦发生，控制权就会讯速地沿着调用栈的反方向\n传播。所以，**在 panic 函数调用之后的代码，根本就没有执行的机会**。\n\n先调用 `recover` 函数，再调用 `panic` 函数会怎么样呢？\n如果在我们调用 `recover` 函数时未发生 panic，那么该函数就不会做任何事情，并且只会返回一个 `nil`。\n\n**`defer` 语句调用 `recover` 函数才是正确的打开方式**。\n\n无论函数结束执行的原因是什么，其中的 `defer` 函数调用都会在它即将结束执行的那一刻执行。即使导致它执行结束的原因是一\n个 panic 也会是这样。\n\n要注意，我们要**尽量把 `defer` 语句写在函数体的开始处，因为在引发 panic 的语句之后的所有语句，都不会有任何执行机会**。\n","source":"basic/error.md","raw":"---\ntitle: 错误\n---\n# 错误\n\n## error 类型\n`error` 类型是内置的接口类型。`error` 类型可能是 `nil` 或者 `non-nil`，`nil` 表示成功。\n\n### 错误处理\n当函数调用返回错误时，最常用的处理方式是**传播错误**，如。\n```go\nresp, err := http.Get(url)\nif err != nil{ // 将这个HTTP错误返回给调用者\n    return nil, err\n}\n\n\ndoc, err := html.Parse(resp.Body)\nresp.Body.Close()\nif err != nil {\n\t// fmt.Errorf函数使用fmt.Sprintf格式化错误信息并返回\n\t// 使用该函数前缀添加额外的上下文信息到原始错误信息。\n  return nil, fmt.Errorf(\"parsing %s as HTML: %v\", url,err)\n}\n```\n由于错误信息经常是以链式组合在一起的，所以错误信息中应避免大写和换行符。\n\n编写错误信息时，我们要确保错误信息对问题细节的描述是详尽的。尤其是要注意错误信息表达的一致性，即相同的函数或同包内\n的同一组函数返回的错误在构成和处理方式上是相似的。\n\n根据不同的场景，我们可能要对错误做些特殊处理，比如错误重试机制，或者打印错误日志，或者直接忽略错误。\n\n### 文件结尾错误\n`io` 包在任何由文件结束引起的读取失败都返回同一个错误 `io.EOF`：\n```go\nin := bufio.NewReader(os.Stdin)\nfor {\n    r, _, err := in.ReadRune()\n    if err == io.EOF {\n        break // finished reading\n    }\n    if err != nil {\n        return fmt.Errorf(\"read failed:%v\", err)\n    }\n    // ...use r…\n}\n```\n\n## Panic 异常\nGo 运行时错误会引起 `painc` 异常。\n一般而言，当 `panic` 异常发生时，程序会中断运行，并立即执行在该 `goroutine` 中被延迟的函数（`defer` 机制）。随后，程序崩溃\n并输出日志信息。\n\n由于 `panic` 会引起程序的崩溃，因此 `panic` 一般用于严重错误，如程序内部的逻辑不一致。但是对于大部分漏洞，我们应该使\n用 Go 提供的错误机制，而不是 `panic`，尽量避免程序的崩溃。\n\n### panic 函数\n`panic` 函数接受任何值作为参数。当某些不应该发生的场景发生时，我们就应该调用 `panic`。\n\n### panic 详情中都有什么\n```sh\npanic: runtime error: index out of range\n\ngoroutine 1 [running]:\nmain.main()\n/Users/haolin/GeekTime/Golang_Puzzlers/src/puzzlers/article19/q0/demo47.go:5 +0x3d\nexit status 2\n```\n第一行是 `panic: runtime error: index out of range`。其中的 `runtime error` 的含义是，这是一个 `runtime` 代码包中\n抛出的` panic`。\n\n`goroutine 1 [running]`，它表示有一个 ID 为1的 `goroutine` 在此 `panic` 被引发的时候正在运行。这里的 ID 其实并不重要。\n\n`main.main()` 表明了这个 `goroutine` 包装的 go 函数就是命令源码文件中的那个`main`函数，也就是说这里的 `goroutine` 正\n是**主 goroutine**。\n\n再下面的一行，指出的就是这个 `goroutine` 中的哪一行代码在此 panic 被引发时正在执行。含了此行代码在其所属的源码文件中的行数，\n以及这个源码文件的绝对路径。\n\n`+0x3d` 代表的是：此行代码相对于其所属函数的入口程序计数偏移量。用处并不大。\n\n`exit status 2` 表明我的这个程序是以退出状态码2结束运行的。**在大多数操作系统中，只要退出状态码不是 0，都意味着程序运行的非正\n常结束**。在 Go 语言中，**因 panic 导致程序结束运行的退出状态码一般都会是 2**。\n\n\n### 从 panic 被引发到程序终止运行的大致过程是什么\n\n此行代码所属函数的执行随即终止。紧接着，控制权并不会在此有片刻停留，它又会立即转移至再上一级的调用代码处。控制权如此一级一\n级地沿着调用栈的反方向传播至顶端，\n也就是我们编写的最外层函数那里。\n\n这里的最外层函数指的是go函数，对于主 goroutine 来说就是 `main` 函数。但是控制权也不会停留在那里，而是被 Go 语言运行时系统收回。\n\n随后，程序崩溃并终止运行，承载程序这次运行的进程也会随之死亡并消失。与此同时，在这个控制权传播的过程中，panic 详情会被逐\n渐地积累和完善，并会在程序终止之前被打印出来。\n\n### 怎样让 panic 包含一个值，以及应该让它包含什么样的值\n其实很简单，在调用 `panic` 函数时，把某个值作为参数传给该函数就可以了。`panic` 函数的唯一一个参数是空接口\n（也就是`interface{}`）类型的，所以从语法上讲，它可以接受任何类型的值。\n\n但是，我们**最好传入 `error` 类型的错误值，或者其他的可以被有效序列化的值。这里的“有效序列化”指的是，可以更易读地去表示\n形式转换**。\n\n## Recover 捕获异常\n一般情况下，我们不能因为某个处理函数引发的 `panic` 异常，杀掉整个进程，可以使用 `recover` 函数恢复 `panic` 异常。\n\n`panic` 时会调用 `recover`，但是 `recover` 不能滥用，可能会引起资源泄漏或者其他问题。我们可以将 `panic value` 设置成特\n殊类型，来标识某个 `panic` 是否应该被恢复。**`recover` 只能在 `defer` 修饰的函数中使用**:\n```go\nfunc soleTitle(doc *html.Node) (title string, err error) {\n\ttype bailout struct{}\n\tdefer func() {\n\t\tswitch p := recover(); p {\n            case nil:       // no panic\n            case bailout{}: // \"expected\" panic\n                err = fmt.Errorf(\"multiple title elements\")\n            default:\n                panic(p) // unexpected panic; carry on panicking\n\t\t}\n\t}()\n    panic(bailout{}) \n}\n```\n\n上面的代码，`deferred` 函数调用 `recover`，并检查 `panic value`。当 `panic value` 是 `bailout{}` 类型时，`deferred` 函数生\n成一个 `error` 返回给调用者。\n当 `panic value` 是其他 `non-nil` 值时，表示发生了未知的 `panic` 异常。\n\n### 正确调用 recover 函数\n```go\npackage main\n\nimport (\n    \"fmt\"\n    \"errors\"\n)\n\nfunc main() {\n    fmt.Println(\"Enter function main.\")\n    // 引发 panic。\n    panic(errors.New(\"something wrong\"))\n    p := recover()\n    fmt.Printf(\"panic: %s\\n\", p)\n    fmt.Println(\"Exit function main.\")\n}\n```\n上面的代码，`recover` 函数调用并不会起到任何作用，甚至都没有机会执行。因为 panic 一旦发生，控制权就会讯速地沿着调用栈的反方向\n传播。所以，**在 panic 函数调用之后的代码，根本就没有执行的机会**。\n\n先调用 `recover` 函数，再调用 `panic` 函数会怎么样呢？\n如果在我们调用 `recover` 函数时未发生 panic，那么该函数就不会做任何事情，并且只会返回一个 `nil`。\n\n**`defer` 语句调用 `recover` 函数才是正确的打开方式**。\n\n无论函数结束执行的原因是什么，其中的 `defer` 函数调用都会在它即将结束执行的那一刻执行。即使导致它执行结束的原因是一\n个 panic 也会是这样。\n\n要注意，我们要**尽量把 `defer` 语句写在函数体的开始处，因为在引发 panic 的语句之后的所有语句，都不会有任何执行机会**。\n","date":"2019-10-19T13:40:15.169Z","updated":"2019-10-19T13:40:15.169Z","path":"basic/error.html","comments":1,"layout":"page","_id":"ck1xm14kf000afcw2r8oa9snk","content":"<h1 id=\"错误\"><a href=\"#错误\" class=\"headerlink\" title=\"错误\"></a>错误</h1><h2 id=\"error-类型\"><a href=\"#error-类型\" class=\"headerlink\" title=\"error 类型\"></a>error 类型</h2><p><code>error</code> 类型是内置的接口类型。<code>error</code> 类型可能是 <code>nil</code> 或者 <code>non-nil</code>，<code>nil</code> 表示成功。</p>\n<h3 id=\"错误处理\"><a href=\"#错误处理\" class=\"headerlink\" title=\"错误处理\"></a>错误处理</h3><p>当函数调用返回错误时，最常用的处理方式是<strong>传播错误</strong>，如。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">resp, err := http.Get(url)</span><br><span class=\"line\"><span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span>&#123; <span class=\"comment\">// 将这个HTTP错误返回给调用者</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, err</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">doc, err := html.Parse(resp.Body)</span><br><span class=\"line\">resp.Body.Close()</span><br><span class=\"line\"><span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// fmt.Errorf函数使用fmt.Sprintf格式化错误信息并返回</span></span><br><span class=\"line\">\t<span class=\"comment\">// 使用该函数前缀添加额外的上下文信息到原始错误信息。</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, fmt.Errorf(<span class=\"string\">\"parsing %s as HTML: %v\"</span>, url,err)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>由于错误信息经常是以链式组合在一起的，所以错误信息中应避免大写和换行符。</p>\n<p>编写错误信息时，我们要确保错误信息对问题细节的描述是详尽的。尤其是要注意错误信息表达的一致性，即相同的函数或同包内<br>的同一组函数返回的错误在构成和处理方式上是相似的。</p>\n<p>根据不同的场景，我们可能要对错误做些特殊处理，比如错误重试机制，或者打印错误日志，或者直接忽略错误。</p>\n<h3 id=\"文件结尾错误\"><a href=\"#文件结尾错误\" class=\"headerlink\" title=\"文件结尾错误\"></a>文件结尾错误</h3><p><code>io</code> 包在任何由文件结束引起的读取失败都返回同一个错误 <code>io.EOF</code>：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">in := bufio.NewReader(os.Stdin)</span><br><span class=\"line\"><span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">    r, _, err := in.ReadRune()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err == io.EOF &#123;</span><br><span class=\"line\">        <span class=\"keyword\">break</span> <span class=\"comment\">// finished reading</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> fmt.Errorf(<span class=\"string\">\"read failed:%v\"</span>, err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// ...use r…</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Panic-异常\"><a href=\"#Panic-异常\" class=\"headerlink\" title=\"Panic 异常\"></a>Panic 异常</h2><p>Go 运行时错误会引起 <code>painc</code> 异常。<br>一般而言，当 <code>panic</code> 异常发生时，程序会中断运行，并立即执行在该 <code>goroutine</code> 中被延迟的函数（<code>defer</code> 机制）。随后，程序崩溃<br>并输出日志信息。</p>\n<p>由于 <code>panic</code> 会引起程序的崩溃，因此 <code>panic</code> 一般用于严重错误，如程序内部的逻辑不一致。但是对于大部分漏洞，我们应该使<br>用 Go 提供的错误机制，而不是 <code>panic</code>，尽量避免程序的崩溃。</p>\n<h3 id=\"panic-函数\"><a href=\"#panic-函数\" class=\"headerlink\" title=\"panic 函数\"></a>panic 函数</h3><p><code>panic</code> 函数接受任何值作为参数。当某些不应该发生的场景发生时，我们就应该调用 <code>panic</code>。</p>\n<h3 id=\"panic-详情中都有什么\"><a href=\"#panic-详情中都有什么\" class=\"headerlink\" title=\"panic 详情中都有什么\"></a>panic 详情中都有什么</h3><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">panic: runtime error: index out of range</span><br><span class=\"line\"></span><br><span class=\"line\">goroutine 1 [running]:</span><br><span class=\"line\">main.main()</span><br><span class=\"line\">/Users/haolin/GeekTime/Golang_Puzzlers/src/puzzlers/article19/q0/demo47.go:5 +0x3d</span><br><span class=\"line\"><span class=\"built_in\">exit</span> status 2</span><br></pre></td></tr></table></figure>\n<p>第一行是 <code>panic: runtime error: index out of range</code>。其中的 <code>runtime error</code> 的含义是，这是一个 <code>runtime</code> 代码包中<br>抛出的<code>panic</code>。</p>\n<p><code>goroutine 1 [running]</code>，它表示有一个 ID 为1的 <code>goroutine</code> 在此 <code>panic</code> 被引发的时候正在运行。这里的 ID 其实并不重要。</p>\n<p><code>main.main()</code> 表明了这个 <code>goroutine</code> 包装的 go 函数就是命令源码文件中的那个<code>main</code>函数，也就是说这里的 <code>goroutine</code> 正<br>是<strong>主 goroutine</strong>。</p>\n<p>再下面的一行，指出的就是这个 <code>goroutine</code> 中的哪一行代码在此 panic 被引发时正在执行。含了此行代码在其所属的源码文件中的行数，<br>以及这个源码文件的绝对路径。</p>\n<p><code>+0x3d</code> 代表的是：此行代码相对于其所属函数的入口程序计数偏移量。用处并不大。</p>\n<p><code>exit status 2</code> 表明我的这个程序是以退出状态码2结束运行的。<strong>在大多数操作系统中，只要退出状态码不是 0，都意味着程序运行的非正<br>常结束</strong>。在 Go 语言中，<strong>因 panic 导致程序结束运行的退出状态码一般都会是 2</strong>。</p>\n<h3 id=\"从-panic-被引发到程序终止运行的大致过程是什么\"><a href=\"#从-panic-被引发到程序终止运行的大致过程是什么\" class=\"headerlink\" title=\"从 panic 被引发到程序终止运行的大致过程是什么\"></a>从 panic 被引发到程序终止运行的大致过程是什么</h3><p>此行代码所属函数的执行随即终止。紧接着，控制权并不会在此有片刻停留，它又会立即转移至再上一级的调用代码处。控制权如此一级一<br>级地沿着调用栈的反方向传播至顶端，<br>也就是我们编写的最外层函数那里。</p>\n<p>这里的最外层函数指的是go函数，对于主 goroutine 来说就是 <code>main</code> 函数。但是控制权也不会停留在那里，而是被 Go 语言运行时系统收回。</p>\n<p>随后，程序崩溃并终止运行，承载程序这次运行的进程也会随之死亡并消失。与此同时，在这个控制权传播的过程中，panic 详情会被逐<br>渐地积累和完善，并会在程序终止之前被打印出来。</p>\n<h3 id=\"怎样让-panic-包含一个值，以及应该让它包含什么样的值\"><a href=\"#怎样让-panic-包含一个值，以及应该让它包含什么样的值\" class=\"headerlink\" title=\"怎样让 panic 包含一个值，以及应该让它包含什么样的值\"></a>怎样让 panic 包含一个值，以及应该让它包含什么样的值</h3><p>其实很简单，在调用 <code>panic</code> 函数时，把某个值作为参数传给该函数就可以了。<code>panic</code> 函数的唯一一个参数是空接口<br>（也就是<code>interface{}</code>）类型的，所以从语法上讲，它可以接受任何类型的值。</p>\n<p>但是，我们<strong>最好传入 <code>error</code> 类型的错误值，或者其他的可以被有效序列化的值。这里的“有效序列化”指的是，可以更易读地去表示<br>形式转换</strong>。</p>\n<h2 id=\"Recover-捕获异常\"><a href=\"#Recover-捕获异常\" class=\"headerlink\" title=\"Recover 捕获异常\"></a>Recover 捕获异常</h2><p>一般情况下，我们不能因为某个处理函数引发的 <code>panic</code> 异常，杀掉整个进程，可以使用 <code>recover</code> 函数恢复 <code>panic</code> 异常。</p>\n<p><code>panic</code> 时会调用 <code>recover</code>，但是 <code>recover</code> 不能滥用，可能会引起资源泄漏或者其他问题。我们可以将 <code>panic value</code> 设置成特<br>殊类型，来标识某个 <code>panic</code> 是否应该被恢复。<strong><code>recover</code> 只能在 <code>defer</code> 修饰的函数中使用</strong>:<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">soleTitle</span><span class=\"params\">(doc *html.Node)</span> <span class=\"params\">(title <span class=\"keyword\">string</span>, err error)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">type</span> bailout <span class=\"keyword\">struct</span>&#123;&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">switch</span> p := <span class=\"built_in\">recover</span>(); p &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"literal\">nil</span>:       <span class=\"comment\">// no panic</span></span><br><span class=\"line\">            <span class=\"keyword\">case</span> bailout&#123;&#125;: <span class=\"comment\">// \"expected\" panic</span></span><br><span class=\"line\">                err = fmt.Errorf(<span class=\"string\">\"multiple title elements\"</span>)</span><br><span class=\"line\">            <span class=\"keyword\">default</span>:</span><br><span class=\"line\">                <span class=\"built_in\">panic</span>(p) <span class=\"comment\">// unexpected panic; carry on panicking</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\">    <span class=\"built_in\">panic</span>(bailout&#123;&#125;) </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面的代码，<code>deferred</code> 函数调用 <code>recover</code>，并检查 <code>panic value</code>。当 <code>panic value</code> 是 <code>bailout{}</code> 类型时，<code>deferred</code> 函数生<br>成一个 <code>error</code> 返回给调用者。<br>当 <code>panic value</code> 是其他 <code>non-nil</code> 值时，表示发生了未知的 <code>panic</code> 异常。</p>\n<h3 id=\"正确调用-recover-函数\"><a href=\"#正确调用-recover-函数\" class=\"headerlink\" title=\"正确调用 recover 函数\"></a>正确调用 recover 函数</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">\"fmt\"</span></span><br><span class=\"line\">    <span class=\"string\">\"errors\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    fmt.Println(<span class=\"string\">\"Enter function main.\"</span>)</span><br><span class=\"line\">    <span class=\"comment\">// 引发 panic。</span></span><br><span class=\"line\">    <span class=\"built_in\">panic</span>(errors.New(<span class=\"string\">\"something wrong\"</span>))</span><br><span class=\"line\">    p := <span class=\"built_in\">recover</span>()</span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">\"panic: %s\\n\"</span>, p)</span><br><span class=\"line\">    fmt.Println(<span class=\"string\">\"Exit function main.\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的代码，<code>recover</code> 函数调用并不会起到任何作用，甚至都没有机会执行。因为 panic 一旦发生，控制权就会讯速地沿着调用栈的反方向<br>传播。所以，<strong>在 panic 函数调用之后的代码，根本就没有执行的机会</strong>。</p>\n<p>先调用 <code>recover</code> 函数，再调用 <code>panic</code> 函数会怎么样呢？<br>如果在我们调用 <code>recover</code> 函数时未发生 panic，那么该函数就不会做任何事情，并且只会返回一个 <code>nil</code>。</p>\n<p><strong><code>defer</code> 语句调用 <code>recover</code> 函数才是正确的打开方式</strong>。</p>\n<p>无论函数结束执行的原因是什么，其中的 <code>defer</code> 函数调用都会在它即将结束执行的那一刻执行。即使导致它执行结束的原因是一<br>个 panic 也会是这样。</p>\n<p>要注意，我们要<strong>尽量把 <code>defer</code> 语句写在函数体的开始处，因为在引发 panic 的语句之后的所有语句，都不会有任何执行机会</strong>。</p>\n","site":{"data":{"navigation":{"logo":{"text":"Golang Learn","type":"link","path":"index.html"},"main":[{"text":"Golang 基础","type":"label"},{"text":"Go 环境配置","type":"link","path":"basic/env_config.html"},{"text":"包","type":"link","path":"basic/package.html"},{"text":"基础数据类型","type":"link","path":"basic/basic_data.html"},{"text":"变量","type":"link","path":"basic/var.html"},{"text":"常量","type":"link","path":"basic/constant.html"},{"text":"控制语句","type":"link","path":"basic/flow.html"},{"text":"运算符","type":"link","path":"basic/operator.html"},{"text":"作用域","type":"link","path":"basic/scope.html"},{"text":"指针","type":"link","path":"basic/pointer.html"},{"text":"数组","type":"link","path":"basic/array.html"},{"text":"切片","type":"link","path":"basic/slice.html"},{"text":"字典","type":"link","path":"basic/map.html"},{"text":"函数","type":"link","path":"basic/function.html"},{"text":"结构体","type":"link","path":"basic/struct.html"},{"text":"接口","type":"link","path":"basic/interface.html"},{"text":"面向对象","type":"link","path":"basic/oop.html"},{"text":"错误","type":"link","path":"basic/error.html"},{"text":"序列化","type":"link","path":"basic/json.html"},{"text":"反射","type":"link","path":"basic/reflect.html"},{"text":"测试","type":"link","path":"basic/test.html"},{"text":"并发编程","type":"label"},{"text":"goroutine","type":"link","path":"concurrent/goroutine.html"},{"text":"channel","type":"link","path":"concurrent/channel.html"},{"text":"同步和锁","type":"link","path":"concurrent/sync_lock.html"},{"text":"内存分配","type":"label"},{"text":"内存分配","type":"link","path":"advance/mm.html"},{"text":"垃圾回收","type":"label"},{"text":"垃圾回收","type":"link","path":"advance/gc.html"},{"text":"标准库","type":"label"},{"text":"fmt","type":"link","path":"standards/io/fmt.html"},{"text":"io","type":"link","path":"standards/io/io.html"},{"text":"ioutil","type":"link","path":"standards/io/ioutil.html"},{"text":"bufio","type":"link","path":"standards/io/bufio.html"},{"text":"os","type":"link","path":"standards/os/os.html"},{"text":"filepath","type":"link","path":"standards/os/filepath.html"},{"text":"strings","type":"link","path":"standards/text/strings.html"},{"text":"strconv","type":"link","path":"standards/text/strconv.html"},{"text":"unicode","type":"link","path":"standards/text/unicode.html"},{"text":"log","type":"link","path":"standards/log.html"},{"text":"time","type":"link","path":"standards/time.html"},{"text":"http","type":"link","path":"standards/net/http.html"},{"text":"math","type":"link","path":"standards/data/math.html"},{"text":"sort","type":"link","path":"standards/data/sort.html"},{"text":"big","type":"link","path":"standards/data/big.html"},{"text":"container","type":"link","path":"standards/data/container.html"},{"text":"sql","type":"link","path":"standards/database/sql.html"},{"text":"THEME","type":"label"},{"text":"使用文档主题","type":"link","path":"theme/theme-usage.html"},{"text":"SUPPORT AND FEEDBACK","type":"label"},{"text":"Raise an Issue on Github","type":"link","path":"https://github.com/shipengqi/golang-learn/issues/new"}]}}},"excerpt":"","more":"<h1 id=\"错误\"><a href=\"#错误\" class=\"headerlink\" title=\"错误\"></a>错误</h1><h2 id=\"error-类型\"><a href=\"#error-类型\" class=\"headerlink\" title=\"error 类型\"></a>error 类型</h2><p><code>error</code> 类型是内置的接口类型。<code>error</code> 类型可能是 <code>nil</code> 或者 <code>non-nil</code>，<code>nil</code> 表示成功。</p>\n<h3 id=\"错误处理\"><a href=\"#错误处理\" class=\"headerlink\" title=\"错误处理\"></a>错误处理</h3><p>当函数调用返回错误时，最常用的处理方式是<strong>传播错误</strong>，如。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">resp, err := http.Get(url)</span><br><span class=\"line\"><span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span>&#123; <span class=\"comment\">// 将这个HTTP错误返回给调用者</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, err</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">doc, err := html.Parse(resp.Body)</span><br><span class=\"line\">resp.Body.Close()</span><br><span class=\"line\"><span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// fmt.Errorf函数使用fmt.Sprintf格式化错误信息并返回</span></span><br><span class=\"line\">\t<span class=\"comment\">// 使用该函数前缀添加额外的上下文信息到原始错误信息。</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, fmt.Errorf(<span class=\"string\">\"parsing %s as HTML: %v\"</span>, url,err)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>由于错误信息经常是以链式组合在一起的，所以错误信息中应避免大写和换行符。</p>\n<p>编写错误信息时，我们要确保错误信息对问题细节的描述是详尽的。尤其是要注意错误信息表达的一致性，即相同的函数或同包内<br>的同一组函数返回的错误在构成和处理方式上是相似的。</p>\n<p>根据不同的场景，我们可能要对错误做些特殊处理，比如错误重试机制，或者打印错误日志，或者直接忽略错误。</p>\n<h3 id=\"文件结尾错误\"><a href=\"#文件结尾错误\" class=\"headerlink\" title=\"文件结尾错误\"></a>文件结尾错误</h3><p><code>io</code> 包在任何由文件结束引起的读取失败都返回同一个错误 <code>io.EOF</code>：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">in := bufio.NewReader(os.Stdin)</span><br><span class=\"line\"><span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">    r, _, err := in.ReadRune()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err == io.EOF &#123;</span><br><span class=\"line\">        <span class=\"keyword\">break</span> <span class=\"comment\">// finished reading</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> fmt.Errorf(<span class=\"string\">\"read failed:%v\"</span>, err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// ...use r…</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Panic-异常\"><a href=\"#Panic-异常\" class=\"headerlink\" title=\"Panic 异常\"></a>Panic 异常</h2><p>Go 运行时错误会引起 <code>painc</code> 异常。<br>一般而言，当 <code>panic</code> 异常发生时，程序会中断运行，并立即执行在该 <code>goroutine</code> 中被延迟的函数（<code>defer</code> 机制）。随后，程序崩溃<br>并输出日志信息。</p>\n<p>由于 <code>panic</code> 会引起程序的崩溃，因此 <code>panic</code> 一般用于严重错误，如程序内部的逻辑不一致。但是对于大部分漏洞，我们应该使<br>用 Go 提供的错误机制，而不是 <code>panic</code>，尽量避免程序的崩溃。</p>\n<h3 id=\"panic-函数\"><a href=\"#panic-函数\" class=\"headerlink\" title=\"panic 函数\"></a>panic 函数</h3><p><code>panic</code> 函数接受任何值作为参数。当某些不应该发生的场景发生时，我们就应该调用 <code>panic</code>。</p>\n<h3 id=\"panic-详情中都有什么\"><a href=\"#panic-详情中都有什么\" class=\"headerlink\" title=\"panic 详情中都有什么\"></a>panic 详情中都有什么</h3><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">panic: runtime error: index out of range</span><br><span class=\"line\"></span><br><span class=\"line\">goroutine 1 [running]:</span><br><span class=\"line\">main.main()</span><br><span class=\"line\">/Users/haolin/GeekTime/Golang_Puzzlers/src/puzzlers/article19/q0/demo47.go:5 +0x3d</span><br><span class=\"line\"><span class=\"built_in\">exit</span> status 2</span><br></pre></td></tr></table></figure>\n<p>第一行是 <code>panic: runtime error: index out of range</code>。其中的 <code>runtime error</code> 的含义是，这是一个 <code>runtime</code> 代码包中<br>抛出的<code>panic</code>。</p>\n<p><code>goroutine 1 [running]</code>，它表示有一个 ID 为1的 <code>goroutine</code> 在此 <code>panic</code> 被引发的时候正在运行。这里的 ID 其实并不重要。</p>\n<p><code>main.main()</code> 表明了这个 <code>goroutine</code> 包装的 go 函数就是命令源码文件中的那个<code>main</code>函数，也就是说这里的 <code>goroutine</code> 正<br>是<strong>主 goroutine</strong>。</p>\n<p>再下面的一行，指出的就是这个 <code>goroutine</code> 中的哪一行代码在此 panic 被引发时正在执行。含了此行代码在其所属的源码文件中的行数，<br>以及这个源码文件的绝对路径。</p>\n<p><code>+0x3d</code> 代表的是：此行代码相对于其所属函数的入口程序计数偏移量。用处并不大。</p>\n<p><code>exit status 2</code> 表明我的这个程序是以退出状态码2结束运行的。<strong>在大多数操作系统中，只要退出状态码不是 0，都意味着程序运行的非正<br>常结束</strong>。在 Go 语言中，<strong>因 panic 导致程序结束运行的退出状态码一般都会是 2</strong>。</p>\n<h3 id=\"从-panic-被引发到程序终止运行的大致过程是什么\"><a href=\"#从-panic-被引发到程序终止运行的大致过程是什么\" class=\"headerlink\" title=\"从 panic 被引发到程序终止运行的大致过程是什么\"></a>从 panic 被引发到程序终止运行的大致过程是什么</h3><p>此行代码所属函数的执行随即终止。紧接着，控制权并不会在此有片刻停留，它又会立即转移至再上一级的调用代码处。控制权如此一级一<br>级地沿着调用栈的反方向传播至顶端，<br>也就是我们编写的最外层函数那里。</p>\n<p>这里的最外层函数指的是go函数，对于主 goroutine 来说就是 <code>main</code> 函数。但是控制权也不会停留在那里，而是被 Go 语言运行时系统收回。</p>\n<p>随后，程序崩溃并终止运行，承载程序这次运行的进程也会随之死亡并消失。与此同时，在这个控制权传播的过程中，panic 详情会被逐<br>渐地积累和完善，并会在程序终止之前被打印出来。</p>\n<h3 id=\"怎样让-panic-包含一个值，以及应该让它包含什么样的值\"><a href=\"#怎样让-panic-包含一个值，以及应该让它包含什么样的值\" class=\"headerlink\" title=\"怎样让 panic 包含一个值，以及应该让它包含什么样的值\"></a>怎样让 panic 包含一个值，以及应该让它包含什么样的值</h3><p>其实很简单，在调用 <code>panic</code> 函数时，把某个值作为参数传给该函数就可以了。<code>panic</code> 函数的唯一一个参数是空接口<br>（也就是<code>interface{}</code>）类型的，所以从语法上讲，它可以接受任何类型的值。</p>\n<p>但是，我们<strong>最好传入 <code>error</code> 类型的错误值，或者其他的可以被有效序列化的值。这里的“有效序列化”指的是，可以更易读地去表示<br>形式转换</strong>。</p>\n<h2 id=\"Recover-捕获异常\"><a href=\"#Recover-捕获异常\" class=\"headerlink\" title=\"Recover 捕获异常\"></a>Recover 捕获异常</h2><p>一般情况下，我们不能因为某个处理函数引发的 <code>panic</code> 异常，杀掉整个进程，可以使用 <code>recover</code> 函数恢复 <code>panic</code> 异常。</p>\n<p><code>panic</code> 时会调用 <code>recover</code>，但是 <code>recover</code> 不能滥用，可能会引起资源泄漏或者其他问题。我们可以将 <code>panic value</code> 设置成特<br>殊类型，来标识某个 <code>panic</code> 是否应该被恢复。<strong><code>recover</code> 只能在 <code>defer</code> 修饰的函数中使用</strong>:<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">soleTitle</span><span class=\"params\">(doc *html.Node)</span> <span class=\"params\">(title <span class=\"keyword\">string</span>, err error)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">type</span> bailout <span class=\"keyword\">struct</span>&#123;&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">switch</span> p := <span class=\"built_in\">recover</span>(); p &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"literal\">nil</span>:       <span class=\"comment\">// no panic</span></span><br><span class=\"line\">            <span class=\"keyword\">case</span> bailout&#123;&#125;: <span class=\"comment\">// \"expected\" panic</span></span><br><span class=\"line\">                err = fmt.Errorf(<span class=\"string\">\"multiple title elements\"</span>)</span><br><span class=\"line\">            <span class=\"keyword\">default</span>:</span><br><span class=\"line\">                <span class=\"built_in\">panic</span>(p) <span class=\"comment\">// unexpected panic; carry on panicking</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\">    <span class=\"built_in\">panic</span>(bailout&#123;&#125;) </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面的代码，<code>deferred</code> 函数调用 <code>recover</code>，并检查 <code>panic value</code>。当 <code>panic value</code> 是 <code>bailout{}</code> 类型时，<code>deferred</code> 函数生<br>成一个 <code>error</code> 返回给调用者。<br>当 <code>panic value</code> 是其他 <code>non-nil</code> 值时，表示发生了未知的 <code>panic</code> 异常。</p>\n<h3 id=\"正确调用-recover-函数\"><a href=\"#正确调用-recover-函数\" class=\"headerlink\" title=\"正确调用 recover 函数\"></a>正确调用 recover 函数</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">\"fmt\"</span></span><br><span class=\"line\">    <span class=\"string\">\"errors\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    fmt.Println(<span class=\"string\">\"Enter function main.\"</span>)</span><br><span class=\"line\">    <span class=\"comment\">// 引发 panic。</span></span><br><span class=\"line\">    <span class=\"built_in\">panic</span>(errors.New(<span class=\"string\">\"something wrong\"</span>))</span><br><span class=\"line\">    p := <span class=\"built_in\">recover</span>()</span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">\"panic: %s\\n\"</span>, p)</span><br><span class=\"line\">    fmt.Println(<span class=\"string\">\"Exit function main.\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的代码，<code>recover</code> 函数调用并不会起到任何作用，甚至都没有机会执行。因为 panic 一旦发生，控制权就会讯速地沿着调用栈的反方向<br>传播。所以，<strong>在 panic 函数调用之后的代码，根本就没有执行的机会</strong>。</p>\n<p>先调用 <code>recover</code> 函数，再调用 <code>panic</code> 函数会怎么样呢？<br>如果在我们调用 <code>recover</code> 函数时未发生 panic，那么该函数就不会做任何事情，并且只会返回一个 <code>nil</code>。</p>\n<p><strong><code>defer</code> 语句调用 <code>recover</code> 函数才是正确的打开方式</strong>。</p>\n<p>无论函数结束执行的原因是什么，其中的 <code>defer</code> 函数调用都会在它即将结束执行的那一刻执行。即使导致它执行结束的原因是一<br>个 panic 也会是这样。</p>\n<p>要注意，我们要<strong>尽量把 <code>defer</code> 语句写在函数体的开始处，因为在引发 panic 的语句之后的所有语句，都不会有任何执行机会</strong>。</p>\n"},{"title":"数组","_content":"# 数组\n数组是一个由固定长度的指定类型元素组成的序列。数组的长度在编译阶段确定。\n\n声明数组：\n```go\nvar 变量名 [SIZE]类型\n```\n\n内置函数 `len` 获取数组长度。通过下标访问元素：\n```go\nvar a [3]int             // array of 3 integers\nfmt.Println(a[0])        // print the first element\nfmt.Println(a[len(a)-1]) // print the last element, a[2]\n```\n\n默认情况下，数组的每个元素都被初始化为元素类型对应的零值。\n初始化数组：\n```go\nvar q [3]int = [3]int{1, 2, 3}\nvar r [3]int = [3]int{1, 2}\nfmt.Println(r[2]) // \"0\"\n\nvar balance = []float32{1000.0, 2.0, 3.4, 7.0, 50.0}\nmt.Println(len(balance)) // 5\nvar balance2 = []float32\nfmt.Println(len(balance2)) // type []float32 is not an expression\n\nq := [...]int{1, 2, 3}\nfmt.Printf(\"%T\\n\", q) // \"[3]int\"\n```\n初始化数组中 `{}` 中的元素个数不能大于 `[]` 中的数字。\n如果 `[]` 设置了 `SIZE`，Go 语言会根据元素的个数来设置数组的大小。\n上面代码中的**`...`省略号，表示数组的长度是根据初始化值的个数来计算**。\n\n**声明数组 `SIZE` 是必须的，如果没有，那就是切片了。**\n\n## 二维数组\n```go\nvar a = [3][4]int{  \n {0, 1, 2, 3} ,   /*  第一行索引为 0 */\n {4, 5, 6, 7} ,   /*  第二行索引为 1 */\n {8, 9, 10, 11},   /* 第三行索引为 2 */\n}\nfmt.Printf(\"a[%d][%d] = %d\\n\", 2, 3, a[2][3] )\n```\n\n`==` 和 `!=` 比较运算符来比较两个数组，只有当两个数组的所有元素都是相等的时候数组才是相等的。\n\n## 数组传入函数\n当调用函数时，函数的形参会被赋值，**所以函数参数变量接收的是一个复制的副本，并不是原始调用的变量。** 但是\n这种机制，**如果碰到传递一个大数组时，效率较低。这个时候可以显示的传入一个数组指针**（其他语言其实是隐式的传递指针）。\n```go\nfunc test(ptr *[32]byte) {\n  *ptr = [32]byte{}\n}\n```","source":"basic/array.md","raw":"---\ntitle: 数组\n---\n# 数组\n数组是一个由固定长度的指定类型元素组成的序列。数组的长度在编译阶段确定。\n\n声明数组：\n```go\nvar 变量名 [SIZE]类型\n```\n\n内置函数 `len` 获取数组长度。通过下标访问元素：\n```go\nvar a [3]int             // array of 3 integers\nfmt.Println(a[0])        // print the first element\nfmt.Println(a[len(a)-1]) // print the last element, a[2]\n```\n\n默认情况下，数组的每个元素都被初始化为元素类型对应的零值。\n初始化数组：\n```go\nvar q [3]int = [3]int{1, 2, 3}\nvar r [3]int = [3]int{1, 2}\nfmt.Println(r[2]) // \"0\"\n\nvar balance = []float32{1000.0, 2.0, 3.4, 7.0, 50.0}\nmt.Println(len(balance)) // 5\nvar balance2 = []float32\nfmt.Println(len(balance2)) // type []float32 is not an expression\n\nq := [...]int{1, 2, 3}\nfmt.Printf(\"%T\\n\", q) // \"[3]int\"\n```\n初始化数组中 `{}` 中的元素个数不能大于 `[]` 中的数字。\n如果 `[]` 设置了 `SIZE`，Go 语言会根据元素的个数来设置数组的大小。\n上面代码中的**`...`省略号，表示数组的长度是根据初始化值的个数来计算**。\n\n**声明数组 `SIZE` 是必须的，如果没有，那就是切片了。**\n\n## 二维数组\n```go\nvar a = [3][4]int{  \n {0, 1, 2, 3} ,   /*  第一行索引为 0 */\n {4, 5, 6, 7} ,   /*  第二行索引为 1 */\n {8, 9, 10, 11},   /* 第三行索引为 2 */\n}\nfmt.Printf(\"a[%d][%d] = %d\\n\", 2, 3, a[2][3] )\n```\n\n`==` 和 `!=` 比较运算符来比较两个数组，只有当两个数组的所有元素都是相等的时候数组才是相等的。\n\n## 数组传入函数\n当调用函数时，函数的形参会被赋值，**所以函数参数变量接收的是一个复制的副本，并不是原始调用的变量。** 但是\n这种机制，**如果碰到传递一个大数组时，效率较低。这个时候可以显示的传入一个数组指针**（其他语言其实是隐式的传递指针）。\n```go\nfunc test(ptr *[32]byte) {\n  *ptr = [32]byte{}\n}\n```","date":"2019-08-24T02:08:28.377Z","updated":"2019-08-24T02:08:28.355Z","path":"basic/array.html","comments":1,"layout":"page","_id":"ck1xm14kg000bfcw2ai6t92lf","content":"<h1 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h1><p>数组是一个由固定长度的指定类型元素组成的序列。数组的长度在编译阶段确定。</p>\n<p>声明数组：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> 变量名 [SIZE]类型</span><br></pre></td></tr></table></figure></p>\n<p>内置函数 <code>len</code> 获取数组长度。通过下标访问元素：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a [<span class=\"number\">3</span>]<span class=\"keyword\">int</span>             <span class=\"comment\">// array of 3 integers</span></span><br><span class=\"line\">fmt.Println(a[<span class=\"number\">0</span>])        <span class=\"comment\">// print the first element</span></span><br><span class=\"line\">fmt.Println(a[<span class=\"built_in\">len</span>(a)<span class=\"number\">-1</span>]) <span class=\"comment\">// print the last element, a[2]</span></span><br></pre></td></tr></table></figure></p>\n<p>默认情况下，数组的每个元素都被初始化为元素类型对应的零值。<br>初始化数组：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> q [<span class=\"number\">3</span>]<span class=\"keyword\">int</span> = [<span class=\"number\">3</span>]<span class=\"keyword\">int</span>&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> r [<span class=\"number\">3</span>]<span class=\"keyword\">int</span> = [<span class=\"number\">3</span>]<span class=\"keyword\">int</span>&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>&#125;</span><br><span class=\"line\">fmt.Println(r[<span class=\"number\">2</span>]) <span class=\"comment\">// \"0\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> balance = []<span class=\"keyword\">float32</span>&#123;<span class=\"number\">1000.0</span>, <span class=\"number\">2.0</span>, <span class=\"number\">3.4</span>, <span class=\"number\">7.0</span>, <span class=\"number\">50.0</span>&#125;</span><br><span class=\"line\">mt.Println(<span class=\"built_in\">len</span>(balance)) <span class=\"comment\">// 5</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> balance2 = []<span class=\"keyword\">float32</span></span><br><span class=\"line\">fmt.Println(<span class=\"built_in\">len</span>(balance2)) <span class=\"comment\">// type []float32 is not an expression</span></span><br><span class=\"line\"></span><br><span class=\"line\">q := [...]<span class=\"keyword\">int</span>&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>&#125;</span><br><span class=\"line\">fmt.Printf(<span class=\"string\">\"%T\\n\"</span>, q) <span class=\"comment\">// \"[3]int\"</span></span><br></pre></td></tr></table></figure></p>\n<p>初始化数组中 <code>{}</code> 中的元素个数不能大于 <code>[]</code> 中的数字。<br>如果 <code>[]</code> 设置了 <code>SIZE</code>，Go 语言会根据元素的个数来设置数组的大小。<br>上面代码中的<strong><code>...</code>省略号，表示数组的长度是根据初始化值的个数来计算</strong>。</p>\n<p><strong>声明数组 <code>SIZE</code> 是必须的，如果没有，那就是切片了。</strong></p>\n<h2 id=\"二维数组\"><a href=\"#二维数组\" class=\"headerlink\" title=\"二维数组\"></a>二维数组</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"number\">3</span>][<span class=\"number\">4</span>]<span class=\"keyword\">int</span>&#123;  </span><br><span class=\"line\"> &#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>&#125; ,   <span class=\"comment\">/*  第一行索引为 0 */</span></span><br><span class=\"line\"> &#123;<span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>&#125; ,   <span class=\"comment\">/*  第二行索引为 1 */</span></span><br><span class=\"line\"> &#123;<span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">10</span>, <span class=\"number\">11</span>&#125;,   <span class=\"comment\">/* 第三行索引为 2 */</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fmt.Printf(<span class=\"string\">\"a[%d][%d] = %d\\n\"</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, a[<span class=\"number\">2</span>][<span class=\"number\">3</span>] )</span><br></pre></td></tr></table></figure>\n<p><code>==</code> 和 <code>!=</code> 比较运算符来比较两个数组，只有当两个数组的所有元素都是相等的时候数组才是相等的。</p>\n<h2 id=\"数组传入函数\"><a href=\"#数组传入函数\" class=\"headerlink\" title=\"数组传入函数\"></a>数组传入函数</h2><p>当调用函数时，函数的形参会被赋值，<strong>所以函数参数变量接收的是一个复制的副本，并不是原始调用的变量。</strong> 但是<br>这种机制，<strong>如果碰到传递一个大数组时，效率较低。这个时候可以显示的传入一个数组指针</strong>（其他语言其实是隐式的传递指针）。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">test</span><span class=\"params\">(ptr *[32]<span class=\"keyword\">byte</span>)</span></span> &#123;</span><br><span class=\"line\">  *ptr = [<span class=\"number\">32</span>]<span class=\"keyword\">byte</span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{"navigation":{"logo":{"text":"Golang Learn","type":"link","path":"index.html"},"main":[{"text":"Golang 基础","type":"label"},{"text":"Go 环境配置","type":"link","path":"basic/env_config.html"},{"text":"包","type":"link","path":"basic/package.html"},{"text":"基础数据类型","type":"link","path":"basic/basic_data.html"},{"text":"变量","type":"link","path":"basic/var.html"},{"text":"常量","type":"link","path":"basic/constant.html"},{"text":"控制语句","type":"link","path":"basic/flow.html"},{"text":"运算符","type":"link","path":"basic/operator.html"},{"text":"作用域","type":"link","path":"basic/scope.html"},{"text":"指针","type":"link","path":"basic/pointer.html"},{"text":"数组","type":"link","path":"basic/array.html"},{"text":"切片","type":"link","path":"basic/slice.html"},{"text":"字典","type":"link","path":"basic/map.html"},{"text":"函数","type":"link","path":"basic/function.html"},{"text":"结构体","type":"link","path":"basic/struct.html"},{"text":"接口","type":"link","path":"basic/interface.html"},{"text":"面向对象","type":"link","path":"basic/oop.html"},{"text":"错误","type":"link","path":"basic/error.html"},{"text":"序列化","type":"link","path":"basic/json.html"},{"text":"反射","type":"link","path":"basic/reflect.html"},{"text":"测试","type":"link","path":"basic/test.html"},{"text":"并发编程","type":"label"},{"text":"goroutine","type":"link","path":"concurrent/goroutine.html"},{"text":"channel","type":"link","path":"concurrent/channel.html"},{"text":"同步和锁","type":"link","path":"concurrent/sync_lock.html"},{"text":"内存分配","type":"label"},{"text":"内存分配","type":"link","path":"advance/mm.html"},{"text":"垃圾回收","type":"label"},{"text":"垃圾回收","type":"link","path":"advance/gc.html"},{"text":"标准库","type":"label"},{"text":"fmt","type":"link","path":"standards/io/fmt.html"},{"text":"io","type":"link","path":"standards/io/io.html"},{"text":"ioutil","type":"link","path":"standards/io/ioutil.html"},{"text":"bufio","type":"link","path":"standards/io/bufio.html"},{"text":"os","type":"link","path":"standards/os/os.html"},{"text":"filepath","type":"link","path":"standards/os/filepath.html"},{"text":"strings","type":"link","path":"standards/text/strings.html"},{"text":"strconv","type":"link","path":"standards/text/strconv.html"},{"text":"unicode","type":"link","path":"standards/text/unicode.html"},{"text":"log","type":"link","path":"standards/log.html"},{"text":"time","type":"link","path":"standards/time.html"},{"text":"http","type":"link","path":"standards/net/http.html"},{"text":"math","type":"link","path":"standards/data/math.html"},{"text":"sort","type":"link","path":"standards/data/sort.html"},{"text":"big","type":"link","path":"standards/data/big.html"},{"text":"container","type":"link","path":"standards/data/container.html"},{"text":"sql","type":"link","path":"standards/database/sql.html"},{"text":"THEME","type":"label"},{"text":"使用文档主题","type":"link","path":"theme/theme-usage.html"},{"text":"SUPPORT AND FEEDBACK","type":"label"},{"text":"Raise an Issue on Github","type":"link","path":"https://github.com/shipengqi/golang-learn/issues/new"}]}}},"excerpt":"","more":"<h1 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h1><p>数组是一个由固定长度的指定类型元素组成的序列。数组的长度在编译阶段确定。</p>\n<p>声明数组：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> 变量名 [SIZE]类型</span><br></pre></td></tr></table></figure></p>\n<p>内置函数 <code>len</code> 获取数组长度。通过下标访问元素：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a [<span class=\"number\">3</span>]<span class=\"keyword\">int</span>             <span class=\"comment\">// array of 3 integers</span></span><br><span class=\"line\">fmt.Println(a[<span class=\"number\">0</span>])        <span class=\"comment\">// print the first element</span></span><br><span class=\"line\">fmt.Println(a[<span class=\"built_in\">len</span>(a)<span class=\"number\">-1</span>]) <span class=\"comment\">// print the last element, a[2]</span></span><br></pre></td></tr></table></figure></p>\n<p>默认情况下，数组的每个元素都被初始化为元素类型对应的零值。<br>初始化数组：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> q [<span class=\"number\">3</span>]<span class=\"keyword\">int</span> = [<span class=\"number\">3</span>]<span class=\"keyword\">int</span>&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> r [<span class=\"number\">3</span>]<span class=\"keyword\">int</span> = [<span class=\"number\">3</span>]<span class=\"keyword\">int</span>&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>&#125;</span><br><span class=\"line\">fmt.Println(r[<span class=\"number\">2</span>]) <span class=\"comment\">// \"0\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> balance = []<span class=\"keyword\">float32</span>&#123;<span class=\"number\">1000.0</span>, <span class=\"number\">2.0</span>, <span class=\"number\">3.4</span>, <span class=\"number\">7.0</span>, <span class=\"number\">50.0</span>&#125;</span><br><span class=\"line\">mt.Println(<span class=\"built_in\">len</span>(balance)) <span class=\"comment\">// 5</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> balance2 = []<span class=\"keyword\">float32</span></span><br><span class=\"line\">fmt.Println(<span class=\"built_in\">len</span>(balance2)) <span class=\"comment\">// type []float32 is not an expression</span></span><br><span class=\"line\"></span><br><span class=\"line\">q := [...]<span class=\"keyword\">int</span>&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>&#125;</span><br><span class=\"line\">fmt.Printf(<span class=\"string\">\"%T\\n\"</span>, q) <span class=\"comment\">// \"[3]int\"</span></span><br></pre></td></tr></table></figure></p>\n<p>初始化数组中 <code>{}</code> 中的元素个数不能大于 <code>[]</code> 中的数字。<br>如果 <code>[]</code> 设置了 <code>SIZE</code>，Go 语言会根据元素的个数来设置数组的大小。<br>上面代码中的<strong><code>...</code>省略号，表示数组的长度是根据初始化值的个数来计算</strong>。</p>\n<p><strong>声明数组 <code>SIZE</code> 是必须的，如果没有，那就是切片了。</strong></p>\n<h2 id=\"二维数组\"><a href=\"#二维数组\" class=\"headerlink\" title=\"二维数组\"></a>二维数组</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"number\">3</span>][<span class=\"number\">4</span>]<span class=\"keyword\">int</span>&#123;  </span><br><span class=\"line\"> &#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>&#125; ,   <span class=\"comment\">/*  第一行索引为 0 */</span></span><br><span class=\"line\"> &#123;<span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>&#125; ,   <span class=\"comment\">/*  第二行索引为 1 */</span></span><br><span class=\"line\"> &#123;<span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">10</span>, <span class=\"number\">11</span>&#125;,   <span class=\"comment\">/* 第三行索引为 2 */</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fmt.Printf(<span class=\"string\">\"a[%d][%d] = %d\\n\"</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, a[<span class=\"number\">2</span>][<span class=\"number\">3</span>] )</span><br></pre></td></tr></table></figure>\n<p><code>==</code> 和 <code>!=</code> 比较运算符来比较两个数组，只有当两个数组的所有元素都是相等的时候数组才是相等的。</p>\n<h2 id=\"数组传入函数\"><a href=\"#数组传入函数\" class=\"headerlink\" title=\"数组传入函数\"></a>数组传入函数</h2><p>当调用函数时，函数的形参会被赋值，<strong>所以函数参数变量接收的是一个复制的副本，并不是原始调用的变量。</strong> 但是<br>这种机制，<strong>如果碰到传递一个大数组时，效率较低。这个时候可以显示的传入一个数组指针</strong>（其他语言其实是隐式的传递指针）。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">test</span><span class=\"params\">(ptr *[32]<span class=\"keyword\">byte</span>)</span></span> &#123;</span><br><span class=\"line\">  *ptr = [<span class=\"number\">32</span>]<span class=\"keyword\">byte</span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n"},{"title":"Go 环境配置","_content":"\n# Go 环境配置\n## 安装\nWindows 下安装，官网 [下载安装包](https://golang.org/dl/)，直接安装。\n默认情况下 `.msi` 文件会安装在 `c:\\Go` 目录下。安装完成后默认会将 `c:\\Go\\bin` 目录添加到 `PATH` 环境变量中。\n并添加环境变量 `GOROOT`，值为 Go 安装根目录 `C:\\Go\\`。重启命令窗口生效。\n\n打开 CMD 输入 `go` 命令，验证是否安装成功。否则检查环境变量 `Path` 和 `GOROOT`。\n\n## 工作区\n### GOROOT\n环境变量 `GOROOT` 用来指定 Go 的安装目录，Go 的标准库也在这个位置。目录结构与 `GOPATH` 类似。\n\n### GOPATH\n我们安装好 Go 之后，**必须配置一个环境变量 `GOPATH`**，这个 `GOPATH` 路径是用来指定当前工作目录的。\n**不能和 Go 的安装目录（`GOROOT`）一样**。\n\n工作区的目录结构：\n```bash\nGOPATH/\n    src/ # 源码目录\n    bin/ # 存放编译后的可执行程序\n    pkg/ # 存放编译后的包的目标文件\n```\n\n`GOPATH` 允许多个目录，当有多个目录时，请注意分隔符，多个目录的时候 Windows 是分号 `;`，Linux 系统是冒号 `:`，\n当有多个 `GOPATH` 时，默认会将 `go get` 的内容放在第一个目录下。\n\n\n## Go Module\ngolang 1.11 已经支持 Go Module。这是官方提倡的新的包管理，乃至项目管理机制，可以不再需要 `GOPATH` 的存在。\n\n### Module 机制\nGo Module 不同于以往基于 `GOPATH` 和 Vendor 的项目构建，其主要是通过 `$GOPATH/pkg/mod` 下的缓存包来对项目进行构建。\n Go Module 可以通过 `GO111MODULE` 来控制是否启用，`GO111MODULE` 有三种类型:\n- `on` 所有的构建，都使用 Module 机制\n- `off` 所有的构建，都不使用 Module 机制，而是使用 `GOPATH` 和 Vendor\n- `auto` 在 GOPATH 下的项目，不使用 Module 机制，不在 `GOPATH` 下的项目使用\n\n### 和 dep 的区别\n- dep 是解析所有的包引用，然后在 `$GOPATH/pkg/dep` 下进行缓存，再在项目下生成 vendor，然后基于 vendor 来构建项目，\n无法脱离 `GOPATH`。\n- mod 是解析所有的包引用，然后在 `$GOPATH/pkg/mod` 下进行缓存，直接基于缓存包来构建项目，所以可以脱离 `GOPATH`\n\n### 准备环境\n- golang 1.11 的环境需要开启 `GO11MODULE` ，并且**确保项目目录不在 `GOPATH` 中**。\n```sh\nexport GO111MODULE=on\n```\n- golang 1.12 只需要确保实验目录不在 `GOPATH` 中。\n- 配置代理 `export GOPROXY=https://goproxy.io`。（如果拉取包失败，会报  `cannot find module for path xxx` 的错误）\n\n### 迁移到 Go Module\n```sh\n# clone 项目, 不要在 `GOPATH` 中, 比如之前的项目的结构是 `GOPATH/src/cdf-mannager`\ngit clone https://github.com/xxx/cdf-mannager\n\n# 删除 vender\ncd cdf-mannager\nrm -rf vender\n\n# init\ngo mod init cdf-mannager\n\n# 下载依赖 也可以不执行这一步， go run 或 go build 会自动下载\ngo mod download\n```\n\nGo 会把 `Gopkg.lock` 或者 `glide.lock` 中的依赖项写入到 `go.mod` 文件中。`go.mod` 文件的内容像下面这样：\n```\nmodule cdf-manager\n\nrequire (\n        github.com/fsnotify/fsnotify v1.4.7\n        github.com/gin-contrib/sse v0.0.0-20170109093832-22d885f9ecc7\n        github.com/gin-gonic/gin v0.0.0-20180814085852-b869fe1415e4\n        github.com/golang/protobuf v0.0.0-20170601230230-5a0f697c9ed9\n        github.com/hashicorp/hcl v1.0.0\n        github.com/inconshreveable/mousetrap v0.0.0-20141017200713-76626ae9c91c\n        github.com/json-iterator/go v0.0.0-20170829155851-36b14963da70\n        github.com/lexkong/log v0.0.0-20180607165131-972f9cd951fc\n        github.com/magiconair/properties v1.8.0\n        github.com/mattn/go-isatty v0.0.0-20170307163044-57fdcb988a5c\n        github.com/mitchellh/mapstructure v1.1.2\n        github.com/pelletier/go-toml v1.2.0\n        github.com/satori/go.uuid v0.0.0-20180103152354-f58768cc1a7a\n        github.com/spf13/afero v1.1.2\n        github.com/spf13/cast v1.3.0\n        github.com/spf13/cobra v0.0.0-20180427134550-ef82de70bb3f\n        github.com/spf13/jwalterweatherman v1.0.0\n        github.com/spf13/pflag v1.0.3\n        github.com/spf13/viper v0.0.0-20181207100336-6d33b5a963d9\n        github.com/ugorji/go v1.1.2-0.20180831062425-e253f1f20942\n        github.com/willf/pad v0.0.0-20160331131008-b3d780601022\n        golang.org/x/sys v0.0.0-20190116161447-11f53e031339\n        golang.org/x/text v0.3.0\n        gopkg.in/go-playground/validator.v8 v8.0.0-20160718134125-5f57d2222ad7\n        gopkg.in/yaml.v2 v2.2.2\n)\n\n```\n\n## 开发工具\n常用 IDE：\n- LiteIDE\n- Sublime\n- GoLand\n- VS Code\n\n","source":"basic/env_config.md","raw":"---\ntitle: Go 环境配置\n---\n\n# Go 环境配置\n## 安装\nWindows 下安装，官网 [下载安装包](https://golang.org/dl/)，直接安装。\n默认情况下 `.msi` 文件会安装在 `c:\\Go` 目录下。安装完成后默认会将 `c:\\Go\\bin` 目录添加到 `PATH` 环境变量中。\n并添加环境变量 `GOROOT`，值为 Go 安装根目录 `C:\\Go\\`。重启命令窗口生效。\n\n打开 CMD 输入 `go` 命令，验证是否安装成功。否则检查环境变量 `Path` 和 `GOROOT`。\n\n## 工作区\n### GOROOT\n环境变量 `GOROOT` 用来指定 Go 的安装目录，Go 的标准库也在这个位置。目录结构与 `GOPATH` 类似。\n\n### GOPATH\n我们安装好 Go 之后，**必须配置一个环境变量 `GOPATH`**，这个 `GOPATH` 路径是用来指定当前工作目录的。\n**不能和 Go 的安装目录（`GOROOT`）一样**。\n\n工作区的目录结构：\n```bash\nGOPATH/\n    src/ # 源码目录\n    bin/ # 存放编译后的可执行程序\n    pkg/ # 存放编译后的包的目标文件\n```\n\n`GOPATH` 允许多个目录，当有多个目录时，请注意分隔符，多个目录的时候 Windows 是分号 `;`，Linux 系统是冒号 `:`，\n当有多个 `GOPATH` 时，默认会将 `go get` 的内容放在第一个目录下。\n\n\n## Go Module\ngolang 1.11 已经支持 Go Module。这是官方提倡的新的包管理，乃至项目管理机制，可以不再需要 `GOPATH` 的存在。\n\n### Module 机制\nGo Module 不同于以往基于 `GOPATH` 和 Vendor 的项目构建，其主要是通过 `$GOPATH/pkg/mod` 下的缓存包来对项目进行构建。\n Go Module 可以通过 `GO111MODULE` 来控制是否启用，`GO111MODULE` 有三种类型:\n- `on` 所有的构建，都使用 Module 机制\n- `off` 所有的构建，都不使用 Module 机制，而是使用 `GOPATH` 和 Vendor\n- `auto` 在 GOPATH 下的项目，不使用 Module 机制，不在 `GOPATH` 下的项目使用\n\n### 和 dep 的区别\n- dep 是解析所有的包引用，然后在 `$GOPATH/pkg/dep` 下进行缓存，再在项目下生成 vendor，然后基于 vendor 来构建项目，\n无法脱离 `GOPATH`。\n- mod 是解析所有的包引用，然后在 `$GOPATH/pkg/mod` 下进行缓存，直接基于缓存包来构建项目，所以可以脱离 `GOPATH`\n\n### 准备环境\n- golang 1.11 的环境需要开启 `GO11MODULE` ，并且**确保项目目录不在 `GOPATH` 中**。\n```sh\nexport GO111MODULE=on\n```\n- golang 1.12 只需要确保实验目录不在 `GOPATH` 中。\n- 配置代理 `export GOPROXY=https://goproxy.io`。（如果拉取包失败，会报  `cannot find module for path xxx` 的错误）\n\n### 迁移到 Go Module\n```sh\n# clone 项目, 不要在 `GOPATH` 中, 比如之前的项目的结构是 `GOPATH/src/cdf-mannager`\ngit clone https://github.com/xxx/cdf-mannager\n\n# 删除 vender\ncd cdf-mannager\nrm -rf vender\n\n# init\ngo mod init cdf-mannager\n\n# 下载依赖 也可以不执行这一步， go run 或 go build 会自动下载\ngo mod download\n```\n\nGo 会把 `Gopkg.lock` 或者 `glide.lock` 中的依赖项写入到 `go.mod` 文件中。`go.mod` 文件的内容像下面这样：\n```\nmodule cdf-manager\n\nrequire (\n        github.com/fsnotify/fsnotify v1.4.7\n        github.com/gin-contrib/sse v0.0.0-20170109093832-22d885f9ecc7\n        github.com/gin-gonic/gin v0.0.0-20180814085852-b869fe1415e4\n        github.com/golang/protobuf v0.0.0-20170601230230-5a0f697c9ed9\n        github.com/hashicorp/hcl v1.0.0\n        github.com/inconshreveable/mousetrap v0.0.0-20141017200713-76626ae9c91c\n        github.com/json-iterator/go v0.0.0-20170829155851-36b14963da70\n        github.com/lexkong/log v0.0.0-20180607165131-972f9cd951fc\n        github.com/magiconair/properties v1.8.0\n        github.com/mattn/go-isatty v0.0.0-20170307163044-57fdcb988a5c\n        github.com/mitchellh/mapstructure v1.1.2\n        github.com/pelletier/go-toml v1.2.0\n        github.com/satori/go.uuid v0.0.0-20180103152354-f58768cc1a7a\n        github.com/spf13/afero v1.1.2\n        github.com/spf13/cast v1.3.0\n        github.com/spf13/cobra v0.0.0-20180427134550-ef82de70bb3f\n        github.com/spf13/jwalterweatherman v1.0.0\n        github.com/spf13/pflag v1.0.3\n        github.com/spf13/viper v0.0.0-20181207100336-6d33b5a963d9\n        github.com/ugorji/go v1.1.2-0.20180831062425-e253f1f20942\n        github.com/willf/pad v0.0.0-20160331131008-b3d780601022\n        golang.org/x/sys v0.0.0-20190116161447-11f53e031339\n        golang.org/x/text v0.3.0\n        gopkg.in/go-playground/validator.v8 v8.0.0-20160718134125-5f57d2222ad7\n        gopkg.in/yaml.v2 v2.2.2\n)\n\n```\n\n## 开发工具\n常用 IDE：\n- LiteIDE\n- Sublime\n- GoLand\n- VS Code\n\n","date":"2019-08-24T02:08:28.527Z","updated":"2019-08-24T02:08:28.505Z","path":"basic/env_config.html","comments":1,"layout":"page","_id":"ck1xm14kh000cfcw2a936p303","content":"<h1 id=\"Go-环境配置\"><a href=\"#Go-环境配置\" class=\"headerlink\" title=\"Go 环境配置\"></a>Go 环境配置</h1><h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>Windows 下安装，官网 <a href=\"https://golang.org/dl/\" target=\"_blank\" rel=\"noopener\">下载安装包</a>，直接安装。<br>默认情况下 <code>.msi</code> 文件会安装在 <code>c:\\Go</code> 目录下。安装完成后默认会将 <code>c:\\Go\\bin</code> 目录添加到 <code>PATH</code> 环境变量中。<br>并添加环境变量 <code>GOROOT</code>，值为 Go 安装根目录 <code>C:\\Go\\</code>。重启命令窗口生效。</p>\n<p>打开 CMD 输入 <code>go</code> 命令，验证是否安装成功。否则检查环境变量 <code>Path</code> 和 <code>GOROOT</code>。</p>\n<h2 id=\"工作区\"><a href=\"#工作区\" class=\"headerlink\" title=\"工作区\"></a>工作区</h2><h3 id=\"GOROOT\"><a href=\"#GOROOT\" class=\"headerlink\" title=\"GOROOT\"></a>GOROOT</h3><p>环境变量 <code>GOROOT</code> 用来指定 Go 的安装目录，Go 的标准库也在这个位置。目录结构与 <code>GOPATH</code> 类似。</p>\n<h3 id=\"GOPATH\"><a href=\"#GOPATH\" class=\"headerlink\" title=\"GOPATH\"></a>GOPATH</h3><p>我们安装好 Go 之后，<strong>必须配置一个环境变量 <code>GOPATH</code></strong>，这个 <code>GOPATH</code> 路径是用来指定当前工作目录的。<br><strong>不能和 Go 的安装目录（<code>GOROOT</code>）一样</strong>。</p>\n<p>工作区的目录结构：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GOPATH/</span><br><span class=\"line\">    src/ <span class=\"comment\"># 源码目录</span></span><br><span class=\"line\">    bin/ <span class=\"comment\"># 存放编译后的可执行程序</span></span><br><span class=\"line\">    pkg/ <span class=\"comment\"># 存放编译后的包的目标文件</span></span><br></pre></td></tr></table></figure></p>\n<p><code>GOPATH</code> 允许多个目录，当有多个目录时，请注意分隔符，多个目录的时候 Windows 是分号 <code>;</code>，Linux 系统是冒号 <code>:</code>，<br>当有多个 <code>GOPATH</code> 时，默认会将 <code>go get</code> 的内容放在第一个目录下。</p>\n<h2 id=\"Go-Module\"><a href=\"#Go-Module\" class=\"headerlink\" title=\"Go Module\"></a>Go Module</h2><p>golang 1.11 已经支持 Go Module。这是官方提倡的新的包管理，乃至项目管理机制，可以不再需要 <code>GOPATH</code> 的存在。</p>\n<h3 id=\"Module-机制\"><a href=\"#Module-机制\" class=\"headerlink\" title=\"Module 机制\"></a>Module 机制</h3><p>Go Module 不同于以往基于 <code>GOPATH</code> 和 Vendor 的项目构建，其主要是通过 <code>$GOPATH/pkg/mod</code> 下的缓存包来对项目进行构建。<br> Go Module 可以通过 <code>GO111MODULE</code> 来控制是否启用，<code>GO111MODULE</code> 有三种类型:</p>\n<ul>\n<li><code>on</code> 所有的构建，都使用 Module 机制</li>\n<li><code>off</code> 所有的构建，都不使用 Module 机制，而是使用 <code>GOPATH</code> 和 Vendor</li>\n<li><code>auto</code> 在 GOPATH 下的项目，不使用 Module 机制，不在 <code>GOPATH</code> 下的项目使用</li>\n</ul>\n<h3 id=\"和-dep-的区别\"><a href=\"#和-dep-的区别\" class=\"headerlink\" title=\"和 dep 的区别\"></a>和 dep 的区别</h3><ul>\n<li>dep 是解析所有的包引用，然后在 <code>$GOPATH/pkg/dep</code> 下进行缓存，再在项目下生成 vendor，然后基于 vendor 来构建项目，<br>无法脱离 <code>GOPATH</code>。</li>\n<li>mod 是解析所有的包引用，然后在 <code>$GOPATH/pkg/mod</code> 下进行缓存，直接基于缓存包来构建项目，所以可以脱离 <code>GOPATH</code></li>\n</ul>\n<h3 id=\"准备环境\"><a href=\"#准备环境\" class=\"headerlink\" title=\"准备环境\"></a>准备环境</h3><ul>\n<li><p>golang 1.11 的环境需要开启 <code>GO11MODULE</code> ，并且<strong>确保项目目录不在 <code>GOPATH</code> 中</strong>。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">export</span> GO111MODULE=on</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>golang 1.12 只需要确保实验目录不在 <code>GOPATH</code> 中。</p>\n</li>\n<li>配置代理 <code>export GOPROXY=https://goproxy.io</code>。（如果拉取包失败，会报  <code>cannot find module for path xxx</code> 的错误）</li>\n</ul>\n<h3 id=\"迁移到-Go-Module\"><a href=\"#迁移到-Go-Module\" class=\"headerlink\" title=\"迁移到 Go Module\"></a>迁移到 Go Module</h3><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># clone 项目, 不要在 `GOPATH` 中, 比如之前的项目的结构是 `GOPATH/src/cdf-mannager`</span></span><br><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/xxx/cdf-mannager</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 删除 vender</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> cdf-mannager</span><br><span class=\"line\">rm -rf vender</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># init</span></span><br><span class=\"line\">go mod init cdf-mannager</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 下载依赖 也可以不执行这一步， go run 或 go build 会自动下载</span></span><br><span class=\"line\">go mod download</span><br></pre></td></tr></table></figure>\n<p>Go 会把 <code>Gopkg.lock</code> 或者 <code>glide.lock</code> 中的依赖项写入到 <code>go.mod</code> 文件中。<code>go.mod</code> 文件的内容像下面这样：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module cdf-manager</span><br><span class=\"line\"></span><br><span class=\"line\">require (</span><br><span class=\"line\">        github.com/fsnotify/fsnotify v1.4.7</span><br><span class=\"line\">        github.com/gin-contrib/sse v0.0.0-20170109093832-22d885f9ecc7</span><br><span class=\"line\">        github.com/gin-gonic/gin v0.0.0-20180814085852-b869fe1415e4</span><br><span class=\"line\">        github.com/golang/protobuf v0.0.0-20170601230230-5a0f697c9ed9</span><br><span class=\"line\">        github.com/hashicorp/hcl v1.0.0</span><br><span class=\"line\">        github.com/inconshreveable/mousetrap v0.0.0-20141017200713-76626ae9c91c</span><br><span class=\"line\">        github.com/json-iterator/go v0.0.0-20170829155851-36b14963da70</span><br><span class=\"line\">        github.com/lexkong/log v0.0.0-20180607165131-972f9cd951fc</span><br><span class=\"line\">        github.com/magiconair/properties v1.8.0</span><br><span class=\"line\">        github.com/mattn/go-isatty v0.0.0-20170307163044-57fdcb988a5c</span><br><span class=\"line\">        github.com/mitchellh/mapstructure v1.1.2</span><br><span class=\"line\">        github.com/pelletier/go-toml v1.2.0</span><br><span class=\"line\">        github.com/satori/go.uuid v0.0.0-20180103152354-f58768cc1a7a</span><br><span class=\"line\">        github.com/spf13/afero v1.1.2</span><br><span class=\"line\">        github.com/spf13/cast v1.3.0</span><br><span class=\"line\">        github.com/spf13/cobra v0.0.0-20180427134550-ef82de70bb3f</span><br><span class=\"line\">        github.com/spf13/jwalterweatherman v1.0.0</span><br><span class=\"line\">        github.com/spf13/pflag v1.0.3</span><br><span class=\"line\">        github.com/spf13/viper v0.0.0-20181207100336-6d33b5a963d9</span><br><span class=\"line\">        github.com/ugorji/go v1.1.2-0.20180831062425-e253f1f20942</span><br><span class=\"line\">        github.com/willf/pad v0.0.0-20160331131008-b3d780601022</span><br><span class=\"line\">        golang.org/x/sys v0.0.0-20190116161447-11f53e031339</span><br><span class=\"line\">        golang.org/x/text v0.3.0</span><br><span class=\"line\">        gopkg.in/go-playground/validator.v8 v8.0.0-20160718134125-5f57d2222ad7</span><br><span class=\"line\">        gopkg.in/yaml.v2 v2.2.2</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"开发工具\"><a href=\"#开发工具\" class=\"headerlink\" title=\"开发工具\"></a>开发工具</h2><p>常用 IDE：</p>\n<ul>\n<li>LiteIDE</li>\n<li>Sublime</li>\n<li>GoLand</li>\n<li>VS Code</li>\n</ul>\n","site":{"data":{"navigation":{"logo":{"text":"Golang Learn","type":"link","path":"index.html"},"main":[{"text":"Golang 基础","type":"label"},{"text":"Go 环境配置","type":"link","path":"basic/env_config.html"},{"text":"包","type":"link","path":"basic/package.html"},{"text":"基础数据类型","type":"link","path":"basic/basic_data.html"},{"text":"变量","type":"link","path":"basic/var.html"},{"text":"常量","type":"link","path":"basic/constant.html"},{"text":"控制语句","type":"link","path":"basic/flow.html"},{"text":"运算符","type":"link","path":"basic/operator.html"},{"text":"作用域","type":"link","path":"basic/scope.html"},{"text":"指针","type":"link","path":"basic/pointer.html"},{"text":"数组","type":"link","path":"basic/array.html"},{"text":"切片","type":"link","path":"basic/slice.html"},{"text":"字典","type":"link","path":"basic/map.html"},{"text":"函数","type":"link","path":"basic/function.html"},{"text":"结构体","type":"link","path":"basic/struct.html"},{"text":"接口","type":"link","path":"basic/interface.html"},{"text":"面向对象","type":"link","path":"basic/oop.html"},{"text":"错误","type":"link","path":"basic/error.html"},{"text":"序列化","type":"link","path":"basic/json.html"},{"text":"反射","type":"link","path":"basic/reflect.html"},{"text":"测试","type":"link","path":"basic/test.html"},{"text":"并发编程","type":"label"},{"text":"goroutine","type":"link","path":"concurrent/goroutine.html"},{"text":"channel","type":"link","path":"concurrent/channel.html"},{"text":"同步和锁","type":"link","path":"concurrent/sync_lock.html"},{"text":"内存分配","type":"label"},{"text":"内存分配","type":"link","path":"advance/mm.html"},{"text":"垃圾回收","type":"label"},{"text":"垃圾回收","type":"link","path":"advance/gc.html"},{"text":"标准库","type":"label"},{"text":"fmt","type":"link","path":"standards/io/fmt.html"},{"text":"io","type":"link","path":"standards/io/io.html"},{"text":"ioutil","type":"link","path":"standards/io/ioutil.html"},{"text":"bufio","type":"link","path":"standards/io/bufio.html"},{"text":"os","type":"link","path":"standards/os/os.html"},{"text":"filepath","type":"link","path":"standards/os/filepath.html"},{"text":"strings","type":"link","path":"standards/text/strings.html"},{"text":"strconv","type":"link","path":"standards/text/strconv.html"},{"text":"unicode","type":"link","path":"standards/text/unicode.html"},{"text":"log","type":"link","path":"standards/log.html"},{"text":"time","type":"link","path":"standards/time.html"},{"text":"http","type":"link","path":"standards/net/http.html"},{"text":"math","type":"link","path":"standards/data/math.html"},{"text":"sort","type":"link","path":"standards/data/sort.html"},{"text":"big","type":"link","path":"standards/data/big.html"},{"text":"container","type":"link","path":"standards/data/container.html"},{"text":"sql","type":"link","path":"standards/database/sql.html"},{"text":"THEME","type":"label"},{"text":"使用文档主题","type":"link","path":"theme/theme-usage.html"},{"text":"SUPPORT AND FEEDBACK","type":"label"},{"text":"Raise an Issue on Github","type":"link","path":"https://github.com/shipengqi/golang-learn/issues/new"}]}}},"excerpt":"","more":"<h1 id=\"Go-环境配置\"><a href=\"#Go-环境配置\" class=\"headerlink\" title=\"Go 环境配置\"></a>Go 环境配置</h1><h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>Windows 下安装，官网 <a href=\"https://golang.org/dl/\" target=\"_blank\" rel=\"noopener\">下载安装包</a>，直接安装。<br>默认情况下 <code>.msi</code> 文件会安装在 <code>c:\\Go</code> 目录下。安装完成后默认会将 <code>c:\\Go\\bin</code> 目录添加到 <code>PATH</code> 环境变量中。<br>并添加环境变量 <code>GOROOT</code>，值为 Go 安装根目录 <code>C:\\Go\\</code>。重启命令窗口生效。</p>\n<p>打开 CMD 输入 <code>go</code> 命令，验证是否安装成功。否则检查环境变量 <code>Path</code> 和 <code>GOROOT</code>。</p>\n<h2 id=\"工作区\"><a href=\"#工作区\" class=\"headerlink\" title=\"工作区\"></a>工作区</h2><h3 id=\"GOROOT\"><a href=\"#GOROOT\" class=\"headerlink\" title=\"GOROOT\"></a>GOROOT</h3><p>环境变量 <code>GOROOT</code> 用来指定 Go 的安装目录，Go 的标准库也在这个位置。目录结构与 <code>GOPATH</code> 类似。</p>\n<h3 id=\"GOPATH\"><a href=\"#GOPATH\" class=\"headerlink\" title=\"GOPATH\"></a>GOPATH</h3><p>我们安装好 Go 之后，<strong>必须配置一个环境变量 <code>GOPATH</code></strong>，这个 <code>GOPATH</code> 路径是用来指定当前工作目录的。<br><strong>不能和 Go 的安装目录（<code>GOROOT</code>）一样</strong>。</p>\n<p>工作区的目录结构：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GOPATH/</span><br><span class=\"line\">    src/ <span class=\"comment\"># 源码目录</span></span><br><span class=\"line\">    bin/ <span class=\"comment\"># 存放编译后的可执行程序</span></span><br><span class=\"line\">    pkg/ <span class=\"comment\"># 存放编译后的包的目标文件</span></span><br></pre></td></tr></table></figure></p>\n<p><code>GOPATH</code> 允许多个目录，当有多个目录时，请注意分隔符，多个目录的时候 Windows 是分号 <code>;</code>，Linux 系统是冒号 <code>:</code>，<br>当有多个 <code>GOPATH</code> 时，默认会将 <code>go get</code> 的内容放在第一个目录下。</p>\n<h2 id=\"Go-Module\"><a href=\"#Go-Module\" class=\"headerlink\" title=\"Go Module\"></a>Go Module</h2><p>golang 1.11 已经支持 Go Module。这是官方提倡的新的包管理，乃至项目管理机制，可以不再需要 <code>GOPATH</code> 的存在。</p>\n<h3 id=\"Module-机制\"><a href=\"#Module-机制\" class=\"headerlink\" title=\"Module 机制\"></a>Module 机制</h3><p>Go Module 不同于以往基于 <code>GOPATH</code> 和 Vendor 的项目构建，其主要是通过 <code>$GOPATH/pkg/mod</code> 下的缓存包来对项目进行构建。<br> Go Module 可以通过 <code>GO111MODULE</code> 来控制是否启用，<code>GO111MODULE</code> 有三种类型:</p>\n<ul>\n<li><code>on</code> 所有的构建，都使用 Module 机制</li>\n<li><code>off</code> 所有的构建，都不使用 Module 机制，而是使用 <code>GOPATH</code> 和 Vendor</li>\n<li><code>auto</code> 在 GOPATH 下的项目，不使用 Module 机制，不在 <code>GOPATH</code> 下的项目使用</li>\n</ul>\n<h3 id=\"和-dep-的区别\"><a href=\"#和-dep-的区别\" class=\"headerlink\" title=\"和 dep 的区别\"></a>和 dep 的区别</h3><ul>\n<li>dep 是解析所有的包引用，然后在 <code>$GOPATH/pkg/dep</code> 下进行缓存，再在项目下生成 vendor，然后基于 vendor 来构建项目，<br>无法脱离 <code>GOPATH</code>。</li>\n<li>mod 是解析所有的包引用，然后在 <code>$GOPATH/pkg/mod</code> 下进行缓存，直接基于缓存包来构建项目，所以可以脱离 <code>GOPATH</code></li>\n</ul>\n<h3 id=\"准备环境\"><a href=\"#准备环境\" class=\"headerlink\" title=\"准备环境\"></a>准备环境</h3><ul>\n<li><p>golang 1.11 的环境需要开启 <code>GO11MODULE</code> ，并且<strong>确保项目目录不在 <code>GOPATH</code> 中</strong>。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">export</span> GO111MODULE=on</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>golang 1.12 只需要确保实验目录不在 <code>GOPATH</code> 中。</p>\n</li>\n<li>配置代理 <code>export GOPROXY=https://goproxy.io</code>。（如果拉取包失败，会报  <code>cannot find module for path xxx</code> 的错误）</li>\n</ul>\n<h3 id=\"迁移到-Go-Module\"><a href=\"#迁移到-Go-Module\" class=\"headerlink\" title=\"迁移到 Go Module\"></a>迁移到 Go Module</h3><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># clone 项目, 不要在 `GOPATH` 中, 比如之前的项目的结构是 `GOPATH/src/cdf-mannager`</span></span><br><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/xxx/cdf-mannager</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 删除 vender</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> cdf-mannager</span><br><span class=\"line\">rm -rf vender</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># init</span></span><br><span class=\"line\">go mod init cdf-mannager</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 下载依赖 也可以不执行这一步， go run 或 go build 会自动下载</span></span><br><span class=\"line\">go mod download</span><br></pre></td></tr></table></figure>\n<p>Go 会把 <code>Gopkg.lock</code> 或者 <code>glide.lock</code> 中的依赖项写入到 <code>go.mod</code> 文件中。<code>go.mod</code> 文件的内容像下面这样：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module cdf-manager</span><br><span class=\"line\"></span><br><span class=\"line\">require (</span><br><span class=\"line\">        github.com/fsnotify/fsnotify v1.4.7</span><br><span class=\"line\">        github.com/gin-contrib/sse v0.0.0-20170109093832-22d885f9ecc7</span><br><span class=\"line\">        github.com/gin-gonic/gin v0.0.0-20180814085852-b869fe1415e4</span><br><span class=\"line\">        github.com/golang/protobuf v0.0.0-20170601230230-5a0f697c9ed9</span><br><span class=\"line\">        github.com/hashicorp/hcl v1.0.0</span><br><span class=\"line\">        github.com/inconshreveable/mousetrap v0.0.0-20141017200713-76626ae9c91c</span><br><span class=\"line\">        github.com/json-iterator/go v0.0.0-20170829155851-36b14963da70</span><br><span class=\"line\">        github.com/lexkong/log v0.0.0-20180607165131-972f9cd951fc</span><br><span class=\"line\">        github.com/magiconair/properties v1.8.0</span><br><span class=\"line\">        github.com/mattn/go-isatty v0.0.0-20170307163044-57fdcb988a5c</span><br><span class=\"line\">        github.com/mitchellh/mapstructure v1.1.2</span><br><span class=\"line\">        github.com/pelletier/go-toml v1.2.0</span><br><span class=\"line\">        github.com/satori/go.uuid v0.0.0-20180103152354-f58768cc1a7a</span><br><span class=\"line\">        github.com/spf13/afero v1.1.2</span><br><span class=\"line\">        github.com/spf13/cast v1.3.0</span><br><span class=\"line\">        github.com/spf13/cobra v0.0.0-20180427134550-ef82de70bb3f</span><br><span class=\"line\">        github.com/spf13/jwalterweatherman v1.0.0</span><br><span class=\"line\">        github.com/spf13/pflag v1.0.3</span><br><span class=\"line\">        github.com/spf13/viper v0.0.0-20181207100336-6d33b5a963d9</span><br><span class=\"line\">        github.com/ugorji/go v1.1.2-0.20180831062425-e253f1f20942</span><br><span class=\"line\">        github.com/willf/pad v0.0.0-20160331131008-b3d780601022</span><br><span class=\"line\">        golang.org/x/sys v0.0.0-20190116161447-11f53e031339</span><br><span class=\"line\">        golang.org/x/text v0.3.0</span><br><span class=\"line\">        gopkg.in/go-playground/validator.v8 v8.0.0-20160718134125-5f57d2222ad7</span><br><span class=\"line\">        gopkg.in/yaml.v2 v2.2.2</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"开发工具\"><a href=\"#开发工具\" class=\"headerlink\" title=\"开发工具\"></a>开发工具</h2><p>常用 IDE：</p>\n<ul>\n<li>LiteIDE</li>\n<li>Sublime</li>\n<li>GoLand</li>\n<li>VS Code</li>\n</ul>\n"},{"title":"控制语句","_content":"# 控制语句\n## if\n```go\nif 布尔表达式 {\n   \n}\n```\n### if...else\n\n```go\nif 布尔表达式 {\n   \n} else {\n  \n}\n```\n\n## switch\n```go\nswitch var1 {\n    case val1:\n        ...  // 不需要显示的break，case 执行完会自动中断\n    case val2:\n\t\t\t\t...\n\t\tcase val3,val4,...:\t\t\n    default:\n        ...\n}\n```\n`val1`,`val2` ... 类型不被局限于常量或整数，但必须是相同的类型。\n\n`switch` 语句，你要明白其中的 `case` 表达式的所有子表达式的结果值都是要与 `switch` 表达式的结果值判等的，因此它们的类型必须相\n同或者能够都统一到 `switch` 表达式的结果类型。\n如果无法做到，那么这条 `switch` 语句就不能通过编译。\n\n**`switch`语句在 `case` 子句的选择上是具有唯一性的**。正因为如此，`switch` 语句不允许 `case` 表达式中的子表达式结果值存\n在相等的情况，不论这些结果值相等的子表达式，是否存在于不同的 `case` 表达式中，都会是这样的结果。\n\n**普通 `case` 子句的编写顺序很重要，最上边的 `case` 子句中的子表达式总是会被最先求值，在判等的时候顺序也是这样**。因此，\n如果某些子表达式的结果值有重复并且它们与 `switch` 表达式的结果值相等，那么位置靠上的 `case` 子句总会被选中。\n\n## select\n`select` 类似于用于通信的 `switch` 语句。每个 `case` 必须是一个通信操作，要么是发送要么是接收。\n\n当条件满足时，`select` 会去通信并执行 `case` 之后的语句，这时候其它通信是不会执行的。\n如果多个 `case` 同时满足条件，`select` 会随机地选择一个执行。如果没有 `case` 可运行，它将阻塞，直到有 `case` 可运行。\n\n一个默认的子句应该总是可运行的。\n\n```go\nselect {\n  case communication clause:\n      ...     \n  case communication clause:\n      ... \n  default: /* 可选 */\n\t\t\t... \n}\t\t\t\n```\n\n## for\n```go\nfor init; condition; post { }\n\n// 相当于  while (x < 5) { ... }\nfor x < 5 {\n  ...\n}\n\n// 相当于 while (true) { ... }\nfor {\n\t...\n}\n\nfor key, value := range oldMap { // 第二个循环变量可以忽略，但是第一个变量要忽略可以使用空标识符 _ 代替\n    newMap[key] = value\n}\n```\n`for range` 支持遍历数组，切片，字符串，字典，通道，并返回索引和键值。**`for range` 会复制目标数据。可改用数组指针或者切片**。\n`range` 关键字右边的位置上的代码被称为 `range` 表达式。\n1. **`range` 表达式只会在 `for` 语句开始执行时被求值一次，无论后边会有多少次迭代**；\n2. `range` 表达式的求值结果会被复制，也就是说，被迭代的对象是 `range` 表达式结果值的副本而不是原值。\n\n```go\nnumbers1 := []int{1, 2, 3, 4, 5, 6}\nfor i := range numbers1 {\n    if i == 3 {\n        numbers1[i] |= i\n    }\n}\nfmt.Println(numbers1)\n```\n打印的内容会是 `[1 2 3 7 5 6]`，为什么，首先 `i` 是切片的下标，当 `i` 的值等于 3 的时候，与之对应的是切片中的第 4 个元素\n值 4。对 4 和 3 进行按位或操作得到的结果是 7。\n\n当 `for` 语句被执行的时候，在 `range` 关键字右边的 `numbers1` 会先被求值。`range` 表达式的结果值可以是数组、数组的指针、\n切片、字符串、字典或者允许接收操作的通道中的某一个，并且结果值只能有一个。这里的 `numbers1` 是一个切片,那么迭代变量就可以\n有两个，右边的迭代变量代表当次迭代对应的某一个元素值，而左边的迭代变量则代表该元素值在切片中的索引值。\n循环控制语句：\n- `break`，用于中断当前 `for` 循环或跳出 `switch` 语句\n- `continue`，跳过当前循，继续进行下一轮循环。\n- `goto`，将控制转移到被标记的语句。通常与条件语句配合使用。可用来实现条件转移， 构成循环，跳出循环体等功能。不推荐\n使用，以免造成流程混乱。\n\n`goto` 实例：\n```go\nLOOP: for a < 20 {\n\tif a == 15 {\n\t\t\t/* 跳过迭代 */\n\t\t\ta = a + 1\n\t\t\tgoto LOOP\n\t}\n\tfmt.Printf(\"a的值为 : %d\\n\", a)\n\ta ++  \n}  \n```\n\n### 使用带有 `range` 子句的 `for` 语句遍历字符串值的时候应该注意\n带有 `range` 子句的 `for` 语句会先把被遍历的字符串值拆成一个**字节序列**（注意是字节序列），然后再试图找出这个字节序列中\n包含的每一个 UTF-8 编码值，或者说每一个 Unicode 字符。\n\n这样的 `for` 语句可以为两个迭代变量赋值。如果存在两个迭代变量，那么赋给第一个变量的值就将会是当前字节序列中的某个 UTF-8 编码\n值的第一个字节所对应的那个索引值。而赋给第二个变量的值则是这个 UTF-8 编码值代表的那个 Unicode 字符，其类型会是 `rune`。\n\n```go\nstr := \"Go 爱好者 \"\nfor i, c := range str {\n    fmt.Printf(\"%d: %q [% x]\\n\", i, c, []byte(string(c)))\n}\n```\n完整的打印内容如下：\n```bash\n0: 'G' [47]\n1: 'o' [6f]\n2: '爱' [e7 88 b1]\n5: '好' [e5 a5 bd]\n8: '者' [e8 80 85]\n```\n\n**注意了，'爱'是由三个字节共同表达的，所以第四个 Unicode 字符'好'对应的索引值并不是 3，而是 2 加 3 后得到的 5**。","source":"basic/flow.md","raw":"---\ntitle: 控制语句\n---\n# 控制语句\n## if\n```go\nif 布尔表达式 {\n   \n}\n```\n### if...else\n\n```go\nif 布尔表达式 {\n   \n} else {\n  \n}\n```\n\n## switch\n```go\nswitch var1 {\n    case val1:\n        ...  // 不需要显示的break，case 执行完会自动中断\n    case val2:\n\t\t\t\t...\n\t\tcase val3,val4,...:\t\t\n    default:\n        ...\n}\n```\n`val1`,`val2` ... 类型不被局限于常量或整数，但必须是相同的类型。\n\n`switch` 语句，你要明白其中的 `case` 表达式的所有子表达式的结果值都是要与 `switch` 表达式的结果值判等的，因此它们的类型必须相\n同或者能够都统一到 `switch` 表达式的结果类型。\n如果无法做到，那么这条 `switch` 语句就不能通过编译。\n\n**`switch`语句在 `case` 子句的选择上是具有唯一性的**。正因为如此，`switch` 语句不允许 `case` 表达式中的子表达式结果值存\n在相等的情况，不论这些结果值相等的子表达式，是否存在于不同的 `case` 表达式中，都会是这样的结果。\n\n**普通 `case` 子句的编写顺序很重要，最上边的 `case` 子句中的子表达式总是会被最先求值，在判等的时候顺序也是这样**。因此，\n如果某些子表达式的结果值有重复并且它们与 `switch` 表达式的结果值相等，那么位置靠上的 `case` 子句总会被选中。\n\n## select\n`select` 类似于用于通信的 `switch` 语句。每个 `case` 必须是一个通信操作，要么是发送要么是接收。\n\n当条件满足时，`select` 会去通信并执行 `case` 之后的语句，这时候其它通信是不会执行的。\n如果多个 `case` 同时满足条件，`select` 会随机地选择一个执行。如果没有 `case` 可运行，它将阻塞，直到有 `case` 可运行。\n\n一个默认的子句应该总是可运行的。\n\n```go\nselect {\n  case communication clause:\n      ...     \n  case communication clause:\n      ... \n  default: /* 可选 */\n\t\t\t... \n}\t\t\t\n```\n\n## for\n```go\nfor init; condition; post { }\n\n// 相当于  while (x < 5) { ... }\nfor x < 5 {\n  ...\n}\n\n// 相当于 while (true) { ... }\nfor {\n\t...\n}\n\nfor key, value := range oldMap { // 第二个循环变量可以忽略，但是第一个变量要忽略可以使用空标识符 _ 代替\n    newMap[key] = value\n}\n```\n`for range` 支持遍历数组，切片，字符串，字典，通道，并返回索引和键值。**`for range` 会复制目标数据。可改用数组指针或者切片**。\n`range` 关键字右边的位置上的代码被称为 `range` 表达式。\n1. **`range` 表达式只会在 `for` 语句开始执行时被求值一次，无论后边会有多少次迭代**；\n2. `range` 表达式的求值结果会被复制，也就是说，被迭代的对象是 `range` 表达式结果值的副本而不是原值。\n\n```go\nnumbers1 := []int{1, 2, 3, 4, 5, 6}\nfor i := range numbers1 {\n    if i == 3 {\n        numbers1[i] |= i\n    }\n}\nfmt.Println(numbers1)\n```\n打印的内容会是 `[1 2 3 7 5 6]`，为什么，首先 `i` 是切片的下标，当 `i` 的值等于 3 的时候，与之对应的是切片中的第 4 个元素\n值 4。对 4 和 3 进行按位或操作得到的结果是 7。\n\n当 `for` 语句被执行的时候，在 `range` 关键字右边的 `numbers1` 会先被求值。`range` 表达式的结果值可以是数组、数组的指针、\n切片、字符串、字典或者允许接收操作的通道中的某一个，并且结果值只能有一个。这里的 `numbers1` 是一个切片,那么迭代变量就可以\n有两个，右边的迭代变量代表当次迭代对应的某一个元素值，而左边的迭代变量则代表该元素值在切片中的索引值。\n循环控制语句：\n- `break`，用于中断当前 `for` 循环或跳出 `switch` 语句\n- `continue`，跳过当前循，继续进行下一轮循环。\n- `goto`，将控制转移到被标记的语句。通常与条件语句配合使用。可用来实现条件转移， 构成循环，跳出循环体等功能。不推荐\n使用，以免造成流程混乱。\n\n`goto` 实例：\n```go\nLOOP: for a < 20 {\n\tif a == 15 {\n\t\t\t/* 跳过迭代 */\n\t\t\ta = a + 1\n\t\t\tgoto LOOP\n\t}\n\tfmt.Printf(\"a的值为 : %d\\n\", a)\n\ta ++  \n}  \n```\n\n### 使用带有 `range` 子句的 `for` 语句遍历字符串值的时候应该注意\n带有 `range` 子句的 `for` 语句会先把被遍历的字符串值拆成一个**字节序列**（注意是字节序列），然后再试图找出这个字节序列中\n包含的每一个 UTF-8 编码值，或者说每一个 Unicode 字符。\n\n这样的 `for` 语句可以为两个迭代变量赋值。如果存在两个迭代变量，那么赋给第一个变量的值就将会是当前字节序列中的某个 UTF-8 编码\n值的第一个字节所对应的那个索引值。而赋给第二个变量的值则是这个 UTF-8 编码值代表的那个 Unicode 字符，其类型会是 `rune`。\n\n```go\nstr := \"Go 爱好者 \"\nfor i, c := range str {\n    fmt.Printf(\"%d: %q [% x]\\n\", i, c, []byte(string(c)))\n}\n```\n完整的打印内容如下：\n```bash\n0: 'G' [47]\n1: 'o' [6f]\n2: '爱' [e7 88 b1]\n5: '好' [e5 a5 bd]\n8: '者' [e8 80 85]\n```\n\n**注意了，'爱'是由三个字节共同表达的，所以第四个 Unicode 字符'好'对应的索引值并不是 3，而是 2 加 3 后得到的 5**。","date":"2019-08-24T04:24:00.898Z","updated":"2019-08-24T04:24:00.839Z","path":"basic/flow.html","comments":1,"layout":"page","_id":"ck1xm14ki000dfcw20m7mq8sj","content":"<h1 id=\"控制语句\"><a href=\"#控制语句\" class=\"headerlink\" title=\"控制语句\"></a>控制语句</h1><h2 id=\"if\"><a href=\"#if\" class=\"headerlink\" title=\"if\"></a>if</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> 布尔表达式 &#123;</span><br><span class=\"line\">   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"if…else\"><a href=\"#if…else\" class=\"headerlink\" title=\"if…else\"></a>if…else</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> 布尔表达式 &#123;</span><br><span class=\"line\">   </span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"switch\"><a href=\"#switch\" class=\"headerlink\" title=\"switch\"></a>switch</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">switch</span> var1 &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> val1:</span><br><span class=\"line\">        ...  <span class=\"comment\">// 不需要显示的break，case 执行完会自动中断</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> val2:</span><br><span class=\"line\">\t\t\t\t...</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> val3,val4,...:\t\t</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">        ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>val1</code>,<code>val2</code> … 类型不被局限于常量或整数，但必须是相同的类型。</p>\n<p><code>switch</code> 语句，你要明白其中的 <code>case</code> 表达式的所有子表达式的结果值都是要与 <code>switch</code> 表达式的结果值判等的，因此它们的类型必须相<br>同或者能够都统一到 <code>switch</code> 表达式的结果类型。<br>如果无法做到，那么这条 <code>switch</code> 语句就不能通过编译。</p>\n<p><strong><code>switch</code>语句在 <code>case</code> 子句的选择上是具有唯一性的</strong>。正因为如此，<code>switch</code> 语句不允许 <code>case</code> 表达式中的子表达式结果值存<br>在相等的情况，不论这些结果值相等的子表达式，是否存在于不同的 <code>case</code> 表达式中，都会是这样的结果。</p>\n<p><strong>普通 <code>case</code> 子句的编写顺序很重要，最上边的 <code>case</code> 子句中的子表达式总是会被最先求值，在判等的时候顺序也是这样</strong>。因此，<br>如果某些子表达式的结果值有重复并且它们与 <code>switch</code> 表达式的结果值相等，那么位置靠上的 <code>case</code> 子句总会被选中。</p>\n<h2 id=\"select\"><a href=\"#select\" class=\"headerlink\" title=\"select\"></a>select</h2><p><code>select</code> 类似于用于通信的 <code>switch</code> 语句。每个 <code>case</code> 必须是一个通信操作，要么是发送要么是接收。</p>\n<p>当条件满足时，<code>select</code> 会去通信并执行 <code>case</code> 之后的语句，这时候其它通信是不会执行的。<br>如果多个 <code>case</code> 同时满足条件，<code>select</code> 会随机地选择一个执行。如果没有 <code>case</code> 可运行，它将阻塞，直到有 <code>case</code> 可运行。</p>\n<p>一个默认的子句应该总是可运行的。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> communication clause:</span><br><span class=\"line\">      ...     </span><br><span class=\"line\">  <span class=\"keyword\">case</span> communication clause:</span><br><span class=\"line\">      ... </span><br><span class=\"line\">  <span class=\"keyword\">default</span>: <span class=\"comment\">/* 可选 */</span></span><br><span class=\"line\">\t\t\t... </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"for\"><a href=\"#for\" class=\"headerlink\" title=\"for\"></a>for</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> init; condition; post &#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 相当于  while (x &lt; 5) &#123; ... &#125;</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> x &lt; <span class=\"number\">5</span> &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 相当于 while (true) &#123; ... &#125;</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> key, value := <span class=\"keyword\">range</span> oldMap &#123; <span class=\"comment\">// 第二个循环变量可以忽略，但是第一个变量要忽略可以使用空标识符 _ 代替</span></span><br><span class=\"line\">    newMap[key] = value</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>for range</code> 支持遍历数组，切片，字符串，字典，通道，并返回索引和键值。<strong><code>for range</code> 会复制目标数据。可改用数组指针或者切片</strong>。<br><code>range</code> 关键字右边的位置上的代码被称为 <code>range</code> 表达式。</p>\n<ol>\n<li><strong><code>range</code> 表达式只会在 <code>for</code> 语句开始执行时被求值一次，无论后边会有多少次迭代</strong>；</li>\n<li><code>range</code> 表达式的求值结果会被复制，也就是说，被迭代的对象是 <code>range</code> 表达式结果值的副本而不是原值。</li>\n</ol>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">numbers1 := []<span class=\"keyword\">int</span>&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>&#125;</span><br><span class=\"line\"><span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> numbers1 &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> i == <span class=\"number\">3</span> &#123;</span><br><span class=\"line\">        numbers1[i] |= i</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fmt.Println(numbers1)</span><br></pre></td></tr></table></figure>\n<p>打印的内容会是 <code>[1 2 3 7 5 6]</code>，为什么，首先 <code>i</code> 是切片的下标，当 <code>i</code> 的值等于 3 的时候，与之对应的是切片中的第 4 个元素<br>值 4。对 4 和 3 进行按位或操作得到的结果是 7。</p>\n<p>当 <code>for</code> 语句被执行的时候，在 <code>range</code> 关键字右边的 <code>numbers1</code> 会先被求值。<code>range</code> 表达式的结果值可以是数组、数组的指针、<br>切片、字符串、字典或者允许接收操作的通道中的某一个，并且结果值只能有一个。这里的 <code>numbers1</code> 是一个切片,那么迭代变量就可以<br>有两个，右边的迭代变量代表当次迭代对应的某一个元素值，而左边的迭代变量则代表该元素值在切片中的索引值。<br>循环控制语句：</p>\n<ul>\n<li><code>break</code>，用于中断当前 <code>for</code> 循环或跳出 <code>switch</code> 语句</li>\n<li><code>continue</code>，跳过当前循，继续进行下一轮循环。</li>\n<li><code>goto</code>，将控制转移到被标记的语句。通常与条件语句配合使用。可用来实现条件转移， 构成循环，跳出循环体等功能。不推荐<br>使用，以免造成流程混乱。</li>\n</ul>\n<p><code>goto</code> 实例：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LOOP: <span class=\"keyword\">for</span> a &lt; <span class=\"number\">20</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> a == <span class=\"number\">15</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">/* 跳过迭代 */</span></span><br><span class=\"line\">\t\t\ta = a + <span class=\"number\">1</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">goto</span> LOOP</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"a的值为 : %d\\n\"</span>, a)</span><br><span class=\"line\">\ta ++  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"使用带有-range-子句的-for-语句遍历字符串值的时候应该注意\"><a href=\"#使用带有-range-子句的-for-语句遍历字符串值的时候应该注意\" class=\"headerlink\" title=\"使用带有 range 子句的 for 语句遍历字符串值的时候应该注意\"></a>使用带有 <code>range</code> 子句的 <code>for</code> 语句遍历字符串值的时候应该注意</h3><p>带有 <code>range</code> 子句的 <code>for</code> 语句会先把被遍历的字符串值拆成一个<strong>字节序列</strong>（注意是字节序列），然后再试图找出这个字节序列中<br>包含的每一个 UTF-8 编码值，或者说每一个 Unicode 字符。</p>\n<p>这样的 <code>for</code> 语句可以为两个迭代变量赋值。如果存在两个迭代变量，那么赋给第一个变量的值就将会是当前字节序列中的某个 UTF-8 编码<br>值的第一个字节所对应的那个索引值。而赋给第二个变量的值则是这个 UTF-8 编码值代表的那个 Unicode 字符，其类型会是 <code>rune</code>。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str := <span class=\"string\">\"Go 爱好者 \"</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i, c := <span class=\"keyword\">range</span> str &#123;</span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">\"%d: %q [% x]\\n\"</span>, i, c, []<span class=\"keyword\">byte</span>(<span class=\"keyword\">string</span>(c)))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>完整的打印内容如下：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0: <span class=\"string\">'G'</span> [47]</span><br><span class=\"line\">1: <span class=\"string\">'o'</span> [6f]</span><br><span class=\"line\">2: <span class=\"string\">'爱'</span> [e7 88 b1]</span><br><span class=\"line\">5: <span class=\"string\">'好'</span> [e5 a5 bd]</span><br><span class=\"line\">8: <span class=\"string\">'者'</span> [e8 80 85]</span><br></pre></td></tr></table></figure></p>\n<p><strong>注意了，’爱’是由三个字节共同表达的，所以第四个 Unicode 字符’好’对应的索引值并不是 3，而是 2 加 3 后得到的 5</strong>。</p>\n","site":{"data":{"navigation":{"logo":{"text":"Golang Learn","type":"link","path":"index.html"},"main":[{"text":"Golang 基础","type":"label"},{"text":"Go 环境配置","type":"link","path":"basic/env_config.html"},{"text":"包","type":"link","path":"basic/package.html"},{"text":"基础数据类型","type":"link","path":"basic/basic_data.html"},{"text":"变量","type":"link","path":"basic/var.html"},{"text":"常量","type":"link","path":"basic/constant.html"},{"text":"控制语句","type":"link","path":"basic/flow.html"},{"text":"运算符","type":"link","path":"basic/operator.html"},{"text":"作用域","type":"link","path":"basic/scope.html"},{"text":"指针","type":"link","path":"basic/pointer.html"},{"text":"数组","type":"link","path":"basic/array.html"},{"text":"切片","type":"link","path":"basic/slice.html"},{"text":"字典","type":"link","path":"basic/map.html"},{"text":"函数","type":"link","path":"basic/function.html"},{"text":"结构体","type":"link","path":"basic/struct.html"},{"text":"接口","type":"link","path":"basic/interface.html"},{"text":"面向对象","type":"link","path":"basic/oop.html"},{"text":"错误","type":"link","path":"basic/error.html"},{"text":"序列化","type":"link","path":"basic/json.html"},{"text":"反射","type":"link","path":"basic/reflect.html"},{"text":"测试","type":"link","path":"basic/test.html"},{"text":"并发编程","type":"label"},{"text":"goroutine","type":"link","path":"concurrent/goroutine.html"},{"text":"channel","type":"link","path":"concurrent/channel.html"},{"text":"同步和锁","type":"link","path":"concurrent/sync_lock.html"},{"text":"内存分配","type":"label"},{"text":"内存分配","type":"link","path":"advance/mm.html"},{"text":"垃圾回收","type":"label"},{"text":"垃圾回收","type":"link","path":"advance/gc.html"},{"text":"标准库","type":"label"},{"text":"fmt","type":"link","path":"standards/io/fmt.html"},{"text":"io","type":"link","path":"standards/io/io.html"},{"text":"ioutil","type":"link","path":"standards/io/ioutil.html"},{"text":"bufio","type":"link","path":"standards/io/bufio.html"},{"text":"os","type":"link","path":"standards/os/os.html"},{"text":"filepath","type":"link","path":"standards/os/filepath.html"},{"text":"strings","type":"link","path":"standards/text/strings.html"},{"text":"strconv","type":"link","path":"standards/text/strconv.html"},{"text":"unicode","type":"link","path":"standards/text/unicode.html"},{"text":"log","type":"link","path":"standards/log.html"},{"text":"time","type":"link","path":"standards/time.html"},{"text":"http","type":"link","path":"standards/net/http.html"},{"text":"math","type":"link","path":"standards/data/math.html"},{"text":"sort","type":"link","path":"standards/data/sort.html"},{"text":"big","type":"link","path":"standards/data/big.html"},{"text":"container","type":"link","path":"standards/data/container.html"},{"text":"sql","type":"link","path":"standards/database/sql.html"},{"text":"THEME","type":"label"},{"text":"使用文档主题","type":"link","path":"theme/theme-usage.html"},{"text":"SUPPORT AND FEEDBACK","type":"label"},{"text":"Raise an Issue on Github","type":"link","path":"https://github.com/shipengqi/golang-learn/issues/new"}]}}},"excerpt":"","more":"<h1 id=\"控制语句\"><a href=\"#控制语句\" class=\"headerlink\" title=\"控制语句\"></a>控制语句</h1><h2 id=\"if\"><a href=\"#if\" class=\"headerlink\" title=\"if\"></a>if</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> 布尔表达式 &#123;</span><br><span class=\"line\">   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"if…else\"><a href=\"#if…else\" class=\"headerlink\" title=\"if…else\"></a>if…else</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> 布尔表达式 &#123;</span><br><span class=\"line\">   </span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"switch\"><a href=\"#switch\" class=\"headerlink\" title=\"switch\"></a>switch</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">switch</span> var1 &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> val1:</span><br><span class=\"line\">        ...  <span class=\"comment\">// 不需要显示的break，case 执行完会自动中断</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> val2:</span><br><span class=\"line\">\t\t\t\t...</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> val3,val4,...:\t\t</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">        ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>val1</code>,<code>val2</code> … 类型不被局限于常量或整数，但必须是相同的类型。</p>\n<p><code>switch</code> 语句，你要明白其中的 <code>case</code> 表达式的所有子表达式的结果值都是要与 <code>switch</code> 表达式的结果值判等的，因此它们的类型必须相<br>同或者能够都统一到 <code>switch</code> 表达式的结果类型。<br>如果无法做到，那么这条 <code>switch</code> 语句就不能通过编译。</p>\n<p><strong><code>switch</code>语句在 <code>case</code> 子句的选择上是具有唯一性的</strong>。正因为如此，<code>switch</code> 语句不允许 <code>case</code> 表达式中的子表达式结果值存<br>在相等的情况，不论这些结果值相等的子表达式，是否存在于不同的 <code>case</code> 表达式中，都会是这样的结果。</p>\n<p><strong>普通 <code>case</code> 子句的编写顺序很重要，最上边的 <code>case</code> 子句中的子表达式总是会被最先求值，在判等的时候顺序也是这样</strong>。因此，<br>如果某些子表达式的结果值有重复并且它们与 <code>switch</code> 表达式的结果值相等，那么位置靠上的 <code>case</code> 子句总会被选中。</p>\n<h2 id=\"select\"><a href=\"#select\" class=\"headerlink\" title=\"select\"></a>select</h2><p><code>select</code> 类似于用于通信的 <code>switch</code> 语句。每个 <code>case</code> 必须是一个通信操作，要么是发送要么是接收。</p>\n<p>当条件满足时，<code>select</code> 会去通信并执行 <code>case</code> 之后的语句，这时候其它通信是不会执行的。<br>如果多个 <code>case</code> 同时满足条件，<code>select</code> 会随机地选择一个执行。如果没有 <code>case</code> 可运行，它将阻塞，直到有 <code>case</code> 可运行。</p>\n<p>一个默认的子句应该总是可运行的。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> communication clause:</span><br><span class=\"line\">      ...     </span><br><span class=\"line\">  <span class=\"keyword\">case</span> communication clause:</span><br><span class=\"line\">      ... </span><br><span class=\"line\">  <span class=\"keyword\">default</span>: <span class=\"comment\">/* 可选 */</span></span><br><span class=\"line\">\t\t\t... </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"for\"><a href=\"#for\" class=\"headerlink\" title=\"for\"></a>for</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> init; condition; post &#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 相当于  while (x &lt; 5) &#123; ... &#125;</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> x &lt; <span class=\"number\">5</span> &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 相当于 while (true) &#123; ... &#125;</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> key, value := <span class=\"keyword\">range</span> oldMap &#123; <span class=\"comment\">// 第二个循环变量可以忽略，但是第一个变量要忽略可以使用空标识符 _ 代替</span></span><br><span class=\"line\">    newMap[key] = value</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>for range</code> 支持遍历数组，切片，字符串，字典，通道，并返回索引和键值。<strong><code>for range</code> 会复制目标数据。可改用数组指针或者切片</strong>。<br><code>range</code> 关键字右边的位置上的代码被称为 <code>range</code> 表达式。</p>\n<ol>\n<li><strong><code>range</code> 表达式只会在 <code>for</code> 语句开始执行时被求值一次，无论后边会有多少次迭代</strong>；</li>\n<li><code>range</code> 表达式的求值结果会被复制，也就是说，被迭代的对象是 <code>range</code> 表达式结果值的副本而不是原值。</li>\n</ol>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">numbers1 := []<span class=\"keyword\">int</span>&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>&#125;</span><br><span class=\"line\"><span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> numbers1 &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> i == <span class=\"number\">3</span> &#123;</span><br><span class=\"line\">        numbers1[i] |= i</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fmt.Println(numbers1)</span><br></pre></td></tr></table></figure>\n<p>打印的内容会是 <code>[1 2 3 7 5 6]</code>，为什么，首先 <code>i</code> 是切片的下标，当 <code>i</code> 的值等于 3 的时候，与之对应的是切片中的第 4 个元素<br>值 4。对 4 和 3 进行按位或操作得到的结果是 7。</p>\n<p>当 <code>for</code> 语句被执行的时候，在 <code>range</code> 关键字右边的 <code>numbers1</code> 会先被求值。<code>range</code> 表达式的结果值可以是数组、数组的指针、<br>切片、字符串、字典或者允许接收操作的通道中的某一个，并且结果值只能有一个。这里的 <code>numbers1</code> 是一个切片,那么迭代变量就可以<br>有两个，右边的迭代变量代表当次迭代对应的某一个元素值，而左边的迭代变量则代表该元素值在切片中的索引值。<br>循环控制语句：</p>\n<ul>\n<li><code>break</code>，用于中断当前 <code>for</code> 循环或跳出 <code>switch</code> 语句</li>\n<li><code>continue</code>，跳过当前循，继续进行下一轮循环。</li>\n<li><code>goto</code>，将控制转移到被标记的语句。通常与条件语句配合使用。可用来实现条件转移， 构成循环，跳出循环体等功能。不推荐<br>使用，以免造成流程混乱。</li>\n</ul>\n<p><code>goto</code> 实例：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LOOP: <span class=\"keyword\">for</span> a &lt; <span class=\"number\">20</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> a == <span class=\"number\">15</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">/* 跳过迭代 */</span></span><br><span class=\"line\">\t\t\ta = a + <span class=\"number\">1</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">goto</span> LOOP</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"a的值为 : %d\\n\"</span>, a)</span><br><span class=\"line\">\ta ++  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"使用带有-range-子句的-for-语句遍历字符串值的时候应该注意\"><a href=\"#使用带有-range-子句的-for-语句遍历字符串值的时候应该注意\" class=\"headerlink\" title=\"使用带有 range 子句的 for 语句遍历字符串值的时候应该注意\"></a>使用带有 <code>range</code> 子句的 <code>for</code> 语句遍历字符串值的时候应该注意</h3><p>带有 <code>range</code> 子句的 <code>for</code> 语句会先把被遍历的字符串值拆成一个<strong>字节序列</strong>（注意是字节序列），然后再试图找出这个字节序列中<br>包含的每一个 UTF-8 编码值，或者说每一个 Unicode 字符。</p>\n<p>这样的 <code>for</code> 语句可以为两个迭代变量赋值。如果存在两个迭代变量，那么赋给第一个变量的值就将会是当前字节序列中的某个 UTF-8 编码<br>值的第一个字节所对应的那个索引值。而赋给第二个变量的值则是这个 UTF-8 编码值代表的那个 Unicode 字符，其类型会是 <code>rune</code>。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str := <span class=\"string\">\"Go 爱好者 \"</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i, c := <span class=\"keyword\">range</span> str &#123;</span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">\"%d: %q [% x]\\n\"</span>, i, c, []<span class=\"keyword\">byte</span>(<span class=\"keyword\">string</span>(c)))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>完整的打印内容如下：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0: <span class=\"string\">'G'</span> [47]</span><br><span class=\"line\">1: <span class=\"string\">'o'</span> [6f]</span><br><span class=\"line\">2: <span class=\"string\">'爱'</span> [e7 88 b1]</span><br><span class=\"line\">5: <span class=\"string\">'好'</span> [e5 a5 bd]</span><br><span class=\"line\">8: <span class=\"string\">'者'</span> [e8 80 85]</span><br></pre></td></tr></table></figure></p>\n<p><strong>注意了，’爱’是由三个字节共同表达的，所以第四个 Unicode 字符’好’对应的索引值并不是 3，而是 2 加 3 后得到的 5</strong>。</p>\n"},{"title":"面向对象","_content":"\n# 面向对象\nGO 支持面向对象编程。\n\n## 方法\n\n方法声明：\n```go\nfunc (变量名 类型) 方法名() [返回类型]{\n   /* 函数体*/\n}\n```\n实例：\n```go\n/* 定义结构体 */\ntype Circle struct {\n  radius float64\n}\n\nfunc main() {\n  var c1 Circle\n  c1.radius = 10.00\n  fmt.Println(\"Area of Circle(c1) = \", c1.getArea())\n}\n\n// 该 method 属于 Circle 类型对象中的方法\n// 这里的 c 叫作方法的接收器，类似 Javascript 的 this\nfunc (c Circle) getArea() float64 {\n  // c.radius 即为 Circle 类型对象中的属性\n  return 3.14 * c.radius * c.radius\n}\n```\n\nGo 没有像其它语言那样用 `this` 或者 `self` 作为接收器。**Go 可以给任意类型定义方法**。\n\n```go\nfunc (p *Point) ScaleBy(factor float64) {\n\tp.X *= factor\n\tp.Y *= factor\n}\n```\n调用指针类型方法`(*Point).ScaleBy`，`()`必须有，否则会被理解为`*(Point.ScaleBy)`。\n```go\n// 调用指针类型方法\nr := &Point{1, 2}\nr.ScaleBy(2)\n\n// 简短写法\np := Point{1, 2}\n\n// 编译器会隐式地帮我们用&p去调用ScaleBy这个方法。这种简写方法只适用于“变量”\np.ScaleBy(2)\n```\n\n只有类型(`Point`)和指向他们的指针(`*Point`)，才是可能会出现在接收器声明里的两种接收器。此外，为了避免歧义，在声明方法时，\n如果一个类型名本身是一个指针的话，是不允许其出现在接收器中的:\n```go\ntype P *int\nfunc (P) f() { /* ... */ } // compile error: invalid receiver type\n```\n\n### 如何选择 receiver 的类型\n1. **不管你的 `method` 的 `receiver` 是指针类型还是非指针类型，都是可以通过指针/非指针类型进行调用的，编译器会帮你做类型转换**。\n2. 在声明一个 `method` 的 `receiver` 该是指针还是非指针类型时，你需要考虑：\n  - 要修改实例状态，用 `*T`，无需修改使用 `T`。\n  - 大对象建议使用 `*T`，减少复制成本，`T` 调用时会产生一次拷贝。\n  - 对于引用类型，直接使用 `T`，因为它们本身就是指针包装的。\n  - 包含 `Mutex` 等同步字段，使用 `*T`，避免因为复制造成锁操作无效。\n  - 无法确定时，使用 `*T`。\n\n**方法的接收者类型必须是某个自定义的数据类型，而且不能是接口类型或接口的指针类型**。\n- 值方法，就是接收者类型是非指针的自定义数据类型的方法。\n- 指针方法，就是接收者类型是指针类型的方法。\n\n## 嵌入结构体扩展类型\n```go\nimport \"image/color\"\n\ntype Point struct{ X, Y float64 }\n\ntype ColoredPoint struct {\n  Point\n  Color color.RGBA\n}\n\nred := color.RGBA{255, 0, 0, 255}\nblue := color.RGBA{0, 0, 255, 255}\nvar p = ColoredPoint{Point{1, 1}, red}\nvar q = ColoredPoint{Point{5, 4}, blue}\nfmt.Println(p.Distance(q.Point)) // \"5\"\np.ScaleBy(2)\nq.ScaleBy(2)\nfmt.Println(p.Distance(q.Point)) // \"10\"\n```\n\n如果对基于类来实现面向对象的语言比较熟悉的话，可能会倾向于将 `Point` 看作一个基类，而 `ColoredPoint` 看作其子类或者继承类。\n但这是错误的理解。请注意上面例子中对 `Distance` 方法的调用。`Distance` 有一个参数是 `Point` 类型，但是这里的 `q` 虽然貌\n似是继承了`Point` 类，但 `q` 并不是，所以尽管 `q` 有着 `Point` 这个内嵌类型，我们也必须要显式传入 `q.Point`。\n\n### Go 语言是用嵌入字段实现了继承吗\nGo 语言中**没有继承的概念，它所做的是通过嵌入字段的方式实现了类型之间的组合**。\n具体原因和理念请见 [Why is there no type inheritance?](https://golang.org/doc/faq#inheritance)。\n\n简单来说，面向对象编程中的继承，其实是通过牺牲一定的代码简洁性来换取可扩展性，而且这种可扩展性是通过侵入的方式来实现的。\n类型之间的组合采用的是非声明的方式，我们不需要显式地声明某个类型实现了某个接口，或者一个类型继承了另一个类型。\n\n同时，类型组合也是非侵入式的，它不会破坏类型的封装或加重类型之间的耦合。我们要做的只是把类型当做字段嵌入进来，然后坐\n享其成地使用嵌入字段所拥有的一切。如果嵌入字段有哪里不合心意，我们还可以用“包装”或“屏蔽”的方式去调整和优化。\n\n另外，类型间的组合也是灵活的，我们总是可以通过嵌入字段的方式把一个类型的属性和能力“嫁接”给另一个类型。\n\n这时候，被嵌入类型也就自然而然地实现了嵌入字段所实现的接口。再者，组合要比继承更加简洁和清晰，Go 语言可以轻而易举地通过嵌入\n多个字段来实现功能强大的类型，却不会有多重继承那样复杂的层次结构和可观的管理成本。\n\n## 封装\n一个对象的变量或者方法如果对调用方是不可见的话，一般就被定义为“封装”。通过首字母大小写来定义是否从包中导出。\n封装一个对象，必须定义为一个 `struct`：\n```go\ntype IntSet struct {\n  words []uint64\n}\n```\n\n优点：\n- 调用方不能直接修改对象的变量值\n- 隐藏实现的细节，防止调用方依赖那些可能变化的具体实现，这样使设计包的程序员在不破坏对外的api情况下能得到更大的自由。\n- 阻止了外部调用方对对象内部的值任意地进行修改。\n\n## `String` 方法\n在 Go 语言中，**我们可以通过为一个类型编写名为 `String` 的方法，来自定义该类型的字符串表示形式。这个 `String` 方法不需\n要任何参数声明，但需要有一个 `string` 类型的结果声明**。\n```go\ntype AnimalCategory struct {\n    kingdom string // 界。\n    phylum string // 门。\n    class  string // 纲。\n    order  string // 目。\n    family string // 科。\n    genus  string // 属。\n    species string // 种。\n}\n\nfunc (ac AnimalCategory) String() string {\n    return fmt.Sprintf(\"%s%s%s%s%s%s%s\",ac.kingdom, ac.phylum, ac.class, ac.order,ac.family, ac.genus, ac.species)\n}\n\ncategory := AnimalCategory{species: \"cat\"}\nfmt.Printf(\"The animal category: %s\\n\", category)\n\n```\n正因为如此，我在调用 `fmt.Printf` 函数时，使用占位符 `%s` 和 `category` 值本身就可以打印出后者的字符串表示形式，\n而**无需显式地调用它的 `String` 方法**。\n\n`fmt.Printf` 函数会自己去寻找它。此时的打印内容会是 `The animal category: cat`。显而易见，`category` 的 `String` 方法成\n功地引用了当前值的所有字段。\n\n当你广泛使用一个自定义类型时，最好为它定义 `String()` 方法。\n\n**不要在 `String()` 方法里面调用涉及 `String()` 方法的方法，它会导致意料之外的错误**，比如：\n```go\ntype TT float64\n\nfunc (t TT) String() string {\n    return fmt.Sprintf(\"%v\", t)\n}\nt.String()\n```\n\n它导致了一个无限递归调用（`TT.String()` 调用 `fmt.Sprintf`，而 `fmt.Sprintf` 又会反过来调用 `TT.String()`...），很快就会导\n致内存溢出。","source":"basic/oop.md","raw":"---\ntitle: 面向对象\n---\n\n# 面向对象\nGO 支持面向对象编程。\n\n## 方法\n\n方法声明：\n```go\nfunc (变量名 类型) 方法名() [返回类型]{\n   /* 函数体*/\n}\n```\n实例：\n```go\n/* 定义结构体 */\ntype Circle struct {\n  radius float64\n}\n\nfunc main() {\n  var c1 Circle\n  c1.radius = 10.00\n  fmt.Println(\"Area of Circle(c1) = \", c1.getArea())\n}\n\n// 该 method 属于 Circle 类型对象中的方法\n// 这里的 c 叫作方法的接收器，类似 Javascript 的 this\nfunc (c Circle) getArea() float64 {\n  // c.radius 即为 Circle 类型对象中的属性\n  return 3.14 * c.radius * c.radius\n}\n```\n\nGo 没有像其它语言那样用 `this` 或者 `self` 作为接收器。**Go 可以给任意类型定义方法**。\n\n```go\nfunc (p *Point) ScaleBy(factor float64) {\n\tp.X *= factor\n\tp.Y *= factor\n}\n```\n调用指针类型方法`(*Point).ScaleBy`，`()`必须有，否则会被理解为`*(Point.ScaleBy)`。\n```go\n// 调用指针类型方法\nr := &Point{1, 2}\nr.ScaleBy(2)\n\n// 简短写法\np := Point{1, 2}\n\n// 编译器会隐式地帮我们用&p去调用ScaleBy这个方法。这种简写方法只适用于“变量”\np.ScaleBy(2)\n```\n\n只有类型(`Point`)和指向他们的指针(`*Point`)，才是可能会出现在接收器声明里的两种接收器。此外，为了避免歧义，在声明方法时，\n如果一个类型名本身是一个指针的话，是不允许其出现在接收器中的:\n```go\ntype P *int\nfunc (P) f() { /* ... */ } // compile error: invalid receiver type\n```\n\n### 如何选择 receiver 的类型\n1. **不管你的 `method` 的 `receiver` 是指针类型还是非指针类型，都是可以通过指针/非指针类型进行调用的，编译器会帮你做类型转换**。\n2. 在声明一个 `method` 的 `receiver` 该是指针还是非指针类型时，你需要考虑：\n  - 要修改实例状态，用 `*T`，无需修改使用 `T`。\n  - 大对象建议使用 `*T`，减少复制成本，`T` 调用时会产生一次拷贝。\n  - 对于引用类型，直接使用 `T`，因为它们本身就是指针包装的。\n  - 包含 `Mutex` 等同步字段，使用 `*T`，避免因为复制造成锁操作无效。\n  - 无法确定时，使用 `*T`。\n\n**方法的接收者类型必须是某个自定义的数据类型，而且不能是接口类型或接口的指针类型**。\n- 值方法，就是接收者类型是非指针的自定义数据类型的方法。\n- 指针方法，就是接收者类型是指针类型的方法。\n\n## 嵌入结构体扩展类型\n```go\nimport \"image/color\"\n\ntype Point struct{ X, Y float64 }\n\ntype ColoredPoint struct {\n  Point\n  Color color.RGBA\n}\n\nred := color.RGBA{255, 0, 0, 255}\nblue := color.RGBA{0, 0, 255, 255}\nvar p = ColoredPoint{Point{1, 1}, red}\nvar q = ColoredPoint{Point{5, 4}, blue}\nfmt.Println(p.Distance(q.Point)) // \"5\"\np.ScaleBy(2)\nq.ScaleBy(2)\nfmt.Println(p.Distance(q.Point)) // \"10\"\n```\n\n如果对基于类来实现面向对象的语言比较熟悉的话，可能会倾向于将 `Point` 看作一个基类，而 `ColoredPoint` 看作其子类或者继承类。\n但这是错误的理解。请注意上面例子中对 `Distance` 方法的调用。`Distance` 有一个参数是 `Point` 类型，但是这里的 `q` 虽然貌\n似是继承了`Point` 类，但 `q` 并不是，所以尽管 `q` 有着 `Point` 这个内嵌类型，我们也必须要显式传入 `q.Point`。\n\n### Go 语言是用嵌入字段实现了继承吗\nGo 语言中**没有继承的概念，它所做的是通过嵌入字段的方式实现了类型之间的组合**。\n具体原因和理念请见 [Why is there no type inheritance?](https://golang.org/doc/faq#inheritance)。\n\n简单来说，面向对象编程中的继承，其实是通过牺牲一定的代码简洁性来换取可扩展性，而且这种可扩展性是通过侵入的方式来实现的。\n类型之间的组合采用的是非声明的方式，我们不需要显式地声明某个类型实现了某个接口，或者一个类型继承了另一个类型。\n\n同时，类型组合也是非侵入式的，它不会破坏类型的封装或加重类型之间的耦合。我们要做的只是把类型当做字段嵌入进来，然后坐\n享其成地使用嵌入字段所拥有的一切。如果嵌入字段有哪里不合心意，我们还可以用“包装”或“屏蔽”的方式去调整和优化。\n\n另外，类型间的组合也是灵活的，我们总是可以通过嵌入字段的方式把一个类型的属性和能力“嫁接”给另一个类型。\n\n这时候，被嵌入类型也就自然而然地实现了嵌入字段所实现的接口。再者，组合要比继承更加简洁和清晰，Go 语言可以轻而易举地通过嵌入\n多个字段来实现功能强大的类型，却不会有多重继承那样复杂的层次结构和可观的管理成本。\n\n## 封装\n一个对象的变量或者方法如果对调用方是不可见的话，一般就被定义为“封装”。通过首字母大小写来定义是否从包中导出。\n封装一个对象，必须定义为一个 `struct`：\n```go\ntype IntSet struct {\n  words []uint64\n}\n```\n\n优点：\n- 调用方不能直接修改对象的变量值\n- 隐藏实现的细节，防止调用方依赖那些可能变化的具体实现，这样使设计包的程序员在不破坏对外的api情况下能得到更大的自由。\n- 阻止了外部调用方对对象内部的值任意地进行修改。\n\n## `String` 方法\n在 Go 语言中，**我们可以通过为一个类型编写名为 `String` 的方法，来自定义该类型的字符串表示形式。这个 `String` 方法不需\n要任何参数声明，但需要有一个 `string` 类型的结果声明**。\n```go\ntype AnimalCategory struct {\n    kingdom string // 界。\n    phylum string // 门。\n    class  string // 纲。\n    order  string // 目。\n    family string // 科。\n    genus  string // 属。\n    species string // 种。\n}\n\nfunc (ac AnimalCategory) String() string {\n    return fmt.Sprintf(\"%s%s%s%s%s%s%s\",ac.kingdom, ac.phylum, ac.class, ac.order,ac.family, ac.genus, ac.species)\n}\n\ncategory := AnimalCategory{species: \"cat\"}\nfmt.Printf(\"The animal category: %s\\n\", category)\n\n```\n正因为如此，我在调用 `fmt.Printf` 函数时，使用占位符 `%s` 和 `category` 值本身就可以打印出后者的字符串表示形式，\n而**无需显式地调用它的 `String` 方法**。\n\n`fmt.Printf` 函数会自己去寻找它。此时的打印内容会是 `The animal category: cat`。显而易见，`category` 的 `String` 方法成\n功地引用了当前值的所有字段。\n\n当你广泛使用一个自定义类型时，最好为它定义 `String()` 方法。\n\n**不要在 `String()` 方法里面调用涉及 `String()` 方法的方法，它会导致意料之外的错误**，比如：\n```go\ntype TT float64\n\nfunc (t TT) String() string {\n    return fmt.Sprintf(\"%v\", t)\n}\nt.String()\n```\n\n它导致了一个无限递归调用（`TT.String()` 调用 `fmt.Sprintf`，而 `fmt.Sprintf` 又会反过来调用 `TT.String()`...），很快就会导\n致内存溢出。","date":"2019-10-19T13:40:15.170Z","updated":"2019-10-19T13:40:15.170Z","path":"basic/oop.html","comments":1,"layout":"page","_id":"ck1xm14ki000efcw2dtttiube","content":"<h1 id=\"面向对象\"><a href=\"#面向对象\" class=\"headerlink\" title=\"面向对象\"></a>面向对象</h1><p>GO 支持面向对象编程。</p>\n<h2 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h2><p>方法声明：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(变量名 类型)</span> 方法名<span class=\"params\">()</span> [返回类型]</span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">/* 函数体*/</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>实例：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 定义结构体 */</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Circle <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  radius <span class=\"keyword\">float64</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> c1 Circle</span><br><span class=\"line\">  c1.radius = <span class=\"number\">10.00</span></span><br><span class=\"line\">  fmt.Println(<span class=\"string\">\"Area of Circle(c1) = \"</span>, c1.getArea())</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 该 method 属于 Circle 类型对象中的方法</span></span><br><span class=\"line\"><span class=\"comment\">// 这里的 c 叫作方法的接收器，类似 Javascript 的 this</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c Circle)</span> <span class=\"title\">getArea</span><span class=\"params\">()</span> <span class=\"title\">float64</span></span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// c.radius 即为 Circle 类型对象中的属性</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">3.14</span> * c.radius * c.radius</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>Go 没有像其它语言那样用 <code>this</code> 或者 <code>self</code> 作为接收器。<strong>Go 可以给任意类型定义方法</strong>。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p *Point)</span> <span class=\"title\">ScaleBy</span><span class=\"params\">(factor <span class=\"keyword\">float64</span>)</span></span> &#123;</span><br><span class=\"line\">\tp.X *= factor</span><br><span class=\"line\">\tp.Y *= factor</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>调用指针类型方法<code>(*Point).ScaleBy</code>，<code>()</code>必须有，否则会被理解为<code>*(Point.ScaleBy)</code>。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 调用指针类型方法</span></span><br><span class=\"line\">r := &amp;Point&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>&#125;</span><br><span class=\"line\">r.ScaleBy(<span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 简短写法</span></span><br><span class=\"line\">p := Point&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 编译器会隐式地帮我们用&amp;p去调用ScaleBy这个方法。这种简写方法只适用于“变量”</span></span><br><span class=\"line\">p.ScaleBy(<span class=\"number\">2</span>)</span><br></pre></td></tr></table></figure></p>\n<p>只有类型(<code>Point</code>)和指向他们的指针(<code>*Point</code>)，才是可能会出现在接收器声明里的两种接收器。此外，为了避免歧义，在声明方法时，<br>如果一个类型名本身是一个指针的话，是不允许其出现在接收器中的:<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> P *<span class=\"keyword\">int</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(P)</span> <span class=\"title\">f</span><span class=\"params\">()</span></span> &#123; <span class=\"comment\">/* ... */</span> &#125; <span class=\"comment\">// compile error: invalid receiver type</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"如何选择-receiver-的类型\"><a href=\"#如何选择-receiver-的类型\" class=\"headerlink\" title=\"如何选择 receiver 的类型\"></a>如何选择 receiver 的类型</h3><ol>\n<li><strong>不管你的 <code>method</code> 的 <code>receiver</code> 是指针类型还是非指针类型，都是可以通过指针/非指针类型进行调用的，编译器会帮你做类型转换</strong>。</li>\n<li>在声明一个 <code>method</code> 的 <code>receiver</code> 该是指针还是非指针类型时，你需要考虑：<ul>\n<li>要修改实例状态，用 <code>*T</code>，无需修改使用 <code>T</code>。</li>\n<li>大对象建议使用 <code>*T</code>，减少复制成本，<code>T</code> 调用时会产生一次拷贝。</li>\n<li>对于引用类型，直接使用 <code>T</code>，因为它们本身就是指针包装的。</li>\n<li>包含 <code>Mutex</code> 等同步字段，使用 <code>*T</code>，避免因为复制造成锁操作无效。</li>\n<li>无法确定时，使用 <code>*T</code>。</li>\n</ul>\n</li>\n</ol>\n<p><strong>方法的接收者类型必须是某个自定义的数据类型，而且不能是接口类型或接口的指针类型</strong>。</p>\n<ul>\n<li>值方法，就是接收者类型是非指针的自定义数据类型的方法。</li>\n<li>指针方法，就是接收者类型是指针类型的方法。</li>\n</ul>\n<h2 id=\"嵌入结构体扩展类型\"><a href=\"#嵌入结构体扩展类型\" class=\"headerlink\" title=\"嵌入结构体扩展类型\"></a>嵌入结构体扩展类型</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"image/color\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Point <span class=\"keyword\">struct</span>&#123; X, Y <span class=\"keyword\">float64</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> ColoredPoint <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  Point</span><br><span class=\"line\">  Color color.RGBA</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">red := color.RGBA&#123;<span class=\"number\">255</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">255</span>&#125;</span><br><span class=\"line\">blue := color.RGBA&#123;<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">255</span>, <span class=\"number\">255</span>&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> p = ColoredPoint&#123;Point&#123;<span class=\"number\">1</span>, <span class=\"number\">1</span>&#125;, red&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> q = ColoredPoint&#123;Point&#123;<span class=\"number\">5</span>, <span class=\"number\">4</span>&#125;, blue&#125;</span><br><span class=\"line\">fmt.Println(p.Distance(q.Point)) <span class=\"comment\">// \"5\"</span></span><br><span class=\"line\">p.ScaleBy(<span class=\"number\">2</span>)</span><br><span class=\"line\">q.ScaleBy(<span class=\"number\">2</span>)</span><br><span class=\"line\">fmt.Println(p.Distance(q.Point)) <span class=\"comment\">// \"10\"</span></span><br></pre></td></tr></table></figure>\n<p>如果对基于类来实现面向对象的语言比较熟悉的话，可能会倾向于将 <code>Point</code> 看作一个基类，而 <code>ColoredPoint</code> 看作其子类或者继承类。<br>但这是错误的理解。请注意上面例子中对 <code>Distance</code> 方法的调用。<code>Distance</code> 有一个参数是 <code>Point</code> 类型，但是这里的 <code>q</code> 虽然貌<br>似是继承了<code>Point</code> 类，但 <code>q</code> 并不是，所以尽管 <code>q</code> 有着 <code>Point</code> 这个内嵌类型，我们也必须要显式传入 <code>q.Point</code>。</p>\n<h3 id=\"Go-语言是用嵌入字段实现了继承吗\"><a href=\"#Go-语言是用嵌入字段实现了继承吗\" class=\"headerlink\" title=\"Go 语言是用嵌入字段实现了继承吗\"></a>Go 语言是用嵌入字段实现了继承吗</h3><p>Go 语言中<strong>没有继承的概念，它所做的是通过嵌入字段的方式实现了类型之间的组合</strong>。<br>具体原因和理念请见 <a href=\"https://golang.org/doc/faq#inheritance\" target=\"_blank\" rel=\"noopener\">Why is there no type inheritance?</a>。</p>\n<p>简单来说，面向对象编程中的继承，其实是通过牺牲一定的代码简洁性来换取可扩展性，而且这种可扩展性是通过侵入的方式来实现的。<br>类型之间的组合采用的是非声明的方式，我们不需要显式地声明某个类型实现了某个接口，或者一个类型继承了另一个类型。</p>\n<p>同时，类型组合也是非侵入式的，它不会破坏类型的封装或加重类型之间的耦合。我们要做的只是把类型当做字段嵌入进来，然后坐<br>享其成地使用嵌入字段所拥有的一切。如果嵌入字段有哪里不合心意，我们还可以用“包装”或“屏蔽”的方式去调整和优化。</p>\n<p>另外，类型间的组合也是灵活的，我们总是可以通过嵌入字段的方式把一个类型的属性和能力“嫁接”给另一个类型。</p>\n<p>这时候，被嵌入类型也就自然而然地实现了嵌入字段所实现的接口。再者，组合要比继承更加简洁和清晰，Go 语言可以轻而易举地通过嵌入<br>多个字段来实现功能强大的类型，却不会有多重继承那样复杂的层次结构和可观的管理成本。</p>\n<h2 id=\"封装\"><a href=\"#封装\" class=\"headerlink\" title=\"封装\"></a>封装</h2><p>一个对象的变量或者方法如果对调用方是不可见的话，一般就被定义为“封装”。通过首字母大小写来定义是否从包中导出。<br>封装一个对象，必须定义为一个 <code>struct</code>：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> IntSet <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  words []<span class=\"keyword\">uint64</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>优点：</p>\n<ul>\n<li>调用方不能直接修改对象的变量值</li>\n<li>隐藏实现的细节，防止调用方依赖那些可能变化的具体实现，这样使设计包的程序员在不破坏对外的api情况下能得到更大的自由。</li>\n<li>阻止了外部调用方对对象内部的值任意地进行修改。</li>\n</ul>\n<h2 id=\"String-方法\"><a href=\"#String-方法\" class=\"headerlink\" title=\"String 方法\"></a><code>String</code> 方法</h2><p>在 Go 语言中，<strong>我们可以通过为一个类型编写名为 <code>String</code> 的方法，来自定义该类型的字符串表示形式。这个 <code>String</code> 方法不需<br>要任何参数声明，但需要有一个 <code>string</code> 类型的结果声明</strong>。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> AnimalCategory <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    kingdom <span class=\"keyword\">string</span> <span class=\"comment\">// 界。</span></span><br><span class=\"line\">    phylum <span class=\"keyword\">string</span> <span class=\"comment\">// 门。</span></span><br><span class=\"line\">    class  <span class=\"keyword\">string</span> <span class=\"comment\">// 纲。</span></span><br><span class=\"line\">    order  <span class=\"keyword\">string</span> <span class=\"comment\">// 目。</span></span><br><span class=\"line\">    family <span class=\"keyword\">string</span> <span class=\"comment\">// 科。</span></span><br><span class=\"line\">    genus  <span class=\"keyword\">string</span> <span class=\"comment\">// 属。</span></span><br><span class=\"line\">    species <span class=\"keyword\">string</span> <span class=\"comment\">// 种。</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(ac AnimalCategory)</span> <span class=\"title\">String</span><span class=\"params\">()</span> <span class=\"title\">string</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fmt.Sprintf(<span class=\"string\">\"%s%s%s%s%s%s%s\"</span>,ac.kingdom, ac.phylum, ac.class, ac.order,ac.family, ac.genus, ac.species)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">category := AnimalCategory&#123;species: <span class=\"string\">\"cat\"</span>&#125;</span><br><span class=\"line\">fmt.Printf(<span class=\"string\">\"The animal category: %s\\n\"</span>, category)</span><br></pre></td></tr></table></figure></p>\n<p>正因为如此，我在调用 <code>fmt.Printf</code> 函数时，使用占位符 <code>%s</code> 和 <code>category</code> 值本身就可以打印出后者的字符串表示形式，<br>而<strong>无需显式地调用它的 <code>String</code> 方法</strong>。</p>\n<p><code>fmt.Printf</code> 函数会自己去寻找它。此时的打印内容会是 <code>The animal category: cat</code>。显而易见，<code>category</code> 的 <code>String</code> 方法成<br>功地引用了当前值的所有字段。</p>\n<p>当你广泛使用一个自定义类型时，最好为它定义 <code>String()</code> 方法。</p>\n<p><strong>不要在 <code>String()</code> 方法里面调用涉及 <code>String()</code> 方法的方法，它会导致意料之外的错误</strong>，比如：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> TT <span class=\"keyword\">float64</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(t TT)</span> <span class=\"title\">String</span><span class=\"params\">()</span> <span class=\"title\">string</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fmt.Sprintf(<span class=\"string\">\"%v\"</span>, t)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">t.String()</span><br></pre></td></tr></table></figure></p>\n<p>它导致了一个无限递归调用（<code>TT.String()</code> 调用 <code>fmt.Sprintf</code>，而 <code>fmt.Sprintf</code> 又会反过来调用 <code>TT.String()</code>…），很快就会导<br>致内存溢出。</p>\n","site":{"data":{"navigation":{"logo":{"text":"Golang Learn","type":"link","path":"index.html"},"main":[{"text":"Golang 基础","type":"label"},{"text":"Go 环境配置","type":"link","path":"basic/env_config.html"},{"text":"包","type":"link","path":"basic/package.html"},{"text":"基础数据类型","type":"link","path":"basic/basic_data.html"},{"text":"变量","type":"link","path":"basic/var.html"},{"text":"常量","type":"link","path":"basic/constant.html"},{"text":"控制语句","type":"link","path":"basic/flow.html"},{"text":"运算符","type":"link","path":"basic/operator.html"},{"text":"作用域","type":"link","path":"basic/scope.html"},{"text":"指针","type":"link","path":"basic/pointer.html"},{"text":"数组","type":"link","path":"basic/array.html"},{"text":"切片","type":"link","path":"basic/slice.html"},{"text":"字典","type":"link","path":"basic/map.html"},{"text":"函数","type":"link","path":"basic/function.html"},{"text":"结构体","type":"link","path":"basic/struct.html"},{"text":"接口","type":"link","path":"basic/interface.html"},{"text":"面向对象","type":"link","path":"basic/oop.html"},{"text":"错误","type":"link","path":"basic/error.html"},{"text":"序列化","type":"link","path":"basic/json.html"},{"text":"反射","type":"link","path":"basic/reflect.html"},{"text":"测试","type":"link","path":"basic/test.html"},{"text":"并发编程","type":"label"},{"text":"goroutine","type":"link","path":"concurrent/goroutine.html"},{"text":"channel","type":"link","path":"concurrent/channel.html"},{"text":"同步和锁","type":"link","path":"concurrent/sync_lock.html"},{"text":"内存分配","type":"label"},{"text":"内存分配","type":"link","path":"advance/mm.html"},{"text":"垃圾回收","type":"label"},{"text":"垃圾回收","type":"link","path":"advance/gc.html"},{"text":"标准库","type":"label"},{"text":"fmt","type":"link","path":"standards/io/fmt.html"},{"text":"io","type":"link","path":"standards/io/io.html"},{"text":"ioutil","type":"link","path":"standards/io/ioutil.html"},{"text":"bufio","type":"link","path":"standards/io/bufio.html"},{"text":"os","type":"link","path":"standards/os/os.html"},{"text":"filepath","type":"link","path":"standards/os/filepath.html"},{"text":"strings","type":"link","path":"standards/text/strings.html"},{"text":"strconv","type":"link","path":"standards/text/strconv.html"},{"text":"unicode","type":"link","path":"standards/text/unicode.html"},{"text":"log","type":"link","path":"standards/log.html"},{"text":"time","type":"link","path":"standards/time.html"},{"text":"http","type":"link","path":"standards/net/http.html"},{"text":"math","type":"link","path":"standards/data/math.html"},{"text":"sort","type":"link","path":"standards/data/sort.html"},{"text":"big","type":"link","path":"standards/data/big.html"},{"text":"container","type":"link","path":"standards/data/container.html"},{"text":"sql","type":"link","path":"standards/database/sql.html"},{"text":"THEME","type":"label"},{"text":"使用文档主题","type":"link","path":"theme/theme-usage.html"},{"text":"SUPPORT AND FEEDBACK","type":"label"},{"text":"Raise an Issue on Github","type":"link","path":"https://github.com/shipengqi/golang-learn/issues/new"}]}}},"excerpt":"","more":"<h1 id=\"面向对象\"><a href=\"#面向对象\" class=\"headerlink\" title=\"面向对象\"></a>面向对象</h1><p>GO 支持面向对象编程。</p>\n<h2 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h2><p>方法声明：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(变量名 类型)</span> 方法名<span class=\"params\">()</span> [返回类型]</span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">/* 函数体*/</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>实例：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 定义结构体 */</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Circle <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  radius <span class=\"keyword\">float64</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> c1 Circle</span><br><span class=\"line\">  c1.radius = <span class=\"number\">10.00</span></span><br><span class=\"line\">  fmt.Println(<span class=\"string\">\"Area of Circle(c1) = \"</span>, c1.getArea())</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 该 method 属于 Circle 类型对象中的方法</span></span><br><span class=\"line\"><span class=\"comment\">// 这里的 c 叫作方法的接收器，类似 Javascript 的 this</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c Circle)</span> <span class=\"title\">getArea</span><span class=\"params\">()</span> <span class=\"title\">float64</span></span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// c.radius 即为 Circle 类型对象中的属性</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">3.14</span> * c.radius * c.radius</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>Go 没有像其它语言那样用 <code>this</code> 或者 <code>self</code> 作为接收器。<strong>Go 可以给任意类型定义方法</strong>。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p *Point)</span> <span class=\"title\">ScaleBy</span><span class=\"params\">(factor <span class=\"keyword\">float64</span>)</span></span> &#123;</span><br><span class=\"line\">\tp.X *= factor</span><br><span class=\"line\">\tp.Y *= factor</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>调用指针类型方法<code>(*Point).ScaleBy</code>，<code>()</code>必须有，否则会被理解为<code>*(Point.ScaleBy)</code>。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 调用指针类型方法</span></span><br><span class=\"line\">r := &amp;Point&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>&#125;</span><br><span class=\"line\">r.ScaleBy(<span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 简短写法</span></span><br><span class=\"line\">p := Point&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 编译器会隐式地帮我们用&amp;p去调用ScaleBy这个方法。这种简写方法只适用于“变量”</span></span><br><span class=\"line\">p.ScaleBy(<span class=\"number\">2</span>)</span><br></pre></td></tr></table></figure></p>\n<p>只有类型(<code>Point</code>)和指向他们的指针(<code>*Point</code>)，才是可能会出现在接收器声明里的两种接收器。此外，为了避免歧义，在声明方法时，<br>如果一个类型名本身是一个指针的话，是不允许其出现在接收器中的:<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> P *<span class=\"keyword\">int</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(P)</span> <span class=\"title\">f</span><span class=\"params\">()</span></span> &#123; <span class=\"comment\">/* ... */</span> &#125; <span class=\"comment\">// compile error: invalid receiver type</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"如何选择-receiver-的类型\"><a href=\"#如何选择-receiver-的类型\" class=\"headerlink\" title=\"如何选择 receiver 的类型\"></a>如何选择 receiver 的类型</h3><ol>\n<li><strong>不管你的 <code>method</code> 的 <code>receiver</code> 是指针类型还是非指针类型，都是可以通过指针/非指针类型进行调用的，编译器会帮你做类型转换</strong>。</li>\n<li>在声明一个 <code>method</code> 的 <code>receiver</code> 该是指针还是非指针类型时，你需要考虑：<ul>\n<li>要修改实例状态，用 <code>*T</code>，无需修改使用 <code>T</code>。</li>\n<li>大对象建议使用 <code>*T</code>，减少复制成本，<code>T</code> 调用时会产生一次拷贝。</li>\n<li>对于引用类型，直接使用 <code>T</code>，因为它们本身就是指针包装的。</li>\n<li>包含 <code>Mutex</code> 等同步字段，使用 <code>*T</code>，避免因为复制造成锁操作无效。</li>\n<li>无法确定时，使用 <code>*T</code>。</li>\n</ul>\n</li>\n</ol>\n<p><strong>方法的接收者类型必须是某个自定义的数据类型，而且不能是接口类型或接口的指针类型</strong>。</p>\n<ul>\n<li>值方法，就是接收者类型是非指针的自定义数据类型的方法。</li>\n<li>指针方法，就是接收者类型是指针类型的方法。</li>\n</ul>\n<h2 id=\"嵌入结构体扩展类型\"><a href=\"#嵌入结构体扩展类型\" class=\"headerlink\" title=\"嵌入结构体扩展类型\"></a>嵌入结构体扩展类型</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"image/color\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Point <span class=\"keyword\">struct</span>&#123; X, Y <span class=\"keyword\">float64</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> ColoredPoint <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  Point</span><br><span class=\"line\">  Color color.RGBA</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">red := color.RGBA&#123;<span class=\"number\">255</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">255</span>&#125;</span><br><span class=\"line\">blue := color.RGBA&#123;<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">255</span>, <span class=\"number\">255</span>&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> p = ColoredPoint&#123;Point&#123;<span class=\"number\">1</span>, <span class=\"number\">1</span>&#125;, red&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> q = ColoredPoint&#123;Point&#123;<span class=\"number\">5</span>, <span class=\"number\">4</span>&#125;, blue&#125;</span><br><span class=\"line\">fmt.Println(p.Distance(q.Point)) <span class=\"comment\">// \"5\"</span></span><br><span class=\"line\">p.ScaleBy(<span class=\"number\">2</span>)</span><br><span class=\"line\">q.ScaleBy(<span class=\"number\">2</span>)</span><br><span class=\"line\">fmt.Println(p.Distance(q.Point)) <span class=\"comment\">// \"10\"</span></span><br></pre></td></tr></table></figure>\n<p>如果对基于类来实现面向对象的语言比较熟悉的话，可能会倾向于将 <code>Point</code> 看作一个基类，而 <code>ColoredPoint</code> 看作其子类或者继承类。<br>但这是错误的理解。请注意上面例子中对 <code>Distance</code> 方法的调用。<code>Distance</code> 有一个参数是 <code>Point</code> 类型，但是这里的 <code>q</code> 虽然貌<br>似是继承了<code>Point</code> 类，但 <code>q</code> 并不是，所以尽管 <code>q</code> 有着 <code>Point</code> 这个内嵌类型，我们也必须要显式传入 <code>q.Point</code>。</p>\n<h3 id=\"Go-语言是用嵌入字段实现了继承吗\"><a href=\"#Go-语言是用嵌入字段实现了继承吗\" class=\"headerlink\" title=\"Go 语言是用嵌入字段实现了继承吗\"></a>Go 语言是用嵌入字段实现了继承吗</h3><p>Go 语言中<strong>没有继承的概念，它所做的是通过嵌入字段的方式实现了类型之间的组合</strong>。<br>具体原因和理念请见 <a href=\"https://golang.org/doc/faq#inheritance\" target=\"_blank\" rel=\"noopener\">Why is there no type inheritance?</a>。</p>\n<p>简单来说，面向对象编程中的继承，其实是通过牺牲一定的代码简洁性来换取可扩展性，而且这种可扩展性是通过侵入的方式来实现的。<br>类型之间的组合采用的是非声明的方式，我们不需要显式地声明某个类型实现了某个接口，或者一个类型继承了另一个类型。</p>\n<p>同时，类型组合也是非侵入式的，它不会破坏类型的封装或加重类型之间的耦合。我们要做的只是把类型当做字段嵌入进来，然后坐<br>享其成地使用嵌入字段所拥有的一切。如果嵌入字段有哪里不合心意，我们还可以用“包装”或“屏蔽”的方式去调整和优化。</p>\n<p>另外，类型间的组合也是灵活的，我们总是可以通过嵌入字段的方式把一个类型的属性和能力“嫁接”给另一个类型。</p>\n<p>这时候，被嵌入类型也就自然而然地实现了嵌入字段所实现的接口。再者，组合要比继承更加简洁和清晰，Go 语言可以轻而易举地通过嵌入<br>多个字段来实现功能强大的类型，却不会有多重继承那样复杂的层次结构和可观的管理成本。</p>\n<h2 id=\"封装\"><a href=\"#封装\" class=\"headerlink\" title=\"封装\"></a>封装</h2><p>一个对象的变量或者方法如果对调用方是不可见的话，一般就被定义为“封装”。通过首字母大小写来定义是否从包中导出。<br>封装一个对象，必须定义为一个 <code>struct</code>：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> IntSet <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  words []<span class=\"keyword\">uint64</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>优点：</p>\n<ul>\n<li>调用方不能直接修改对象的变量值</li>\n<li>隐藏实现的细节，防止调用方依赖那些可能变化的具体实现，这样使设计包的程序员在不破坏对外的api情况下能得到更大的自由。</li>\n<li>阻止了外部调用方对对象内部的值任意地进行修改。</li>\n</ul>\n<h2 id=\"String-方法\"><a href=\"#String-方法\" class=\"headerlink\" title=\"String 方法\"></a><code>String</code> 方法</h2><p>在 Go 语言中，<strong>我们可以通过为一个类型编写名为 <code>String</code> 的方法，来自定义该类型的字符串表示形式。这个 <code>String</code> 方法不需<br>要任何参数声明，但需要有一个 <code>string</code> 类型的结果声明</strong>。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> AnimalCategory <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    kingdom <span class=\"keyword\">string</span> <span class=\"comment\">// 界。</span></span><br><span class=\"line\">    phylum <span class=\"keyword\">string</span> <span class=\"comment\">// 门。</span></span><br><span class=\"line\">    class  <span class=\"keyword\">string</span> <span class=\"comment\">// 纲。</span></span><br><span class=\"line\">    order  <span class=\"keyword\">string</span> <span class=\"comment\">// 目。</span></span><br><span class=\"line\">    family <span class=\"keyword\">string</span> <span class=\"comment\">// 科。</span></span><br><span class=\"line\">    genus  <span class=\"keyword\">string</span> <span class=\"comment\">// 属。</span></span><br><span class=\"line\">    species <span class=\"keyword\">string</span> <span class=\"comment\">// 种。</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(ac AnimalCategory)</span> <span class=\"title\">String</span><span class=\"params\">()</span> <span class=\"title\">string</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fmt.Sprintf(<span class=\"string\">\"%s%s%s%s%s%s%s\"</span>,ac.kingdom, ac.phylum, ac.class, ac.order,ac.family, ac.genus, ac.species)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">category := AnimalCategory&#123;species: <span class=\"string\">\"cat\"</span>&#125;</span><br><span class=\"line\">fmt.Printf(<span class=\"string\">\"The animal category: %s\\n\"</span>, category)</span><br></pre></td></tr></table></figure></p>\n<p>正因为如此，我在调用 <code>fmt.Printf</code> 函数时，使用占位符 <code>%s</code> 和 <code>category</code> 值本身就可以打印出后者的字符串表示形式，<br>而<strong>无需显式地调用它的 <code>String</code> 方法</strong>。</p>\n<p><code>fmt.Printf</code> 函数会自己去寻找它。此时的打印内容会是 <code>The animal category: cat</code>。显而易见，<code>category</code> 的 <code>String</code> 方法成<br>功地引用了当前值的所有字段。</p>\n<p>当你广泛使用一个自定义类型时，最好为它定义 <code>String()</code> 方法。</p>\n<p><strong>不要在 <code>String()</code> 方法里面调用涉及 <code>String()</code> 方法的方法，它会导致意料之外的错误</strong>，比如：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> TT <span class=\"keyword\">float64</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(t TT)</span> <span class=\"title\">String</span><span class=\"params\">()</span> <span class=\"title\">string</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fmt.Sprintf(<span class=\"string\">\"%v\"</span>, t)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">t.String()</span><br></pre></td></tr></table></figure></p>\n<p>它导致了一个无限递归调用（<code>TT.String()</code> 调用 <code>fmt.Sprintf</code>，而 <code>fmt.Sprintf</code> 又会反过来调用 <code>TT.String()</code>…），很快就会导<br>致内存溢出。</p>\n"},{"title":"常量","_content":"# 常量\n\n`const` 声明常量，运行时不可改变（只读），注意常量的**底层数据类型只能是基础类型（布尔型、数值型和字符串型）**：\n```go\nconst 常量名字 类型 = 表达式\n```\n\n\"类型\"可以省略。也就是如果没有类型，可以通过表达式推导出类型。\n\n比如：\n```go\n// 声明一个`string`类型\nconst b string = \"abc\"\nconst a = \"abc\"\n\n// 声明一组不同类型\nconst c, f, s = true, 2.3, \"four\" // bool, float64, string\n\n// 批量声明多个常量\nconst (\n  Unknown = 0\n  Female = 1\n  Male = 2\n)\n\nconst strSize = len(\"hello, world\")\n```\n常量表达式的值在**编译期计算**。因此常量表达式中，函数必须是内置函数。如 `unsafe.Sizeof()`，`len()`, `cap()`。\n\n**常量组中，如果不指定类型和初始值，那么就和上一行非空常量右值相同**：\n例如：\n```go\nconst (\n\ta = 1\n\tb\n\tc = 2\n\td\n)\n\nfmt.Println(a, b, c, d) // \"1 1 2 2\"\n```\n\n## iota\n**Go 中没有枚举的定义，但是可以使用 `iota`**，`iota` 标识符可以认为是**一个可以被编译器修改的常量**。\n在 `const` 声明中，被重置为 `0`，在第一个声明的常量所在的行，`iota` 将会被置为 `0`，然后在每一个有常量声明的\n行加 `1`。\n```go\nconst (\n\ta = iota   // 0\n\tb          // 1\n\tc          // 2\n\td = \"ha\"   // \"ha\", iota += 1\n\te          // \"ha\" ,不指定类型和初始值，那么就和上一行非空常量右值相同,  iota += 1\n\tf = 100    // 100, iota +=1\n\tg          // 100,不指定类型和初始值，那么就和上一行非空常量右值相同,  iota +=1\n\th = iota   // 7, 中断的 iota 计数必须显示恢复\n\ti          // 8\n)\n\nconst (\n\ti = 1 << iota // 1, 1 << 0\n\tj = 3 << iota // 6, 3 << 1\n\tk             // 12, 3 << 2\n\tl             // 24, 3 << 3\n)\n```","source":"basic/constant.md","raw":"---\ntitle: 常量\n---\n# 常量\n\n`const` 声明常量，运行时不可改变（只读），注意常量的**底层数据类型只能是基础类型（布尔型、数值型和字符串型）**：\n```go\nconst 常量名字 类型 = 表达式\n```\n\n\"类型\"可以省略。也就是如果没有类型，可以通过表达式推导出类型。\n\n比如：\n```go\n// 声明一个`string`类型\nconst b string = \"abc\"\nconst a = \"abc\"\n\n// 声明一组不同类型\nconst c, f, s = true, 2.3, \"four\" // bool, float64, string\n\n// 批量声明多个常量\nconst (\n  Unknown = 0\n  Female = 1\n  Male = 2\n)\n\nconst strSize = len(\"hello, world\")\n```\n常量表达式的值在**编译期计算**。因此常量表达式中，函数必须是内置函数。如 `unsafe.Sizeof()`，`len()`, `cap()`。\n\n**常量组中，如果不指定类型和初始值，那么就和上一行非空常量右值相同**：\n例如：\n```go\nconst (\n\ta = 1\n\tb\n\tc = 2\n\td\n)\n\nfmt.Println(a, b, c, d) // \"1 1 2 2\"\n```\n\n## iota\n**Go 中没有枚举的定义，但是可以使用 `iota`**，`iota` 标识符可以认为是**一个可以被编译器修改的常量**。\n在 `const` 声明中，被重置为 `0`，在第一个声明的常量所在的行，`iota` 将会被置为 `0`，然后在每一个有常量声明的\n行加 `1`。\n```go\nconst (\n\ta = iota   // 0\n\tb          // 1\n\tc          // 2\n\td = \"ha\"   // \"ha\", iota += 1\n\te          // \"ha\" ,不指定类型和初始值，那么就和上一行非空常量右值相同,  iota += 1\n\tf = 100    // 100, iota +=1\n\tg          // 100,不指定类型和初始值，那么就和上一行非空常量右值相同,  iota +=1\n\th = iota   // 7, 中断的 iota 计数必须显示恢复\n\ti          // 8\n)\n\nconst (\n\ti = 1 << iota // 1, 1 << 0\n\tj = 3 << iota // 6, 3 << 1\n\tk             // 12, 3 << 2\n\tl             // 24, 3 << 3\n)\n```","date":"2019-08-24T04:34:57.570Z","updated":"2019-08-24T04:34:57.521Z","path":"basic/constant.html","comments":1,"layout":"page","_id":"ck1xm14kj000ffcw288ize79y","content":"<h1 id=\"常量\"><a href=\"#常量\" class=\"headerlink\" title=\"常量\"></a>常量</h1><p><code>const</code> 声明常量，运行时不可改变（只读），注意常量的<strong>底层数据类型只能是基础类型（布尔型、数值型和字符串型）</strong>：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> 常量名字 类型 = 表达式</span><br></pre></td></tr></table></figure></p>\n<p>“类型”可以省略。也就是如果没有类型，可以通过表达式推导出类型。</p>\n<p>比如：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 声明一个`string`类型</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> b <span class=\"keyword\">string</span> = <span class=\"string\">\"abc\"</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> a = <span class=\"string\">\"abc\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 声明一组不同类型</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> c, f, s = <span class=\"literal\">true</span>, <span class=\"number\">2.3</span>, <span class=\"string\">\"four\"</span> <span class=\"comment\">// bool, float64, string</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 批量声明多个常量</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">  Unknown = <span class=\"number\">0</span></span><br><span class=\"line\">  Female = <span class=\"number\">1</span></span><br><span class=\"line\">  Male = <span class=\"number\">2</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> strSize = <span class=\"built_in\">len</span>(<span class=\"string\">\"hello, world\"</span>)</span><br></pre></td></tr></table></figure></p>\n<p>常量表达式的值在<strong>编译期计算</strong>。因此常量表达式中，函数必须是内置函数。如 <code>unsafe.Sizeof()</code>，<code>len()</code>, <code>cap()</code>。</p>\n<p><strong>常量组中，如果不指定类型和初始值，那么就和上一行非空常量右值相同</strong>：<br>例如：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">\ta = <span class=\"number\">1</span></span><br><span class=\"line\">\tb</span><br><span class=\"line\">\tc = <span class=\"number\">2</span></span><br><span class=\"line\">\td</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">fmt.Println(a, b, c, d) <span class=\"comment\">// \"1 1 2 2\"</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"iota\"><a href=\"#iota\" class=\"headerlink\" title=\"iota\"></a>iota</h2><p><strong>Go 中没有枚举的定义，但是可以使用 <code>iota</code></strong>，<code>iota</code> 标识符可以认为是<strong>一个可以被编译器修改的常量</strong>。<br>在 <code>const</code> 声明中，被重置为 <code>0</code>，在第一个声明的常量所在的行，<code>iota</code> 将会被置为 <code>0</code>，然后在每一个有常量声明的<br>行加 <code>1</code>。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">\ta = <span class=\"literal\">iota</span>   <span class=\"comment\">// 0</span></span><br><span class=\"line\">\tb          <span class=\"comment\">// 1</span></span><br><span class=\"line\">\tc          <span class=\"comment\">// 2</span></span><br><span class=\"line\">\td = <span class=\"string\">\"ha\"</span>   <span class=\"comment\">// \"ha\", iota += 1</span></span><br><span class=\"line\">\te          <span class=\"comment\">// \"ha\" ,不指定类型和初始值，那么就和上一行非空常量右值相同,  iota += 1</span></span><br><span class=\"line\">\tf = <span class=\"number\">100</span>    <span class=\"comment\">// 100, iota +=1</span></span><br><span class=\"line\">\tg          <span class=\"comment\">// 100,不指定类型和初始值，那么就和上一行非空常量右值相同,  iota +=1</span></span><br><span class=\"line\">\th = <span class=\"literal\">iota</span>   <span class=\"comment\">// 7, 中断的 iota 计数必须显示恢复</span></span><br><span class=\"line\">\ti          <span class=\"comment\">// 8</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">\ti = <span class=\"number\">1</span> &lt;&lt; <span class=\"literal\">iota</span> <span class=\"comment\">// 1, 1 &lt;&lt; 0</span></span><br><span class=\"line\">\tj = <span class=\"number\">3</span> &lt;&lt; <span class=\"literal\">iota</span> <span class=\"comment\">// 6, 3 &lt;&lt; 1</span></span><br><span class=\"line\">\tk             <span class=\"comment\">// 12, 3 &lt;&lt; 2</span></span><br><span class=\"line\">\tl             <span class=\"comment\">// 24, 3 &lt;&lt; 3</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{"navigation":{"logo":{"text":"Golang Learn","type":"link","path":"index.html"},"main":[{"text":"Golang 基础","type":"label"},{"text":"Go 环境配置","type":"link","path":"basic/env_config.html"},{"text":"包","type":"link","path":"basic/package.html"},{"text":"基础数据类型","type":"link","path":"basic/basic_data.html"},{"text":"变量","type":"link","path":"basic/var.html"},{"text":"常量","type":"link","path":"basic/constant.html"},{"text":"控制语句","type":"link","path":"basic/flow.html"},{"text":"运算符","type":"link","path":"basic/operator.html"},{"text":"作用域","type":"link","path":"basic/scope.html"},{"text":"指针","type":"link","path":"basic/pointer.html"},{"text":"数组","type":"link","path":"basic/array.html"},{"text":"切片","type":"link","path":"basic/slice.html"},{"text":"字典","type":"link","path":"basic/map.html"},{"text":"函数","type":"link","path":"basic/function.html"},{"text":"结构体","type":"link","path":"basic/struct.html"},{"text":"接口","type":"link","path":"basic/interface.html"},{"text":"面向对象","type":"link","path":"basic/oop.html"},{"text":"错误","type":"link","path":"basic/error.html"},{"text":"序列化","type":"link","path":"basic/json.html"},{"text":"反射","type":"link","path":"basic/reflect.html"},{"text":"测试","type":"link","path":"basic/test.html"},{"text":"并发编程","type":"label"},{"text":"goroutine","type":"link","path":"concurrent/goroutine.html"},{"text":"channel","type":"link","path":"concurrent/channel.html"},{"text":"同步和锁","type":"link","path":"concurrent/sync_lock.html"},{"text":"内存分配","type":"label"},{"text":"内存分配","type":"link","path":"advance/mm.html"},{"text":"垃圾回收","type":"label"},{"text":"垃圾回收","type":"link","path":"advance/gc.html"},{"text":"标准库","type":"label"},{"text":"fmt","type":"link","path":"standards/io/fmt.html"},{"text":"io","type":"link","path":"standards/io/io.html"},{"text":"ioutil","type":"link","path":"standards/io/ioutil.html"},{"text":"bufio","type":"link","path":"standards/io/bufio.html"},{"text":"os","type":"link","path":"standards/os/os.html"},{"text":"filepath","type":"link","path":"standards/os/filepath.html"},{"text":"strings","type":"link","path":"standards/text/strings.html"},{"text":"strconv","type":"link","path":"standards/text/strconv.html"},{"text":"unicode","type":"link","path":"standards/text/unicode.html"},{"text":"log","type":"link","path":"standards/log.html"},{"text":"time","type":"link","path":"standards/time.html"},{"text":"http","type":"link","path":"standards/net/http.html"},{"text":"math","type":"link","path":"standards/data/math.html"},{"text":"sort","type":"link","path":"standards/data/sort.html"},{"text":"big","type":"link","path":"standards/data/big.html"},{"text":"container","type":"link","path":"standards/data/container.html"},{"text":"sql","type":"link","path":"standards/database/sql.html"},{"text":"THEME","type":"label"},{"text":"使用文档主题","type":"link","path":"theme/theme-usage.html"},{"text":"SUPPORT AND FEEDBACK","type":"label"},{"text":"Raise an Issue on Github","type":"link","path":"https://github.com/shipengqi/golang-learn/issues/new"}]}}},"excerpt":"","more":"<h1 id=\"常量\"><a href=\"#常量\" class=\"headerlink\" title=\"常量\"></a>常量</h1><p><code>const</code> 声明常量，运行时不可改变（只读），注意常量的<strong>底层数据类型只能是基础类型（布尔型、数值型和字符串型）</strong>：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> 常量名字 类型 = 表达式</span><br></pre></td></tr></table></figure></p>\n<p>“类型”可以省略。也就是如果没有类型，可以通过表达式推导出类型。</p>\n<p>比如：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 声明一个`string`类型</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> b <span class=\"keyword\">string</span> = <span class=\"string\">\"abc\"</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> a = <span class=\"string\">\"abc\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 声明一组不同类型</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> c, f, s = <span class=\"literal\">true</span>, <span class=\"number\">2.3</span>, <span class=\"string\">\"four\"</span> <span class=\"comment\">// bool, float64, string</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 批量声明多个常量</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">  Unknown = <span class=\"number\">0</span></span><br><span class=\"line\">  Female = <span class=\"number\">1</span></span><br><span class=\"line\">  Male = <span class=\"number\">2</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> strSize = <span class=\"built_in\">len</span>(<span class=\"string\">\"hello, world\"</span>)</span><br></pre></td></tr></table></figure></p>\n<p>常量表达式的值在<strong>编译期计算</strong>。因此常量表达式中，函数必须是内置函数。如 <code>unsafe.Sizeof()</code>，<code>len()</code>, <code>cap()</code>。</p>\n<p><strong>常量组中，如果不指定类型和初始值，那么就和上一行非空常量右值相同</strong>：<br>例如：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">\ta = <span class=\"number\">1</span></span><br><span class=\"line\">\tb</span><br><span class=\"line\">\tc = <span class=\"number\">2</span></span><br><span class=\"line\">\td</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">fmt.Println(a, b, c, d) <span class=\"comment\">// \"1 1 2 2\"</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"iota\"><a href=\"#iota\" class=\"headerlink\" title=\"iota\"></a>iota</h2><p><strong>Go 中没有枚举的定义，但是可以使用 <code>iota</code></strong>，<code>iota</code> 标识符可以认为是<strong>一个可以被编译器修改的常量</strong>。<br>在 <code>const</code> 声明中，被重置为 <code>0</code>，在第一个声明的常量所在的行，<code>iota</code> 将会被置为 <code>0</code>，然后在每一个有常量声明的<br>行加 <code>1</code>。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">\ta = <span class=\"literal\">iota</span>   <span class=\"comment\">// 0</span></span><br><span class=\"line\">\tb          <span class=\"comment\">// 1</span></span><br><span class=\"line\">\tc          <span class=\"comment\">// 2</span></span><br><span class=\"line\">\td = <span class=\"string\">\"ha\"</span>   <span class=\"comment\">// \"ha\", iota += 1</span></span><br><span class=\"line\">\te          <span class=\"comment\">// \"ha\" ,不指定类型和初始值，那么就和上一行非空常量右值相同,  iota += 1</span></span><br><span class=\"line\">\tf = <span class=\"number\">100</span>    <span class=\"comment\">// 100, iota +=1</span></span><br><span class=\"line\">\tg          <span class=\"comment\">// 100,不指定类型和初始值，那么就和上一行非空常量右值相同,  iota +=1</span></span><br><span class=\"line\">\th = <span class=\"literal\">iota</span>   <span class=\"comment\">// 7, 中断的 iota 计数必须显示恢复</span></span><br><span class=\"line\">\ti          <span class=\"comment\">// 8</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">\ti = <span class=\"number\">1</span> &lt;&lt; <span class=\"literal\">iota</span> <span class=\"comment\">// 1, 1 &lt;&lt; 0</span></span><br><span class=\"line\">\tj = <span class=\"number\">3</span> &lt;&lt; <span class=\"literal\">iota</span> <span class=\"comment\">// 6, 3 &lt;&lt; 1</span></span><br><span class=\"line\">\tk             <span class=\"comment\">// 12, 3 &lt;&lt; 2</span></span><br><span class=\"line\">\tl             <span class=\"comment\">// 24, 3 &lt;&lt; 3</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n"},{"title":"map","_content":"# map\n`map` 是一个无序的 `key/value` 对的集合。**`map` 是引用类型**。这意味着它拥有对底层数据结构的引用，\n就像指针一样。它底层的数据结构是 `hash table` 或 `hash map`。\n\n`map` 作为引用类型是非常好的，因为无论 `map` 有多大，都只会有一个副本。\n\n定义 `map`，使用 `map` 关键字：\n```go\n/* 声明变量，默认 map 是 nil */\nvar 变量名 map[键类型]值类型\n\n/* 使用 make 函数 */\n变量名 := make(map[键类型]值类型)\n\n/* 字面值的语法创建 */\n变量名 := map[键类型]值类型{\n  key1: value1,\n  key2: value2,\n  ...\n}\n```\n\n一个 `map` 在未初始化之前默认为 `nil`。\n通过索引下标 `key` 来访问 `map` 中对应的 `value`\n```go\nage, ok := ages[\"bob\"]\nif !ok { /* \"bob\" is not a key in this map; age == 0. */ }\n```\n`ok` 表示操作结果，是一个布尔值。**这叫做 `ok-idiom` 模式，就是在多返回值中返回一个 `ok` 布尔值，表示是否操作\n成功**。\n\n使用 `map` 过程中需要注意的几点：\n- **`map` 是无序的，每次打印出来的 `map` 都会不一样**，它不能通过 `index` 获取，而必须通过 `key` 获取\n- `map` 的长度是不固定的，也就是和 `slice` 一样，也是一种引用类型\n- 内置的 `len` 函数同样适用于 `map`，返回 `map` 拥有的 `key` 的数量\n- `map` 的值可以很方便的修改，通过 `numbers[\"one\"]=11` 可以很容易的把 `key` 为 `one` 的字典值改为 11\n- **`map` 和其他基本型别不同，它不是 `thread-safe` 的**，在多个 `go-routine` 存取时，必须使用 `mutex lock` 机制\n\n#### delete()\n`delete` 函数删除 `map` 元素。\n```go\ndelete(mapName, key)\n```\n\n#### 遍历\n可以使用 `for range` 遍历 `map`：\n```go\nfor key, value := range mapName {\n\tfmt.Println(mapName[key])\n}\n```\n**`Map` 的迭代顺序是不确定的。可以先使用 `sort` 包排序**。\n\n#### map 的键类型不能是哪些类型\n`map` 的键和元素的最大不同在于，前者的类型是受限的，而后者却可以是任意类型的。\n\n**`map` 的键类型不可以是函数类型、字典类型和切片类型**。\n\n为什么？\n\nGo 语言规范规定，在**键类型的值之间必须可以施加操作符 `==` 和 `!=`**。换句话说，键类型的值必须要支持判等操作。由于\n函数类型、字典类型和切片类型的值并不支持判等操作，所以字典的键类型不能是这些类型。\n\n另外，如果键的类型是接口类型的，那么键值的实际类型也不能是上述三种类型，否则在程序运行过程中会引发 panic（即运行时恐慌）。\n```go\nvar badMap2 = map[interface{}]int{\n\"1\":   1,\n[]int{2}: 2, // 这里会引发 panic。\n3:    3,\n}\n```\n\n#### 优先考虑哪些类型作为字典的键类型\n求哈希和判等操作的速度越快，对应的类型就越适合作为键类型。\n\n对于所有的基本类型、指针类型，以及数组类型、结构体类型和接口类型，Go 语言都有一套算法与之对应。这套算法中就包含了哈希和判等。\n以求哈希的操作为例，宽度越小的类型速度通常越快。对于布尔类型、整数类型、浮点数类型、复数类型和指针类型来说都是如此。对于字\n符串类型，由于它的宽度是不定的，所以要看它的值的具体长度，长度越短求哈希越快。\n\n类型的宽度是指它的单个值需要占用的字节数。比如，`bool`、`int8` 和 `uint8` 类型的一个值需要占用的字节数都是 1，因此这\n些类型的宽度就都是 1。\n\n\n#### 在值为 nil 的字典上执行读写操作会成功吗\n当我们仅声明而不初始化一个字典类型的变量的时候，它的值会是 `nil`。如果你尝试使用一个 `nil` 的 `map`，你会\n得到一个 `nil` 指针异常，这将导致程序终止运行。所以不应该初始化一个空的 map 变量，比如 `var m map[string]string`。\n\n**除了添加键 - 元素对，我们在一个值为 `nil` 的字典上做任何操作都不会引起错误**。当我们试图在一个值为 `nil` 的字典中\n添加键 - 元素对的时候，Go 语言的运行时系统就会立即抛出一个 panic。\n\n可以先使用 `make` 函数初始化，或者 `dictionary = map[string]string{}`。这两种方法都可以创建一个空的 `hash map`\n 并指向 `dictionary`。这确保永远不会获得 `nil 指针异常`。\n","source":"basic/map.md","raw":"---\ntitle: map\n---\n# map\n`map` 是一个无序的 `key/value` 对的集合。**`map` 是引用类型**。这意味着它拥有对底层数据结构的引用，\n就像指针一样。它底层的数据结构是 `hash table` 或 `hash map`。\n\n`map` 作为引用类型是非常好的，因为无论 `map` 有多大，都只会有一个副本。\n\n定义 `map`，使用 `map` 关键字：\n```go\n/* 声明变量，默认 map 是 nil */\nvar 变量名 map[键类型]值类型\n\n/* 使用 make 函数 */\n变量名 := make(map[键类型]值类型)\n\n/* 字面值的语法创建 */\n变量名 := map[键类型]值类型{\n  key1: value1,\n  key2: value2,\n  ...\n}\n```\n\n一个 `map` 在未初始化之前默认为 `nil`。\n通过索引下标 `key` 来访问 `map` 中对应的 `value`\n```go\nage, ok := ages[\"bob\"]\nif !ok { /* \"bob\" is not a key in this map; age == 0. */ }\n```\n`ok` 表示操作结果，是一个布尔值。**这叫做 `ok-idiom` 模式，就是在多返回值中返回一个 `ok` 布尔值，表示是否操作\n成功**。\n\n使用 `map` 过程中需要注意的几点：\n- **`map` 是无序的，每次打印出来的 `map` 都会不一样**，它不能通过 `index` 获取，而必须通过 `key` 获取\n- `map` 的长度是不固定的，也就是和 `slice` 一样，也是一种引用类型\n- 内置的 `len` 函数同样适用于 `map`，返回 `map` 拥有的 `key` 的数量\n- `map` 的值可以很方便的修改，通过 `numbers[\"one\"]=11` 可以很容易的把 `key` 为 `one` 的字典值改为 11\n- **`map` 和其他基本型别不同，它不是 `thread-safe` 的**，在多个 `go-routine` 存取时，必须使用 `mutex lock` 机制\n\n#### delete()\n`delete` 函数删除 `map` 元素。\n```go\ndelete(mapName, key)\n```\n\n#### 遍历\n可以使用 `for range` 遍历 `map`：\n```go\nfor key, value := range mapName {\n\tfmt.Println(mapName[key])\n}\n```\n**`Map` 的迭代顺序是不确定的。可以先使用 `sort` 包排序**。\n\n#### map 的键类型不能是哪些类型\n`map` 的键和元素的最大不同在于，前者的类型是受限的，而后者却可以是任意类型的。\n\n**`map` 的键类型不可以是函数类型、字典类型和切片类型**。\n\n为什么？\n\nGo 语言规范规定，在**键类型的值之间必须可以施加操作符 `==` 和 `!=`**。换句话说，键类型的值必须要支持判等操作。由于\n函数类型、字典类型和切片类型的值并不支持判等操作，所以字典的键类型不能是这些类型。\n\n另外，如果键的类型是接口类型的，那么键值的实际类型也不能是上述三种类型，否则在程序运行过程中会引发 panic（即运行时恐慌）。\n```go\nvar badMap2 = map[interface{}]int{\n\"1\":   1,\n[]int{2}: 2, // 这里会引发 panic。\n3:    3,\n}\n```\n\n#### 优先考虑哪些类型作为字典的键类型\n求哈希和判等操作的速度越快，对应的类型就越适合作为键类型。\n\n对于所有的基本类型、指针类型，以及数组类型、结构体类型和接口类型，Go 语言都有一套算法与之对应。这套算法中就包含了哈希和判等。\n以求哈希的操作为例，宽度越小的类型速度通常越快。对于布尔类型、整数类型、浮点数类型、复数类型和指针类型来说都是如此。对于字\n符串类型，由于它的宽度是不定的，所以要看它的值的具体长度，长度越短求哈希越快。\n\n类型的宽度是指它的单个值需要占用的字节数。比如，`bool`、`int8` 和 `uint8` 类型的一个值需要占用的字节数都是 1，因此这\n些类型的宽度就都是 1。\n\n\n#### 在值为 nil 的字典上执行读写操作会成功吗\n当我们仅声明而不初始化一个字典类型的变量的时候，它的值会是 `nil`。如果你尝试使用一个 `nil` 的 `map`，你会\n得到一个 `nil` 指针异常，这将导致程序终止运行。所以不应该初始化一个空的 map 变量，比如 `var m map[string]string`。\n\n**除了添加键 - 元素对，我们在一个值为 `nil` 的字典上做任何操作都不会引起错误**。当我们试图在一个值为 `nil` 的字典中\n添加键 - 元素对的时候，Go 语言的运行时系统就会立即抛出一个 panic。\n\n可以先使用 `make` 函数初始化，或者 `dictionary = map[string]string{}`。这两种方法都可以创建一个空的 `hash map`\n 并指向 `dictionary`。这确保永远不会获得 `nil 指针异常`。\n","date":"2019-08-24T02:08:28.403Z","updated":"2019-08-24T02:08:28.380Z","path":"basic/map.html","comments":1,"layout":"page","_id":"ck1xm14kk000gfcw2n1dcxl8p","content":"<h1 id=\"map\"><a href=\"#map\" class=\"headerlink\" title=\"map\"></a>map</h1><p><code>map</code> 是一个无序的 <code>key/value</code> 对的集合。<strong><code>map</code> 是引用类型</strong>。这意味着它拥有对底层数据结构的引用，<br>就像指针一样。它底层的数据结构是 <code>hash table</code> 或 <code>hash map</code>。</p>\n<p><code>map</code> 作为引用类型是非常好的，因为无论 <code>map</code> 有多大，都只会有一个副本。</p>\n<p>定义 <code>map</code>，使用 <code>map</code> 关键字：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 声明变量，默认 map 是 nil */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> 变量名 <span class=\"keyword\">map</span>[键类型]值类型</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 使用 make 函数 */</span></span><br><span class=\"line\">变量名 := <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[键类型]值类型)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 字面值的语法创建 */</span></span><br><span class=\"line\">变量名 := <span class=\"keyword\">map</span>[键类型]值类型&#123;</span><br><span class=\"line\">  key1: value1,</span><br><span class=\"line\">  key2: value2,</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>一个 <code>map</code> 在未初始化之前默认为 <code>nil</code>。<br>通过索引下标 <code>key</code> 来访问 <code>map</code> 中对应的 <code>value</code><br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">age, ok := ages[<span class=\"string\">\"bob\"</span>]</span><br><span class=\"line\"><span class=\"keyword\">if</span> !ok &#123; <span class=\"comment\">/* \"bob\" is not a key in this map; age == 0. */</span> &#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>ok</code> 表示操作结果，是一个布尔值。<strong>这叫做 <code>ok-idiom</code> 模式，就是在多返回值中返回一个 <code>ok</code> 布尔值，表示是否操作<br>成功</strong>。</p>\n<p>使用 <code>map</code> 过程中需要注意的几点：</p>\n<ul>\n<li><strong><code>map</code> 是无序的，每次打印出来的 <code>map</code> 都会不一样</strong>，它不能通过 <code>index</code> 获取，而必须通过 <code>key</code> 获取</li>\n<li><code>map</code> 的长度是不固定的，也就是和 <code>slice</code> 一样，也是一种引用类型</li>\n<li>内置的 <code>len</code> 函数同样适用于 <code>map</code>，返回 <code>map</code> 拥有的 <code>key</code> 的数量</li>\n<li><code>map</code> 的值可以很方便的修改，通过 <code>numbers[&quot;one&quot;]=11</code> 可以很容易的把 <code>key</code> 为 <code>one</code> 的字典值改为 11</li>\n<li><strong><code>map</code> 和其他基本型别不同，它不是 <code>thread-safe</code> 的</strong>，在多个 <code>go-routine</code> 存取时，必须使用 <code>mutex lock</code> 机制</li>\n</ul>\n<h4 id=\"delete\"><a href=\"#delete\" class=\"headerlink\" title=\"delete()\"></a>delete()</h4><p><code>delete</code> 函数删除 <code>map</code> 元素。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">delete</span>(mapName, key)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"遍历\"><a href=\"#遍历\" class=\"headerlink\" title=\"遍历\"></a>遍历</h4><p>可以使用 <code>for range</code> 遍历 <code>map</code>：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> key, value := <span class=\"keyword\">range</span> mapName &#123;</span><br><span class=\"line\">\tfmt.Println(mapName[key])</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong><code>Map</code> 的迭代顺序是不确定的。可以先使用 <code>sort</code> 包排序</strong>。</p>\n<h4 id=\"map-的键类型不能是哪些类型\"><a href=\"#map-的键类型不能是哪些类型\" class=\"headerlink\" title=\"map 的键类型不能是哪些类型\"></a>map 的键类型不能是哪些类型</h4><p><code>map</code> 的键和元素的最大不同在于，前者的类型是受限的，而后者却可以是任意类型的。</p>\n<p><strong><code>map</code> 的键类型不可以是函数类型、字典类型和切片类型</strong>。</p>\n<p>为什么？</p>\n<p>Go 语言规范规定，在<strong>键类型的值之间必须可以施加操作符 <code>==</code> 和 <code>!=</code></strong>。换句话说，键类型的值必须要支持判等操作。由于<br>函数类型、字典类型和切片类型的值并不支持判等操作，所以字典的键类型不能是这些类型。</p>\n<p>另外，如果键的类型是接口类型的，那么键值的实际类型也不能是上述三种类型，否则在程序运行过程中会引发 panic（即运行时恐慌）。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> badMap2 = <span class=\"keyword\">map</span>[<span class=\"keyword\">interface</span>&#123;&#125;]<span class=\"keyword\">int</span>&#123;</span><br><span class=\"line\"><span class=\"string\">\"1\"</span>:   <span class=\"number\">1</span>,</span><br><span class=\"line\">[]<span class=\"keyword\">int</span>&#123;<span class=\"number\">2</span>&#125;: <span class=\"number\">2</span>, <span class=\"comment\">// 这里会引发 panic。</span></span><br><span class=\"line\"><span class=\"number\">3</span>:    <span class=\"number\">3</span>,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"优先考虑哪些类型作为字典的键类型\"><a href=\"#优先考虑哪些类型作为字典的键类型\" class=\"headerlink\" title=\"优先考虑哪些类型作为字典的键类型\"></a>优先考虑哪些类型作为字典的键类型</h4><p>求哈希和判等操作的速度越快，对应的类型就越适合作为键类型。</p>\n<p>对于所有的基本类型、指针类型，以及数组类型、结构体类型和接口类型，Go 语言都有一套算法与之对应。这套算法中就包含了哈希和判等。<br>以求哈希的操作为例，宽度越小的类型速度通常越快。对于布尔类型、整数类型、浮点数类型、复数类型和指针类型来说都是如此。对于字<br>符串类型，由于它的宽度是不定的，所以要看它的值的具体长度，长度越短求哈希越快。</p>\n<p>类型的宽度是指它的单个值需要占用的字节数。比如，<code>bool</code>、<code>int8</code> 和 <code>uint8</code> 类型的一个值需要占用的字节数都是 1，因此这<br>些类型的宽度就都是 1。</p>\n<h4 id=\"在值为-nil-的字典上执行读写操作会成功吗\"><a href=\"#在值为-nil-的字典上执行读写操作会成功吗\" class=\"headerlink\" title=\"在值为 nil 的字典上执行读写操作会成功吗\"></a>在值为 nil 的字典上执行读写操作会成功吗</h4><p>当我们仅声明而不初始化一个字典类型的变量的时候，它的值会是 <code>nil</code>。如果你尝试使用一个 <code>nil</code> 的 <code>map</code>，你会<br>得到一个 <code>nil</code> 指针异常，这将导致程序终止运行。所以不应该初始化一个空的 map 变量，比如 <code>var m map[string]string</code>。</p>\n<p><strong>除了添加键 - 元素对，我们在一个值为 <code>nil</code> 的字典上做任何操作都不会引起错误</strong>。当我们试图在一个值为 <code>nil</code> 的字典中<br>添加键 - 元素对的时候，Go 语言的运行时系统就会立即抛出一个 panic。</p>\n<p>可以先使用 <code>make</code> 函数初始化，或者 <code>dictionary = map[string]string{}</code>。这两种方法都可以创建一个空的 <code>hash map</code><br> 并指向 <code>dictionary</code>。这确保永远不会获得 <code>nil 指针异常</code>。</p>\n","site":{"data":{"navigation":{"logo":{"text":"Golang Learn","type":"link","path":"index.html"},"main":[{"text":"Golang 基础","type":"label"},{"text":"Go 环境配置","type":"link","path":"basic/env_config.html"},{"text":"包","type":"link","path":"basic/package.html"},{"text":"基础数据类型","type":"link","path":"basic/basic_data.html"},{"text":"变量","type":"link","path":"basic/var.html"},{"text":"常量","type":"link","path":"basic/constant.html"},{"text":"控制语句","type":"link","path":"basic/flow.html"},{"text":"运算符","type":"link","path":"basic/operator.html"},{"text":"作用域","type":"link","path":"basic/scope.html"},{"text":"指针","type":"link","path":"basic/pointer.html"},{"text":"数组","type":"link","path":"basic/array.html"},{"text":"切片","type":"link","path":"basic/slice.html"},{"text":"字典","type":"link","path":"basic/map.html"},{"text":"函数","type":"link","path":"basic/function.html"},{"text":"结构体","type":"link","path":"basic/struct.html"},{"text":"接口","type":"link","path":"basic/interface.html"},{"text":"面向对象","type":"link","path":"basic/oop.html"},{"text":"错误","type":"link","path":"basic/error.html"},{"text":"序列化","type":"link","path":"basic/json.html"},{"text":"反射","type":"link","path":"basic/reflect.html"},{"text":"测试","type":"link","path":"basic/test.html"},{"text":"并发编程","type":"label"},{"text":"goroutine","type":"link","path":"concurrent/goroutine.html"},{"text":"channel","type":"link","path":"concurrent/channel.html"},{"text":"同步和锁","type":"link","path":"concurrent/sync_lock.html"},{"text":"内存分配","type":"label"},{"text":"内存分配","type":"link","path":"advance/mm.html"},{"text":"垃圾回收","type":"label"},{"text":"垃圾回收","type":"link","path":"advance/gc.html"},{"text":"标准库","type":"label"},{"text":"fmt","type":"link","path":"standards/io/fmt.html"},{"text":"io","type":"link","path":"standards/io/io.html"},{"text":"ioutil","type":"link","path":"standards/io/ioutil.html"},{"text":"bufio","type":"link","path":"standards/io/bufio.html"},{"text":"os","type":"link","path":"standards/os/os.html"},{"text":"filepath","type":"link","path":"standards/os/filepath.html"},{"text":"strings","type":"link","path":"standards/text/strings.html"},{"text":"strconv","type":"link","path":"standards/text/strconv.html"},{"text":"unicode","type":"link","path":"standards/text/unicode.html"},{"text":"log","type":"link","path":"standards/log.html"},{"text":"time","type":"link","path":"standards/time.html"},{"text":"http","type":"link","path":"standards/net/http.html"},{"text":"math","type":"link","path":"standards/data/math.html"},{"text":"sort","type":"link","path":"standards/data/sort.html"},{"text":"big","type":"link","path":"standards/data/big.html"},{"text":"container","type":"link","path":"standards/data/container.html"},{"text":"sql","type":"link","path":"standards/database/sql.html"},{"text":"THEME","type":"label"},{"text":"使用文档主题","type":"link","path":"theme/theme-usage.html"},{"text":"SUPPORT AND FEEDBACK","type":"label"},{"text":"Raise an Issue on Github","type":"link","path":"https://github.com/shipengqi/golang-learn/issues/new"}]}}},"excerpt":"","more":"<h1 id=\"map\"><a href=\"#map\" class=\"headerlink\" title=\"map\"></a>map</h1><p><code>map</code> 是一个无序的 <code>key/value</code> 对的集合。<strong><code>map</code> 是引用类型</strong>。这意味着它拥有对底层数据结构的引用，<br>就像指针一样。它底层的数据结构是 <code>hash table</code> 或 <code>hash map</code>。</p>\n<p><code>map</code> 作为引用类型是非常好的，因为无论 <code>map</code> 有多大，都只会有一个副本。</p>\n<p>定义 <code>map</code>，使用 <code>map</code> 关键字：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 声明变量，默认 map 是 nil */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> 变量名 <span class=\"keyword\">map</span>[键类型]值类型</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 使用 make 函数 */</span></span><br><span class=\"line\">变量名 := <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[键类型]值类型)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 字面值的语法创建 */</span></span><br><span class=\"line\">变量名 := <span class=\"keyword\">map</span>[键类型]值类型&#123;</span><br><span class=\"line\">  key1: value1,</span><br><span class=\"line\">  key2: value2,</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>一个 <code>map</code> 在未初始化之前默认为 <code>nil</code>。<br>通过索引下标 <code>key</code> 来访问 <code>map</code> 中对应的 <code>value</code><br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">age, ok := ages[<span class=\"string\">\"bob\"</span>]</span><br><span class=\"line\"><span class=\"keyword\">if</span> !ok &#123; <span class=\"comment\">/* \"bob\" is not a key in this map; age == 0. */</span> &#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>ok</code> 表示操作结果，是一个布尔值。<strong>这叫做 <code>ok-idiom</code> 模式，就是在多返回值中返回一个 <code>ok</code> 布尔值，表示是否操作<br>成功</strong>。</p>\n<p>使用 <code>map</code> 过程中需要注意的几点：</p>\n<ul>\n<li><strong><code>map</code> 是无序的，每次打印出来的 <code>map</code> 都会不一样</strong>，它不能通过 <code>index</code> 获取，而必须通过 <code>key</code> 获取</li>\n<li><code>map</code> 的长度是不固定的，也就是和 <code>slice</code> 一样，也是一种引用类型</li>\n<li>内置的 <code>len</code> 函数同样适用于 <code>map</code>，返回 <code>map</code> 拥有的 <code>key</code> 的数量</li>\n<li><code>map</code> 的值可以很方便的修改，通过 <code>numbers[&quot;one&quot;]=11</code> 可以很容易的把 <code>key</code> 为 <code>one</code> 的字典值改为 11</li>\n<li><strong><code>map</code> 和其他基本型别不同，它不是 <code>thread-safe</code> 的</strong>，在多个 <code>go-routine</code> 存取时，必须使用 <code>mutex lock</code> 机制</li>\n</ul>\n<h4 id=\"delete\"><a href=\"#delete\" class=\"headerlink\" title=\"delete()\"></a>delete()</h4><p><code>delete</code> 函数删除 <code>map</code> 元素。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">delete</span>(mapName, key)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"遍历\"><a href=\"#遍历\" class=\"headerlink\" title=\"遍历\"></a>遍历</h4><p>可以使用 <code>for range</code> 遍历 <code>map</code>：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> key, value := <span class=\"keyword\">range</span> mapName &#123;</span><br><span class=\"line\">\tfmt.Println(mapName[key])</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong><code>Map</code> 的迭代顺序是不确定的。可以先使用 <code>sort</code> 包排序</strong>。</p>\n<h4 id=\"map-的键类型不能是哪些类型\"><a href=\"#map-的键类型不能是哪些类型\" class=\"headerlink\" title=\"map 的键类型不能是哪些类型\"></a>map 的键类型不能是哪些类型</h4><p><code>map</code> 的键和元素的最大不同在于，前者的类型是受限的，而后者却可以是任意类型的。</p>\n<p><strong><code>map</code> 的键类型不可以是函数类型、字典类型和切片类型</strong>。</p>\n<p>为什么？</p>\n<p>Go 语言规范规定，在<strong>键类型的值之间必须可以施加操作符 <code>==</code> 和 <code>!=</code></strong>。换句话说，键类型的值必须要支持判等操作。由于<br>函数类型、字典类型和切片类型的值并不支持判等操作，所以字典的键类型不能是这些类型。</p>\n<p>另外，如果键的类型是接口类型的，那么键值的实际类型也不能是上述三种类型，否则在程序运行过程中会引发 panic（即运行时恐慌）。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> badMap2 = <span class=\"keyword\">map</span>[<span class=\"keyword\">interface</span>&#123;&#125;]<span class=\"keyword\">int</span>&#123;</span><br><span class=\"line\"><span class=\"string\">\"1\"</span>:   <span class=\"number\">1</span>,</span><br><span class=\"line\">[]<span class=\"keyword\">int</span>&#123;<span class=\"number\">2</span>&#125;: <span class=\"number\">2</span>, <span class=\"comment\">// 这里会引发 panic。</span></span><br><span class=\"line\"><span class=\"number\">3</span>:    <span class=\"number\">3</span>,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"优先考虑哪些类型作为字典的键类型\"><a href=\"#优先考虑哪些类型作为字典的键类型\" class=\"headerlink\" title=\"优先考虑哪些类型作为字典的键类型\"></a>优先考虑哪些类型作为字典的键类型</h4><p>求哈希和判等操作的速度越快，对应的类型就越适合作为键类型。</p>\n<p>对于所有的基本类型、指针类型，以及数组类型、结构体类型和接口类型，Go 语言都有一套算法与之对应。这套算法中就包含了哈希和判等。<br>以求哈希的操作为例，宽度越小的类型速度通常越快。对于布尔类型、整数类型、浮点数类型、复数类型和指针类型来说都是如此。对于字<br>符串类型，由于它的宽度是不定的，所以要看它的值的具体长度，长度越短求哈希越快。</p>\n<p>类型的宽度是指它的单个值需要占用的字节数。比如，<code>bool</code>、<code>int8</code> 和 <code>uint8</code> 类型的一个值需要占用的字节数都是 1，因此这<br>些类型的宽度就都是 1。</p>\n<h4 id=\"在值为-nil-的字典上执行读写操作会成功吗\"><a href=\"#在值为-nil-的字典上执行读写操作会成功吗\" class=\"headerlink\" title=\"在值为 nil 的字典上执行读写操作会成功吗\"></a>在值为 nil 的字典上执行读写操作会成功吗</h4><p>当我们仅声明而不初始化一个字典类型的变量的时候，它的值会是 <code>nil</code>。如果你尝试使用一个 <code>nil</code> 的 <code>map</code>，你会<br>得到一个 <code>nil</code> 指针异常，这将导致程序终止运行。所以不应该初始化一个空的 map 变量，比如 <code>var m map[string]string</code>。</p>\n<p><strong>除了添加键 - 元素对，我们在一个值为 <code>nil</code> 的字典上做任何操作都不会引起错误</strong>。当我们试图在一个值为 <code>nil</code> 的字典中<br>添加键 - 元素对的时候，Go 语言的运行时系统就会立即抛出一个 panic。</p>\n<p>可以先使用 <code>make</code> 函数初始化，或者 <code>dictionary = map[string]string{}</code>。这两种方法都可以创建一个空的 <code>hash map</code><br> 并指向 <code>dictionary</code>。这确保永远不会获得 <code>nil 指针异常</code>。</p>\n"},{"title":"序列化","_content":"# 序列化\nGo 对于其他序列化协议如 `Json`，`XML`，`Protocol Buffers`，都有良好的支持，\n\n由标准库中的 `encoding/json`、`encoding/xml`、`encoding/asn1` 等包提供支持，`Protocol Buffers` 的\n由 `github.com/golang/protobuf` 包提供支持，并且这类包都有着相似的 API 接口。\n\nGO 中结构体转为 `JSON` 使用 `json.Marshal`，也就是编码操作：\n```go\ntype Movie struct {\n\tTitle  string\n\tYear   int  `json:\"released\"`\n\tColor  bool `json:\"color,omitempty\"`\n\tActors []string\n\tActors []string\n}\n\nvar movies = []Movie{\n\t{\n\t\tTitle: \"Casablanca\", \n\t\tYear: 1942, \n\t\tColor: false,\n\t\tActors: []string{\"Humphrey Bogart\", \"Ingrid Bergman\"}},\n\t{\n\t\tTitle: \"Cool Hand Luke\",\n\t\tYear: 1967, \n\t\tColor: true,\n\t\tActors: []string{\"Paul Newman\"}},\n\t{\n\t\tTitle: \"Bullitt\", \n\t\tYear: 1968, \n\t\tColor: true,\n\t\tActors: []string{\"Steve McQueen\", \"Jacqueline Bisset\"}}}\t\n\ndata, err := json.Marshal(movies)\nif err != nil {\n    log.Fatalf(\"JSON marshaling failed: %s\", err)\n}\nfmt.Printf(\"%s\\n\", data)\n```\n\n`json.MarshalIndent` 格式化输出 `JSON`，例如：\n```go\ndata, err := json.MarshalIndent(movies, \"\", \"    \")\nif err != nil {\n    log.Fatalf(\"JSON marshaling failed: %s\", err)\n}\nfmt.Printf(\"%s\\n\", data)\n```\n输出：\n```js\n[\n    {\n        \"Title\": \"Casablanca\",\n        \"released\": 1942,\n        \"Actors\": [\n            \"Humphrey Bogart\",\n            \"Ingrid Bergman\"\n        ]\n    },\n    {\n        \"Title\": \"Cool Hand Luke\",\n        \"released\": 1967,\n        \"color\": true,\n        \"Actors\": [\n            \"Paul Newman\"\n        ]\n    },\n    {\n        \"Title\": \"Bullitt\",\n        \"released\": 1968,\n        \"color\": true,\n        \"Actors\": [\n            \"Steve McQueen\",\n            \"Jacqueline Bisset\"\n        ]\n    }\n]\n```\n\n有没有注意到，`Year` 字段名的成员在编码后变成了 `released`，`Color` 变成了小写的 `color`。这是因为结构体的成员 Tag 导致的，\n如上面的：\n```go\nYear   int  `json:\"released\"`\nColor  bool `json:\"color,omitempty\"`\n```\n\n结构体的成员 Tag 可以是任意的字符串面值，但是通常是一系列用空格分隔的 `key:\"value\"` 键值对序列；因为值中含义双引号字符，\n因此成员 Tag 一般用原生字符串面值的形式书写。`json` 开头键名对应的值用于控制 `encoding/json` 包的编码和解码的行为，\n并且 `encoding/...` 下面其它的包也遵循这个约定。成员 `Tag` 中 `json` 对应值的第一部分用于指定 JSON 对象的名字，\n比如将 Go 语言中的 `TotalCount` 成员对应到 JSON 中的 `total_count` 对象。`Color` 成员的 Tag 还带了一个额外的 `omitempty` \n选项，表示当 Go 语言结构体成员为空或零值时不生成 JSON 对象（这里 `false` 为零值）。果然，`Casablanca` 是一个黑白电影，\n并没有输出 `Color` 成员。\n\n**注意，只有导出的结构体成员才会被编码**\n\n解码操作，使用`json.Unmarshal`：\n```go\nvar titles []struct{ Title string }\nif err := json.Unmarshal(data, &titles); err != nil {\n    log.Fatalf(\"JSON unmarshaling failed: %s\", err)\n}\nfmt.Println(titles) // \"[{Casablanca} {Cool Hand Luke} {Bullitt}]\"\n```\n通过定义合适的Go语言数据结构，我们可以选择性地解码JSON中感兴趣的成员。\n\n基于流式的解码器 `json.Decoder`。针对输出流的  `json.Encoder` 编码对象\n","source":"basic/json.md","raw":"---\ntitle: 序列化\n---\n# 序列化\nGo 对于其他序列化协议如 `Json`，`XML`，`Protocol Buffers`，都有良好的支持，\n\n由标准库中的 `encoding/json`、`encoding/xml`、`encoding/asn1` 等包提供支持，`Protocol Buffers` 的\n由 `github.com/golang/protobuf` 包提供支持，并且这类包都有着相似的 API 接口。\n\nGO 中结构体转为 `JSON` 使用 `json.Marshal`，也就是编码操作：\n```go\ntype Movie struct {\n\tTitle  string\n\tYear   int  `json:\"released\"`\n\tColor  bool `json:\"color,omitempty\"`\n\tActors []string\n\tActors []string\n}\n\nvar movies = []Movie{\n\t{\n\t\tTitle: \"Casablanca\", \n\t\tYear: 1942, \n\t\tColor: false,\n\t\tActors: []string{\"Humphrey Bogart\", \"Ingrid Bergman\"}},\n\t{\n\t\tTitle: \"Cool Hand Luke\",\n\t\tYear: 1967, \n\t\tColor: true,\n\t\tActors: []string{\"Paul Newman\"}},\n\t{\n\t\tTitle: \"Bullitt\", \n\t\tYear: 1968, \n\t\tColor: true,\n\t\tActors: []string{\"Steve McQueen\", \"Jacqueline Bisset\"}}}\t\n\ndata, err := json.Marshal(movies)\nif err != nil {\n    log.Fatalf(\"JSON marshaling failed: %s\", err)\n}\nfmt.Printf(\"%s\\n\", data)\n```\n\n`json.MarshalIndent` 格式化输出 `JSON`，例如：\n```go\ndata, err := json.MarshalIndent(movies, \"\", \"    \")\nif err != nil {\n    log.Fatalf(\"JSON marshaling failed: %s\", err)\n}\nfmt.Printf(\"%s\\n\", data)\n```\n输出：\n```js\n[\n    {\n        \"Title\": \"Casablanca\",\n        \"released\": 1942,\n        \"Actors\": [\n            \"Humphrey Bogart\",\n            \"Ingrid Bergman\"\n        ]\n    },\n    {\n        \"Title\": \"Cool Hand Luke\",\n        \"released\": 1967,\n        \"color\": true,\n        \"Actors\": [\n            \"Paul Newman\"\n        ]\n    },\n    {\n        \"Title\": \"Bullitt\",\n        \"released\": 1968,\n        \"color\": true,\n        \"Actors\": [\n            \"Steve McQueen\",\n            \"Jacqueline Bisset\"\n        ]\n    }\n]\n```\n\n有没有注意到，`Year` 字段名的成员在编码后变成了 `released`，`Color` 变成了小写的 `color`。这是因为结构体的成员 Tag 导致的，\n如上面的：\n```go\nYear   int  `json:\"released\"`\nColor  bool `json:\"color,omitempty\"`\n```\n\n结构体的成员 Tag 可以是任意的字符串面值，但是通常是一系列用空格分隔的 `key:\"value\"` 键值对序列；因为值中含义双引号字符，\n因此成员 Tag 一般用原生字符串面值的形式书写。`json` 开头键名对应的值用于控制 `encoding/json` 包的编码和解码的行为，\n并且 `encoding/...` 下面其它的包也遵循这个约定。成员 `Tag` 中 `json` 对应值的第一部分用于指定 JSON 对象的名字，\n比如将 Go 语言中的 `TotalCount` 成员对应到 JSON 中的 `total_count` 对象。`Color` 成员的 Tag 还带了一个额外的 `omitempty` \n选项，表示当 Go 语言结构体成员为空或零值时不生成 JSON 对象（这里 `false` 为零值）。果然，`Casablanca` 是一个黑白电影，\n并没有输出 `Color` 成员。\n\n**注意，只有导出的结构体成员才会被编码**\n\n解码操作，使用`json.Unmarshal`：\n```go\nvar titles []struct{ Title string }\nif err := json.Unmarshal(data, &titles); err != nil {\n    log.Fatalf(\"JSON unmarshaling failed: %s\", err)\n}\nfmt.Println(titles) // \"[{Casablanca} {Cool Hand Luke} {Bullitt}]\"\n```\n通过定义合适的Go语言数据结构，我们可以选择性地解码JSON中感兴趣的成员。\n\n基于流式的解码器 `json.Decoder`。针对输出流的  `json.Encoder` 编码对象\n","date":"2019-08-24T02:34:20.558Z","updated":"2019-08-24T02:34:20.535Z","path":"basic/json.html","comments":1,"layout":"page","_id":"ck1xm14kk000hfcw235zse0ku","content":"<h1 id=\"序列化\"><a href=\"#序列化\" class=\"headerlink\" title=\"序列化\"></a>序列化</h1><p>Go 对于其他序列化协议如 <code>Json</code>，<code>XML</code>，<code>Protocol Buffers</code>，都有良好的支持，</p>\n<p>由标准库中的 <code>encoding/json</code>、<code>encoding/xml</code>、<code>encoding/asn1</code> 等包提供支持，<code>Protocol Buffers</code> 的<br>由 <code>github.com/golang/protobuf</code> 包提供支持，并且这类包都有着相似的 API 接口。</p>\n<p>GO 中结构体转为 <code>JSON</code> 使用 <code>json.Marshal</code>，也就是编码操作：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Movie <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tTitle  <span class=\"keyword\">string</span></span><br><span class=\"line\">\tYear   <span class=\"keyword\">int</span>  <span class=\"string\">`json:\"released\"`</span></span><br><span class=\"line\">\tColor  <span class=\"keyword\">bool</span> <span class=\"string\">`json:\"color,omitempty\"`</span></span><br><span class=\"line\">\tActors []<span class=\"keyword\">string</span></span><br><span class=\"line\">\tActors []<span class=\"keyword\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> movies = []Movie&#123;</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tTitle: <span class=\"string\">\"Casablanca\"</span>, </span><br><span class=\"line\">\t\tYear: <span class=\"number\">1942</span>, </span><br><span class=\"line\">\t\tColor: <span class=\"literal\">false</span>,</span><br><span class=\"line\">\t\tActors: []<span class=\"keyword\">string</span>&#123;<span class=\"string\">\"Humphrey Bogart\"</span>, <span class=\"string\">\"Ingrid Bergman\"</span>&#125;&#125;,</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tTitle: <span class=\"string\">\"Cool Hand Luke\"</span>,</span><br><span class=\"line\">\t\tYear: <span class=\"number\">1967</span>, </span><br><span class=\"line\">\t\tColor: <span class=\"literal\">true</span>,</span><br><span class=\"line\">\t\tActors: []<span class=\"keyword\">string</span>&#123;<span class=\"string\">\"Paul Newman\"</span>&#125;&#125;,</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tTitle: <span class=\"string\">\"Bullitt\"</span>, </span><br><span class=\"line\">\t\tYear: <span class=\"number\">1968</span>, </span><br><span class=\"line\">\t\tColor: <span class=\"literal\">true</span>,</span><br><span class=\"line\">\t\tActors: []<span class=\"keyword\">string</span>&#123;<span class=\"string\">\"Steve McQueen\"</span>, <span class=\"string\">\"Jacqueline Bisset\"</span>&#125;&#125;&#125;\t</span><br><span class=\"line\"></span><br><span class=\"line\">data, err := json.Marshal(movies)</span><br><span class=\"line\"><span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    log.Fatalf(<span class=\"string\">\"JSON marshaling failed: %s\"</span>, err)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fmt.Printf(<span class=\"string\">\"%s\\n\"</span>, data)</span><br></pre></td></tr></table></figure></p>\n<p><code>json.MarshalIndent</code> 格式化输出 <code>JSON</code>，例如：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">data, err := json.MarshalIndent(movies, <span class=\"string\">\"\"</span>, <span class=\"string\">\"    \"</span>)</span><br><span class=\"line\"><span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    log.Fatalf(<span class=\"string\">\"JSON marshaling failed: %s\"</span>, err)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fmt.Printf(<span class=\"string\">\"%s\\n\"</span>, data)</span><br></pre></td></tr></table></figure></p>\n<p>输出：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"string\">\"Title\"</span>: <span class=\"string\">\"Casablanca\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"released\"</span>: <span class=\"number\">1942</span>,</span><br><span class=\"line\">        <span class=\"string\">\"Actors\"</span>: [</span><br><span class=\"line\">            <span class=\"string\">\"Humphrey Bogart\"</span>,</span><br><span class=\"line\">            <span class=\"string\">\"Ingrid Bergman\"</span></span><br><span class=\"line\">        ]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"string\">\"Title\"</span>: <span class=\"string\">\"Cool Hand Luke\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"released\"</span>: <span class=\"number\">1967</span>,</span><br><span class=\"line\">        <span class=\"string\">\"color\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        <span class=\"string\">\"Actors\"</span>: [</span><br><span class=\"line\">            <span class=\"string\">\"Paul Newman\"</span></span><br><span class=\"line\">        ]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"string\">\"Title\"</span>: <span class=\"string\">\"Bullitt\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"released\"</span>: <span class=\"number\">1968</span>,</span><br><span class=\"line\">        <span class=\"string\">\"color\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        <span class=\"string\">\"Actors\"</span>: [</span><br><span class=\"line\">            <span class=\"string\">\"Steve McQueen\"</span>,</span><br><span class=\"line\">            <span class=\"string\">\"Jacqueline Bisset\"</span></span><br><span class=\"line\">        ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure></p>\n<p>有没有注意到，<code>Year</code> 字段名的成员在编码后变成了 <code>released</code>，<code>Color</code> 变成了小写的 <code>color</code>。这是因为结构体的成员 Tag 导致的，<br>如上面的：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Year   <span class=\"keyword\">int</span>  <span class=\"string\">`json:\"released\"`</span></span><br><span class=\"line\">Color  <span class=\"keyword\">bool</span> <span class=\"string\">`json:\"color,omitempty\"`</span></span><br></pre></td></tr></table></figure></p>\n<p>结构体的成员 Tag 可以是任意的字符串面值，但是通常是一系列用空格分隔的 <code>key:&quot;value&quot;</code> 键值对序列；因为值中含义双引号字符，<br>因此成员 Tag 一般用原生字符串面值的形式书写。<code>json</code> 开头键名对应的值用于控制 <code>encoding/json</code> 包的编码和解码的行为，<br>并且 <code>encoding/...</code> 下面其它的包也遵循这个约定。成员 <code>Tag</code> 中 <code>json</code> 对应值的第一部分用于指定 JSON 对象的名字，<br>比如将 Go 语言中的 <code>TotalCount</code> 成员对应到 JSON 中的 <code>total_count</code> 对象。<code>Color</code> 成员的 Tag 还带了一个额外的 <code>omitempty</code><br>选项，表示当 Go 语言结构体成员为空或零值时不生成 JSON 对象（这里 <code>false</code> 为零值）。果然，<code>Casablanca</code> 是一个黑白电影，<br>并没有输出 <code>Color</code> 成员。</p>\n<p><strong>注意，只有导出的结构体成员才会被编码</strong></p>\n<p>解码操作，使用<code>json.Unmarshal</code>：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> titles []<span class=\"keyword\">struct</span>&#123; Title <span class=\"keyword\">string</span> &#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span> err := json.Unmarshal(data, &amp;titles); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    log.Fatalf(<span class=\"string\">\"JSON unmarshaling failed: %s\"</span>, err)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fmt.Println(titles) <span class=\"comment\">// \"[&#123;Casablanca&#125; &#123;Cool Hand Luke&#125; &#123;Bullitt&#125;]\"</span></span><br></pre></td></tr></table></figure></p>\n<p>通过定义合适的Go语言数据结构，我们可以选择性地解码JSON中感兴趣的成员。</p>\n<p>基于流式的解码器 <code>json.Decoder</code>。针对输出流的  <code>json.Encoder</code> 编码对象</p>\n","site":{"data":{"navigation":{"logo":{"text":"Golang Learn","type":"link","path":"index.html"},"main":[{"text":"Golang 基础","type":"label"},{"text":"Go 环境配置","type":"link","path":"basic/env_config.html"},{"text":"包","type":"link","path":"basic/package.html"},{"text":"基础数据类型","type":"link","path":"basic/basic_data.html"},{"text":"变量","type":"link","path":"basic/var.html"},{"text":"常量","type":"link","path":"basic/constant.html"},{"text":"控制语句","type":"link","path":"basic/flow.html"},{"text":"运算符","type":"link","path":"basic/operator.html"},{"text":"作用域","type":"link","path":"basic/scope.html"},{"text":"指针","type":"link","path":"basic/pointer.html"},{"text":"数组","type":"link","path":"basic/array.html"},{"text":"切片","type":"link","path":"basic/slice.html"},{"text":"字典","type":"link","path":"basic/map.html"},{"text":"函数","type":"link","path":"basic/function.html"},{"text":"结构体","type":"link","path":"basic/struct.html"},{"text":"接口","type":"link","path":"basic/interface.html"},{"text":"面向对象","type":"link","path":"basic/oop.html"},{"text":"错误","type":"link","path":"basic/error.html"},{"text":"序列化","type":"link","path":"basic/json.html"},{"text":"反射","type":"link","path":"basic/reflect.html"},{"text":"测试","type":"link","path":"basic/test.html"},{"text":"并发编程","type":"label"},{"text":"goroutine","type":"link","path":"concurrent/goroutine.html"},{"text":"channel","type":"link","path":"concurrent/channel.html"},{"text":"同步和锁","type":"link","path":"concurrent/sync_lock.html"},{"text":"内存分配","type":"label"},{"text":"内存分配","type":"link","path":"advance/mm.html"},{"text":"垃圾回收","type":"label"},{"text":"垃圾回收","type":"link","path":"advance/gc.html"},{"text":"标准库","type":"label"},{"text":"fmt","type":"link","path":"standards/io/fmt.html"},{"text":"io","type":"link","path":"standards/io/io.html"},{"text":"ioutil","type":"link","path":"standards/io/ioutil.html"},{"text":"bufio","type":"link","path":"standards/io/bufio.html"},{"text":"os","type":"link","path":"standards/os/os.html"},{"text":"filepath","type":"link","path":"standards/os/filepath.html"},{"text":"strings","type":"link","path":"standards/text/strings.html"},{"text":"strconv","type":"link","path":"standards/text/strconv.html"},{"text":"unicode","type":"link","path":"standards/text/unicode.html"},{"text":"log","type":"link","path":"standards/log.html"},{"text":"time","type":"link","path":"standards/time.html"},{"text":"http","type":"link","path":"standards/net/http.html"},{"text":"math","type":"link","path":"standards/data/math.html"},{"text":"sort","type":"link","path":"standards/data/sort.html"},{"text":"big","type":"link","path":"standards/data/big.html"},{"text":"container","type":"link","path":"standards/data/container.html"},{"text":"sql","type":"link","path":"standards/database/sql.html"},{"text":"THEME","type":"label"},{"text":"使用文档主题","type":"link","path":"theme/theme-usage.html"},{"text":"SUPPORT AND FEEDBACK","type":"label"},{"text":"Raise an Issue on Github","type":"link","path":"https://github.com/shipengqi/golang-learn/issues/new"}]}}},"excerpt":"","more":"<h1 id=\"序列化\"><a href=\"#序列化\" class=\"headerlink\" title=\"序列化\"></a>序列化</h1><p>Go 对于其他序列化协议如 <code>Json</code>，<code>XML</code>，<code>Protocol Buffers</code>，都有良好的支持，</p>\n<p>由标准库中的 <code>encoding/json</code>、<code>encoding/xml</code>、<code>encoding/asn1</code> 等包提供支持，<code>Protocol Buffers</code> 的<br>由 <code>github.com/golang/protobuf</code> 包提供支持，并且这类包都有着相似的 API 接口。</p>\n<p>GO 中结构体转为 <code>JSON</code> 使用 <code>json.Marshal</code>，也就是编码操作：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Movie <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tTitle  <span class=\"keyword\">string</span></span><br><span class=\"line\">\tYear   <span class=\"keyword\">int</span>  <span class=\"string\">`json:\"released\"`</span></span><br><span class=\"line\">\tColor  <span class=\"keyword\">bool</span> <span class=\"string\">`json:\"color,omitempty\"`</span></span><br><span class=\"line\">\tActors []<span class=\"keyword\">string</span></span><br><span class=\"line\">\tActors []<span class=\"keyword\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> movies = []Movie&#123;</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tTitle: <span class=\"string\">\"Casablanca\"</span>, </span><br><span class=\"line\">\t\tYear: <span class=\"number\">1942</span>, </span><br><span class=\"line\">\t\tColor: <span class=\"literal\">false</span>,</span><br><span class=\"line\">\t\tActors: []<span class=\"keyword\">string</span>&#123;<span class=\"string\">\"Humphrey Bogart\"</span>, <span class=\"string\">\"Ingrid Bergman\"</span>&#125;&#125;,</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tTitle: <span class=\"string\">\"Cool Hand Luke\"</span>,</span><br><span class=\"line\">\t\tYear: <span class=\"number\">1967</span>, </span><br><span class=\"line\">\t\tColor: <span class=\"literal\">true</span>,</span><br><span class=\"line\">\t\tActors: []<span class=\"keyword\">string</span>&#123;<span class=\"string\">\"Paul Newman\"</span>&#125;&#125;,</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tTitle: <span class=\"string\">\"Bullitt\"</span>, </span><br><span class=\"line\">\t\tYear: <span class=\"number\">1968</span>, </span><br><span class=\"line\">\t\tColor: <span class=\"literal\">true</span>,</span><br><span class=\"line\">\t\tActors: []<span class=\"keyword\">string</span>&#123;<span class=\"string\">\"Steve McQueen\"</span>, <span class=\"string\">\"Jacqueline Bisset\"</span>&#125;&#125;&#125;\t</span><br><span class=\"line\"></span><br><span class=\"line\">data, err := json.Marshal(movies)</span><br><span class=\"line\"><span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    log.Fatalf(<span class=\"string\">\"JSON marshaling failed: %s\"</span>, err)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fmt.Printf(<span class=\"string\">\"%s\\n\"</span>, data)</span><br></pre></td></tr></table></figure></p>\n<p><code>json.MarshalIndent</code> 格式化输出 <code>JSON</code>，例如：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">data, err := json.MarshalIndent(movies, <span class=\"string\">\"\"</span>, <span class=\"string\">\"    \"</span>)</span><br><span class=\"line\"><span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    log.Fatalf(<span class=\"string\">\"JSON marshaling failed: %s\"</span>, err)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fmt.Printf(<span class=\"string\">\"%s\\n\"</span>, data)</span><br></pre></td></tr></table></figure></p>\n<p>输出：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"string\">\"Title\"</span>: <span class=\"string\">\"Casablanca\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"released\"</span>: <span class=\"number\">1942</span>,</span><br><span class=\"line\">        <span class=\"string\">\"Actors\"</span>: [</span><br><span class=\"line\">            <span class=\"string\">\"Humphrey Bogart\"</span>,</span><br><span class=\"line\">            <span class=\"string\">\"Ingrid Bergman\"</span></span><br><span class=\"line\">        ]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"string\">\"Title\"</span>: <span class=\"string\">\"Cool Hand Luke\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"released\"</span>: <span class=\"number\">1967</span>,</span><br><span class=\"line\">        <span class=\"string\">\"color\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        <span class=\"string\">\"Actors\"</span>: [</span><br><span class=\"line\">            <span class=\"string\">\"Paul Newman\"</span></span><br><span class=\"line\">        ]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"string\">\"Title\"</span>: <span class=\"string\">\"Bullitt\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"released\"</span>: <span class=\"number\">1968</span>,</span><br><span class=\"line\">        <span class=\"string\">\"color\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        <span class=\"string\">\"Actors\"</span>: [</span><br><span class=\"line\">            <span class=\"string\">\"Steve McQueen\"</span>,</span><br><span class=\"line\">            <span class=\"string\">\"Jacqueline Bisset\"</span></span><br><span class=\"line\">        ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure></p>\n<p>有没有注意到，<code>Year</code> 字段名的成员在编码后变成了 <code>released</code>，<code>Color</code> 变成了小写的 <code>color</code>。这是因为结构体的成员 Tag 导致的，<br>如上面的：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Year   <span class=\"keyword\">int</span>  <span class=\"string\">`json:\"released\"`</span></span><br><span class=\"line\">Color  <span class=\"keyword\">bool</span> <span class=\"string\">`json:\"color,omitempty\"`</span></span><br></pre></td></tr></table></figure></p>\n<p>结构体的成员 Tag 可以是任意的字符串面值，但是通常是一系列用空格分隔的 <code>key:&quot;value&quot;</code> 键值对序列；因为值中含义双引号字符，<br>因此成员 Tag 一般用原生字符串面值的形式书写。<code>json</code> 开头键名对应的值用于控制 <code>encoding/json</code> 包的编码和解码的行为，<br>并且 <code>encoding/...</code> 下面其它的包也遵循这个约定。成员 <code>Tag</code> 中 <code>json</code> 对应值的第一部分用于指定 JSON 对象的名字，<br>比如将 Go 语言中的 <code>TotalCount</code> 成员对应到 JSON 中的 <code>total_count</code> 对象。<code>Color</code> 成员的 Tag 还带了一个额外的 <code>omitempty</code><br>选项，表示当 Go 语言结构体成员为空或零值时不生成 JSON 对象（这里 <code>false</code> 为零值）。果然，<code>Casablanca</code> 是一个黑白电影，<br>并没有输出 <code>Color</code> 成员。</p>\n<p><strong>注意，只有导出的结构体成员才会被编码</strong></p>\n<p>解码操作，使用<code>json.Unmarshal</code>：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> titles []<span class=\"keyword\">struct</span>&#123; Title <span class=\"keyword\">string</span> &#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span> err := json.Unmarshal(data, &amp;titles); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    log.Fatalf(<span class=\"string\">\"JSON unmarshaling failed: %s\"</span>, err)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fmt.Println(titles) <span class=\"comment\">// \"[&#123;Casablanca&#125; &#123;Cool Hand Luke&#125; &#123;Bullitt&#125;]\"</span></span><br></pre></td></tr></table></figure></p>\n<p>通过定义合适的Go语言数据结构，我们可以选择性地解码JSON中感兴趣的成员。</p>\n<p>基于流式的解码器 <code>json.Decoder</code>。针对输出流的  <code>json.Encoder</code> 编码对象</p>\n"},{"title":"指针","_content":"# 指针\n\n**指针和内存地址不能混为一谈**。内存地址是内存中每个字节单元的唯一编号，而指针是一个实体。指针也会分配内存空间，相当于一个\n保存内存地址的整形变量。\n\n```go\nx := 1\np := &x         // p, of type *int, points to x\nfmt.Println(*p) // \"1\"\n*p = 2          // equivalent to x = 2\nfmt.Println(x)  // \"2\"\n```\n\n上面的代码，初始化一个变量 `x`，`&` 是取地址操作，`&x` 就是取变量 `x` 的内存地址，那么 `p` 就是一个指针，\n类型是 `*int`，`p` 这个指针保存了变量 `x` 的内存地址。接下来 `*p` 表示读取指针指向的变量的值，也就是变量 `x` 的值 1。\n`*p`也可以被赋值。\n\n任何类型的指针的零值都是 `nil`。当指针指向同一个变量或者 `nil` 时是相等的。\n当一个指针被定义后没有分配到任何变量时，它的值为 `nil`。`nil` 指针也称为空指针。\n\n## 指向指针的指针\n```go\nvar a int\nvar ptr *int\nvar pptr **int\n\na = 3000\n\n/* 指针 ptr 地址 */\nptr = &a\n\n/* 指向指针 ptr 地址 */\npptr = &ptr\n\n/* 获取 pptr 的值 */\nfmt.Printf(\"变量 a = %d\\n\", a )\nfmt.Printf(\"指针变量 *ptr = %d\\n\", *ptr )\nfmt.Printf(\"指向指针的指针变量 **pptr = %d\\n\", **pptr)\n```\n\n## 为什么需要指针\n相比 Java，Python，Javascript 等引用类型的语言，Golang 拥有类似C语言的指针这个相对古老的特性。但不同于 C 语言，Golang 的指\n针是单独的类型，而且也不能对指针做整数运算。从这一点看，Golang 的指针基本就是一种引用。\n\n在学习引用类型语言的时候，总是要先搞清楚，当给一个 `函数/方法` 传参的时候，传进去的是值还是引用。实际上，在大部分引用型语言里，\n参数为基本类型时，传进去的大都是值，也就是另外复制了一份参数到当前的函数调用栈。参数为高级类型时，传进去的基本都是引用。\n\n内存管理中的内存区域一般包括 `heap` 和 `stack`，`stack` 主要用来存储当前调用栈用到的简单类型数据：`string`，`boolean`，\n`int`，`float` 等。这些类型的内存占用小，容易回收，基本上它们的值和指针占用的空间差不多，因此可以直接复制，`GC` 也比较容易做针对性的\n优化。复杂的高级类型占用的内存往往相对较大，存储在 `heap` 中，`GC` 回收频率相对较低，代价也较大，因此传 `引用/指针` 可以避免进行成本较\n高的复制操作，并且节省内存，提高程序运行效率。\n\n因此，在下列情况可以考虑使用指针：\n1. **需要改变参数的值**\n2. **避免复制操作**\n3. **节省内存**\n\n而在 Golang 中，具体到高级类型 `struct`，`slice`，`map` 也各有不同。实际上，只有 `struct` 的使用有点复杂，**`slice`，`map`，\n`chan`都可以直接使用，不用考虑是值还是指针**。\n\n### `struct`\n\n对于函数（`function`），由函数的参数类型指定，传入的参数的类型不对会报错，例如：\n```go\nfunc passValue(s struct){}\n\nfunc passPointer(s *struct){}\n```\n\n对于方法（`method`），接收者（`receiver`）可以是指针，也可以是值，Golang 会在传递参数前自动适配以符合参数的类型。也就是：如果方法的参数\n是值，那么按照传值的方式 ，方法内部对 `struct` 的改动无法作用在外部的变量上，例如：\n```go\npackage main\n\nimport \"fmt\"\n\ntype MyPoint struct {\n    X int\n    Y int\n}\n\nfunc printFuncValue(p MyPoint){\n    p.X = 1\n    p.Y = 1\n    fmt.Printf(\" -> %v\", p)\n}\n\nfunc printFuncPointer(pp *MyPoint){\n    pp.X = 1 // 实际上应该写做 (*pp).X，Golang 给了语法糖，减少了麻烦，但是也导致了 * 的不一致\n    pp.Y = 1\n    fmt.Printf(\" -> %v\", pp)\n}\n\nfunc (p MyPoint) printMethodValue(){\n    p.X += 1\n    p.Y += 1\n    fmt.Printf(\" -> %v\", p)\n}\n\n// 建议使用指针作为方法（method：printMethodPointer）的接收者（receiver：*MyPoint），一是可以修改接收者的值，二是可以避免大对象的复制\nfunc (pp *MyPoint) printMethodPointer(){\n    pp.X += 1\n    pp.Y += 1\n    fmt.Printf(\" -> %v\", pp)\n}\n\nfunc main(){\n    p := MyPoint{0, 0}\n    pp := &MyPoint{0, 0}\n\n    fmt.Printf(\"\\n value to func(value): %v\", p)\n    printFuncValue(p)\n    fmt.Printf(\" --> %v\", p)\n    // Output: value to func(value): {0 0} -> {1 1} --> {0 0}\n\n    //printFuncValue(pp) // cannot use pp (type *MyPoint) as type MyPoint in argument to printFuncValue\n\n    //printFuncPointer(p) // cannot use p (type MyPoint) as type *MyPoint in argument to printFuncPointer\n\n    fmt.Printf(\"\\n pointer to func(pointer): %v\", pp)\n    printFuncPointer(pp)\n    fmt.Printf(\" --> %v\", pp)\n    // Output: pointer to func(pointer): &{0 0} -> &{1 1} --> &{1 1}\n\n    fmt.Printf(\"\\n value to method(value): %v\", p)\n    p.printMethodValue()\n    fmt.Printf(\" --> %v\", p)\n    // Output: value to method(value): {0 0} -> {1 1} --> {0 0}\n\n    fmt.Printf(\"\\n value to method(pointer): %v\", p)\n    p.printMethodPointer()\n    fmt.Printf(\" --> %v\", p)\n    // Output: value to method(pointer): {0 0} -> &{1 1} --> {1 1}\n\n    fmt.Printf(\"\\n pointer to method(value): %v\", pp)\n    pp.printMethodValue()\n    fmt.Printf(\" --> %v\", pp)\n    // Output: pointer to method(value): &{1 1} -> {2 2} --> &{1 1}\n\n    fmt.Printf(\"\\n pointer to method(pointer): %v\", pp)\n    pp.printMethodPointer()\n    fmt.Printf(\" --> %v\", pp)\n    // Output: pointer to method(pointer): &{1 1} -> &{2 2} --> &{2 2}\n}\n```\n\n### `slice`\n**`slice` 实际上相当于对其依附的 `array` 的引用，它不存储数据，只是对 `array` 进行描述。因此，修改 `slice` 中的元素，\n改变会体现在 `array` 上，当然也会体现在该 `array` 的所有 `slice` 上**。\n\n### map\n\n**使用 `make(map[string]string)` 返回的本身是个引用，可以直接用来操作**：\n```go\nmap[\"name\"]=\"Jason\"\n```\n\n而**如果使用 `map` 的指针，反而会产生错误**：\n```go\n*map[\"name\"]=\"Jason\"  //  invalid indirect of m[\"title\"] (type string)\n(*map)[\"name\"]=\"Jason\"  // invalid indirect of m (type map[string]string)\n```\n\n## 哪些值是不可寻址的\n1. **不可变的值不可寻址**。常量、基本类型的值字面量、字符串变量的值、函数以及方法的字面量都是如此。\n其实这样规定也有安全性方面的考虑。\n2. 绝大多数被视为**临时结果的值都是不可寻址的**。算术操作的结果值属于临时结果，针对值字面量的表达式结果值也属于临时结果。\n但有一个例外，对切片字面量的索引结果值虽然也属于临时结果，但却是可寻址的。函数的返回值也是临时结果。`++` 和 `--` 并不属\n于操作符。\n3. **不安全的值不可寻址**，若拿到某值的指针可能会破坏程序的一致性，那么就是不安全的。由于字典的内部机制，对字典的索\n引结果值的取址操作都是不安全的。另外，获取由字面量或标识符代表的函数或方法的地址显然也是不安全的。","source":"basic/pointer.md","raw":"---\ntitle: 指针\n---\n# 指针\n\n**指针和内存地址不能混为一谈**。内存地址是内存中每个字节单元的唯一编号，而指针是一个实体。指针也会分配内存空间，相当于一个\n保存内存地址的整形变量。\n\n```go\nx := 1\np := &x         // p, of type *int, points to x\nfmt.Println(*p) // \"1\"\n*p = 2          // equivalent to x = 2\nfmt.Println(x)  // \"2\"\n```\n\n上面的代码，初始化一个变量 `x`，`&` 是取地址操作，`&x` 就是取变量 `x` 的内存地址，那么 `p` 就是一个指针，\n类型是 `*int`，`p` 这个指针保存了变量 `x` 的内存地址。接下来 `*p` 表示读取指针指向的变量的值，也就是变量 `x` 的值 1。\n`*p`也可以被赋值。\n\n任何类型的指针的零值都是 `nil`。当指针指向同一个变量或者 `nil` 时是相等的。\n当一个指针被定义后没有分配到任何变量时，它的值为 `nil`。`nil` 指针也称为空指针。\n\n## 指向指针的指针\n```go\nvar a int\nvar ptr *int\nvar pptr **int\n\na = 3000\n\n/* 指针 ptr 地址 */\nptr = &a\n\n/* 指向指针 ptr 地址 */\npptr = &ptr\n\n/* 获取 pptr 的值 */\nfmt.Printf(\"变量 a = %d\\n\", a )\nfmt.Printf(\"指针变量 *ptr = %d\\n\", *ptr )\nfmt.Printf(\"指向指针的指针变量 **pptr = %d\\n\", **pptr)\n```\n\n## 为什么需要指针\n相比 Java，Python，Javascript 等引用类型的语言，Golang 拥有类似C语言的指针这个相对古老的特性。但不同于 C 语言，Golang 的指\n针是单独的类型，而且也不能对指针做整数运算。从这一点看，Golang 的指针基本就是一种引用。\n\n在学习引用类型语言的时候，总是要先搞清楚，当给一个 `函数/方法` 传参的时候，传进去的是值还是引用。实际上，在大部分引用型语言里，\n参数为基本类型时，传进去的大都是值，也就是另外复制了一份参数到当前的函数调用栈。参数为高级类型时，传进去的基本都是引用。\n\n内存管理中的内存区域一般包括 `heap` 和 `stack`，`stack` 主要用来存储当前调用栈用到的简单类型数据：`string`，`boolean`，\n`int`，`float` 等。这些类型的内存占用小，容易回收，基本上它们的值和指针占用的空间差不多，因此可以直接复制，`GC` 也比较容易做针对性的\n优化。复杂的高级类型占用的内存往往相对较大，存储在 `heap` 中，`GC` 回收频率相对较低，代价也较大，因此传 `引用/指针` 可以避免进行成本较\n高的复制操作，并且节省内存，提高程序运行效率。\n\n因此，在下列情况可以考虑使用指针：\n1. **需要改变参数的值**\n2. **避免复制操作**\n3. **节省内存**\n\n而在 Golang 中，具体到高级类型 `struct`，`slice`，`map` 也各有不同。实际上，只有 `struct` 的使用有点复杂，**`slice`，`map`，\n`chan`都可以直接使用，不用考虑是值还是指针**。\n\n### `struct`\n\n对于函数（`function`），由函数的参数类型指定，传入的参数的类型不对会报错，例如：\n```go\nfunc passValue(s struct){}\n\nfunc passPointer(s *struct){}\n```\n\n对于方法（`method`），接收者（`receiver`）可以是指针，也可以是值，Golang 会在传递参数前自动适配以符合参数的类型。也就是：如果方法的参数\n是值，那么按照传值的方式 ，方法内部对 `struct` 的改动无法作用在外部的变量上，例如：\n```go\npackage main\n\nimport \"fmt\"\n\ntype MyPoint struct {\n    X int\n    Y int\n}\n\nfunc printFuncValue(p MyPoint){\n    p.X = 1\n    p.Y = 1\n    fmt.Printf(\" -> %v\", p)\n}\n\nfunc printFuncPointer(pp *MyPoint){\n    pp.X = 1 // 实际上应该写做 (*pp).X，Golang 给了语法糖，减少了麻烦，但是也导致了 * 的不一致\n    pp.Y = 1\n    fmt.Printf(\" -> %v\", pp)\n}\n\nfunc (p MyPoint) printMethodValue(){\n    p.X += 1\n    p.Y += 1\n    fmt.Printf(\" -> %v\", p)\n}\n\n// 建议使用指针作为方法（method：printMethodPointer）的接收者（receiver：*MyPoint），一是可以修改接收者的值，二是可以避免大对象的复制\nfunc (pp *MyPoint) printMethodPointer(){\n    pp.X += 1\n    pp.Y += 1\n    fmt.Printf(\" -> %v\", pp)\n}\n\nfunc main(){\n    p := MyPoint{0, 0}\n    pp := &MyPoint{0, 0}\n\n    fmt.Printf(\"\\n value to func(value): %v\", p)\n    printFuncValue(p)\n    fmt.Printf(\" --> %v\", p)\n    // Output: value to func(value): {0 0} -> {1 1} --> {0 0}\n\n    //printFuncValue(pp) // cannot use pp (type *MyPoint) as type MyPoint in argument to printFuncValue\n\n    //printFuncPointer(p) // cannot use p (type MyPoint) as type *MyPoint in argument to printFuncPointer\n\n    fmt.Printf(\"\\n pointer to func(pointer): %v\", pp)\n    printFuncPointer(pp)\n    fmt.Printf(\" --> %v\", pp)\n    // Output: pointer to func(pointer): &{0 0} -> &{1 1} --> &{1 1}\n\n    fmt.Printf(\"\\n value to method(value): %v\", p)\n    p.printMethodValue()\n    fmt.Printf(\" --> %v\", p)\n    // Output: value to method(value): {0 0} -> {1 1} --> {0 0}\n\n    fmt.Printf(\"\\n value to method(pointer): %v\", p)\n    p.printMethodPointer()\n    fmt.Printf(\" --> %v\", p)\n    // Output: value to method(pointer): {0 0} -> &{1 1} --> {1 1}\n\n    fmt.Printf(\"\\n pointer to method(value): %v\", pp)\n    pp.printMethodValue()\n    fmt.Printf(\" --> %v\", pp)\n    // Output: pointer to method(value): &{1 1} -> {2 2} --> &{1 1}\n\n    fmt.Printf(\"\\n pointer to method(pointer): %v\", pp)\n    pp.printMethodPointer()\n    fmt.Printf(\" --> %v\", pp)\n    // Output: pointer to method(pointer): &{1 1} -> &{2 2} --> &{2 2}\n}\n```\n\n### `slice`\n**`slice` 实际上相当于对其依附的 `array` 的引用，它不存储数据，只是对 `array` 进行描述。因此，修改 `slice` 中的元素，\n改变会体现在 `array` 上，当然也会体现在该 `array` 的所有 `slice` 上**。\n\n### map\n\n**使用 `make(map[string]string)` 返回的本身是个引用，可以直接用来操作**：\n```go\nmap[\"name\"]=\"Jason\"\n```\n\n而**如果使用 `map` 的指针，反而会产生错误**：\n```go\n*map[\"name\"]=\"Jason\"  //  invalid indirect of m[\"title\"] (type string)\n(*map)[\"name\"]=\"Jason\"  // invalid indirect of m (type map[string]string)\n```\n\n## 哪些值是不可寻址的\n1. **不可变的值不可寻址**。常量、基本类型的值字面量、字符串变量的值、函数以及方法的字面量都是如此。\n其实这样规定也有安全性方面的考虑。\n2. 绝大多数被视为**临时结果的值都是不可寻址的**。算术操作的结果值属于临时结果，针对值字面量的表达式结果值也属于临时结果。\n但有一个例外，对切片字面量的索引结果值虽然也属于临时结果，但却是可寻址的。函数的返回值也是临时结果。`++` 和 `--` 并不属\n于操作符。\n3. **不安全的值不可寻址**，若拿到某值的指针可能会破坏程序的一致性，那么就是不安全的。由于字典的内部机制，对字典的索\n引结果值的取址操作都是不安全的。另外，获取由字面量或标识符代表的函数或方法的地址显然也是不安全的。","date":"2019-08-28T00:15:07.511Z","updated":"2019-08-28T00:15:07.511Z","path":"basic/pointer.html","comments":1,"layout":"page","_id":"ck1xm14kl000ifcw2x1zlpvul","content":"<h1 id=\"指针\"><a href=\"#指针\" class=\"headerlink\" title=\"指针\"></a>指针</h1><p><strong>指针和内存地址不能混为一谈</strong>。内存地址是内存中每个字节单元的唯一编号，而指针是一个实体。指针也会分配内存空间，相当于一个<br>保存内存地址的整形变量。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x := <span class=\"number\">1</span></span><br><span class=\"line\">p := &amp;x         <span class=\"comment\">// p, of type *int, points to x</span></span><br><span class=\"line\">fmt.Println(*p) <span class=\"comment\">// \"1\"</span></span><br><span class=\"line\">*p = <span class=\"number\">2</span>          <span class=\"comment\">// equivalent to x = 2</span></span><br><span class=\"line\">fmt.Println(x)  <span class=\"comment\">// \"2\"</span></span><br></pre></td></tr></table></figure>\n<p>上面的代码，初始化一个变量 <code>x</code>，<code>&amp;</code> 是取地址操作，<code>&amp;x</code> 就是取变量 <code>x</code> 的内存地址，那么 <code>p</code> 就是一个指针，<br>类型是 <code>*int</code>，<code>p</code> 这个指针保存了变量 <code>x</code> 的内存地址。接下来 <code>*p</code> 表示读取指针指向的变量的值，也就是变量 <code>x</code> 的值 1。<br><code>*p</code>也可以被赋值。</p>\n<p>任何类型的指针的零值都是 <code>nil</code>。当指针指向同一个变量或者 <code>nil</code> 时是相等的。<br>当一个指针被定义后没有分配到任何变量时，它的值为 <code>nil</code>。<code>nil</code> 指针也称为空指针。</p>\n<h2 id=\"指向指针的指针\"><a href=\"#指向指针的指针\" class=\"headerlink\" title=\"指向指针的指针\"></a>指向指针的指针</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a <span class=\"keyword\">int</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> ptr *<span class=\"keyword\">int</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> pptr **<span class=\"keyword\">int</span></span><br><span class=\"line\"></span><br><span class=\"line\">a = <span class=\"number\">3000</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 指针 ptr 地址 */</span></span><br><span class=\"line\">ptr = &amp;a</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 指向指针 ptr 地址 */</span></span><br><span class=\"line\">pptr = &amp;ptr</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 获取 pptr 的值 */</span></span><br><span class=\"line\">fmt.Printf(<span class=\"string\">\"变量 a = %d\\n\"</span>, a )</span><br><span class=\"line\">fmt.Printf(<span class=\"string\">\"指针变量 *ptr = %d\\n\"</span>, *ptr )</span><br><span class=\"line\">fmt.Printf(<span class=\"string\">\"指向指针的指针变量 **pptr = %d\\n\"</span>, **pptr)</span><br></pre></td></tr></table></figure>\n<h2 id=\"为什么需要指针\"><a href=\"#为什么需要指针\" class=\"headerlink\" title=\"为什么需要指针\"></a>为什么需要指针</h2><p>相比 Java，Python，Javascript 等引用类型的语言，Golang 拥有类似C语言的指针这个相对古老的特性。但不同于 C 语言，Golang 的指<br>针是单独的类型，而且也不能对指针做整数运算。从这一点看，Golang 的指针基本就是一种引用。</p>\n<p>在学习引用类型语言的时候，总是要先搞清楚，当给一个 <code>函数/方法</code> 传参的时候，传进去的是值还是引用。实际上，在大部分引用型语言里，<br>参数为基本类型时，传进去的大都是值，也就是另外复制了一份参数到当前的函数调用栈。参数为高级类型时，传进去的基本都是引用。</p>\n<p>内存管理中的内存区域一般包括 <code>heap</code> 和 <code>stack</code>，<code>stack</code> 主要用来存储当前调用栈用到的简单类型数据：<code>string</code>，<code>boolean</code>，<br><code>int</code>，<code>float</code> 等。这些类型的内存占用小，容易回收，基本上它们的值和指针占用的空间差不多，因此可以直接复制，<code>GC</code> 也比较容易做针对性的<br>优化。复杂的高级类型占用的内存往往相对较大，存储在 <code>heap</code> 中，<code>GC</code> 回收频率相对较低，代价也较大，因此传 <code>引用/指针</code> 可以避免进行成本较<br>高的复制操作，并且节省内存，提高程序运行效率。</p>\n<p>因此，在下列情况可以考虑使用指针：</p>\n<ol>\n<li><strong>需要改变参数的值</strong></li>\n<li><strong>避免复制操作</strong></li>\n<li><strong>节省内存</strong></li>\n</ol>\n<p>而在 Golang 中，具体到高级类型 <code>struct</code>，<code>slice</code>，<code>map</code> 也各有不同。实际上，只有 <code>struct</code> 的使用有点复杂，<strong><code>slice</code>，<code>map</code>，<br><code>chan</code>都可以直接使用，不用考虑是值还是指针</strong>。</p>\n<h3 id=\"struct\"><a href=\"#struct\" class=\"headerlink\" title=\"struct\"></a><code>struct</code></h3><p>对于函数（<code>function</code>），由函数的参数类型指定，传入的参数的类型不对会报错，例如：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">passValue</span><span class=\"params\">(s <span class=\"keyword\">struct</span>)</span></span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">passPointer</span><span class=\"params\">(s *<span class=\"keyword\">struct</span>)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>\n<p>对于方法（<code>method</code>），接收者（<code>receiver</code>）可以是指针，也可以是值，Golang 会在传递参数前自动适配以符合参数的类型。也就是：如果方法的参数<br>是值，那么按照传值的方式 ，方法内部对 <code>struct</code> 的改动无法作用在外部的变量上，例如：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"fmt\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> MyPoint <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    X <span class=\"keyword\">int</span></span><br><span class=\"line\">    Y <span class=\"keyword\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">printFuncValue</span><span class=\"params\">(p MyPoint)</span></span>&#123;</span><br><span class=\"line\">    p.X = <span class=\"number\">1</span></span><br><span class=\"line\">    p.Y = <span class=\"number\">1</span></span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">\" -&gt; %v\"</span>, p)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">printFuncPointer</span><span class=\"params\">(pp *MyPoint)</span></span>&#123;</span><br><span class=\"line\">    pp.X = <span class=\"number\">1</span> <span class=\"comment\">// 实际上应该写做 (*pp).X，Golang 给了语法糖，减少了麻烦，但是也导致了 * 的不一致</span></span><br><span class=\"line\">    pp.Y = <span class=\"number\">1</span></span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">\" -&gt; %v\"</span>, pp)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p MyPoint)</span> <span class=\"title\">printMethodValue</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    p.X += <span class=\"number\">1</span></span><br><span class=\"line\">    p.Y += <span class=\"number\">1</span></span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">\" -&gt; %v\"</span>, p)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 建议使用指针作为方法（method：printMethodPointer）的接收者（receiver：*MyPoint），一是可以修改接收者的值，二是可以避免大对象的复制</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(pp *MyPoint)</span> <span class=\"title\">printMethodPointer</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    pp.X += <span class=\"number\">1</span></span><br><span class=\"line\">    pp.Y += <span class=\"number\">1</span></span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">\" -&gt; %v\"</span>, pp)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    p := MyPoint&#123;<span class=\"number\">0</span>, <span class=\"number\">0</span>&#125;</span><br><span class=\"line\">    pp := &amp;MyPoint&#123;<span class=\"number\">0</span>, <span class=\"number\">0</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">\"\\n value to func(value): %v\"</span>, p)</span><br><span class=\"line\">    printFuncValue(p)</span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">\" --&gt; %v\"</span>, p)</span><br><span class=\"line\">    <span class=\"comment\">// Output: value to func(value): &#123;0 0&#125; -&gt; &#123;1 1&#125; --&gt; &#123;0 0&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//printFuncValue(pp) // cannot use pp (type *MyPoint) as type MyPoint in argument to printFuncValue</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//printFuncPointer(p) // cannot use p (type MyPoint) as type *MyPoint in argument to printFuncPointer</span></span><br><span class=\"line\"></span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">\"\\n pointer to func(pointer): %v\"</span>, pp)</span><br><span class=\"line\">    printFuncPointer(pp)</span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">\" --&gt; %v\"</span>, pp)</span><br><span class=\"line\">    <span class=\"comment\">// Output: pointer to func(pointer): &amp;&#123;0 0&#125; -&gt; &amp;&#123;1 1&#125; --&gt; &amp;&#123;1 1&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">\"\\n value to method(value): %v\"</span>, p)</span><br><span class=\"line\">    p.printMethodValue()</span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">\" --&gt; %v\"</span>, p)</span><br><span class=\"line\">    <span class=\"comment\">// Output: value to method(value): &#123;0 0&#125; -&gt; &#123;1 1&#125; --&gt; &#123;0 0&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">\"\\n value to method(pointer): %v\"</span>, p)</span><br><span class=\"line\">    p.printMethodPointer()</span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">\" --&gt; %v\"</span>, p)</span><br><span class=\"line\">    <span class=\"comment\">// Output: value to method(pointer): &#123;0 0&#125; -&gt; &amp;&#123;1 1&#125; --&gt; &#123;1 1&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">\"\\n pointer to method(value): %v\"</span>, pp)</span><br><span class=\"line\">    pp.printMethodValue()</span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">\" --&gt; %v\"</span>, pp)</span><br><span class=\"line\">    <span class=\"comment\">// Output: pointer to method(value): &amp;&#123;1 1&#125; -&gt; &#123;2 2&#125; --&gt; &amp;&#123;1 1&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">\"\\n pointer to method(pointer): %v\"</span>, pp)</span><br><span class=\"line\">    pp.printMethodPointer()</span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">\" --&gt; %v\"</span>, pp)</span><br><span class=\"line\">    <span class=\"comment\">// Output: pointer to method(pointer): &amp;&#123;1 1&#125; -&gt; &amp;&#123;2 2&#125; --&gt; &amp;&#123;2 2&#125;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"slice\"><a href=\"#slice\" class=\"headerlink\" title=\"slice\"></a><code>slice</code></h3><p><strong><code>slice</code> 实际上相当于对其依附的 <code>array</code> 的引用，它不存储数据，只是对 <code>array</code> 进行描述。因此，修改 <code>slice</code> 中的元素，<br>改变会体现在 <code>array</code> 上，当然也会体现在该 <code>array</code> 的所有 <code>slice</code> 上</strong>。</p>\n<h3 id=\"map\"><a href=\"#map\" class=\"headerlink\" title=\"map\"></a>map</h3><p><strong>使用 <code>make(map[string]string)</code> 返回的本身是个引用，可以直接用来操作</strong>：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">map</span>[<span class=\"string\">\"name\"</span>]=<span class=\"string\">\"Jason\"</span></span><br></pre></td></tr></table></figure></p>\n<p>而<strong>如果使用 <code>map</code> 的指针，反而会产生错误</strong>：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*<span class=\"keyword\">map</span>[<span class=\"string\">\"name\"</span>]=<span class=\"string\">\"Jason\"</span>  <span class=\"comment\">//  invalid indirect of m[\"title\"] (type string)</span></span><br><span class=\"line\">(*<span class=\"keyword\">map</span>)[<span class=\"string\">\"name\"</span>]=<span class=\"string\">\"Jason\"</span>  <span class=\"comment\">// invalid indirect of m (type map[string]string)</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"哪些值是不可寻址的\"><a href=\"#哪些值是不可寻址的\" class=\"headerlink\" title=\"哪些值是不可寻址的\"></a>哪些值是不可寻址的</h2><ol>\n<li><strong>不可变的值不可寻址</strong>。常量、基本类型的值字面量、字符串变量的值、函数以及方法的字面量都是如此。<br>其实这样规定也有安全性方面的考虑。</li>\n<li>绝大多数被视为<strong>临时结果的值都是不可寻址的</strong>。算术操作的结果值属于临时结果，针对值字面量的表达式结果值也属于临时结果。<br>但有一个例外，对切片字面量的索引结果值虽然也属于临时结果，但却是可寻址的。函数的返回值也是临时结果。<code>++</code> 和 <code>--</code> 并不属<br>于操作符。</li>\n<li><strong>不安全的值不可寻址</strong>，若拿到某值的指针可能会破坏程序的一致性，那么就是不安全的。由于字典的内部机制，对字典的索<br>引结果值的取址操作都是不安全的。另外，获取由字面量或标识符代表的函数或方法的地址显然也是不安全的。</li>\n</ol>\n","site":{"data":{"navigation":{"logo":{"text":"Golang Learn","type":"link","path":"index.html"},"main":[{"text":"Golang 基础","type":"label"},{"text":"Go 环境配置","type":"link","path":"basic/env_config.html"},{"text":"包","type":"link","path":"basic/package.html"},{"text":"基础数据类型","type":"link","path":"basic/basic_data.html"},{"text":"变量","type":"link","path":"basic/var.html"},{"text":"常量","type":"link","path":"basic/constant.html"},{"text":"控制语句","type":"link","path":"basic/flow.html"},{"text":"运算符","type":"link","path":"basic/operator.html"},{"text":"作用域","type":"link","path":"basic/scope.html"},{"text":"指针","type":"link","path":"basic/pointer.html"},{"text":"数组","type":"link","path":"basic/array.html"},{"text":"切片","type":"link","path":"basic/slice.html"},{"text":"字典","type":"link","path":"basic/map.html"},{"text":"函数","type":"link","path":"basic/function.html"},{"text":"结构体","type":"link","path":"basic/struct.html"},{"text":"接口","type":"link","path":"basic/interface.html"},{"text":"面向对象","type":"link","path":"basic/oop.html"},{"text":"错误","type":"link","path":"basic/error.html"},{"text":"序列化","type":"link","path":"basic/json.html"},{"text":"反射","type":"link","path":"basic/reflect.html"},{"text":"测试","type":"link","path":"basic/test.html"},{"text":"并发编程","type":"label"},{"text":"goroutine","type":"link","path":"concurrent/goroutine.html"},{"text":"channel","type":"link","path":"concurrent/channel.html"},{"text":"同步和锁","type":"link","path":"concurrent/sync_lock.html"},{"text":"内存分配","type":"label"},{"text":"内存分配","type":"link","path":"advance/mm.html"},{"text":"垃圾回收","type":"label"},{"text":"垃圾回收","type":"link","path":"advance/gc.html"},{"text":"标准库","type":"label"},{"text":"fmt","type":"link","path":"standards/io/fmt.html"},{"text":"io","type":"link","path":"standards/io/io.html"},{"text":"ioutil","type":"link","path":"standards/io/ioutil.html"},{"text":"bufio","type":"link","path":"standards/io/bufio.html"},{"text":"os","type":"link","path":"standards/os/os.html"},{"text":"filepath","type":"link","path":"standards/os/filepath.html"},{"text":"strings","type":"link","path":"standards/text/strings.html"},{"text":"strconv","type":"link","path":"standards/text/strconv.html"},{"text":"unicode","type":"link","path":"standards/text/unicode.html"},{"text":"log","type":"link","path":"standards/log.html"},{"text":"time","type":"link","path":"standards/time.html"},{"text":"http","type":"link","path":"standards/net/http.html"},{"text":"math","type":"link","path":"standards/data/math.html"},{"text":"sort","type":"link","path":"standards/data/sort.html"},{"text":"big","type":"link","path":"standards/data/big.html"},{"text":"container","type":"link","path":"standards/data/container.html"},{"text":"sql","type":"link","path":"standards/database/sql.html"},{"text":"THEME","type":"label"},{"text":"使用文档主题","type":"link","path":"theme/theme-usage.html"},{"text":"SUPPORT AND FEEDBACK","type":"label"},{"text":"Raise an Issue on Github","type":"link","path":"https://github.com/shipengqi/golang-learn/issues/new"}]}}},"excerpt":"","more":"<h1 id=\"指针\"><a href=\"#指针\" class=\"headerlink\" title=\"指针\"></a>指针</h1><p><strong>指针和内存地址不能混为一谈</strong>。内存地址是内存中每个字节单元的唯一编号，而指针是一个实体。指针也会分配内存空间，相当于一个<br>保存内存地址的整形变量。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x := <span class=\"number\">1</span></span><br><span class=\"line\">p := &amp;x         <span class=\"comment\">// p, of type *int, points to x</span></span><br><span class=\"line\">fmt.Println(*p) <span class=\"comment\">// \"1\"</span></span><br><span class=\"line\">*p = <span class=\"number\">2</span>          <span class=\"comment\">// equivalent to x = 2</span></span><br><span class=\"line\">fmt.Println(x)  <span class=\"comment\">// \"2\"</span></span><br></pre></td></tr></table></figure>\n<p>上面的代码，初始化一个变量 <code>x</code>，<code>&amp;</code> 是取地址操作，<code>&amp;x</code> 就是取变量 <code>x</code> 的内存地址，那么 <code>p</code> 就是一个指针，<br>类型是 <code>*int</code>，<code>p</code> 这个指针保存了变量 <code>x</code> 的内存地址。接下来 <code>*p</code> 表示读取指针指向的变量的值，也就是变量 <code>x</code> 的值 1。<br><code>*p</code>也可以被赋值。</p>\n<p>任何类型的指针的零值都是 <code>nil</code>。当指针指向同一个变量或者 <code>nil</code> 时是相等的。<br>当一个指针被定义后没有分配到任何变量时，它的值为 <code>nil</code>。<code>nil</code> 指针也称为空指针。</p>\n<h2 id=\"指向指针的指针\"><a href=\"#指向指针的指针\" class=\"headerlink\" title=\"指向指针的指针\"></a>指向指针的指针</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a <span class=\"keyword\">int</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> ptr *<span class=\"keyword\">int</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> pptr **<span class=\"keyword\">int</span></span><br><span class=\"line\"></span><br><span class=\"line\">a = <span class=\"number\">3000</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 指针 ptr 地址 */</span></span><br><span class=\"line\">ptr = &amp;a</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 指向指针 ptr 地址 */</span></span><br><span class=\"line\">pptr = &amp;ptr</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 获取 pptr 的值 */</span></span><br><span class=\"line\">fmt.Printf(<span class=\"string\">\"变量 a = %d\\n\"</span>, a )</span><br><span class=\"line\">fmt.Printf(<span class=\"string\">\"指针变量 *ptr = %d\\n\"</span>, *ptr )</span><br><span class=\"line\">fmt.Printf(<span class=\"string\">\"指向指针的指针变量 **pptr = %d\\n\"</span>, **pptr)</span><br></pre></td></tr></table></figure>\n<h2 id=\"为什么需要指针\"><a href=\"#为什么需要指针\" class=\"headerlink\" title=\"为什么需要指针\"></a>为什么需要指针</h2><p>相比 Java，Python，Javascript 等引用类型的语言，Golang 拥有类似C语言的指针这个相对古老的特性。但不同于 C 语言，Golang 的指<br>针是单独的类型，而且也不能对指针做整数运算。从这一点看，Golang 的指针基本就是一种引用。</p>\n<p>在学习引用类型语言的时候，总是要先搞清楚，当给一个 <code>函数/方法</code> 传参的时候，传进去的是值还是引用。实际上，在大部分引用型语言里，<br>参数为基本类型时，传进去的大都是值，也就是另外复制了一份参数到当前的函数调用栈。参数为高级类型时，传进去的基本都是引用。</p>\n<p>内存管理中的内存区域一般包括 <code>heap</code> 和 <code>stack</code>，<code>stack</code> 主要用来存储当前调用栈用到的简单类型数据：<code>string</code>，<code>boolean</code>，<br><code>int</code>，<code>float</code> 等。这些类型的内存占用小，容易回收，基本上它们的值和指针占用的空间差不多，因此可以直接复制，<code>GC</code> 也比较容易做针对性的<br>优化。复杂的高级类型占用的内存往往相对较大，存储在 <code>heap</code> 中，<code>GC</code> 回收频率相对较低，代价也较大，因此传 <code>引用/指针</code> 可以避免进行成本较<br>高的复制操作，并且节省内存，提高程序运行效率。</p>\n<p>因此，在下列情况可以考虑使用指针：</p>\n<ol>\n<li><strong>需要改变参数的值</strong></li>\n<li><strong>避免复制操作</strong></li>\n<li><strong>节省内存</strong></li>\n</ol>\n<p>而在 Golang 中，具体到高级类型 <code>struct</code>，<code>slice</code>，<code>map</code> 也各有不同。实际上，只有 <code>struct</code> 的使用有点复杂，<strong><code>slice</code>，<code>map</code>，<br><code>chan</code>都可以直接使用，不用考虑是值还是指针</strong>。</p>\n<h3 id=\"struct\"><a href=\"#struct\" class=\"headerlink\" title=\"struct\"></a><code>struct</code></h3><p>对于函数（<code>function</code>），由函数的参数类型指定，传入的参数的类型不对会报错，例如：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">passValue</span><span class=\"params\">(s <span class=\"keyword\">struct</span>)</span></span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">passPointer</span><span class=\"params\">(s *<span class=\"keyword\">struct</span>)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>\n<p>对于方法（<code>method</code>），接收者（<code>receiver</code>）可以是指针，也可以是值，Golang 会在传递参数前自动适配以符合参数的类型。也就是：如果方法的参数<br>是值，那么按照传值的方式 ，方法内部对 <code>struct</code> 的改动无法作用在外部的变量上，例如：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"fmt\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> MyPoint <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    X <span class=\"keyword\">int</span></span><br><span class=\"line\">    Y <span class=\"keyword\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">printFuncValue</span><span class=\"params\">(p MyPoint)</span></span>&#123;</span><br><span class=\"line\">    p.X = <span class=\"number\">1</span></span><br><span class=\"line\">    p.Y = <span class=\"number\">1</span></span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">\" -&gt; %v\"</span>, p)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">printFuncPointer</span><span class=\"params\">(pp *MyPoint)</span></span>&#123;</span><br><span class=\"line\">    pp.X = <span class=\"number\">1</span> <span class=\"comment\">// 实际上应该写做 (*pp).X，Golang 给了语法糖，减少了麻烦，但是也导致了 * 的不一致</span></span><br><span class=\"line\">    pp.Y = <span class=\"number\">1</span></span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">\" -&gt; %v\"</span>, pp)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p MyPoint)</span> <span class=\"title\">printMethodValue</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    p.X += <span class=\"number\">1</span></span><br><span class=\"line\">    p.Y += <span class=\"number\">1</span></span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">\" -&gt; %v\"</span>, p)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 建议使用指针作为方法（method：printMethodPointer）的接收者（receiver：*MyPoint），一是可以修改接收者的值，二是可以避免大对象的复制</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(pp *MyPoint)</span> <span class=\"title\">printMethodPointer</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    pp.X += <span class=\"number\">1</span></span><br><span class=\"line\">    pp.Y += <span class=\"number\">1</span></span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">\" -&gt; %v\"</span>, pp)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    p := MyPoint&#123;<span class=\"number\">0</span>, <span class=\"number\">0</span>&#125;</span><br><span class=\"line\">    pp := &amp;MyPoint&#123;<span class=\"number\">0</span>, <span class=\"number\">0</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">\"\\n value to func(value): %v\"</span>, p)</span><br><span class=\"line\">    printFuncValue(p)</span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">\" --&gt; %v\"</span>, p)</span><br><span class=\"line\">    <span class=\"comment\">// Output: value to func(value): &#123;0 0&#125; -&gt; &#123;1 1&#125; --&gt; &#123;0 0&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//printFuncValue(pp) // cannot use pp (type *MyPoint) as type MyPoint in argument to printFuncValue</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//printFuncPointer(p) // cannot use p (type MyPoint) as type *MyPoint in argument to printFuncPointer</span></span><br><span class=\"line\"></span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">\"\\n pointer to func(pointer): %v\"</span>, pp)</span><br><span class=\"line\">    printFuncPointer(pp)</span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">\" --&gt; %v\"</span>, pp)</span><br><span class=\"line\">    <span class=\"comment\">// Output: pointer to func(pointer): &amp;&#123;0 0&#125; -&gt; &amp;&#123;1 1&#125; --&gt; &amp;&#123;1 1&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">\"\\n value to method(value): %v\"</span>, p)</span><br><span class=\"line\">    p.printMethodValue()</span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">\" --&gt; %v\"</span>, p)</span><br><span class=\"line\">    <span class=\"comment\">// Output: value to method(value): &#123;0 0&#125; -&gt; &#123;1 1&#125; --&gt; &#123;0 0&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">\"\\n value to method(pointer): %v\"</span>, p)</span><br><span class=\"line\">    p.printMethodPointer()</span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">\" --&gt; %v\"</span>, p)</span><br><span class=\"line\">    <span class=\"comment\">// Output: value to method(pointer): &#123;0 0&#125; -&gt; &amp;&#123;1 1&#125; --&gt; &#123;1 1&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">\"\\n pointer to method(value): %v\"</span>, pp)</span><br><span class=\"line\">    pp.printMethodValue()</span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">\" --&gt; %v\"</span>, pp)</span><br><span class=\"line\">    <span class=\"comment\">// Output: pointer to method(value): &amp;&#123;1 1&#125; -&gt; &#123;2 2&#125; --&gt; &amp;&#123;1 1&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">\"\\n pointer to method(pointer): %v\"</span>, pp)</span><br><span class=\"line\">    pp.printMethodPointer()</span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">\" --&gt; %v\"</span>, pp)</span><br><span class=\"line\">    <span class=\"comment\">// Output: pointer to method(pointer): &amp;&#123;1 1&#125; -&gt; &amp;&#123;2 2&#125; --&gt; &amp;&#123;2 2&#125;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"slice\"><a href=\"#slice\" class=\"headerlink\" title=\"slice\"></a><code>slice</code></h3><p><strong><code>slice</code> 实际上相当于对其依附的 <code>array</code> 的引用，它不存储数据，只是对 <code>array</code> 进行描述。因此，修改 <code>slice</code> 中的元素，<br>改变会体现在 <code>array</code> 上，当然也会体现在该 <code>array</code> 的所有 <code>slice</code> 上</strong>。</p>\n<h3 id=\"map\"><a href=\"#map\" class=\"headerlink\" title=\"map\"></a>map</h3><p><strong>使用 <code>make(map[string]string)</code> 返回的本身是个引用，可以直接用来操作</strong>：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">map</span>[<span class=\"string\">\"name\"</span>]=<span class=\"string\">\"Jason\"</span></span><br></pre></td></tr></table></figure></p>\n<p>而<strong>如果使用 <code>map</code> 的指针，反而会产生错误</strong>：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*<span class=\"keyword\">map</span>[<span class=\"string\">\"name\"</span>]=<span class=\"string\">\"Jason\"</span>  <span class=\"comment\">//  invalid indirect of m[\"title\"] (type string)</span></span><br><span class=\"line\">(*<span class=\"keyword\">map</span>)[<span class=\"string\">\"name\"</span>]=<span class=\"string\">\"Jason\"</span>  <span class=\"comment\">// invalid indirect of m (type map[string]string)</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"哪些值是不可寻址的\"><a href=\"#哪些值是不可寻址的\" class=\"headerlink\" title=\"哪些值是不可寻址的\"></a>哪些值是不可寻址的</h2><ol>\n<li><strong>不可变的值不可寻址</strong>。常量、基本类型的值字面量、字符串变量的值、函数以及方法的字面量都是如此。<br>其实这样规定也有安全性方面的考虑。</li>\n<li>绝大多数被视为<strong>临时结果的值都是不可寻址的</strong>。算术操作的结果值属于临时结果，针对值字面量的表达式结果值也属于临时结果。<br>但有一个例外，对切片字面量的索引结果值虽然也属于临时结果，但却是可寻址的。函数的返回值也是临时结果。<code>++</code> 和 <code>--</code> 并不属<br>于操作符。</li>\n<li><strong>不安全的值不可寻址</strong>，若拿到某值的指针可能会破坏程序的一致性，那么就是不安全的。由于字典的内部机制，对字典的索<br>引结果值的取址操作都是不安全的。另外，获取由字面量或标识符代表的函数或方法的地址显然也是不安全的。</li>\n</ol>\n"},{"title":"运算符","_content":"# 运算符\n## 优先级\n\n1. `*`，`/`，`%`，`<<`，`>>`，`&`，`&^`\n2. `+`，`-`，`|`，`^`\n3. `==`，`!=`，`<`，`<=`，`>`，`>=`\n4. `&&`\n5. `||`\n\n上面的运算符得优先级，从上到下，从左到右。也就是 `*` 的优先级最高，`||` 的优先级最低。\n\n## 算术运算符\n`+`、`-`、`*` 和 `/` 可以适用于整数、浮点数和复数。\n\n在 Go 中，`%` 取模运算符的符号和被取模数的符号总是一致的，因此 `-5 % 3` 和 `-5 % -3` 结果都是 `-2`。`%` \n仅用于整数间的运算。除法运算符 `/` 的行为则依赖于操作数是否为全为整数，比如 `5.0/4.0` 的结果是 `1.25`，但是 \n`5/4` 的结果是 `1`，因为整数除法会向着 `0` 方向截断余数。\n\n`++` 自增，`--` 自减\n\n## 关系运算符\n`==`，`!=`，`<`，`<=`，`>`，`>=`。\n\n布尔型、数字类型和字符串等基本类型都是可比较的，也就是说两个相同类型的值可以用 `==` 和 `!=` 进行比较。\n## 逻辑运算符\n`&&`，`||`，`!`（逻辑 NOT 运算符）。\n\n## 位运算符\n`&`，`|`，`^`，`<<`，`>>`，`&^`（位清空 AND NOT）\n\n`&^`：如果对应 `y` 中 `bit` 位为 `1` 的话, 表达式 `z = x &^ y` 结果 `z` 的对应的 `bit` 位为 `0`，否则 `z` \n对应的 `bit` 位等于 `x` 相应的 `bit` 位的值。如：\n```go\nvar x uint8 = 00100010\nvar y uint8 = 00000110\nfmt.Printf(\"%08b\\n\", x&^y) // \"00100000\"\n```\n\n## 赋值运算符\n除了 `=` 外，还有 `+=`（相加后再赋值），`-=`（相减后再赋值），`*=`（相乘后再赋值）等等，其他的赋值运算符也都是\n一个套路。\n\n## 其他运算符\n`&`（取地址操作），`*`（指针变量）。\n","source":"basic/operator.md","raw":"---\ntitle: 运算符\n---\n# 运算符\n## 优先级\n\n1. `*`，`/`，`%`，`<<`，`>>`，`&`，`&^`\n2. `+`，`-`，`|`，`^`\n3. `==`，`!=`，`<`，`<=`，`>`，`>=`\n4. `&&`\n5. `||`\n\n上面的运算符得优先级，从上到下，从左到右。也就是 `*` 的优先级最高，`||` 的优先级最低。\n\n## 算术运算符\n`+`、`-`、`*` 和 `/` 可以适用于整数、浮点数和复数。\n\n在 Go 中，`%` 取模运算符的符号和被取模数的符号总是一致的，因此 `-5 % 3` 和 `-5 % -3` 结果都是 `-2`。`%` \n仅用于整数间的运算。除法运算符 `/` 的行为则依赖于操作数是否为全为整数，比如 `5.0/4.0` 的结果是 `1.25`，但是 \n`5/4` 的结果是 `1`，因为整数除法会向着 `0` 方向截断余数。\n\n`++` 自增，`--` 自减\n\n## 关系运算符\n`==`，`!=`，`<`，`<=`，`>`，`>=`。\n\n布尔型、数字类型和字符串等基本类型都是可比较的，也就是说两个相同类型的值可以用 `==` 和 `!=` 进行比较。\n## 逻辑运算符\n`&&`，`||`，`!`（逻辑 NOT 运算符）。\n\n## 位运算符\n`&`，`|`，`^`，`<<`，`>>`，`&^`（位清空 AND NOT）\n\n`&^`：如果对应 `y` 中 `bit` 位为 `1` 的话, 表达式 `z = x &^ y` 结果 `z` 的对应的 `bit` 位为 `0`，否则 `z` \n对应的 `bit` 位等于 `x` 相应的 `bit` 位的值。如：\n```go\nvar x uint8 = 00100010\nvar y uint8 = 00000110\nfmt.Printf(\"%08b\\n\", x&^y) // \"00100000\"\n```\n\n## 赋值运算符\n除了 `=` 外，还有 `+=`（相加后再赋值），`-=`（相减后再赋值），`*=`（相乘后再赋值）等等，其他的赋值运算符也都是\n一个套路。\n\n## 其他运算符\n`&`（取地址操作），`*`（指针变量）。\n","date":"2019-08-24T02:08:28.352Z","updated":"2019-08-24T02:08:28.337Z","path":"basic/operator.html","comments":1,"layout":"page","_id":"ck1xm14km000jfcw2pzgapwdn","content":"<h1 id=\"运算符\"><a href=\"#运算符\" class=\"headerlink\" title=\"运算符\"></a>运算符</h1><h2 id=\"优先级\"><a href=\"#优先级\" class=\"headerlink\" title=\"优先级\"></a>优先级</h2><ol>\n<li><code>*</code>，<code>/</code>，<code>%</code>，<code>&lt;&lt;</code>，<code>&gt;&gt;</code>，<code>&amp;</code>，<code>&amp;^</code></li>\n<li><code>+</code>，<code>-</code>，<code>|</code>，<code>^</code></li>\n<li><code>==</code>，<code>!=</code>，<code>&lt;</code>，<code>&lt;=</code>，<code>&gt;</code>，<code>&gt;=</code></li>\n<li><code>&amp;&amp;</code></li>\n<li><code>||</code></li>\n</ol>\n<p>上面的运算符得优先级，从上到下，从左到右。也就是 <code>*</code> 的优先级最高，<code>||</code> 的优先级最低。</p>\n<h2 id=\"算术运算符\"><a href=\"#算术运算符\" class=\"headerlink\" title=\"算术运算符\"></a>算术运算符</h2><p><code>+</code>、<code>-</code>、<code>*</code> 和 <code>/</code> 可以适用于整数、浮点数和复数。</p>\n<p>在 Go 中，<code>%</code> 取模运算符的符号和被取模数的符号总是一致的，因此 <code>-5 % 3</code> 和 <code>-5 % -3</code> 结果都是 <code>-2</code>。<code>%</code><br>仅用于整数间的运算。除法运算符 <code>/</code> 的行为则依赖于操作数是否为全为整数，比如 <code>5.0/4.0</code> 的结果是 <code>1.25</code>，但是<br><code>5/4</code> 的结果是 <code>1</code>，因为整数除法会向着 <code>0</code> 方向截断余数。</p>\n<p><code>++</code> 自增，<code>--</code> 自减</p>\n<h2 id=\"关系运算符\"><a href=\"#关系运算符\" class=\"headerlink\" title=\"关系运算符\"></a>关系运算符</h2><p><code>==</code>，<code>!=</code>，<code>&lt;</code>，<code>&lt;=</code>，<code>&gt;</code>，<code>&gt;=</code>。</p>\n<p>布尔型、数字类型和字符串等基本类型都是可比较的，也就是说两个相同类型的值可以用 <code>==</code> 和 <code>!=</code> 进行比较。</p>\n<h2 id=\"逻辑运算符\"><a href=\"#逻辑运算符\" class=\"headerlink\" title=\"逻辑运算符\"></a>逻辑运算符</h2><p><code>&amp;&amp;</code>，<code>||</code>，<code>!</code>（逻辑 NOT 运算符）。</p>\n<h2 id=\"位运算符\"><a href=\"#位运算符\" class=\"headerlink\" title=\"位运算符\"></a>位运算符</h2><p><code>&amp;</code>，<code>|</code>，<code>^</code>，<code>&lt;&lt;</code>，<code>&gt;&gt;</code>，<code>&amp;^</code>（位清空 AND NOT）</p>\n<p><code>&amp;^</code>：如果对应 <code>y</code> 中 <code>bit</code> 位为 <code>1</code> 的话, 表达式 <code>z = x &amp;^ y</code> 结果 <code>z</code> 的对应的 <code>bit</code> 位为 <code>0</code>，否则 <code>z</code><br>对应的 <code>bit</code> 位等于 <code>x</code> 相应的 <code>bit</code> 位的值。如：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x <span class=\"keyword\">uint8</span> = <span class=\"number\">00100010</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> y <span class=\"keyword\">uint8</span> = <span class=\"number\">00000110</span></span><br><span class=\"line\">fmt.Printf(<span class=\"string\">\"%08b\\n\"</span>, x&amp;^y) <span class=\"comment\">// \"00100000\"</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"赋值运算符\"><a href=\"#赋值运算符\" class=\"headerlink\" title=\"赋值运算符\"></a>赋值运算符</h2><p>除了 <code>=</code> 外，还有 <code>+=</code>（相加后再赋值），<code>-=</code>（相减后再赋值），<code>*=</code>（相乘后再赋值）等等，其他的赋值运算符也都是<br>一个套路。</p>\n<h2 id=\"其他运算符\"><a href=\"#其他运算符\" class=\"headerlink\" title=\"其他运算符\"></a>其他运算符</h2><p><code>&amp;</code>（取地址操作），<code>*</code>（指针变量）。</p>\n","site":{"data":{"navigation":{"logo":{"text":"Golang Learn","type":"link","path":"index.html"},"main":[{"text":"Golang 基础","type":"label"},{"text":"Go 环境配置","type":"link","path":"basic/env_config.html"},{"text":"包","type":"link","path":"basic/package.html"},{"text":"基础数据类型","type":"link","path":"basic/basic_data.html"},{"text":"变量","type":"link","path":"basic/var.html"},{"text":"常量","type":"link","path":"basic/constant.html"},{"text":"控制语句","type":"link","path":"basic/flow.html"},{"text":"运算符","type":"link","path":"basic/operator.html"},{"text":"作用域","type":"link","path":"basic/scope.html"},{"text":"指针","type":"link","path":"basic/pointer.html"},{"text":"数组","type":"link","path":"basic/array.html"},{"text":"切片","type":"link","path":"basic/slice.html"},{"text":"字典","type":"link","path":"basic/map.html"},{"text":"函数","type":"link","path":"basic/function.html"},{"text":"结构体","type":"link","path":"basic/struct.html"},{"text":"接口","type":"link","path":"basic/interface.html"},{"text":"面向对象","type":"link","path":"basic/oop.html"},{"text":"错误","type":"link","path":"basic/error.html"},{"text":"序列化","type":"link","path":"basic/json.html"},{"text":"反射","type":"link","path":"basic/reflect.html"},{"text":"测试","type":"link","path":"basic/test.html"},{"text":"并发编程","type":"label"},{"text":"goroutine","type":"link","path":"concurrent/goroutine.html"},{"text":"channel","type":"link","path":"concurrent/channel.html"},{"text":"同步和锁","type":"link","path":"concurrent/sync_lock.html"},{"text":"内存分配","type":"label"},{"text":"内存分配","type":"link","path":"advance/mm.html"},{"text":"垃圾回收","type":"label"},{"text":"垃圾回收","type":"link","path":"advance/gc.html"},{"text":"标准库","type":"label"},{"text":"fmt","type":"link","path":"standards/io/fmt.html"},{"text":"io","type":"link","path":"standards/io/io.html"},{"text":"ioutil","type":"link","path":"standards/io/ioutil.html"},{"text":"bufio","type":"link","path":"standards/io/bufio.html"},{"text":"os","type":"link","path":"standards/os/os.html"},{"text":"filepath","type":"link","path":"standards/os/filepath.html"},{"text":"strings","type":"link","path":"standards/text/strings.html"},{"text":"strconv","type":"link","path":"standards/text/strconv.html"},{"text":"unicode","type":"link","path":"standards/text/unicode.html"},{"text":"log","type":"link","path":"standards/log.html"},{"text":"time","type":"link","path":"standards/time.html"},{"text":"http","type":"link","path":"standards/net/http.html"},{"text":"math","type":"link","path":"standards/data/math.html"},{"text":"sort","type":"link","path":"standards/data/sort.html"},{"text":"big","type":"link","path":"standards/data/big.html"},{"text":"container","type":"link","path":"standards/data/container.html"},{"text":"sql","type":"link","path":"standards/database/sql.html"},{"text":"THEME","type":"label"},{"text":"使用文档主题","type":"link","path":"theme/theme-usage.html"},{"text":"SUPPORT AND FEEDBACK","type":"label"},{"text":"Raise an Issue on Github","type":"link","path":"https://github.com/shipengqi/golang-learn/issues/new"}]}}},"excerpt":"","more":"<h1 id=\"运算符\"><a href=\"#运算符\" class=\"headerlink\" title=\"运算符\"></a>运算符</h1><h2 id=\"优先级\"><a href=\"#优先级\" class=\"headerlink\" title=\"优先级\"></a>优先级</h2><ol>\n<li><code>*</code>，<code>/</code>，<code>%</code>，<code>&lt;&lt;</code>，<code>&gt;&gt;</code>，<code>&amp;</code>，<code>&amp;^</code></li>\n<li><code>+</code>，<code>-</code>，<code>|</code>，<code>^</code></li>\n<li><code>==</code>，<code>!=</code>，<code>&lt;</code>，<code>&lt;=</code>，<code>&gt;</code>，<code>&gt;=</code></li>\n<li><code>&amp;&amp;</code></li>\n<li><code>||</code></li>\n</ol>\n<p>上面的运算符得优先级，从上到下，从左到右。也就是 <code>*</code> 的优先级最高，<code>||</code> 的优先级最低。</p>\n<h2 id=\"算术运算符\"><a href=\"#算术运算符\" class=\"headerlink\" title=\"算术运算符\"></a>算术运算符</h2><p><code>+</code>、<code>-</code>、<code>*</code> 和 <code>/</code> 可以适用于整数、浮点数和复数。</p>\n<p>在 Go 中，<code>%</code> 取模运算符的符号和被取模数的符号总是一致的，因此 <code>-5 % 3</code> 和 <code>-5 % -3</code> 结果都是 <code>-2</code>。<code>%</code><br>仅用于整数间的运算。除法运算符 <code>/</code> 的行为则依赖于操作数是否为全为整数，比如 <code>5.0/4.0</code> 的结果是 <code>1.25</code>，但是<br><code>5/4</code> 的结果是 <code>1</code>，因为整数除法会向着 <code>0</code> 方向截断余数。</p>\n<p><code>++</code> 自增，<code>--</code> 自减</p>\n<h2 id=\"关系运算符\"><a href=\"#关系运算符\" class=\"headerlink\" title=\"关系运算符\"></a>关系运算符</h2><p><code>==</code>，<code>!=</code>，<code>&lt;</code>，<code>&lt;=</code>，<code>&gt;</code>，<code>&gt;=</code>。</p>\n<p>布尔型、数字类型和字符串等基本类型都是可比较的，也就是说两个相同类型的值可以用 <code>==</code> 和 <code>!=</code> 进行比较。</p>\n<h2 id=\"逻辑运算符\"><a href=\"#逻辑运算符\" class=\"headerlink\" title=\"逻辑运算符\"></a>逻辑运算符</h2><p><code>&amp;&amp;</code>，<code>||</code>，<code>!</code>（逻辑 NOT 运算符）。</p>\n<h2 id=\"位运算符\"><a href=\"#位运算符\" class=\"headerlink\" title=\"位运算符\"></a>位运算符</h2><p><code>&amp;</code>，<code>|</code>，<code>^</code>，<code>&lt;&lt;</code>，<code>&gt;&gt;</code>，<code>&amp;^</code>（位清空 AND NOT）</p>\n<p><code>&amp;^</code>：如果对应 <code>y</code> 中 <code>bit</code> 位为 <code>1</code> 的话, 表达式 <code>z = x &amp;^ y</code> 结果 <code>z</code> 的对应的 <code>bit</code> 位为 <code>0</code>，否则 <code>z</code><br>对应的 <code>bit</code> 位等于 <code>x</code> 相应的 <code>bit</code> 位的值。如：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x <span class=\"keyword\">uint8</span> = <span class=\"number\">00100010</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> y <span class=\"keyword\">uint8</span> = <span class=\"number\">00000110</span></span><br><span class=\"line\">fmt.Printf(<span class=\"string\">\"%08b\\n\"</span>, x&amp;^y) <span class=\"comment\">// \"00100000\"</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"赋值运算符\"><a href=\"#赋值运算符\" class=\"headerlink\" title=\"赋值运算符\"></a>赋值运算符</h2><p>除了 <code>=</code> 外，还有 <code>+=</code>（相加后再赋值），<code>-=</code>（相减后再赋值），<code>*=</code>（相乘后再赋值）等等，其他的赋值运算符也都是<br>一个套路。</p>\n<h2 id=\"其他运算符\"><a href=\"#其他运算符\" class=\"headerlink\" title=\"其他运算符\"></a>其他运算符</h2><p><code>&amp;</code>（取地址操作），<code>*</code>（指针变量）。</p>\n"},{"title":"slice","_content":"# slice\n`slice` 的语法和数组很像，由于数组长度是固定的，所以使用 `slice` 相比数组会更灵活，`slice` 是动态的，\n长度可以增加也可以减少。还有一点与数组不同，切片不需要说明长度。\n\n**切片（slice） 是对底层数组一个连续片段的引用，所以切片是一个引用类型**。\n\n**定义切片，和定义数组的区别就是不需要指定 `SIZE`**：\n```go\nvar 变量名 []类型\n```\n一个 `slice` 由三个部分构成：指针、长度和容量。长度不能超过容量。\n一个切片在未初始化之前默认为 `nil`，长度为 `0`。\n\n初始化切片：\n```go\n// 直接初始化切片，[] 表示是切片类型，{1,2,3} 初始化值依次是 1,2,3.其 cap=len=3\ns :=[]int {1,2,3}\n\n// 初始化切片 s,是数组 arr 的引用\ns := arr[:]\n\n// 将 arr 中从下标 startIndex 到 endIndex-1 下的元素创建为一个新的切片\ns := arr[startIndex:endIndex] \n\n// 缺省 endIndex 时将表示一直到 arr 的最后一个元素\ns := arr[startIndex:] \n\n// 缺省 startIndex 时将表示从 arr 的第一个元素开始\ns := arr[:endIndex]\n\n// 使用 make 函数来创建切片\n// len 是数组的长度并且也是切片的初始长度\n// capacity 为可选参数, 指定容量\ns := make([]int, len, capacity)\n```\n\n## len() 和 cap()\n- `len`获取切片长度。\n- `cap`计算切片的最大容量\n\n## append() 和 copy()\n- `append` 向切片追加新元素\n- `copy` 拷贝切片\n\n### append 的使用\n使用 `append` 函数时要注意，`append` 总是从 `slice` 的尾部开始追加数据。比如下面的代码：\n```go\nurls := make([]string, 3) \nappend(urls, \"hello\")\nlen(urls) // 4\n\nurls2 := make([]string, 0)\nappend(urls, \"hello\")\nlen(urls) // 1\n```\n\n## 切片操作\n### 截取切片\n```go\n/* 创建切片 */\nnumbers := []int{0,1,2,3,4,5,6,7,8}   \n\n/* 打印子切片从索引 1 (包含) 到索引 4(不包含)*/\nfmt.Println(\"numbers[1:4] ==\", numbers[1:4]) // numbers[1:4] == [1 2 3]\n\n/* 默认下限为 0*/\nfmt.Println(\"numbers[:3] ==\", numbers[:3]) // numbers[:3] == [0 1 2]\n\n/* 默认上限为 len(s)*/\nfmt.Println(\"numbers[4:] ==\", numbers[4:]) // numbers[4:] == [4 5 6 7 8]\n\nnumbers1 := make([]int,0,5)\n\n/* 打印子切片从索引  0 (包含) 到索引 2 (不包含) */\nnumber2 := numbers[:2]\nfmt.Printf(\"len=%d cap=%d slice=%v\\n\",len(number2),cap(number2),number2) // len=2 cap=9 slice=[0 1]\n/* 打印子切片从索引 2 (包含) 到索引 5 (不包含) */\nnumber3 := numbers[2:5]\nfmt.Printf(\"len=%d cap=%d slice=%v\\n\",len(number3),cap(number3),number3) // len=3 cap=7 slice=[2 3 4]\n```\n\n### 切片初始化要注意的事情\n初始化切片可以使用两种方式：\n1. 比如 `s := []string{}`，这种方式初始化的切片长度为 0，不能直接使用下标赋值（`s[0] = \"hello\"`），会报错 `index out of range`。\n2. 使用 `make` 初始化切片，要注意使用 `append` 函数时，是从末尾开始添加数据，注意 `slice` 的 `len` 参数。\n\n## 怎样估算切片容量的增长\n\n一旦**一个切片无法容纳更多的元素，Go 语言就会想办法扩容。但它并不会改变原来的切片，而是会生成一个容量更大的切片，\n然后将把原有的元素和新元素一并拷贝到新切片中**。一般的情况下，你**可以简单地认为新切片的容量（以下简称新容量）将会是\n原切片容量（以下简称原容量）的 2 倍**。\n\n但是，当原切片的长度（以下简称原长度）大于或等于 1024 时，Go 语言将会以原容量的 1.25 倍作为新容量的基准（以下新容量基准）。\n新容量基准会被调整（不断地与 1.25 相乘），直到结果不小于原长度与要追加的元素数量之和（以下简称新长度）。最终，新容量\n往往会、比新长度大一些，当然，相等也是可能的。\n\n一个切片的底层数组永远不会被替换。为什么？虽然在扩容的时候 Go 语言一定会生成新的底层数组，但是它也同时生成了新的切片。它是把新\n的切片作为了新底层数组的窗口，而没有对原切片及其底层数组做任何改动。\n\n**在无需扩容时，`append` 函数返回的是指向“原底层数组”的新切片，而在需要扩容时，`append` 函数返回的是指向“新底层数组”的新切片**。\n\n## 长度和容量\n`Slice` 有两个比较混淆的概念，就是长度和容量。这个长度跟数组的长度是一个概念，即在内存中进行了初始化实际存在的元素的个数。何谓容量？\n如果通过 `make` 函数创建 `Slice` 的时候指定了容量参数，那内存管理器会根据指定的容量的值先划分一块内存空间，然后才在其中存放有数组元素，\n多余部分处于空闲状态，在 `Slice` 上追加元素的时候，首先会放到这块空闲的内存中，如果添加的参数个数超过了容量值，内存管理器会重新划\n分一块容量值为原容量值 `*2` 大小的内存空间，依次类推。这个机制的好处在能够提升运算性能，因为内存的重新划分会降低性能。","source":"basic/slice.md","raw":"---\ntitle: slice\n---\n# slice\n`slice` 的语法和数组很像，由于数组长度是固定的，所以使用 `slice` 相比数组会更灵活，`slice` 是动态的，\n长度可以增加也可以减少。还有一点与数组不同，切片不需要说明长度。\n\n**切片（slice） 是对底层数组一个连续片段的引用，所以切片是一个引用类型**。\n\n**定义切片，和定义数组的区别就是不需要指定 `SIZE`**：\n```go\nvar 变量名 []类型\n```\n一个 `slice` 由三个部分构成：指针、长度和容量。长度不能超过容量。\n一个切片在未初始化之前默认为 `nil`，长度为 `0`。\n\n初始化切片：\n```go\n// 直接初始化切片，[] 表示是切片类型，{1,2,3} 初始化值依次是 1,2,3.其 cap=len=3\ns :=[]int {1,2,3}\n\n// 初始化切片 s,是数组 arr 的引用\ns := arr[:]\n\n// 将 arr 中从下标 startIndex 到 endIndex-1 下的元素创建为一个新的切片\ns := arr[startIndex:endIndex] \n\n// 缺省 endIndex 时将表示一直到 arr 的最后一个元素\ns := arr[startIndex:] \n\n// 缺省 startIndex 时将表示从 arr 的第一个元素开始\ns := arr[:endIndex]\n\n// 使用 make 函数来创建切片\n// len 是数组的长度并且也是切片的初始长度\n// capacity 为可选参数, 指定容量\ns := make([]int, len, capacity)\n```\n\n## len() 和 cap()\n- `len`获取切片长度。\n- `cap`计算切片的最大容量\n\n## append() 和 copy()\n- `append` 向切片追加新元素\n- `copy` 拷贝切片\n\n### append 的使用\n使用 `append` 函数时要注意，`append` 总是从 `slice` 的尾部开始追加数据。比如下面的代码：\n```go\nurls := make([]string, 3) \nappend(urls, \"hello\")\nlen(urls) // 4\n\nurls2 := make([]string, 0)\nappend(urls, \"hello\")\nlen(urls) // 1\n```\n\n## 切片操作\n### 截取切片\n```go\n/* 创建切片 */\nnumbers := []int{0,1,2,3,4,5,6,7,8}   \n\n/* 打印子切片从索引 1 (包含) 到索引 4(不包含)*/\nfmt.Println(\"numbers[1:4] ==\", numbers[1:4]) // numbers[1:4] == [1 2 3]\n\n/* 默认下限为 0*/\nfmt.Println(\"numbers[:3] ==\", numbers[:3]) // numbers[:3] == [0 1 2]\n\n/* 默认上限为 len(s)*/\nfmt.Println(\"numbers[4:] ==\", numbers[4:]) // numbers[4:] == [4 5 6 7 8]\n\nnumbers1 := make([]int,0,5)\n\n/* 打印子切片从索引  0 (包含) 到索引 2 (不包含) */\nnumber2 := numbers[:2]\nfmt.Printf(\"len=%d cap=%d slice=%v\\n\",len(number2),cap(number2),number2) // len=2 cap=9 slice=[0 1]\n/* 打印子切片从索引 2 (包含) 到索引 5 (不包含) */\nnumber3 := numbers[2:5]\nfmt.Printf(\"len=%d cap=%d slice=%v\\n\",len(number3),cap(number3),number3) // len=3 cap=7 slice=[2 3 4]\n```\n\n### 切片初始化要注意的事情\n初始化切片可以使用两种方式：\n1. 比如 `s := []string{}`，这种方式初始化的切片长度为 0，不能直接使用下标赋值（`s[0] = \"hello\"`），会报错 `index out of range`。\n2. 使用 `make` 初始化切片，要注意使用 `append` 函数时，是从末尾开始添加数据，注意 `slice` 的 `len` 参数。\n\n## 怎样估算切片容量的增长\n\n一旦**一个切片无法容纳更多的元素，Go 语言就会想办法扩容。但它并不会改变原来的切片，而是会生成一个容量更大的切片，\n然后将把原有的元素和新元素一并拷贝到新切片中**。一般的情况下，你**可以简单地认为新切片的容量（以下简称新容量）将会是\n原切片容量（以下简称原容量）的 2 倍**。\n\n但是，当原切片的长度（以下简称原长度）大于或等于 1024 时，Go 语言将会以原容量的 1.25 倍作为新容量的基准（以下新容量基准）。\n新容量基准会被调整（不断地与 1.25 相乘），直到结果不小于原长度与要追加的元素数量之和（以下简称新长度）。最终，新容量\n往往会、比新长度大一些，当然，相等也是可能的。\n\n一个切片的底层数组永远不会被替换。为什么？虽然在扩容的时候 Go 语言一定会生成新的底层数组，但是它也同时生成了新的切片。它是把新\n的切片作为了新底层数组的窗口，而没有对原切片及其底层数组做任何改动。\n\n**在无需扩容时，`append` 函数返回的是指向“原底层数组”的新切片，而在需要扩容时，`append` 函数返回的是指向“新底层数组”的新切片**。\n\n## 长度和容量\n`Slice` 有两个比较混淆的概念，就是长度和容量。这个长度跟数组的长度是一个概念，即在内存中进行了初始化实际存在的元素的个数。何谓容量？\n如果通过 `make` 函数创建 `Slice` 的时候指定了容量参数，那内存管理器会根据指定的容量的值先划分一块内存空间，然后才在其中存放有数组元素，\n多余部分处于空闲状态，在 `Slice` 上追加元素的时候，首先会放到这块空闲的内存中，如果添加的参数个数超过了容量值，内存管理器会重新划\n分一块容量值为原容量值 `*2` 大小的内存空间，依次类推。这个机制的好处在能够提升运算性能，因为内存的重新划分会降低性能。","date":"2019-10-19T13:40:15.171Z","updated":"2019-10-19T13:40:15.171Z","path":"basic/slice.html","comments":1,"layout":"page","_id":"ck1xm14km000kfcw2jj97tkrj","content":"<h1 id=\"slice\"><a href=\"#slice\" class=\"headerlink\" title=\"slice\"></a>slice</h1><p><code>slice</code> 的语法和数组很像，由于数组长度是固定的，所以使用 <code>slice</code> 相比数组会更灵活，<code>slice</code> 是动态的，<br>长度可以增加也可以减少。还有一点与数组不同，切片不需要说明长度。</p>\n<p><strong>切片（slice） 是对底层数组一个连续片段的引用，所以切片是一个引用类型</strong>。</p>\n<p><strong>定义切片，和定义数组的区别就是不需要指定 <code>SIZE</code></strong>：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> 变量名 []类型</span><br></pre></td></tr></table></figure></p>\n<p>一个 <code>slice</code> 由三个部分构成：指针、长度和容量。长度不能超过容量。<br>一个切片在未初始化之前默认为 <code>nil</code>，长度为 <code>0</code>。</p>\n<p>初始化切片：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 直接初始化切片，[] 表示是切片类型，&#123;1,2,3&#125; 初始化值依次是 1,2,3.其 cap=len=3</span></span><br><span class=\"line\">s :=[]<span class=\"keyword\">int</span> &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 初始化切片 s,是数组 arr 的引用</span></span><br><span class=\"line\">s := arr[:]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将 arr 中从下标 startIndex 到 endIndex-1 下的元素创建为一个新的切片</span></span><br><span class=\"line\">s := arr[startIndex:endIndex] </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 缺省 endIndex 时将表示一直到 arr 的最后一个元素</span></span><br><span class=\"line\">s := arr[startIndex:] </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 缺省 startIndex 时将表示从 arr 的第一个元素开始</span></span><br><span class=\"line\">s := arr[:endIndex]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用 make 函数来创建切片</span></span><br><span class=\"line\"><span class=\"comment\">// len 是数组的长度并且也是切片的初始长度</span></span><br><span class=\"line\"><span class=\"comment\">// capacity 为可选参数, 指定容量</span></span><br><span class=\"line\">s := <span class=\"built_in\">make</span>([]<span class=\"keyword\">int</span>, <span class=\"built_in\">len</span>, capacity)</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"len-和-cap\"><a href=\"#len-和-cap\" class=\"headerlink\" title=\"len() 和 cap()\"></a>len() 和 cap()</h2><ul>\n<li><code>len</code>获取切片长度。</li>\n<li><code>cap</code>计算切片的最大容量</li>\n</ul>\n<h2 id=\"append-和-copy\"><a href=\"#append-和-copy\" class=\"headerlink\" title=\"append() 和 copy()\"></a>append() 和 copy()</h2><ul>\n<li><code>append</code> 向切片追加新元素</li>\n<li><code>copy</code> 拷贝切片</li>\n</ul>\n<h3 id=\"append-的使用\"><a href=\"#append-的使用\" class=\"headerlink\" title=\"append 的使用\"></a>append 的使用</h3><p>使用 <code>append</code> 函数时要注意，<code>append</code> 总是从 <code>slice</code> 的尾部开始追加数据。比如下面的代码：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">urls := <span class=\"built_in\">make</span>([]<span class=\"keyword\">string</span>, <span class=\"number\">3</span>) </span><br><span class=\"line\"><span class=\"built_in\">append</span>(urls, <span class=\"string\">\"hello\"</span>)</span><br><span class=\"line\"><span class=\"built_in\">len</span>(urls) <span class=\"comment\">// 4</span></span><br><span class=\"line\"></span><br><span class=\"line\">urls2 := <span class=\"built_in\">make</span>([]<span class=\"keyword\">string</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"built_in\">append</span>(urls, <span class=\"string\">\"hello\"</span>)</span><br><span class=\"line\"><span class=\"built_in\">len</span>(urls) <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"切片操作\"><a href=\"#切片操作\" class=\"headerlink\" title=\"切片操作\"></a>切片操作</h2><h3 id=\"截取切片\"><a href=\"#截取切片\" class=\"headerlink\" title=\"截取切片\"></a>截取切片</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 创建切片 */</span></span><br><span class=\"line\">numbers := []<span class=\"keyword\">int</span>&#123;<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>&#125;   </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 打印子切片从索引 1 (包含) 到索引 4(不包含)*/</span></span><br><span class=\"line\">fmt.Println(<span class=\"string\">\"numbers[1:4] ==\"</span>, numbers[<span class=\"number\">1</span>:<span class=\"number\">4</span>]) <span class=\"comment\">// numbers[1:4] == [1 2 3]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 默认下限为 0*/</span></span><br><span class=\"line\">fmt.Println(<span class=\"string\">\"numbers[:3] ==\"</span>, numbers[:<span class=\"number\">3</span>]) <span class=\"comment\">// numbers[:3] == [0 1 2]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 默认上限为 len(s)*/</span></span><br><span class=\"line\">fmt.Println(<span class=\"string\">\"numbers[4:] ==\"</span>, numbers[<span class=\"number\">4</span>:]) <span class=\"comment\">// numbers[4:] == [4 5 6 7 8]</span></span><br><span class=\"line\"></span><br><span class=\"line\">numbers1 := <span class=\"built_in\">make</span>([]<span class=\"keyword\">int</span>,<span class=\"number\">0</span>,<span class=\"number\">5</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 打印子切片从索引  0 (包含) 到索引 2 (不包含) */</span></span><br><span class=\"line\">number2 := numbers[:<span class=\"number\">2</span>]</span><br><span class=\"line\">fmt.Printf(<span class=\"string\">\"len=%d cap=%d slice=%v\\n\"</span>,<span class=\"built_in\">len</span>(number2),<span class=\"built_in\">cap</span>(number2),number2) <span class=\"comment\">// len=2 cap=9 slice=[0 1]</span></span><br><span class=\"line\"><span class=\"comment\">/* 打印子切片从索引 2 (包含) 到索引 5 (不包含) */</span></span><br><span class=\"line\">number3 := numbers[<span class=\"number\">2</span>:<span class=\"number\">5</span>]</span><br><span class=\"line\">fmt.Printf(<span class=\"string\">\"len=%d cap=%d slice=%v\\n\"</span>,<span class=\"built_in\">len</span>(number3),<span class=\"built_in\">cap</span>(number3),number3) <span class=\"comment\">// len=3 cap=7 slice=[2 3 4]</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"切片初始化要注意的事情\"><a href=\"#切片初始化要注意的事情\" class=\"headerlink\" title=\"切片初始化要注意的事情\"></a>切片初始化要注意的事情</h3><p>初始化切片可以使用两种方式：</p>\n<ol>\n<li>比如 <code>s := []string{}</code>，这种方式初始化的切片长度为 0，不能直接使用下标赋值（<code>s[0] = &quot;hello&quot;</code>），会报错 <code>index out of range</code>。</li>\n<li>使用 <code>make</code> 初始化切片，要注意使用 <code>append</code> 函数时，是从末尾开始添加数据，注意 <code>slice</code> 的 <code>len</code> 参数。</li>\n</ol>\n<h2 id=\"怎样估算切片容量的增长\"><a href=\"#怎样估算切片容量的增长\" class=\"headerlink\" title=\"怎样估算切片容量的增长\"></a>怎样估算切片容量的增长</h2><p>一旦<strong>一个切片无法容纳更多的元素，Go 语言就会想办法扩容。但它并不会改变原来的切片，而是会生成一个容量更大的切片，<br>然后将把原有的元素和新元素一并拷贝到新切片中</strong>。一般的情况下，你<strong>可以简单地认为新切片的容量（以下简称新容量）将会是<br>原切片容量（以下简称原容量）的 2 倍</strong>。</p>\n<p>但是，当原切片的长度（以下简称原长度）大于或等于 1024 时，Go 语言将会以原容量的 1.25 倍作为新容量的基准（以下新容量基准）。<br>新容量基准会被调整（不断地与 1.25 相乘），直到结果不小于原长度与要追加的元素数量之和（以下简称新长度）。最终，新容量<br>往往会、比新长度大一些，当然，相等也是可能的。</p>\n<p>一个切片的底层数组永远不会被替换。为什么？虽然在扩容的时候 Go 语言一定会生成新的底层数组，但是它也同时生成了新的切片。它是把新<br>的切片作为了新底层数组的窗口，而没有对原切片及其底层数组做任何改动。</p>\n<p><strong>在无需扩容时，<code>append</code> 函数返回的是指向“原底层数组”的新切片，而在需要扩容时，<code>append</code> 函数返回的是指向“新底层数组”的新切片</strong>。</p>\n<h2 id=\"长度和容量\"><a href=\"#长度和容量\" class=\"headerlink\" title=\"长度和容量\"></a>长度和容量</h2><p><code>Slice</code> 有两个比较混淆的概念，就是长度和容量。这个长度跟数组的长度是一个概念，即在内存中进行了初始化实际存在的元素的个数。何谓容量？<br>如果通过 <code>make</code> 函数创建 <code>Slice</code> 的时候指定了容量参数，那内存管理器会根据指定的容量的值先划分一块内存空间，然后才在其中存放有数组元素，<br>多余部分处于空闲状态，在 <code>Slice</code> 上追加元素的时候，首先会放到这块空闲的内存中，如果添加的参数个数超过了容量值，内存管理器会重新划<br>分一块容量值为原容量值 <code>*2</code> 大小的内存空间，依次类推。这个机制的好处在能够提升运算性能，因为内存的重新划分会降低性能。</p>\n","site":{"data":{"navigation":{"logo":{"text":"Golang Learn","type":"link","path":"index.html"},"main":[{"text":"Golang 基础","type":"label"},{"text":"Go 环境配置","type":"link","path":"basic/env_config.html"},{"text":"包","type":"link","path":"basic/package.html"},{"text":"基础数据类型","type":"link","path":"basic/basic_data.html"},{"text":"变量","type":"link","path":"basic/var.html"},{"text":"常量","type":"link","path":"basic/constant.html"},{"text":"控制语句","type":"link","path":"basic/flow.html"},{"text":"运算符","type":"link","path":"basic/operator.html"},{"text":"作用域","type":"link","path":"basic/scope.html"},{"text":"指针","type":"link","path":"basic/pointer.html"},{"text":"数组","type":"link","path":"basic/array.html"},{"text":"切片","type":"link","path":"basic/slice.html"},{"text":"字典","type":"link","path":"basic/map.html"},{"text":"函数","type":"link","path":"basic/function.html"},{"text":"结构体","type":"link","path":"basic/struct.html"},{"text":"接口","type":"link","path":"basic/interface.html"},{"text":"面向对象","type":"link","path":"basic/oop.html"},{"text":"错误","type":"link","path":"basic/error.html"},{"text":"序列化","type":"link","path":"basic/json.html"},{"text":"反射","type":"link","path":"basic/reflect.html"},{"text":"测试","type":"link","path":"basic/test.html"},{"text":"并发编程","type":"label"},{"text":"goroutine","type":"link","path":"concurrent/goroutine.html"},{"text":"channel","type":"link","path":"concurrent/channel.html"},{"text":"同步和锁","type":"link","path":"concurrent/sync_lock.html"},{"text":"内存分配","type":"label"},{"text":"内存分配","type":"link","path":"advance/mm.html"},{"text":"垃圾回收","type":"label"},{"text":"垃圾回收","type":"link","path":"advance/gc.html"},{"text":"标准库","type":"label"},{"text":"fmt","type":"link","path":"standards/io/fmt.html"},{"text":"io","type":"link","path":"standards/io/io.html"},{"text":"ioutil","type":"link","path":"standards/io/ioutil.html"},{"text":"bufio","type":"link","path":"standards/io/bufio.html"},{"text":"os","type":"link","path":"standards/os/os.html"},{"text":"filepath","type":"link","path":"standards/os/filepath.html"},{"text":"strings","type":"link","path":"standards/text/strings.html"},{"text":"strconv","type":"link","path":"standards/text/strconv.html"},{"text":"unicode","type":"link","path":"standards/text/unicode.html"},{"text":"log","type":"link","path":"standards/log.html"},{"text":"time","type":"link","path":"standards/time.html"},{"text":"http","type":"link","path":"standards/net/http.html"},{"text":"math","type":"link","path":"standards/data/math.html"},{"text":"sort","type":"link","path":"standards/data/sort.html"},{"text":"big","type":"link","path":"standards/data/big.html"},{"text":"container","type":"link","path":"standards/data/container.html"},{"text":"sql","type":"link","path":"standards/database/sql.html"},{"text":"THEME","type":"label"},{"text":"使用文档主题","type":"link","path":"theme/theme-usage.html"},{"text":"SUPPORT AND FEEDBACK","type":"label"},{"text":"Raise an Issue on Github","type":"link","path":"https://github.com/shipengqi/golang-learn/issues/new"}]}}},"excerpt":"","more":"<h1 id=\"slice\"><a href=\"#slice\" class=\"headerlink\" title=\"slice\"></a>slice</h1><p><code>slice</code> 的语法和数组很像，由于数组长度是固定的，所以使用 <code>slice</code> 相比数组会更灵活，<code>slice</code> 是动态的，<br>长度可以增加也可以减少。还有一点与数组不同，切片不需要说明长度。</p>\n<p><strong>切片（slice） 是对底层数组一个连续片段的引用，所以切片是一个引用类型</strong>。</p>\n<p><strong>定义切片，和定义数组的区别就是不需要指定 <code>SIZE</code></strong>：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> 变量名 []类型</span><br></pre></td></tr></table></figure></p>\n<p>一个 <code>slice</code> 由三个部分构成：指针、长度和容量。长度不能超过容量。<br>一个切片在未初始化之前默认为 <code>nil</code>，长度为 <code>0</code>。</p>\n<p>初始化切片：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 直接初始化切片，[] 表示是切片类型，&#123;1,2,3&#125; 初始化值依次是 1,2,3.其 cap=len=3</span></span><br><span class=\"line\">s :=[]<span class=\"keyword\">int</span> &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 初始化切片 s,是数组 arr 的引用</span></span><br><span class=\"line\">s := arr[:]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将 arr 中从下标 startIndex 到 endIndex-1 下的元素创建为一个新的切片</span></span><br><span class=\"line\">s := arr[startIndex:endIndex] </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 缺省 endIndex 时将表示一直到 arr 的最后一个元素</span></span><br><span class=\"line\">s := arr[startIndex:] </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 缺省 startIndex 时将表示从 arr 的第一个元素开始</span></span><br><span class=\"line\">s := arr[:endIndex]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用 make 函数来创建切片</span></span><br><span class=\"line\"><span class=\"comment\">// len 是数组的长度并且也是切片的初始长度</span></span><br><span class=\"line\"><span class=\"comment\">// capacity 为可选参数, 指定容量</span></span><br><span class=\"line\">s := <span class=\"built_in\">make</span>([]<span class=\"keyword\">int</span>, <span class=\"built_in\">len</span>, capacity)</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"len-和-cap\"><a href=\"#len-和-cap\" class=\"headerlink\" title=\"len() 和 cap()\"></a>len() 和 cap()</h2><ul>\n<li><code>len</code>获取切片长度。</li>\n<li><code>cap</code>计算切片的最大容量</li>\n</ul>\n<h2 id=\"append-和-copy\"><a href=\"#append-和-copy\" class=\"headerlink\" title=\"append() 和 copy()\"></a>append() 和 copy()</h2><ul>\n<li><code>append</code> 向切片追加新元素</li>\n<li><code>copy</code> 拷贝切片</li>\n</ul>\n<h3 id=\"append-的使用\"><a href=\"#append-的使用\" class=\"headerlink\" title=\"append 的使用\"></a>append 的使用</h3><p>使用 <code>append</code> 函数时要注意，<code>append</code> 总是从 <code>slice</code> 的尾部开始追加数据。比如下面的代码：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">urls := <span class=\"built_in\">make</span>([]<span class=\"keyword\">string</span>, <span class=\"number\">3</span>) </span><br><span class=\"line\"><span class=\"built_in\">append</span>(urls, <span class=\"string\">\"hello\"</span>)</span><br><span class=\"line\"><span class=\"built_in\">len</span>(urls) <span class=\"comment\">// 4</span></span><br><span class=\"line\"></span><br><span class=\"line\">urls2 := <span class=\"built_in\">make</span>([]<span class=\"keyword\">string</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"built_in\">append</span>(urls, <span class=\"string\">\"hello\"</span>)</span><br><span class=\"line\"><span class=\"built_in\">len</span>(urls) <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"切片操作\"><a href=\"#切片操作\" class=\"headerlink\" title=\"切片操作\"></a>切片操作</h2><h3 id=\"截取切片\"><a href=\"#截取切片\" class=\"headerlink\" title=\"截取切片\"></a>截取切片</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 创建切片 */</span></span><br><span class=\"line\">numbers := []<span class=\"keyword\">int</span>&#123;<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>&#125;   </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 打印子切片从索引 1 (包含) 到索引 4(不包含)*/</span></span><br><span class=\"line\">fmt.Println(<span class=\"string\">\"numbers[1:4] ==\"</span>, numbers[<span class=\"number\">1</span>:<span class=\"number\">4</span>]) <span class=\"comment\">// numbers[1:4] == [1 2 3]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 默认下限为 0*/</span></span><br><span class=\"line\">fmt.Println(<span class=\"string\">\"numbers[:3] ==\"</span>, numbers[:<span class=\"number\">3</span>]) <span class=\"comment\">// numbers[:3] == [0 1 2]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 默认上限为 len(s)*/</span></span><br><span class=\"line\">fmt.Println(<span class=\"string\">\"numbers[4:] ==\"</span>, numbers[<span class=\"number\">4</span>:]) <span class=\"comment\">// numbers[4:] == [4 5 6 7 8]</span></span><br><span class=\"line\"></span><br><span class=\"line\">numbers1 := <span class=\"built_in\">make</span>([]<span class=\"keyword\">int</span>,<span class=\"number\">0</span>,<span class=\"number\">5</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 打印子切片从索引  0 (包含) 到索引 2 (不包含) */</span></span><br><span class=\"line\">number2 := numbers[:<span class=\"number\">2</span>]</span><br><span class=\"line\">fmt.Printf(<span class=\"string\">\"len=%d cap=%d slice=%v\\n\"</span>,<span class=\"built_in\">len</span>(number2),<span class=\"built_in\">cap</span>(number2),number2) <span class=\"comment\">// len=2 cap=9 slice=[0 1]</span></span><br><span class=\"line\"><span class=\"comment\">/* 打印子切片从索引 2 (包含) 到索引 5 (不包含) */</span></span><br><span class=\"line\">number3 := numbers[<span class=\"number\">2</span>:<span class=\"number\">5</span>]</span><br><span class=\"line\">fmt.Printf(<span class=\"string\">\"len=%d cap=%d slice=%v\\n\"</span>,<span class=\"built_in\">len</span>(number3),<span class=\"built_in\">cap</span>(number3),number3) <span class=\"comment\">// len=3 cap=7 slice=[2 3 4]</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"切片初始化要注意的事情\"><a href=\"#切片初始化要注意的事情\" class=\"headerlink\" title=\"切片初始化要注意的事情\"></a>切片初始化要注意的事情</h3><p>初始化切片可以使用两种方式：</p>\n<ol>\n<li>比如 <code>s := []string{}</code>，这种方式初始化的切片长度为 0，不能直接使用下标赋值（<code>s[0] = &quot;hello&quot;</code>），会报错 <code>index out of range</code>。</li>\n<li>使用 <code>make</code> 初始化切片，要注意使用 <code>append</code> 函数时，是从末尾开始添加数据，注意 <code>slice</code> 的 <code>len</code> 参数。</li>\n</ol>\n<h2 id=\"怎样估算切片容量的增长\"><a href=\"#怎样估算切片容量的增长\" class=\"headerlink\" title=\"怎样估算切片容量的增长\"></a>怎样估算切片容量的增长</h2><p>一旦<strong>一个切片无法容纳更多的元素，Go 语言就会想办法扩容。但它并不会改变原来的切片，而是会生成一个容量更大的切片，<br>然后将把原有的元素和新元素一并拷贝到新切片中</strong>。一般的情况下，你<strong>可以简单地认为新切片的容量（以下简称新容量）将会是<br>原切片容量（以下简称原容量）的 2 倍</strong>。</p>\n<p>但是，当原切片的长度（以下简称原长度）大于或等于 1024 时，Go 语言将会以原容量的 1.25 倍作为新容量的基准（以下新容量基准）。<br>新容量基准会被调整（不断地与 1.25 相乘），直到结果不小于原长度与要追加的元素数量之和（以下简称新长度）。最终，新容量<br>往往会、比新长度大一些，当然，相等也是可能的。</p>\n<p>一个切片的底层数组永远不会被替换。为什么？虽然在扩容的时候 Go 语言一定会生成新的底层数组，但是它也同时生成了新的切片。它是把新<br>的切片作为了新底层数组的窗口，而没有对原切片及其底层数组做任何改动。</p>\n<p><strong>在无需扩容时，<code>append</code> 函数返回的是指向“原底层数组”的新切片，而在需要扩容时，<code>append</code> 函数返回的是指向“新底层数组”的新切片</strong>。</p>\n<h2 id=\"长度和容量\"><a href=\"#长度和容量\" class=\"headerlink\" title=\"长度和容量\"></a>长度和容量</h2><p><code>Slice</code> 有两个比较混淆的概念，就是长度和容量。这个长度跟数组的长度是一个概念，即在内存中进行了初始化实际存在的元素的个数。何谓容量？<br>如果通过 <code>make</code> 函数创建 <code>Slice</code> 的时候指定了容量参数，那内存管理器会根据指定的容量的值先划分一块内存空间，然后才在其中存放有数组元素，<br>多余部分处于空闲状态，在 <code>Slice</code> 上追加元素的时候，首先会放到这块空闲的内存中，如果添加的参数个数超过了容量值，内存管理器会重新划<br>分一块容量值为原容量值 <code>*2</code> 大小的内存空间，依次类推。这个机制的好处在能够提升运算性能，因为内存的重新划分会降低性能。</p>\n"},{"title":"结构体","_content":"# 结构体\n结构体是由一系列具有相同类型或不同类型的数据构成的数据集合。\n结构体定义需要使用 `type` 和 `struct` 语句, `struct` 语句定义一个新的数据类型, `type` 语句定义了结构体的名称：\n```go\n// 定义了结构体类型\ntype struct_variable_type struct {\n   member definition;\n   member definition;\n   ...\n   member definition;\n}\n\nvariable_name := structure_variable_type{value1, value2...valuen}\n// 或\nvariable_name := structure_variable_type{ key1: value1, key2: value2..., keyn: valuen}\n```\n\n用点号 `.` 操作符访问结构体成员, 实例：\n```go\ntype Books struct {\n\ttitle string\n\tauthor string\n\tsubject string\n\tbook_id int\n}\n\n\nfunc main() {\n\tvar Book1 Books        /* 声明 Book1 为 Books 类型 */\n\n\t/* book 1 描述 */\n\tBook1.title = \"Go 语言\"\n\tBook1.author = \"www.runoob.com\"\n\tBook1.subject = \"Go 语言教程\"\n\tBook1.book_id = 6495407\n\n\t\t/* 打印 Book1 信息 */\n\tfmt.Printf( \"Book 1 title : %s\\n\", Book1.title)\n\tfmt.Printf( \"Book 1 author : %s\\n\", Book1.author)\n\tfmt.Printf( \"Book 1 subject : %s\\n\", Book1.subject)\n\tfmt.Printf( \"Book 1 book_id : %d\\n\", Book1.book_id)\n}\n```\n`.` 点操作符也可以和指向结构体的指针一起工作:\n```go\nvar employeeOfTheMonth *Employee = &dilbert\nemployeeOfTheMonth.Position += \" (proactive team player)\"\n```\n\n**一个结构体可能同时包含导出和未导出的成员, 如果结构体成员名字是以大写字母开头的，那么该成员就是导出的。\n未导出的成员, 不允许在外部包修改。**\n\n通常一行对应一个结构体成员，成员的名字在前类型在后，不过如果相邻的成员类型如果相同的话可以被合并到一行:\n```go\ntype Employee struct {\n\tID            int\n\tName, Address string\n\tSalary        int\n}\n```\n\n一个命名为 S 的结构体类型将不能再包含 S 类型的成员：因为一个聚合的值不能包含它自身。（该限制同样适应于数组。）\n但是S类型的结构体可以包含 `*S` 指针类型的成员，这可以让我们创建递归的数据结构，比如链表和树结构等：\n```go\ntype tree struct {\n\tvalue       int\n\tleft, right *tree\n}\n```\n\n\n## 结构体字面值\n\n结构体字面值可以指定每个成员的值:\n```go\ntype Point struct{ X, Y int }\n\np := Point{1, 2}\n```\n\n## 结构体比较\n\n两个结构体将可以使用 `==` 或 `!=` 运算符进行比较。\n```go\ntype Point struct{ X, Y int }\n\np := Point{1, 2}\nq := Point{2, 1}\nfmt.Println(p.X == q.X && p.Y == q.Y) // \"false\"\nfmt.Println(p == q)                   // \"false\"\n```\n\n## 结构体嵌入 匿名成员\nGo 语言提供的不同寻常的结构体嵌入机制让一个命名的结构体包含另一个结构体类型的匿名成员，\n这样就可以通过简单的点运算符 `x.f` 来访问匿名成员链中嵌套的 `x.d.e.f` 成员。\n```go\ntype Point struct {\n    X, Y int\n}\n\ntype Circle struct {\n    Center Point\n    Radius int\n}\n\ntype Wheel struct {\n    Circle Circle\n    Spokes int\n}\n```\n\n上面的代码，会使访问每个成员变得繁琐：\n```go\nvar w Wheel\nw.Circle.Center.X = 8\nw.Circle.Center.Y = 8\nw.Circle.Radius = 5\nw.Spokes = 20\n```\n\nGo 语言有一个特性可以**只声明一个成员对应的数据类型而定义成员的名字；这类成员就叫匿名成员**。Go 语言规范规定，\n如果一个字段的声明中只有字段的类型名而没有字段的名称，那么它就是一个嵌入字段，也可以被称为匿名字段。\n匿名成员的数据类型必须是命名的类型或指向一个命名的类型的指针。\n```go\ntype Point struct {\n    X, Y int\n}\n\n\ntype Circle struct {\n    Point\n    Radius int\n}\n\ntype Wheel struct {\n    Circle\n    Spokes int\n}\n\nvar w Wheel\nw.X = 8            // equivalent to w.Circle.Point.X = 8\nw.Y = 8            // equivalent to w.Circle.Point.Y = 8\nw.Radius = 5       // equivalent to w.Circle.Radius = 5\nw.Spokes = 20\n```\n\n上面的代码中，`Circle` 和 `Wheel` 各自都有一个匿名成员。我们可以说 `Point` 类型被嵌入到了 `Circle` 结构体，\n同时 `Circle` 类型被嵌入到了 `Wheel` 结构体。但是**结构体字面值并没有简短表示匿名成员的语法**，所以下面的代码，\n会编译失败：\n```go\nw = Wheel{8, 8, 5, 20}                       // compile error: unknown fields\nw = Wheel{X: 8, Y: 8, Radius: 5, Spokes: 20} // compile error: unknown fields\n\n// 正确的语法\nw = Wheel{Circle{Point{8, 8}, 5}, 20}\n\nw = Wheel{\n    Circle: Circle{\n        Point:  Point{X: 8, Y: 8},\n        Radius: 5,\n    },\n    Spokes: 20, // NOTE: trailing comma necessary here (and at Radius)\n}\n```\n\n**不能同时包含两个类型相同的匿名成员，这会导致名字冲突**。\n\n### 嵌入接口类型\nGo 语言的结构体还可以嵌入接口类型。\n\n```go\ntype Interface interface {\n    Len() int\n    Less(i, j int) bool\n    Swap(i, j int)\n}\n\n// Array 实现Interface接口\ntype Array []int\n\nfunc (arr Array) Len() int {\n    return len(arr)\n}\n\nfunc (arr Array) Less(i, j int) bool {\n    return arr[i] < arr[j]\n}\n\nfunc (arr Array) Swap(i, j int) {\n    arr[i], arr[j] = arr[j], arr[i]\n}\n\n// 匿名接口(anonymous interface)\ntype reverse struct {\n    Interface\n}\n\n// 重写(override)\nfunc (r reverse) Less(i, j int) bool {\n    return r.Interface.Less(j, i)\n}\n\n// 构造reverse Interface\nfunc Reverse(data Interface) Interface {\n    return &reverse{data}\n}\n\nfunc main() {\n    arr := Array{1, 2, 3}\n    rarr := Reverse(arr)\n    fmt.Println(arr.Less(0,1))\n    fmt.Println(rarr.Less(0,1))\n}\n```\n`reverse` 结构体内嵌了一个名为 `Interface` 的 `interface`，并且实现 `Less` 函数，但是\n却没有实现 `Len`, `Swap` 函数。\n\n为什么这么设计？\n\n通过这种方法可以让 **`reverse` 实现 `Interface` 这个接口类型，并且仅实现某个指定的方法，而不需要实现这个接口下的所有方法**。\n\n对比一下传统的组合匿名结构体实现重写的写法：\n```go\ntype Interface interface {\n    Len() int\n    Less(i, j int) bool\n    Swap(i, j int)\n}\n\ntype Array []int\n\nfunc (arr Array) Len() int {\n    return len(arr)\n}\n\nfunc (arr Array) Less(i, j int) bool {\n    return arr[i] < arr[j]\n}\n\nfunc (arr Array) Swap(i, j int) {\n    arr[i], arr[j] = arr[j], arr[i]\n}\n\n// 匿名struct\ntype reverse struct {\n    Array\n}\n\n// 重写\nfunc (r reverse) Less(i, j int) bool {\n    return r.Array.Less(j, i)\n}\n\n// 构造reverse Interface\nfunc Reverse(data Array) Interface {\n    return &reverse{data}\n}\n\nfunc main() {\n    arr := Array{1, 2, 3}\n    rarr := Reverse(arr)\n    fmt.Println(arr.Less(0, 1))\n    fmt.Println(rarr.Less(0, 1))\n}\n```\n\n匿名接口的优点，**匿名接口的方式不依赖具体实现，可以对任意实现了该接口的类型进行重写**。\n\n### 如果被嵌入类型和嵌入类型有同名的方法，那么调用哪一个的方法\n**只要名称相同，无论这两个方法的签名是否一致，被嵌入类型的方法都会“屏蔽”掉嵌入字段的同名方法**。\n\n类似的，由于我们同样可以像访问被嵌入类型的字段那样，直接访问嵌入字段的字段，所以**如果这两个结构体类型里存在同名的字段，\n那么嵌入字段中的那个字段一定会被“屏蔽”**。\n\n正因为嵌入字段的字段和方法都可以“嫁接”到被嵌入类型上，所以即使在两个同名的成员一个是字段，另一个是方法的情况下，这种“屏蔽”现象依然会存在。\n\n**不过，即使被屏蔽了，我们仍然可以通过链式的选择表达式，选择到嵌入字段的字段或方法**。\n\n嵌入字段本身也有嵌入字段的情况，这种情况下，“屏蔽”现象会以嵌入的层级为依据，嵌入层级越深的字段或方法越可能被“屏蔽”。","source":"basic/struct.md","raw":"---\ntitle: 结构体\n---\n# 结构体\n结构体是由一系列具有相同类型或不同类型的数据构成的数据集合。\n结构体定义需要使用 `type` 和 `struct` 语句, `struct` 语句定义一个新的数据类型, `type` 语句定义了结构体的名称：\n```go\n// 定义了结构体类型\ntype struct_variable_type struct {\n   member definition;\n   member definition;\n   ...\n   member definition;\n}\n\nvariable_name := structure_variable_type{value1, value2...valuen}\n// 或\nvariable_name := structure_variable_type{ key1: value1, key2: value2..., keyn: valuen}\n```\n\n用点号 `.` 操作符访问结构体成员, 实例：\n```go\ntype Books struct {\n\ttitle string\n\tauthor string\n\tsubject string\n\tbook_id int\n}\n\n\nfunc main() {\n\tvar Book1 Books        /* 声明 Book1 为 Books 类型 */\n\n\t/* book 1 描述 */\n\tBook1.title = \"Go 语言\"\n\tBook1.author = \"www.runoob.com\"\n\tBook1.subject = \"Go 语言教程\"\n\tBook1.book_id = 6495407\n\n\t\t/* 打印 Book1 信息 */\n\tfmt.Printf( \"Book 1 title : %s\\n\", Book1.title)\n\tfmt.Printf( \"Book 1 author : %s\\n\", Book1.author)\n\tfmt.Printf( \"Book 1 subject : %s\\n\", Book1.subject)\n\tfmt.Printf( \"Book 1 book_id : %d\\n\", Book1.book_id)\n}\n```\n`.` 点操作符也可以和指向结构体的指针一起工作:\n```go\nvar employeeOfTheMonth *Employee = &dilbert\nemployeeOfTheMonth.Position += \" (proactive team player)\"\n```\n\n**一个结构体可能同时包含导出和未导出的成员, 如果结构体成员名字是以大写字母开头的，那么该成员就是导出的。\n未导出的成员, 不允许在外部包修改。**\n\n通常一行对应一个结构体成员，成员的名字在前类型在后，不过如果相邻的成员类型如果相同的话可以被合并到一行:\n```go\ntype Employee struct {\n\tID            int\n\tName, Address string\n\tSalary        int\n}\n```\n\n一个命名为 S 的结构体类型将不能再包含 S 类型的成员：因为一个聚合的值不能包含它自身。（该限制同样适应于数组。）\n但是S类型的结构体可以包含 `*S` 指针类型的成员，这可以让我们创建递归的数据结构，比如链表和树结构等：\n```go\ntype tree struct {\n\tvalue       int\n\tleft, right *tree\n}\n```\n\n\n## 结构体字面值\n\n结构体字面值可以指定每个成员的值:\n```go\ntype Point struct{ X, Y int }\n\np := Point{1, 2}\n```\n\n## 结构体比较\n\n两个结构体将可以使用 `==` 或 `!=` 运算符进行比较。\n```go\ntype Point struct{ X, Y int }\n\np := Point{1, 2}\nq := Point{2, 1}\nfmt.Println(p.X == q.X && p.Y == q.Y) // \"false\"\nfmt.Println(p == q)                   // \"false\"\n```\n\n## 结构体嵌入 匿名成员\nGo 语言提供的不同寻常的结构体嵌入机制让一个命名的结构体包含另一个结构体类型的匿名成员，\n这样就可以通过简单的点运算符 `x.f` 来访问匿名成员链中嵌套的 `x.d.e.f` 成员。\n```go\ntype Point struct {\n    X, Y int\n}\n\ntype Circle struct {\n    Center Point\n    Radius int\n}\n\ntype Wheel struct {\n    Circle Circle\n    Spokes int\n}\n```\n\n上面的代码，会使访问每个成员变得繁琐：\n```go\nvar w Wheel\nw.Circle.Center.X = 8\nw.Circle.Center.Y = 8\nw.Circle.Radius = 5\nw.Spokes = 20\n```\n\nGo 语言有一个特性可以**只声明一个成员对应的数据类型而定义成员的名字；这类成员就叫匿名成员**。Go 语言规范规定，\n如果一个字段的声明中只有字段的类型名而没有字段的名称，那么它就是一个嵌入字段，也可以被称为匿名字段。\n匿名成员的数据类型必须是命名的类型或指向一个命名的类型的指针。\n```go\ntype Point struct {\n    X, Y int\n}\n\n\ntype Circle struct {\n    Point\n    Radius int\n}\n\ntype Wheel struct {\n    Circle\n    Spokes int\n}\n\nvar w Wheel\nw.X = 8            // equivalent to w.Circle.Point.X = 8\nw.Y = 8            // equivalent to w.Circle.Point.Y = 8\nw.Radius = 5       // equivalent to w.Circle.Radius = 5\nw.Spokes = 20\n```\n\n上面的代码中，`Circle` 和 `Wheel` 各自都有一个匿名成员。我们可以说 `Point` 类型被嵌入到了 `Circle` 结构体，\n同时 `Circle` 类型被嵌入到了 `Wheel` 结构体。但是**结构体字面值并没有简短表示匿名成员的语法**，所以下面的代码，\n会编译失败：\n```go\nw = Wheel{8, 8, 5, 20}                       // compile error: unknown fields\nw = Wheel{X: 8, Y: 8, Radius: 5, Spokes: 20} // compile error: unknown fields\n\n// 正确的语法\nw = Wheel{Circle{Point{8, 8}, 5}, 20}\n\nw = Wheel{\n    Circle: Circle{\n        Point:  Point{X: 8, Y: 8},\n        Radius: 5,\n    },\n    Spokes: 20, // NOTE: trailing comma necessary here (and at Radius)\n}\n```\n\n**不能同时包含两个类型相同的匿名成员，这会导致名字冲突**。\n\n### 嵌入接口类型\nGo 语言的结构体还可以嵌入接口类型。\n\n```go\ntype Interface interface {\n    Len() int\n    Less(i, j int) bool\n    Swap(i, j int)\n}\n\n// Array 实现Interface接口\ntype Array []int\n\nfunc (arr Array) Len() int {\n    return len(arr)\n}\n\nfunc (arr Array) Less(i, j int) bool {\n    return arr[i] < arr[j]\n}\n\nfunc (arr Array) Swap(i, j int) {\n    arr[i], arr[j] = arr[j], arr[i]\n}\n\n// 匿名接口(anonymous interface)\ntype reverse struct {\n    Interface\n}\n\n// 重写(override)\nfunc (r reverse) Less(i, j int) bool {\n    return r.Interface.Less(j, i)\n}\n\n// 构造reverse Interface\nfunc Reverse(data Interface) Interface {\n    return &reverse{data}\n}\n\nfunc main() {\n    arr := Array{1, 2, 3}\n    rarr := Reverse(arr)\n    fmt.Println(arr.Less(0,1))\n    fmt.Println(rarr.Less(0,1))\n}\n```\n`reverse` 结构体内嵌了一个名为 `Interface` 的 `interface`，并且实现 `Less` 函数，但是\n却没有实现 `Len`, `Swap` 函数。\n\n为什么这么设计？\n\n通过这种方法可以让 **`reverse` 实现 `Interface` 这个接口类型，并且仅实现某个指定的方法，而不需要实现这个接口下的所有方法**。\n\n对比一下传统的组合匿名结构体实现重写的写法：\n```go\ntype Interface interface {\n    Len() int\n    Less(i, j int) bool\n    Swap(i, j int)\n}\n\ntype Array []int\n\nfunc (arr Array) Len() int {\n    return len(arr)\n}\n\nfunc (arr Array) Less(i, j int) bool {\n    return arr[i] < arr[j]\n}\n\nfunc (arr Array) Swap(i, j int) {\n    arr[i], arr[j] = arr[j], arr[i]\n}\n\n// 匿名struct\ntype reverse struct {\n    Array\n}\n\n// 重写\nfunc (r reverse) Less(i, j int) bool {\n    return r.Array.Less(j, i)\n}\n\n// 构造reverse Interface\nfunc Reverse(data Array) Interface {\n    return &reverse{data}\n}\n\nfunc main() {\n    arr := Array{1, 2, 3}\n    rarr := Reverse(arr)\n    fmt.Println(arr.Less(0, 1))\n    fmt.Println(rarr.Less(0, 1))\n}\n```\n\n匿名接口的优点，**匿名接口的方式不依赖具体实现，可以对任意实现了该接口的类型进行重写**。\n\n### 如果被嵌入类型和嵌入类型有同名的方法，那么调用哪一个的方法\n**只要名称相同，无论这两个方法的签名是否一致，被嵌入类型的方法都会“屏蔽”掉嵌入字段的同名方法**。\n\n类似的，由于我们同样可以像访问被嵌入类型的字段那样，直接访问嵌入字段的字段，所以**如果这两个结构体类型里存在同名的字段，\n那么嵌入字段中的那个字段一定会被“屏蔽”**。\n\n正因为嵌入字段的字段和方法都可以“嫁接”到被嵌入类型上，所以即使在两个同名的成员一个是字段，另一个是方法的情况下，这种“屏蔽”现象依然会存在。\n\n**不过，即使被屏蔽了，我们仍然可以通过链式的选择表达式，选择到嵌入字段的字段或方法**。\n\n嵌入字段本身也有嵌入字段的情况，这种情况下，“屏蔽”现象会以嵌入的层级为依据，嵌入层级越深的字段或方法越可能被“屏蔽”。","date":"2019-10-19T13:40:15.171Z","updated":"2019-10-19T13:40:15.171Z","path":"basic/struct.html","comments":1,"layout":"page","_id":"ck1xm14kn000lfcw2bzrtd60j","content":"<h1 id=\"结构体\"><a href=\"#结构体\" class=\"headerlink\" title=\"结构体\"></a>结构体</h1><p>结构体是由一系列具有相同类型或不同类型的数据构成的数据集合。<br>结构体定义需要使用 <code>type</code> 和 <code>struct</code> 语句, <code>struct</code> 语句定义一个新的数据类型, <code>type</code> 语句定义了结构体的名称：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义了结构体类型</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> struct_variable_type <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">   member definition;</span><br><span class=\"line\">   member definition;</span><br><span class=\"line\">   ...</span><br><span class=\"line\">   member definition;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">variable_name := structure_variable_type&#123;value1, value2...valuen&#125;</span><br><span class=\"line\"><span class=\"comment\">// 或</span></span><br><span class=\"line\">variable_name := structure_variable_type&#123; key1: value1, key2: value2..., keyn: valuen&#125;</span><br></pre></td></tr></table></figure></p>\n<p>用点号 <code>.</code> 操作符访问结构体成员, 实例：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Books <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\ttitle <span class=\"keyword\">string</span></span><br><span class=\"line\">\tauthor <span class=\"keyword\">string</span></span><br><span class=\"line\">\tsubject <span class=\"keyword\">string</span></span><br><span class=\"line\">\tbook_id <span class=\"keyword\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> Book1 Books        <span class=\"comment\">/* 声明 Book1 为 Books 类型 */</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/* book 1 描述 */</span></span><br><span class=\"line\">\tBook1.title = <span class=\"string\">\"Go 语言\"</span></span><br><span class=\"line\">\tBook1.author = <span class=\"string\">\"www.runoob.com\"</span></span><br><span class=\"line\">\tBook1.subject = <span class=\"string\">\"Go 语言教程\"</span></span><br><span class=\"line\">\tBook1.book_id = <span class=\"number\">6495407</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">/* 打印 Book1 信息 */</span></span><br><span class=\"line\">\tfmt.Printf( <span class=\"string\">\"Book 1 title : %s\\n\"</span>, Book1.title)</span><br><span class=\"line\">\tfmt.Printf( <span class=\"string\">\"Book 1 author : %s\\n\"</span>, Book1.author)</span><br><span class=\"line\">\tfmt.Printf( <span class=\"string\">\"Book 1 subject : %s\\n\"</span>, Book1.subject)</span><br><span class=\"line\">\tfmt.Printf( <span class=\"string\">\"Book 1 book_id : %d\\n\"</span>, Book1.book_id)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>.</code> 点操作符也可以和指向结构体的指针一起工作:<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> employeeOfTheMonth *Employee = &amp;dilbert</span><br><span class=\"line\">employeeOfTheMonth.Position += <span class=\"string\">\" (proactive team player)\"</span></span><br></pre></td></tr></table></figure></p>\n<p><strong>一个结构体可能同时包含导出和未导出的成员, 如果结构体成员名字是以大写字母开头的，那么该成员就是导出的。<br>未导出的成员, 不允许在外部包修改。</strong></p>\n<p>通常一行对应一个结构体成员，成员的名字在前类型在后，不过如果相邻的成员类型如果相同的话可以被合并到一行:<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Employee <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tID            <span class=\"keyword\">int</span></span><br><span class=\"line\">\tName, Address <span class=\"keyword\">string</span></span><br><span class=\"line\">\tSalary        <span class=\"keyword\">int</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>一个命名为 S 的结构体类型将不能再包含 S 类型的成员：因为一个聚合的值不能包含它自身。（该限制同样适应于数组。）<br>但是S类型的结构体可以包含 <code>*S</code> 指针类型的成员，这可以让我们创建递归的数据结构，比如链表和树结构等：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> tree <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tvalue       <span class=\"keyword\">int</span></span><br><span class=\"line\">\tleft, right *tree</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"结构体字面值\"><a href=\"#结构体字面值\" class=\"headerlink\" title=\"结构体字面值\"></a>结构体字面值</h2><p>结构体字面值可以指定每个成员的值:<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Point <span class=\"keyword\">struct</span>&#123; X, Y <span class=\"keyword\">int</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">p := Point&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"结构体比较\"><a href=\"#结构体比较\" class=\"headerlink\" title=\"结构体比较\"></a>结构体比较</h2><p>两个结构体将可以使用 <code>==</code> 或 <code>!=</code> 运算符进行比较。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Point <span class=\"keyword\">struct</span>&#123; X, Y <span class=\"keyword\">int</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">p := Point&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>&#125;</span><br><span class=\"line\">q := Point&#123;<span class=\"number\">2</span>, <span class=\"number\">1</span>&#125;</span><br><span class=\"line\">fmt.Println(p.X == q.X &amp;&amp; p.Y == q.Y) <span class=\"comment\">// \"false\"</span></span><br><span class=\"line\">fmt.Println(p == q)                   <span class=\"comment\">// \"false\"</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"结构体嵌入-匿名成员\"><a href=\"#结构体嵌入-匿名成员\" class=\"headerlink\" title=\"结构体嵌入 匿名成员\"></a>结构体嵌入 匿名成员</h2><p>Go 语言提供的不同寻常的结构体嵌入机制让一个命名的结构体包含另一个结构体类型的匿名成员，<br>这样就可以通过简单的点运算符 <code>x.f</code> 来访问匿名成员链中嵌套的 <code>x.d.e.f</code> 成员。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Point <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    X, Y <span class=\"keyword\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Circle <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    Center Point</span><br><span class=\"line\">    Radius <span class=\"keyword\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Wheel <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    Circle Circle</span><br><span class=\"line\">    Spokes <span class=\"keyword\">int</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面的代码，会使访问每个成员变得繁琐：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> w Wheel</span><br><span class=\"line\">w.Circle.Center.X = <span class=\"number\">8</span></span><br><span class=\"line\">w.Circle.Center.Y = <span class=\"number\">8</span></span><br><span class=\"line\">w.Circle.Radius = <span class=\"number\">5</span></span><br><span class=\"line\">w.Spokes = <span class=\"number\">20</span></span><br></pre></td></tr></table></figure></p>\n<p>Go 语言有一个特性可以<strong>只声明一个成员对应的数据类型而定义成员的名字；这类成员就叫匿名成员</strong>。Go 语言规范规定，<br>如果一个字段的声明中只有字段的类型名而没有字段的名称，那么它就是一个嵌入字段，也可以被称为匿名字段。<br>匿名成员的数据类型必须是命名的类型或指向一个命名的类型的指针。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Point <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    X, Y <span class=\"keyword\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Circle <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    Point</span><br><span class=\"line\">    Radius <span class=\"keyword\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Wheel <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    Circle</span><br><span class=\"line\">    Spokes <span class=\"keyword\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> w Wheel</span><br><span class=\"line\">w.X = <span class=\"number\">8</span>            <span class=\"comment\">// equivalent to w.Circle.Point.X = 8</span></span><br><span class=\"line\">w.Y = <span class=\"number\">8</span>            <span class=\"comment\">// equivalent to w.Circle.Point.Y = 8</span></span><br><span class=\"line\">w.Radius = <span class=\"number\">5</span>       <span class=\"comment\">// equivalent to w.Circle.Radius = 5</span></span><br><span class=\"line\">w.Spokes = <span class=\"number\">20</span></span><br></pre></td></tr></table></figure></p>\n<p>上面的代码中，<code>Circle</code> 和 <code>Wheel</code> 各自都有一个匿名成员。我们可以说 <code>Point</code> 类型被嵌入到了 <code>Circle</code> 结构体，<br>同时 <code>Circle</code> 类型被嵌入到了 <code>Wheel</code> 结构体。但是<strong>结构体字面值并没有简短表示匿名成员的语法</strong>，所以下面的代码，<br>会编译失败：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">w = Wheel&#123;<span class=\"number\">8</span>, <span class=\"number\">8</span>, <span class=\"number\">5</span>, <span class=\"number\">20</span>&#125;                       <span class=\"comment\">// compile error: unknown fields</span></span><br><span class=\"line\">w = Wheel&#123;X: <span class=\"number\">8</span>, Y: <span class=\"number\">8</span>, Radius: <span class=\"number\">5</span>, Spokes: <span class=\"number\">20</span>&#125; <span class=\"comment\">// compile error: unknown fields</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 正确的语法</span></span><br><span class=\"line\">w = Wheel&#123;Circle&#123;Point&#123;<span class=\"number\">8</span>, <span class=\"number\">8</span>&#125;, <span class=\"number\">5</span>&#125;, <span class=\"number\">20</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">w = Wheel&#123;</span><br><span class=\"line\">    Circle: Circle&#123;</span><br><span class=\"line\">        Point:  Point&#123;X: <span class=\"number\">8</span>, Y: <span class=\"number\">8</span>&#125;,</span><br><span class=\"line\">        Radius: <span class=\"number\">5</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    Spokes: <span class=\"number\">20</span>, <span class=\"comment\">// <span class=\"doctag\">NOTE:</span> trailing comma necessary here (and at Radius)</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>不能同时包含两个类型相同的匿名成员，这会导致名字冲突</strong>。</p>\n<h3 id=\"嵌入接口类型\"><a href=\"#嵌入接口类型\" class=\"headerlink\" title=\"嵌入接口类型\"></a>嵌入接口类型</h3><p>Go 语言的结构体还可以嵌入接口类型。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Interface <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">    Len() <span class=\"keyword\">int</span></span><br><span class=\"line\">    Less(i, j <span class=\"keyword\">int</span>) <span class=\"keyword\">bool</span></span><br><span class=\"line\">    Swap(i, j <span class=\"keyword\">int</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Array 实现Interface接口</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Array []<span class=\"keyword\">int</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(arr Array)</span> <span class=\"title\">Len</span><span class=\"params\">()</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">len</span>(arr)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(arr Array)</span> <span class=\"title\">Less</span><span class=\"params\">(i, j <span class=\"keyword\">int</span>)</span> <span class=\"title\">bool</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arr[i] &lt; arr[j]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(arr Array)</span> <span class=\"title\">Swap</span><span class=\"params\">(i, j <span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">    arr[i], arr[j] = arr[j], arr[i]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 匿名接口(anonymous interface)</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> reverse <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    Interface</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 重写(override)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(r reverse)</span> <span class=\"title\">Less</span><span class=\"params\">(i, j <span class=\"keyword\">int</span>)</span> <span class=\"title\">bool</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> r.Interface.Less(j, i)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 构造reverse Interface</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Reverse</span><span class=\"params\">(data Interface)</span> <span class=\"title\">Interface</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &amp;reverse&#123;data&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    arr := Array&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>&#125;</span><br><span class=\"line\">    rarr := Reverse(arr)</span><br><span class=\"line\">    fmt.Println(arr.Less(<span class=\"number\">0</span>,<span class=\"number\">1</span>))</span><br><span class=\"line\">    fmt.Println(rarr.Less(<span class=\"number\">0</span>,<span class=\"number\">1</span>))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>reverse</code> 结构体内嵌了一个名为 <code>Interface</code> 的 <code>interface</code>，并且实现 <code>Less</code> 函数，但是<br>却没有实现 <code>Len</code>, <code>Swap</code> 函数。</p>\n<p>为什么这么设计？</p>\n<p>通过这种方法可以让 <strong><code>reverse</code> 实现 <code>Interface</code> 这个接口类型，并且仅实现某个指定的方法，而不需要实现这个接口下的所有方法</strong>。</p>\n<p>对比一下传统的组合匿名结构体实现重写的写法：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Interface <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">    Len() <span class=\"keyword\">int</span></span><br><span class=\"line\">    Less(i, j <span class=\"keyword\">int</span>) <span class=\"keyword\">bool</span></span><br><span class=\"line\">    Swap(i, j <span class=\"keyword\">int</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Array []<span class=\"keyword\">int</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(arr Array)</span> <span class=\"title\">Len</span><span class=\"params\">()</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">len</span>(arr)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(arr Array)</span> <span class=\"title\">Less</span><span class=\"params\">(i, j <span class=\"keyword\">int</span>)</span> <span class=\"title\">bool</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arr[i] &lt; arr[j]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(arr Array)</span> <span class=\"title\">Swap</span><span class=\"params\">(i, j <span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">    arr[i], arr[j] = arr[j], arr[i]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 匿名struct</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> reverse <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    Array</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 重写</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(r reverse)</span> <span class=\"title\">Less</span><span class=\"params\">(i, j <span class=\"keyword\">int</span>)</span> <span class=\"title\">bool</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> r.Array.Less(j, i)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 构造reverse Interface</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Reverse</span><span class=\"params\">(data Array)</span> <span class=\"title\">Interface</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &amp;reverse&#123;data&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    arr := Array&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>&#125;</span><br><span class=\"line\">    rarr := Reverse(arr)</span><br><span class=\"line\">    fmt.Println(arr.Less(<span class=\"number\">0</span>, <span class=\"number\">1</span>))</span><br><span class=\"line\">    fmt.Println(rarr.Less(<span class=\"number\">0</span>, <span class=\"number\">1</span>))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>匿名接口的优点，<strong>匿名接口的方式不依赖具体实现，可以对任意实现了该接口的类型进行重写</strong>。</p>\n<h3 id=\"如果被嵌入类型和嵌入类型有同名的方法，那么调用哪一个的方法\"><a href=\"#如果被嵌入类型和嵌入类型有同名的方法，那么调用哪一个的方法\" class=\"headerlink\" title=\"如果被嵌入类型和嵌入类型有同名的方法，那么调用哪一个的方法\"></a>如果被嵌入类型和嵌入类型有同名的方法，那么调用哪一个的方法</h3><p><strong>只要名称相同，无论这两个方法的签名是否一致，被嵌入类型的方法都会“屏蔽”掉嵌入字段的同名方法</strong>。</p>\n<p>类似的，由于我们同样可以像访问被嵌入类型的字段那样，直接访问嵌入字段的字段，所以<strong>如果这两个结构体类型里存在同名的字段，<br>那么嵌入字段中的那个字段一定会被“屏蔽”</strong>。</p>\n<p>正因为嵌入字段的字段和方法都可以“嫁接”到被嵌入类型上，所以即使在两个同名的成员一个是字段，另一个是方法的情况下，这种“屏蔽”现象依然会存在。</p>\n<p><strong>不过，即使被屏蔽了，我们仍然可以通过链式的选择表达式，选择到嵌入字段的字段或方法</strong>。</p>\n<p>嵌入字段本身也有嵌入字段的情况，这种情况下，“屏蔽”现象会以嵌入的层级为依据，嵌入层级越深的字段或方法越可能被“屏蔽”。</p>\n","site":{"data":{"navigation":{"logo":{"text":"Golang Learn","type":"link","path":"index.html"},"main":[{"text":"Golang 基础","type":"label"},{"text":"Go 环境配置","type":"link","path":"basic/env_config.html"},{"text":"包","type":"link","path":"basic/package.html"},{"text":"基础数据类型","type":"link","path":"basic/basic_data.html"},{"text":"变量","type":"link","path":"basic/var.html"},{"text":"常量","type":"link","path":"basic/constant.html"},{"text":"控制语句","type":"link","path":"basic/flow.html"},{"text":"运算符","type":"link","path":"basic/operator.html"},{"text":"作用域","type":"link","path":"basic/scope.html"},{"text":"指针","type":"link","path":"basic/pointer.html"},{"text":"数组","type":"link","path":"basic/array.html"},{"text":"切片","type":"link","path":"basic/slice.html"},{"text":"字典","type":"link","path":"basic/map.html"},{"text":"函数","type":"link","path":"basic/function.html"},{"text":"结构体","type":"link","path":"basic/struct.html"},{"text":"接口","type":"link","path":"basic/interface.html"},{"text":"面向对象","type":"link","path":"basic/oop.html"},{"text":"错误","type":"link","path":"basic/error.html"},{"text":"序列化","type":"link","path":"basic/json.html"},{"text":"反射","type":"link","path":"basic/reflect.html"},{"text":"测试","type":"link","path":"basic/test.html"},{"text":"并发编程","type":"label"},{"text":"goroutine","type":"link","path":"concurrent/goroutine.html"},{"text":"channel","type":"link","path":"concurrent/channel.html"},{"text":"同步和锁","type":"link","path":"concurrent/sync_lock.html"},{"text":"内存分配","type":"label"},{"text":"内存分配","type":"link","path":"advance/mm.html"},{"text":"垃圾回收","type":"label"},{"text":"垃圾回收","type":"link","path":"advance/gc.html"},{"text":"标准库","type":"label"},{"text":"fmt","type":"link","path":"standards/io/fmt.html"},{"text":"io","type":"link","path":"standards/io/io.html"},{"text":"ioutil","type":"link","path":"standards/io/ioutil.html"},{"text":"bufio","type":"link","path":"standards/io/bufio.html"},{"text":"os","type":"link","path":"standards/os/os.html"},{"text":"filepath","type":"link","path":"standards/os/filepath.html"},{"text":"strings","type":"link","path":"standards/text/strings.html"},{"text":"strconv","type":"link","path":"standards/text/strconv.html"},{"text":"unicode","type":"link","path":"standards/text/unicode.html"},{"text":"log","type":"link","path":"standards/log.html"},{"text":"time","type":"link","path":"standards/time.html"},{"text":"http","type":"link","path":"standards/net/http.html"},{"text":"math","type":"link","path":"standards/data/math.html"},{"text":"sort","type":"link","path":"standards/data/sort.html"},{"text":"big","type":"link","path":"standards/data/big.html"},{"text":"container","type":"link","path":"standards/data/container.html"},{"text":"sql","type":"link","path":"standards/database/sql.html"},{"text":"THEME","type":"label"},{"text":"使用文档主题","type":"link","path":"theme/theme-usage.html"},{"text":"SUPPORT AND FEEDBACK","type":"label"},{"text":"Raise an Issue on Github","type":"link","path":"https://github.com/shipengqi/golang-learn/issues/new"}]}}},"excerpt":"","more":"<h1 id=\"结构体\"><a href=\"#结构体\" class=\"headerlink\" title=\"结构体\"></a>结构体</h1><p>结构体是由一系列具有相同类型或不同类型的数据构成的数据集合。<br>结构体定义需要使用 <code>type</code> 和 <code>struct</code> 语句, <code>struct</code> 语句定义一个新的数据类型, <code>type</code> 语句定义了结构体的名称：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义了结构体类型</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> struct_variable_type <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">   member definition;</span><br><span class=\"line\">   member definition;</span><br><span class=\"line\">   ...</span><br><span class=\"line\">   member definition;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">variable_name := structure_variable_type&#123;value1, value2...valuen&#125;</span><br><span class=\"line\"><span class=\"comment\">// 或</span></span><br><span class=\"line\">variable_name := structure_variable_type&#123; key1: value1, key2: value2..., keyn: valuen&#125;</span><br></pre></td></tr></table></figure></p>\n<p>用点号 <code>.</code> 操作符访问结构体成员, 实例：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Books <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\ttitle <span class=\"keyword\">string</span></span><br><span class=\"line\">\tauthor <span class=\"keyword\">string</span></span><br><span class=\"line\">\tsubject <span class=\"keyword\">string</span></span><br><span class=\"line\">\tbook_id <span class=\"keyword\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> Book1 Books        <span class=\"comment\">/* 声明 Book1 为 Books 类型 */</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/* book 1 描述 */</span></span><br><span class=\"line\">\tBook1.title = <span class=\"string\">\"Go 语言\"</span></span><br><span class=\"line\">\tBook1.author = <span class=\"string\">\"www.runoob.com\"</span></span><br><span class=\"line\">\tBook1.subject = <span class=\"string\">\"Go 语言教程\"</span></span><br><span class=\"line\">\tBook1.book_id = <span class=\"number\">6495407</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">/* 打印 Book1 信息 */</span></span><br><span class=\"line\">\tfmt.Printf( <span class=\"string\">\"Book 1 title : %s\\n\"</span>, Book1.title)</span><br><span class=\"line\">\tfmt.Printf( <span class=\"string\">\"Book 1 author : %s\\n\"</span>, Book1.author)</span><br><span class=\"line\">\tfmt.Printf( <span class=\"string\">\"Book 1 subject : %s\\n\"</span>, Book1.subject)</span><br><span class=\"line\">\tfmt.Printf( <span class=\"string\">\"Book 1 book_id : %d\\n\"</span>, Book1.book_id)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>.</code> 点操作符也可以和指向结构体的指针一起工作:<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> employeeOfTheMonth *Employee = &amp;dilbert</span><br><span class=\"line\">employeeOfTheMonth.Position += <span class=\"string\">\" (proactive team player)\"</span></span><br></pre></td></tr></table></figure></p>\n<p><strong>一个结构体可能同时包含导出和未导出的成员, 如果结构体成员名字是以大写字母开头的，那么该成员就是导出的。<br>未导出的成员, 不允许在外部包修改。</strong></p>\n<p>通常一行对应一个结构体成员，成员的名字在前类型在后，不过如果相邻的成员类型如果相同的话可以被合并到一行:<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Employee <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tID            <span class=\"keyword\">int</span></span><br><span class=\"line\">\tName, Address <span class=\"keyword\">string</span></span><br><span class=\"line\">\tSalary        <span class=\"keyword\">int</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>一个命名为 S 的结构体类型将不能再包含 S 类型的成员：因为一个聚合的值不能包含它自身。（该限制同样适应于数组。）<br>但是S类型的结构体可以包含 <code>*S</code> 指针类型的成员，这可以让我们创建递归的数据结构，比如链表和树结构等：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> tree <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tvalue       <span class=\"keyword\">int</span></span><br><span class=\"line\">\tleft, right *tree</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"结构体字面值\"><a href=\"#结构体字面值\" class=\"headerlink\" title=\"结构体字面值\"></a>结构体字面值</h2><p>结构体字面值可以指定每个成员的值:<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Point <span class=\"keyword\">struct</span>&#123; X, Y <span class=\"keyword\">int</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">p := Point&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"结构体比较\"><a href=\"#结构体比较\" class=\"headerlink\" title=\"结构体比较\"></a>结构体比较</h2><p>两个结构体将可以使用 <code>==</code> 或 <code>!=</code> 运算符进行比较。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Point <span class=\"keyword\">struct</span>&#123; X, Y <span class=\"keyword\">int</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">p := Point&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>&#125;</span><br><span class=\"line\">q := Point&#123;<span class=\"number\">2</span>, <span class=\"number\">1</span>&#125;</span><br><span class=\"line\">fmt.Println(p.X == q.X &amp;&amp; p.Y == q.Y) <span class=\"comment\">// \"false\"</span></span><br><span class=\"line\">fmt.Println(p == q)                   <span class=\"comment\">// \"false\"</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"结构体嵌入-匿名成员\"><a href=\"#结构体嵌入-匿名成员\" class=\"headerlink\" title=\"结构体嵌入 匿名成员\"></a>结构体嵌入 匿名成员</h2><p>Go 语言提供的不同寻常的结构体嵌入机制让一个命名的结构体包含另一个结构体类型的匿名成员，<br>这样就可以通过简单的点运算符 <code>x.f</code> 来访问匿名成员链中嵌套的 <code>x.d.e.f</code> 成员。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Point <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    X, Y <span class=\"keyword\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Circle <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    Center Point</span><br><span class=\"line\">    Radius <span class=\"keyword\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Wheel <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    Circle Circle</span><br><span class=\"line\">    Spokes <span class=\"keyword\">int</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面的代码，会使访问每个成员变得繁琐：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> w Wheel</span><br><span class=\"line\">w.Circle.Center.X = <span class=\"number\">8</span></span><br><span class=\"line\">w.Circle.Center.Y = <span class=\"number\">8</span></span><br><span class=\"line\">w.Circle.Radius = <span class=\"number\">5</span></span><br><span class=\"line\">w.Spokes = <span class=\"number\">20</span></span><br></pre></td></tr></table></figure></p>\n<p>Go 语言有一个特性可以<strong>只声明一个成员对应的数据类型而定义成员的名字；这类成员就叫匿名成员</strong>。Go 语言规范规定，<br>如果一个字段的声明中只有字段的类型名而没有字段的名称，那么它就是一个嵌入字段，也可以被称为匿名字段。<br>匿名成员的数据类型必须是命名的类型或指向一个命名的类型的指针。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Point <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    X, Y <span class=\"keyword\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Circle <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    Point</span><br><span class=\"line\">    Radius <span class=\"keyword\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Wheel <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    Circle</span><br><span class=\"line\">    Spokes <span class=\"keyword\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> w Wheel</span><br><span class=\"line\">w.X = <span class=\"number\">8</span>            <span class=\"comment\">// equivalent to w.Circle.Point.X = 8</span></span><br><span class=\"line\">w.Y = <span class=\"number\">8</span>            <span class=\"comment\">// equivalent to w.Circle.Point.Y = 8</span></span><br><span class=\"line\">w.Radius = <span class=\"number\">5</span>       <span class=\"comment\">// equivalent to w.Circle.Radius = 5</span></span><br><span class=\"line\">w.Spokes = <span class=\"number\">20</span></span><br></pre></td></tr></table></figure></p>\n<p>上面的代码中，<code>Circle</code> 和 <code>Wheel</code> 各自都有一个匿名成员。我们可以说 <code>Point</code> 类型被嵌入到了 <code>Circle</code> 结构体，<br>同时 <code>Circle</code> 类型被嵌入到了 <code>Wheel</code> 结构体。但是<strong>结构体字面值并没有简短表示匿名成员的语法</strong>，所以下面的代码，<br>会编译失败：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">w = Wheel&#123;<span class=\"number\">8</span>, <span class=\"number\">8</span>, <span class=\"number\">5</span>, <span class=\"number\">20</span>&#125;                       <span class=\"comment\">// compile error: unknown fields</span></span><br><span class=\"line\">w = Wheel&#123;X: <span class=\"number\">8</span>, Y: <span class=\"number\">8</span>, Radius: <span class=\"number\">5</span>, Spokes: <span class=\"number\">20</span>&#125; <span class=\"comment\">// compile error: unknown fields</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 正确的语法</span></span><br><span class=\"line\">w = Wheel&#123;Circle&#123;Point&#123;<span class=\"number\">8</span>, <span class=\"number\">8</span>&#125;, <span class=\"number\">5</span>&#125;, <span class=\"number\">20</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">w = Wheel&#123;</span><br><span class=\"line\">    Circle: Circle&#123;</span><br><span class=\"line\">        Point:  Point&#123;X: <span class=\"number\">8</span>, Y: <span class=\"number\">8</span>&#125;,</span><br><span class=\"line\">        Radius: <span class=\"number\">5</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    Spokes: <span class=\"number\">20</span>, <span class=\"comment\">// <span class=\"doctag\">NOTE:</span> trailing comma necessary here (and at Radius)</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>不能同时包含两个类型相同的匿名成员，这会导致名字冲突</strong>。</p>\n<h3 id=\"嵌入接口类型\"><a href=\"#嵌入接口类型\" class=\"headerlink\" title=\"嵌入接口类型\"></a>嵌入接口类型</h3><p>Go 语言的结构体还可以嵌入接口类型。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Interface <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">    Len() <span class=\"keyword\">int</span></span><br><span class=\"line\">    Less(i, j <span class=\"keyword\">int</span>) <span class=\"keyword\">bool</span></span><br><span class=\"line\">    Swap(i, j <span class=\"keyword\">int</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Array 实现Interface接口</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Array []<span class=\"keyword\">int</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(arr Array)</span> <span class=\"title\">Len</span><span class=\"params\">()</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">len</span>(arr)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(arr Array)</span> <span class=\"title\">Less</span><span class=\"params\">(i, j <span class=\"keyword\">int</span>)</span> <span class=\"title\">bool</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arr[i] &lt; arr[j]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(arr Array)</span> <span class=\"title\">Swap</span><span class=\"params\">(i, j <span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">    arr[i], arr[j] = arr[j], arr[i]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 匿名接口(anonymous interface)</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> reverse <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    Interface</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 重写(override)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(r reverse)</span> <span class=\"title\">Less</span><span class=\"params\">(i, j <span class=\"keyword\">int</span>)</span> <span class=\"title\">bool</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> r.Interface.Less(j, i)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 构造reverse Interface</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Reverse</span><span class=\"params\">(data Interface)</span> <span class=\"title\">Interface</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &amp;reverse&#123;data&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    arr := Array&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>&#125;</span><br><span class=\"line\">    rarr := Reverse(arr)</span><br><span class=\"line\">    fmt.Println(arr.Less(<span class=\"number\">0</span>,<span class=\"number\">1</span>))</span><br><span class=\"line\">    fmt.Println(rarr.Less(<span class=\"number\">0</span>,<span class=\"number\">1</span>))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>reverse</code> 结构体内嵌了一个名为 <code>Interface</code> 的 <code>interface</code>，并且实现 <code>Less</code> 函数，但是<br>却没有实现 <code>Len</code>, <code>Swap</code> 函数。</p>\n<p>为什么这么设计？</p>\n<p>通过这种方法可以让 <strong><code>reverse</code> 实现 <code>Interface</code> 这个接口类型，并且仅实现某个指定的方法，而不需要实现这个接口下的所有方法</strong>。</p>\n<p>对比一下传统的组合匿名结构体实现重写的写法：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Interface <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">    Len() <span class=\"keyword\">int</span></span><br><span class=\"line\">    Less(i, j <span class=\"keyword\">int</span>) <span class=\"keyword\">bool</span></span><br><span class=\"line\">    Swap(i, j <span class=\"keyword\">int</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Array []<span class=\"keyword\">int</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(arr Array)</span> <span class=\"title\">Len</span><span class=\"params\">()</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">len</span>(arr)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(arr Array)</span> <span class=\"title\">Less</span><span class=\"params\">(i, j <span class=\"keyword\">int</span>)</span> <span class=\"title\">bool</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arr[i] &lt; arr[j]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(arr Array)</span> <span class=\"title\">Swap</span><span class=\"params\">(i, j <span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">    arr[i], arr[j] = arr[j], arr[i]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 匿名struct</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> reverse <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    Array</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 重写</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(r reverse)</span> <span class=\"title\">Less</span><span class=\"params\">(i, j <span class=\"keyword\">int</span>)</span> <span class=\"title\">bool</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> r.Array.Less(j, i)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 构造reverse Interface</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Reverse</span><span class=\"params\">(data Array)</span> <span class=\"title\">Interface</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &amp;reverse&#123;data&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    arr := Array&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>&#125;</span><br><span class=\"line\">    rarr := Reverse(arr)</span><br><span class=\"line\">    fmt.Println(arr.Less(<span class=\"number\">0</span>, <span class=\"number\">1</span>))</span><br><span class=\"line\">    fmt.Println(rarr.Less(<span class=\"number\">0</span>, <span class=\"number\">1</span>))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>匿名接口的优点，<strong>匿名接口的方式不依赖具体实现，可以对任意实现了该接口的类型进行重写</strong>。</p>\n<h3 id=\"如果被嵌入类型和嵌入类型有同名的方法，那么调用哪一个的方法\"><a href=\"#如果被嵌入类型和嵌入类型有同名的方法，那么调用哪一个的方法\" class=\"headerlink\" title=\"如果被嵌入类型和嵌入类型有同名的方法，那么调用哪一个的方法\"></a>如果被嵌入类型和嵌入类型有同名的方法，那么调用哪一个的方法</h3><p><strong>只要名称相同，无论这两个方法的签名是否一致，被嵌入类型的方法都会“屏蔽”掉嵌入字段的同名方法</strong>。</p>\n<p>类似的，由于我们同样可以像访问被嵌入类型的字段那样，直接访问嵌入字段的字段，所以<strong>如果这两个结构体类型里存在同名的字段，<br>那么嵌入字段中的那个字段一定会被“屏蔽”</strong>。</p>\n<p>正因为嵌入字段的字段和方法都可以“嫁接”到被嵌入类型上，所以即使在两个同名的成员一个是字段，另一个是方法的情况下，这种“屏蔽”现象依然会存在。</p>\n<p><strong>不过，即使被屏蔽了，我们仍然可以通过链式的选择表达式，选择到嵌入字段的字段或方法</strong>。</p>\n<p>嵌入字段本身也有嵌入字段的情况，这种情况下，“屏蔽”现象会以嵌入的层级为依据，嵌入层级越深的字段或方法越可能被“屏蔽”。</p>\n"},{"title":"包","_content":"# 包\nGo 语言的包与其他语言的 `modules` 或者 `libraries` 类似。Go 语言有超过 100个 的标准包，可以使用\n `go list std | wc -l` 查看包的数量。\n\n更多 Go 语言开源包，可以在 [这里](http://godoc.org) 搜索。\n\nGo 语言编译速度很快，主要依赖下面三点：\n1. 导入的包必须在文件的头部显式声明，这样的话编译器就没有必要读取和分析整个源文件来判断包的依赖关系。\n2. 禁止包的循环依赖，每个包可以被独立编译，而且很可能是被并发编译。\n3. 编译后包的目标文件不仅仅记录包本身的导出信息，同时还记录了包的依赖关系。\n因此，在**编译一个包的时候，编译器只需读取每个导入包的目标文件，而不需要遍历所有依赖的的文件**。\n\n## import\n在 `package` 声明下面，我们需要导入一系列需要使用的包。比如 `import \"fmt\"`。注意如果导入了不需要的包，或者缺少了必要的包，\n编译会失败。\n```go\n// 导入一个包\nimport \"fmt\"\n\n// 导入多个\nimport (\n  \"fmt\"\n  \"os\"\n)\n```\n\n## main\n`main` 是一个特殊的包，`main` 包代表一个独立运行的程序，而不是一个 `modules` 或者 `libraries`。`main` 包里\n必须有 `main` 函数，这个是程序的入口函数，并且 `mian` 函数没有参数。比如：\n```go\nfunc main() {\n\tfmt.Println(\"Hello, 世界\")\n}\n```\n\n### hello world\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tfmt.Println(x)\n}\n```\n**函数声明使用 `func` 关键字。Go 不需要在语句或者声明的末尾添加分号。除非一行代码上有多条语句。**\n\n## 点操作\n```go\n import(\n    . \"fmt\"\n )\n```\n这个点操作的含义就是这个包导入之后在你调用这个包的函数时，你可以省略前缀的包名，也就是前面你调用的 `fmt.Println(\"hello world\")`\n可以省略的写成 `Println(\"hello world\")`。\n\n### 导入包重命名\n如果导入两个相同名字的包，如 `math/rand` 包和 `crypto/rand` 包，可以为一个包重命名来解决名字冲突：\n```go\nimport (\n    \"crypto/rand\"\n    mrand \"math/rand\" // alternative name mrand avoids conflict\n)\n```\n注意，重命名的包名只在当前源文件有效。\n\n有些情况下也可以使用包重命名：\n1. 包名很长。重命名一个简短的包名。\n2. 与变量名冲突。\n\n选择用简短名称重命名导入包时候最好统一，以避免包名混乱。\n\n### 匿名导入\n比如 `import _ \"image/png\"`，`_` 是空白标识符，不能被访问。\n匿名导入有什么用？我们知道如果导入一个包而不使用会导致编译错误 `unused import`。当我们想要导入包，\n仅仅只是想计算导入包的包级变量的初始化表达式和执行导入包的 `init` 初始化函数，就可以使用匿名导入。\n\n### 声明所属的代码包与其所在目录的名称不同时\n源码文件所在的目录相对于 `src` 目录的相对路径就是它的代码包导入路径，而实际使用其程序实体时给定的限定符要与它\n声明所属的代码包名称对应。为了不让该代码包的使用者产生困惑，我们总是应该让声明的包名与其父目录的名称一致。\n\n## 包声明\n包声明语句（包名）必须在每个源文件的开头。被其它包导入时默认的标识符。每个包都对应一个独立的名字空间，\n如：`image` 包和 `unicode/utf16` 包中都包含了 `Decode`。要在外部引用该函数，必须显式使用 `image.Decode` 或 \n`utf16.Decode` 形式访问。\n\n**包内以大写字母开头定义的名字（包括变量，类型，函数等等），会被导出，可以在包的外部访问。**\n\n默认包名一般采用导入路径名的最后一段，比如 `GOPTAH/src/packages/test` 的 `test` 就是包名。三种情况例外：\n1. `main` 包，`go build` 命令编译完之后生成一个可执行程序。\n2. 以 `_test` 为后缀包名的测试外部扩展包都由 `go test` 命令独立编译。(以 `_` 或 `.` 开头的源文件会被构建工具忽略)\n3. 如 `gopkg.in/yaml.v2`。包的名字包含版本号后缀 `.v2`，这种情况下包名是 `yaml`。\n\n## 包命名\n包命名尽量有描述性且无歧义，简短，避免冲突。\n\n## 初始化包\n包的初始化首先是解决包级变量的依赖顺序，然后按照包级变量声明出现的顺序依次初始化：\n```go\nvar a = b + c // a 第三个初始化, 为 3\nvar b = f()   // b 第二个初始化, 为 2, 通过调用 f (依赖c)\nvar c = 1     // c 第一个初始化, 为 1\n\nfunc f() int { return c + 1 }\n```\n如果包中含有多个源文件，构建工具首先会将 `.go` 文件根据文件名排序，然后依次调用编译器编译。\n\n每个包在解决依赖的前提下，以导入声明的顺序初始化，每个包只会被初始化一次。因此，如果一个 p 包导入了 q 包，\n那么在 p 包初始化的时候可以认为 q 包必然已经初始化过了。初始化工作是自下而上进行的，`main` 包最后被初始化。以这种方式，\n可以确保在 `main` 函数执行之前，所有依赖的包都已经完成初始化工作了。\n\n### 使用 `init` 函数\n使用 `init` 函数来简化初始化工作，`init` 函数和普通函数类似，但是不能被调用或引用。\n程序开始执行时按照它们声明的顺序自动调用。\n`init` 函数不能有任何的参数和返回值，虽然一个 `package` 里面可以写任意多个 `init` 函数，但这无论是对于可读性还是以后的可维护性来说，\n我们都强烈建议用户在一个 `package` 中每个文件只写一个 `init` 函数。\n\n程序的初始化和执行都起始于 `main` 包。如果 `main` 包还导入了其它的包，那么就会在编译时将它们依次导入。有时一个包会被多个包同时导入，\n那么它只会被导入一次（例如很多包可能都会用到 `fmt` 包，但它只会被导入一次，因为没有必要导入多次）。当一个包被导入时，如果该包还导入了\n其它的包，那么会先将其它包导入进来，然后再对这些包中的包级常量和变量进行初始化，接着执行 `init` 函数（如果有的话），依次类推。等所有\n被导入的包都加载完毕了，就会开始对 `main` 包中的包级常量和变量进行初始化，然后执行 `main` 包中的 `init` 函数（如果存在的话），最后\n执行 `main` 函数。","source":"basic/package.md","raw":"---\ntitle: 包\n---\n# 包\nGo 语言的包与其他语言的 `modules` 或者 `libraries` 类似。Go 语言有超过 100个 的标准包，可以使用\n `go list std | wc -l` 查看包的数量。\n\n更多 Go 语言开源包，可以在 [这里](http://godoc.org) 搜索。\n\nGo 语言编译速度很快，主要依赖下面三点：\n1. 导入的包必须在文件的头部显式声明，这样的话编译器就没有必要读取和分析整个源文件来判断包的依赖关系。\n2. 禁止包的循环依赖，每个包可以被独立编译，而且很可能是被并发编译。\n3. 编译后包的目标文件不仅仅记录包本身的导出信息，同时还记录了包的依赖关系。\n因此，在**编译一个包的时候，编译器只需读取每个导入包的目标文件，而不需要遍历所有依赖的的文件**。\n\n## import\n在 `package` 声明下面，我们需要导入一系列需要使用的包。比如 `import \"fmt\"`。注意如果导入了不需要的包，或者缺少了必要的包，\n编译会失败。\n```go\n// 导入一个包\nimport \"fmt\"\n\n// 导入多个\nimport (\n  \"fmt\"\n  \"os\"\n)\n```\n\n## main\n`main` 是一个特殊的包，`main` 包代表一个独立运行的程序，而不是一个 `modules` 或者 `libraries`。`main` 包里\n必须有 `main` 函数，这个是程序的入口函数，并且 `mian` 函数没有参数。比如：\n```go\nfunc main() {\n\tfmt.Println(\"Hello, 世界\")\n}\n```\n\n### hello world\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tfmt.Println(x)\n}\n```\n**函数声明使用 `func` 关键字。Go 不需要在语句或者声明的末尾添加分号。除非一行代码上有多条语句。**\n\n## 点操作\n```go\n import(\n    . \"fmt\"\n )\n```\n这个点操作的含义就是这个包导入之后在你调用这个包的函数时，你可以省略前缀的包名，也就是前面你调用的 `fmt.Println(\"hello world\")`\n可以省略的写成 `Println(\"hello world\")`。\n\n### 导入包重命名\n如果导入两个相同名字的包，如 `math/rand` 包和 `crypto/rand` 包，可以为一个包重命名来解决名字冲突：\n```go\nimport (\n    \"crypto/rand\"\n    mrand \"math/rand\" // alternative name mrand avoids conflict\n)\n```\n注意，重命名的包名只在当前源文件有效。\n\n有些情况下也可以使用包重命名：\n1. 包名很长。重命名一个简短的包名。\n2. 与变量名冲突。\n\n选择用简短名称重命名导入包时候最好统一，以避免包名混乱。\n\n### 匿名导入\n比如 `import _ \"image/png\"`，`_` 是空白标识符，不能被访问。\n匿名导入有什么用？我们知道如果导入一个包而不使用会导致编译错误 `unused import`。当我们想要导入包，\n仅仅只是想计算导入包的包级变量的初始化表达式和执行导入包的 `init` 初始化函数，就可以使用匿名导入。\n\n### 声明所属的代码包与其所在目录的名称不同时\n源码文件所在的目录相对于 `src` 目录的相对路径就是它的代码包导入路径，而实际使用其程序实体时给定的限定符要与它\n声明所属的代码包名称对应。为了不让该代码包的使用者产生困惑，我们总是应该让声明的包名与其父目录的名称一致。\n\n## 包声明\n包声明语句（包名）必须在每个源文件的开头。被其它包导入时默认的标识符。每个包都对应一个独立的名字空间，\n如：`image` 包和 `unicode/utf16` 包中都包含了 `Decode`。要在外部引用该函数，必须显式使用 `image.Decode` 或 \n`utf16.Decode` 形式访问。\n\n**包内以大写字母开头定义的名字（包括变量，类型，函数等等），会被导出，可以在包的外部访问。**\n\n默认包名一般采用导入路径名的最后一段，比如 `GOPTAH/src/packages/test` 的 `test` 就是包名。三种情况例外：\n1. `main` 包，`go build` 命令编译完之后生成一个可执行程序。\n2. 以 `_test` 为后缀包名的测试外部扩展包都由 `go test` 命令独立编译。(以 `_` 或 `.` 开头的源文件会被构建工具忽略)\n3. 如 `gopkg.in/yaml.v2`。包的名字包含版本号后缀 `.v2`，这种情况下包名是 `yaml`。\n\n## 包命名\n包命名尽量有描述性且无歧义，简短，避免冲突。\n\n## 初始化包\n包的初始化首先是解决包级变量的依赖顺序，然后按照包级变量声明出现的顺序依次初始化：\n```go\nvar a = b + c // a 第三个初始化, 为 3\nvar b = f()   // b 第二个初始化, 为 2, 通过调用 f (依赖c)\nvar c = 1     // c 第一个初始化, 为 1\n\nfunc f() int { return c + 1 }\n```\n如果包中含有多个源文件，构建工具首先会将 `.go` 文件根据文件名排序，然后依次调用编译器编译。\n\n每个包在解决依赖的前提下，以导入声明的顺序初始化，每个包只会被初始化一次。因此，如果一个 p 包导入了 q 包，\n那么在 p 包初始化的时候可以认为 q 包必然已经初始化过了。初始化工作是自下而上进行的，`main` 包最后被初始化。以这种方式，\n可以确保在 `main` 函数执行之前，所有依赖的包都已经完成初始化工作了。\n\n### 使用 `init` 函数\n使用 `init` 函数来简化初始化工作，`init` 函数和普通函数类似，但是不能被调用或引用。\n程序开始执行时按照它们声明的顺序自动调用。\n`init` 函数不能有任何的参数和返回值，虽然一个 `package` 里面可以写任意多个 `init` 函数，但这无论是对于可读性还是以后的可维护性来说，\n我们都强烈建议用户在一个 `package` 中每个文件只写一个 `init` 函数。\n\n程序的初始化和执行都起始于 `main` 包。如果 `main` 包还导入了其它的包，那么就会在编译时将它们依次导入。有时一个包会被多个包同时导入，\n那么它只会被导入一次（例如很多包可能都会用到 `fmt` 包，但它只会被导入一次，因为没有必要导入多次）。当一个包被导入时，如果该包还导入了\n其它的包，那么会先将其它包导入进来，然后再对这些包中的包级常量和变量进行初始化，接着执行 `init` 函数（如果有的话），依次类推。等所有\n被导入的包都加载完毕了，就会开始对 `main` 包中的包级常量和变量进行初始化，然后执行 `main` 包中的 `init` 函数（如果存在的话），最后\n执行 `main` 函数。","date":"2019-08-24T02:08:28.818Z","updated":"2019-08-24T02:08:28.801Z","path":"basic/package.html","comments":1,"layout":"page","_id":"ck1xm14kn000mfcw2tvhvywi0","content":"<h1 id=\"包\"><a href=\"#包\" class=\"headerlink\" title=\"包\"></a>包</h1><p>Go 语言的包与其他语言的 <code>modules</code> 或者 <code>libraries</code> 类似。Go 语言有超过 100个 的标准包，可以使用<br> <code>go list std | wc -l</code> 查看包的数量。</p>\n<p>更多 Go 语言开源包，可以在 <a href=\"http://godoc.org\" target=\"_blank\" rel=\"noopener\">这里</a> 搜索。</p>\n<p>Go 语言编译速度很快，主要依赖下面三点：</p>\n<ol>\n<li>导入的包必须在文件的头部显式声明，这样的话编译器就没有必要读取和分析整个源文件来判断包的依赖关系。</li>\n<li>禁止包的循环依赖，每个包可以被独立编译，而且很可能是被并发编译。</li>\n<li>编译后包的目标文件不仅仅记录包本身的导出信息，同时还记录了包的依赖关系。<br>因此，在<strong>编译一个包的时候，编译器只需读取每个导入包的目标文件，而不需要遍历所有依赖的的文件</strong>。</li>\n</ol>\n<h2 id=\"import\"><a href=\"#import\" class=\"headerlink\" title=\"import\"></a>import</h2><p>在 <code>package</code> 声明下面，我们需要导入一系列需要使用的包。比如 <code>import &quot;fmt&quot;</code>。注意如果导入了不需要的包，或者缺少了必要的包，<br>编译会失败。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 导入一个包</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"fmt\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 导入多个</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">  <span class=\"string\">\"fmt\"</span></span><br><span class=\"line\">  <span class=\"string\">\"os\"</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"main\"><a href=\"#main\" class=\"headerlink\" title=\"main\"></a>main</h2><p><code>main</code> 是一个特殊的包，<code>main</code> 包代表一个独立运行的程序，而不是一个 <code>modules</code> 或者 <code>libraries</code>。<code>main</code> 包里<br>必须有 <code>main</code> 函数，这个是程序的入口函数，并且 <code>mian</code> 函数没有参数。比如：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">\"Hello, 世界\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"hello-world\"><a href=\"#hello-world\" class=\"headerlink\" title=\"hello world\"></a>hello world</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"fmt\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tfmt.Println(x)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>函数声明使用 <code>func</code> 关键字。Go 不需要在语句或者声明的末尾添加分号。除非一行代码上有多条语句。</strong></p>\n<h2 id=\"点操作\"><a href=\"#点操作\" class=\"headerlink\" title=\"点操作\"></a>点操作</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span>(</span><br><span class=\"line\">   . <span class=\"string\">\"fmt\"</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>这个点操作的含义就是这个包导入之后在你调用这个包的函数时，你可以省略前缀的包名，也就是前面你调用的 <code>fmt.Println(&quot;hello world&quot;)</code><br>可以省略的写成 <code>Println(&quot;hello world&quot;)</code>。</p>\n<h3 id=\"导入包重命名\"><a href=\"#导入包重命名\" class=\"headerlink\" title=\"导入包重命名\"></a>导入包重命名</h3><p>如果导入两个相同名字的包，如 <code>math/rand</code> 包和 <code>crypto/rand</code> 包，可以为一个包重命名来解决名字冲突：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">\"crypto/rand\"</span></span><br><span class=\"line\">    mrand <span class=\"string\">\"math/rand\"</span> <span class=\"comment\">// alternative name mrand avoids conflict</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<p>注意，重命名的包名只在当前源文件有效。</p>\n<p>有些情况下也可以使用包重命名：</p>\n<ol>\n<li>包名很长。重命名一个简短的包名。</li>\n<li>与变量名冲突。</li>\n</ol>\n<p>选择用简短名称重命名导入包时候最好统一，以避免包名混乱。</p>\n<h3 id=\"匿名导入\"><a href=\"#匿名导入\" class=\"headerlink\" title=\"匿名导入\"></a>匿名导入</h3><p>比如 <code>import _ &quot;image/png&quot;</code>，<code>_</code> 是空白标识符，不能被访问。<br>匿名导入有什么用？我们知道如果导入一个包而不使用会导致编译错误 <code>unused import</code>。当我们想要导入包，<br>仅仅只是想计算导入包的包级变量的初始化表达式和执行导入包的 <code>init</code> 初始化函数，就可以使用匿名导入。</p>\n<h3 id=\"声明所属的代码包与其所在目录的名称不同时\"><a href=\"#声明所属的代码包与其所在目录的名称不同时\" class=\"headerlink\" title=\"声明所属的代码包与其所在目录的名称不同时\"></a>声明所属的代码包与其所在目录的名称不同时</h3><p>源码文件所在的目录相对于 <code>src</code> 目录的相对路径就是它的代码包导入路径，而实际使用其程序实体时给定的限定符要与它<br>声明所属的代码包名称对应。为了不让该代码包的使用者产生困惑，我们总是应该让声明的包名与其父目录的名称一致。</p>\n<h2 id=\"包声明\"><a href=\"#包声明\" class=\"headerlink\" title=\"包声明\"></a>包声明</h2><p>包声明语句（包名）必须在每个源文件的开头。被其它包导入时默认的标识符。每个包都对应一个独立的名字空间，<br>如：<code>image</code> 包和 <code>unicode/utf16</code> 包中都包含了 <code>Decode</code>。要在外部引用该函数，必须显式使用 <code>image.Decode</code> 或<br><code>utf16.Decode</code> 形式访问。</p>\n<p><strong>包内以大写字母开头定义的名字（包括变量，类型，函数等等），会被导出，可以在包的外部访问。</strong></p>\n<p>默认包名一般采用导入路径名的最后一段，比如 <code>GOPTAH/src/packages/test</code> 的 <code>test</code> 就是包名。三种情况例外：</p>\n<ol>\n<li><code>main</code> 包，<code>go build</code> 命令编译完之后生成一个可执行程序。</li>\n<li>以 <code>_test</code> 为后缀包名的测试外部扩展包都由 <code>go test</code> 命令独立编译。(以 <code>_</code> 或 <code>.</code> 开头的源文件会被构建工具忽略)</li>\n<li>如 <code>gopkg.in/yaml.v2</code>。包的名字包含版本号后缀 <code>.v2</code>，这种情况下包名是 <code>yaml</code>。</li>\n</ol>\n<h2 id=\"包命名\"><a href=\"#包命名\" class=\"headerlink\" title=\"包命名\"></a>包命名</h2><p>包命名尽量有描述性且无歧义，简短，避免冲突。</p>\n<h2 id=\"初始化包\"><a href=\"#初始化包\" class=\"headerlink\" title=\"初始化包\"></a>初始化包</h2><p>包的初始化首先是解决包级变量的依赖顺序，然后按照包级变量声明出现的顺序依次初始化：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = b + c <span class=\"comment\">// a 第三个初始化, 为 3</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> b = f()   <span class=\"comment\">// b 第二个初始化, 为 2, 通过调用 f (依赖c)</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> c = <span class=\"number\">1</span>     <span class=\"comment\">// c 第一个初始化, 为 1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">f</span><span class=\"params\">()</span> <span class=\"title\">int</span></span> &#123; <span class=\"keyword\">return</span> c + <span class=\"number\">1</span> &#125;</span><br></pre></td></tr></table></figure></p>\n<p>如果包中含有多个源文件，构建工具首先会将 <code>.go</code> 文件根据文件名排序，然后依次调用编译器编译。</p>\n<p>每个包在解决依赖的前提下，以导入声明的顺序初始化，每个包只会被初始化一次。因此，如果一个 p 包导入了 q 包，<br>那么在 p 包初始化的时候可以认为 q 包必然已经初始化过了。初始化工作是自下而上进行的，<code>main</code> 包最后被初始化。以这种方式，<br>可以确保在 <code>main</code> 函数执行之前，所有依赖的包都已经完成初始化工作了。</p>\n<h3 id=\"使用-init-函数\"><a href=\"#使用-init-函数\" class=\"headerlink\" title=\"使用 init 函数\"></a>使用 <code>init</code> 函数</h3><p>使用 <code>init</code> 函数来简化初始化工作，<code>init</code> 函数和普通函数类似，但是不能被调用或引用。<br>程序开始执行时按照它们声明的顺序自动调用。<br><code>init</code> 函数不能有任何的参数和返回值，虽然一个 <code>package</code> 里面可以写任意多个 <code>init</code> 函数，但这无论是对于可读性还是以后的可维护性来说，<br>我们都强烈建议用户在一个 <code>package</code> 中每个文件只写一个 <code>init</code> 函数。</p>\n<p>程序的初始化和执行都起始于 <code>main</code> 包。如果 <code>main</code> 包还导入了其它的包，那么就会在编译时将它们依次导入。有时一个包会被多个包同时导入，<br>那么它只会被导入一次（例如很多包可能都会用到 <code>fmt</code> 包，但它只会被导入一次，因为没有必要导入多次）。当一个包被导入时，如果该包还导入了<br>其它的包，那么会先将其它包导入进来，然后再对这些包中的包级常量和变量进行初始化，接着执行 <code>init</code> 函数（如果有的话），依次类推。等所有<br>被导入的包都加载完毕了，就会开始对 <code>main</code> 包中的包级常量和变量进行初始化，然后执行 <code>main</code> 包中的 <code>init</code> 函数（如果存在的话），最后<br>执行 <code>main</code> 函数。</p>\n","site":{"data":{"navigation":{"logo":{"text":"Golang Learn","type":"link","path":"index.html"},"main":[{"text":"Golang 基础","type":"label"},{"text":"Go 环境配置","type":"link","path":"basic/env_config.html"},{"text":"包","type":"link","path":"basic/package.html"},{"text":"基础数据类型","type":"link","path":"basic/basic_data.html"},{"text":"变量","type":"link","path":"basic/var.html"},{"text":"常量","type":"link","path":"basic/constant.html"},{"text":"控制语句","type":"link","path":"basic/flow.html"},{"text":"运算符","type":"link","path":"basic/operator.html"},{"text":"作用域","type":"link","path":"basic/scope.html"},{"text":"指针","type":"link","path":"basic/pointer.html"},{"text":"数组","type":"link","path":"basic/array.html"},{"text":"切片","type":"link","path":"basic/slice.html"},{"text":"字典","type":"link","path":"basic/map.html"},{"text":"函数","type":"link","path":"basic/function.html"},{"text":"结构体","type":"link","path":"basic/struct.html"},{"text":"接口","type":"link","path":"basic/interface.html"},{"text":"面向对象","type":"link","path":"basic/oop.html"},{"text":"错误","type":"link","path":"basic/error.html"},{"text":"序列化","type":"link","path":"basic/json.html"},{"text":"反射","type":"link","path":"basic/reflect.html"},{"text":"测试","type":"link","path":"basic/test.html"},{"text":"并发编程","type":"label"},{"text":"goroutine","type":"link","path":"concurrent/goroutine.html"},{"text":"channel","type":"link","path":"concurrent/channel.html"},{"text":"同步和锁","type":"link","path":"concurrent/sync_lock.html"},{"text":"内存分配","type":"label"},{"text":"内存分配","type":"link","path":"advance/mm.html"},{"text":"垃圾回收","type":"label"},{"text":"垃圾回收","type":"link","path":"advance/gc.html"},{"text":"标准库","type":"label"},{"text":"fmt","type":"link","path":"standards/io/fmt.html"},{"text":"io","type":"link","path":"standards/io/io.html"},{"text":"ioutil","type":"link","path":"standards/io/ioutil.html"},{"text":"bufio","type":"link","path":"standards/io/bufio.html"},{"text":"os","type":"link","path":"standards/os/os.html"},{"text":"filepath","type":"link","path":"standards/os/filepath.html"},{"text":"strings","type":"link","path":"standards/text/strings.html"},{"text":"strconv","type":"link","path":"standards/text/strconv.html"},{"text":"unicode","type":"link","path":"standards/text/unicode.html"},{"text":"log","type":"link","path":"standards/log.html"},{"text":"time","type":"link","path":"standards/time.html"},{"text":"http","type":"link","path":"standards/net/http.html"},{"text":"math","type":"link","path":"standards/data/math.html"},{"text":"sort","type":"link","path":"standards/data/sort.html"},{"text":"big","type":"link","path":"standards/data/big.html"},{"text":"container","type":"link","path":"standards/data/container.html"},{"text":"sql","type":"link","path":"standards/database/sql.html"},{"text":"THEME","type":"label"},{"text":"使用文档主题","type":"link","path":"theme/theme-usage.html"},{"text":"SUPPORT AND FEEDBACK","type":"label"},{"text":"Raise an Issue on Github","type":"link","path":"https://github.com/shipengqi/golang-learn/issues/new"}]}}},"excerpt":"","more":"<h1 id=\"包\"><a href=\"#包\" class=\"headerlink\" title=\"包\"></a>包</h1><p>Go 语言的包与其他语言的 <code>modules</code> 或者 <code>libraries</code> 类似。Go 语言有超过 100个 的标准包，可以使用<br> <code>go list std | wc -l</code> 查看包的数量。</p>\n<p>更多 Go 语言开源包，可以在 <a href=\"http://godoc.org\" target=\"_blank\" rel=\"noopener\">这里</a> 搜索。</p>\n<p>Go 语言编译速度很快，主要依赖下面三点：</p>\n<ol>\n<li>导入的包必须在文件的头部显式声明，这样的话编译器就没有必要读取和分析整个源文件来判断包的依赖关系。</li>\n<li>禁止包的循环依赖，每个包可以被独立编译，而且很可能是被并发编译。</li>\n<li>编译后包的目标文件不仅仅记录包本身的导出信息，同时还记录了包的依赖关系。<br>因此，在<strong>编译一个包的时候，编译器只需读取每个导入包的目标文件，而不需要遍历所有依赖的的文件</strong>。</li>\n</ol>\n<h2 id=\"import\"><a href=\"#import\" class=\"headerlink\" title=\"import\"></a>import</h2><p>在 <code>package</code> 声明下面，我们需要导入一系列需要使用的包。比如 <code>import &quot;fmt&quot;</code>。注意如果导入了不需要的包，或者缺少了必要的包，<br>编译会失败。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 导入一个包</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"fmt\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 导入多个</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">  <span class=\"string\">\"fmt\"</span></span><br><span class=\"line\">  <span class=\"string\">\"os\"</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"main\"><a href=\"#main\" class=\"headerlink\" title=\"main\"></a>main</h2><p><code>main</code> 是一个特殊的包，<code>main</code> 包代表一个独立运行的程序，而不是一个 <code>modules</code> 或者 <code>libraries</code>。<code>main</code> 包里<br>必须有 <code>main</code> 函数，这个是程序的入口函数，并且 <code>mian</code> 函数没有参数。比如：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">\"Hello, 世界\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"hello-world\"><a href=\"#hello-world\" class=\"headerlink\" title=\"hello world\"></a>hello world</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"fmt\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tfmt.Println(x)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>函数声明使用 <code>func</code> 关键字。Go 不需要在语句或者声明的末尾添加分号。除非一行代码上有多条语句。</strong></p>\n<h2 id=\"点操作\"><a href=\"#点操作\" class=\"headerlink\" title=\"点操作\"></a>点操作</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span>(</span><br><span class=\"line\">   . <span class=\"string\">\"fmt\"</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>这个点操作的含义就是这个包导入之后在你调用这个包的函数时，你可以省略前缀的包名，也就是前面你调用的 <code>fmt.Println(&quot;hello world&quot;)</code><br>可以省略的写成 <code>Println(&quot;hello world&quot;)</code>。</p>\n<h3 id=\"导入包重命名\"><a href=\"#导入包重命名\" class=\"headerlink\" title=\"导入包重命名\"></a>导入包重命名</h3><p>如果导入两个相同名字的包，如 <code>math/rand</code> 包和 <code>crypto/rand</code> 包，可以为一个包重命名来解决名字冲突：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">\"crypto/rand\"</span></span><br><span class=\"line\">    mrand <span class=\"string\">\"math/rand\"</span> <span class=\"comment\">// alternative name mrand avoids conflict</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<p>注意，重命名的包名只在当前源文件有效。</p>\n<p>有些情况下也可以使用包重命名：</p>\n<ol>\n<li>包名很长。重命名一个简短的包名。</li>\n<li>与变量名冲突。</li>\n</ol>\n<p>选择用简短名称重命名导入包时候最好统一，以避免包名混乱。</p>\n<h3 id=\"匿名导入\"><a href=\"#匿名导入\" class=\"headerlink\" title=\"匿名导入\"></a>匿名导入</h3><p>比如 <code>import _ &quot;image/png&quot;</code>，<code>_</code> 是空白标识符，不能被访问。<br>匿名导入有什么用？我们知道如果导入一个包而不使用会导致编译错误 <code>unused import</code>。当我们想要导入包，<br>仅仅只是想计算导入包的包级变量的初始化表达式和执行导入包的 <code>init</code> 初始化函数，就可以使用匿名导入。</p>\n<h3 id=\"声明所属的代码包与其所在目录的名称不同时\"><a href=\"#声明所属的代码包与其所在目录的名称不同时\" class=\"headerlink\" title=\"声明所属的代码包与其所在目录的名称不同时\"></a>声明所属的代码包与其所在目录的名称不同时</h3><p>源码文件所在的目录相对于 <code>src</code> 目录的相对路径就是它的代码包导入路径，而实际使用其程序实体时给定的限定符要与它<br>声明所属的代码包名称对应。为了不让该代码包的使用者产生困惑，我们总是应该让声明的包名与其父目录的名称一致。</p>\n<h2 id=\"包声明\"><a href=\"#包声明\" class=\"headerlink\" title=\"包声明\"></a>包声明</h2><p>包声明语句（包名）必须在每个源文件的开头。被其它包导入时默认的标识符。每个包都对应一个独立的名字空间，<br>如：<code>image</code> 包和 <code>unicode/utf16</code> 包中都包含了 <code>Decode</code>。要在外部引用该函数，必须显式使用 <code>image.Decode</code> 或<br><code>utf16.Decode</code> 形式访问。</p>\n<p><strong>包内以大写字母开头定义的名字（包括变量，类型，函数等等），会被导出，可以在包的外部访问。</strong></p>\n<p>默认包名一般采用导入路径名的最后一段，比如 <code>GOPTAH/src/packages/test</code> 的 <code>test</code> 就是包名。三种情况例外：</p>\n<ol>\n<li><code>main</code> 包，<code>go build</code> 命令编译完之后生成一个可执行程序。</li>\n<li>以 <code>_test</code> 为后缀包名的测试外部扩展包都由 <code>go test</code> 命令独立编译。(以 <code>_</code> 或 <code>.</code> 开头的源文件会被构建工具忽略)</li>\n<li>如 <code>gopkg.in/yaml.v2</code>。包的名字包含版本号后缀 <code>.v2</code>，这种情况下包名是 <code>yaml</code>。</li>\n</ol>\n<h2 id=\"包命名\"><a href=\"#包命名\" class=\"headerlink\" title=\"包命名\"></a>包命名</h2><p>包命名尽量有描述性且无歧义，简短，避免冲突。</p>\n<h2 id=\"初始化包\"><a href=\"#初始化包\" class=\"headerlink\" title=\"初始化包\"></a>初始化包</h2><p>包的初始化首先是解决包级变量的依赖顺序，然后按照包级变量声明出现的顺序依次初始化：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = b + c <span class=\"comment\">// a 第三个初始化, 为 3</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> b = f()   <span class=\"comment\">// b 第二个初始化, 为 2, 通过调用 f (依赖c)</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> c = <span class=\"number\">1</span>     <span class=\"comment\">// c 第一个初始化, 为 1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">f</span><span class=\"params\">()</span> <span class=\"title\">int</span></span> &#123; <span class=\"keyword\">return</span> c + <span class=\"number\">1</span> &#125;</span><br></pre></td></tr></table></figure></p>\n<p>如果包中含有多个源文件，构建工具首先会将 <code>.go</code> 文件根据文件名排序，然后依次调用编译器编译。</p>\n<p>每个包在解决依赖的前提下，以导入声明的顺序初始化，每个包只会被初始化一次。因此，如果一个 p 包导入了 q 包，<br>那么在 p 包初始化的时候可以认为 q 包必然已经初始化过了。初始化工作是自下而上进行的，<code>main</code> 包最后被初始化。以这种方式，<br>可以确保在 <code>main</code> 函数执行之前，所有依赖的包都已经完成初始化工作了。</p>\n<h3 id=\"使用-init-函数\"><a href=\"#使用-init-函数\" class=\"headerlink\" title=\"使用 init 函数\"></a>使用 <code>init</code> 函数</h3><p>使用 <code>init</code> 函数来简化初始化工作，<code>init</code> 函数和普通函数类似，但是不能被调用或引用。<br>程序开始执行时按照它们声明的顺序自动调用。<br><code>init</code> 函数不能有任何的参数和返回值，虽然一个 <code>package</code> 里面可以写任意多个 <code>init</code> 函数，但这无论是对于可读性还是以后的可维护性来说，<br>我们都强烈建议用户在一个 <code>package</code> 中每个文件只写一个 <code>init</code> 函数。</p>\n<p>程序的初始化和执行都起始于 <code>main</code> 包。如果 <code>main</code> 包还导入了其它的包，那么就会在编译时将它们依次导入。有时一个包会被多个包同时导入，<br>那么它只会被导入一次（例如很多包可能都会用到 <code>fmt</code> 包，但它只会被导入一次，因为没有必要导入多次）。当一个包被导入时，如果该包还导入了<br>其它的包，那么会先将其它包导入进来，然后再对这些包中的包级常量和变量进行初始化，接着执行 <code>init</code> 函数（如果有的话），依次类推。等所有<br>被导入的包都加载完毕了，就会开始对 <code>main</code> 包中的包级常量和变量进行初始化，然后执行 <code>main</code> 包中的 <code>init</code> 函数（如果存在的话），最后<br>执行 <code>main</code> 函数。</p>\n"},{"title":"作用域","_content":"# 作用域\n声明语句的作用域是指源代码中可以有效使用这个名字的范围。\n- 局部变量 在函数体内或代码块内声明的变量称之为局部变量，它们的作用域只在代码块内，参数和返回值变量也是局部变量。\n- 全局变量 作用域都是全局的（在本包范围内） 在函数体外声明的变量称之为全局变量，**全局变量可以在整个包甚至外部包\n（被导出后 首字母大写）使用**。 全局变量可以在任何函数中使用。\n\n\nGo 的标识符作用域是基于代码块的。代码块就是包裹在一对大括号内部的声明和语句，并且是可嵌套的。代码块内部声明的名字是无法\n被外部块访问的。\n\n声明语句作用域范围的大小。\n- 内置的类型、函数和常量，比如 `int`、`len` 和 `true` 是全局作用域\n- 在函数外部（也就是包级语法域）声明的名字可以在同一个包的任何源文件中访问\n- 导入的包，如 `import \"packages/test\"`，是对应源文件级的作用域，只能在当前的源文件中访问\n- 在函数内部声明的名字，只能在函数内部访问\n\n**一个程序可能包含多个同名的声明，只要它们在不同的词法域就可以。内层的词法域会屏蔽外部的声明。** ","source":"basic/scope.md","raw":"---\ntitle: 作用域\n---\n# 作用域\n声明语句的作用域是指源代码中可以有效使用这个名字的范围。\n- 局部变量 在函数体内或代码块内声明的变量称之为局部变量，它们的作用域只在代码块内，参数和返回值变量也是局部变量。\n- 全局变量 作用域都是全局的（在本包范围内） 在函数体外声明的变量称之为全局变量，**全局变量可以在整个包甚至外部包\n（被导出后 首字母大写）使用**。 全局变量可以在任何函数中使用。\n\n\nGo 的标识符作用域是基于代码块的。代码块就是包裹在一对大括号内部的声明和语句，并且是可嵌套的。代码块内部声明的名字是无法\n被外部块访问的。\n\n声明语句作用域范围的大小。\n- 内置的类型、函数和常量，比如 `int`、`len` 和 `true` 是全局作用域\n- 在函数外部（也就是包级语法域）声明的名字可以在同一个包的任何源文件中访问\n- 导入的包，如 `import \"packages/test\"`，是对应源文件级的作用域，只能在当前的源文件中访问\n- 在函数内部声明的名字，只能在函数内部访问\n\n**一个程序可能包含多个同名的声明，只要它们在不同的词法域就可以。内层的词法域会屏蔽外部的声明。** ","date":"2019-08-24T01:38:49.994Z","updated":"2019-08-24T01:38:49.972Z","path":"basic/scope.html","comments":1,"layout":"page","_id":"ck1xm14ko000nfcw2ils5isk2","content":"<h1 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a>作用域</h1><p>声明语句的作用域是指源代码中可以有效使用这个名字的范围。</p>\n<ul>\n<li>局部变量 在函数体内或代码块内声明的变量称之为局部变量，它们的作用域只在代码块内，参数和返回值变量也是局部变量。</li>\n<li>全局变量 作用域都是全局的（在本包范围内） 在函数体外声明的变量称之为全局变量，<strong>全局变量可以在整个包甚至外部包<br>（被导出后 首字母大写）使用</strong>。 全局变量可以在任何函数中使用。</li>\n</ul>\n<p>Go 的标识符作用域是基于代码块的。代码块就是包裹在一对大括号内部的声明和语句，并且是可嵌套的。代码块内部声明的名字是无法<br>被外部块访问的。</p>\n<p>声明语句作用域范围的大小。</p>\n<ul>\n<li>内置的类型、函数和常量，比如 <code>int</code>、<code>len</code> 和 <code>true</code> 是全局作用域</li>\n<li>在函数外部（也就是包级语法域）声明的名字可以在同一个包的任何源文件中访问</li>\n<li>导入的包，如 <code>import &quot;packages/test&quot;</code>，是对应源文件级的作用域，只能在当前的源文件中访问</li>\n<li>在函数内部声明的名字，只能在函数内部访问</li>\n</ul>\n<p><strong>一个程序可能包含多个同名的声明，只要它们在不同的词法域就可以。内层的词法域会屏蔽外部的声明。</strong> </p>\n","site":{"data":{"navigation":{"logo":{"text":"Golang Learn","type":"link","path":"index.html"},"main":[{"text":"Golang 基础","type":"label"},{"text":"Go 环境配置","type":"link","path":"basic/env_config.html"},{"text":"包","type":"link","path":"basic/package.html"},{"text":"基础数据类型","type":"link","path":"basic/basic_data.html"},{"text":"变量","type":"link","path":"basic/var.html"},{"text":"常量","type":"link","path":"basic/constant.html"},{"text":"控制语句","type":"link","path":"basic/flow.html"},{"text":"运算符","type":"link","path":"basic/operator.html"},{"text":"作用域","type":"link","path":"basic/scope.html"},{"text":"指针","type":"link","path":"basic/pointer.html"},{"text":"数组","type":"link","path":"basic/array.html"},{"text":"切片","type":"link","path":"basic/slice.html"},{"text":"字典","type":"link","path":"basic/map.html"},{"text":"函数","type":"link","path":"basic/function.html"},{"text":"结构体","type":"link","path":"basic/struct.html"},{"text":"接口","type":"link","path":"basic/interface.html"},{"text":"面向对象","type":"link","path":"basic/oop.html"},{"text":"错误","type":"link","path":"basic/error.html"},{"text":"序列化","type":"link","path":"basic/json.html"},{"text":"反射","type":"link","path":"basic/reflect.html"},{"text":"测试","type":"link","path":"basic/test.html"},{"text":"并发编程","type":"label"},{"text":"goroutine","type":"link","path":"concurrent/goroutine.html"},{"text":"channel","type":"link","path":"concurrent/channel.html"},{"text":"同步和锁","type":"link","path":"concurrent/sync_lock.html"},{"text":"内存分配","type":"label"},{"text":"内存分配","type":"link","path":"advance/mm.html"},{"text":"垃圾回收","type":"label"},{"text":"垃圾回收","type":"link","path":"advance/gc.html"},{"text":"标准库","type":"label"},{"text":"fmt","type":"link","path":"standards/io/fmt.html"},{"text":"io","type":"link","path":"standards/io/io.html"},{"text":"ioutil","type":"link","path":"standards/io/ioutil.html"},{"text":"bufio","type":"link","path":"standards/io/bufio.html"},{"text":"os","type":"link","path":"standards/os/os.html"},{"text":"filepath","type":"link","path":"standards/os/filepath.html"},{"text":"strings","type":"link","path":"standards/text/strings.html"},{"text":"strconv","type":"link","path":"standards/text/strconv.html"},{"text":"unicode","type":"link","path":"standards/text/unicode.html"},{"text":"log","type":"link","path":"standards/log.html"},{"text":"time","type":"link","path":"standards/time.html"},{"text":"http","type":"link","path":"standards/net/http.html"},{"text":"math","type":"link","path":"standards/data/math.html"},{"text":"sort","type":"link","path":"standards/data/sort.html"},{"text":"big","type":"link","path":"standards/data/big.html"},{"text":"container","type":"link","path":"standards/data/container.html"},{"text":"sql","type":"link","path":"standards/database/sql.html"},{"text":"THEME","type":"label"},{"text":"使用文档主题","type":"link","path":"theme/theme-usage.html"},{"text":"SUPPORT AND FEEDBACK","type":"label"},{"text":"Raise an Issue on Github","type":"link","path":"https://github.com/shipengqi/golang-learn/issues/new"}]}}},"excerpt":"","more":"<h1 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a>作用域</h1><p>声明语句的作用域是指源代码中可以有效使用这个名字的范围。</p>\n<ul>\n<li>局部变量 在函数体内或代码块内声明的变量称之为局部变量，它们的作用域只在代码块内，参数和返回值变量也是局部变量。</li>\n<li>全局变量 作用域都是全局的（在本包范围内） 在函数体外声明的变量称之为全局变量，<strong>全局变量可以在整个包甚至外部包<br>（被导出后 首字母大写）使用</strong>。 全局变量可以在任何函数中使用。</li>\n</ul>\n<p>Go 的标识符作用域是基于代码块的。代码块就是包裹在一对大括号内部的声明和语句，并且是可嵌套的。代码块内部声明的名字是无法<br>被外部块访问的。</p>\n<p>声明语句作用域范围的大小。</p>\n<ul>\n<li>内置的类型、函数和常量，比如 <code>int</code>、<code>len</code> 和 <code>true</code> 是全局作用域</li>\n<li>在函数外部（也就是包级语法域）声明的名字可以在同一个包的任何源文件中访问</li>\n<li>导入的包，如 <code>import &quot;packages/test&quot;</code>，是对应源文件级的作用域，只能在当前的源文件中访问</li>\n<li>在函数内部声明的名字，只能在函数内部访问</li>\n</ul>\n<p><strong>一个程序可能包含多个同名的声明，只要它们在不同的词法域就可以。内层的词法域会屏蔽外部的声明。</strong> </p>\n"},{"title":"接口","_content":"\n# 接口\n\nGo 支持接口数据类型，接口类型是一种抽象的类型。接口类型具体描述了一系列方法的集合，任何其他类型只要实现了这些方法就是实\n现了这个接口，无须显示声明。**接口只有当有两个或两个以上的具体类型必须以相同的方式进行处理时才需要**。\n\n接口的零值就是它的类型和值的部分都是 `nil`。\n\n简单的说，`interface` 是一组 `method` 的组合，我们通过 `interface` 来定义对象的一组行为。\n\n定义接口：\n```go\ntype 接口名 interface {\n  方法名1 [返回类型]\n  方法名2 [返回类型]\n  方法名3 [返回类型]\n  ...\n}\n\n/* 定义结构体 */\ntype struct_name struct {\n   /* variables */\n}\n\n/* 实现接口方法 */\nfunc (struct_name_variable struct_name) 方法名1() [返回类型] {\n   /* 方法实现 */\n}\n...\nfunc (struct_name_variable struct_name) 方法名2() [返回类型] {\n   /* 方法实现*/\n}\n```\n\n实例：\n```go\ntype Phone interface {\n  call()\n}\n\ntype NokiaPhone struct {\n}\n\nfunc (nokiaPhone NokiaPhone) call() {\n  fmt.Println(\"I am Nokia, I can call you!\")\n}\n\ntype IPhone struct {\n}\n\nfunc (iPhone IPhone) call() {\n  fmt.Println(\"I am iPhone, I can call you!\")\n}\n\nfunc main() {\n  var phone Phone\n\n  phone = new(NokiaPhone)\n  phone.call()\n\n  phone = new(IPhone)\n  phone.call()\n}\n```\n\n接口类型也可以通过组合已有的接口来定义：\n```go\ntype Reader interface {\n  Read(p []byte) (n int, err error)\n}\ntype Closer interface {\n  Close() error\n}\n\n\ntype ReadWriteCloser interface {\n  Reader\n  Writer\n  Closer\n}\n\n// 混合\ntype ReadWriter interface {\n  Read(p []byte) (n int, err error)\n  Writer\n}\n```\n\n### 空接口类型\n`interface {}` 被称为空接口类型，它没有任何方法。所有的类型都实现了空 `interface`，\n空 `interface` 在我们需要存储任意类型的数值的时候相当有用，因为它可以存储任意类型的数值。\n```go\n// 定义a为空接口\nvar a interface{}\nvar i int = 5\ns := \"Hello world\"\n// a可以存储任意类型的数值\na = i\na = s\n```\n一个函数把 `interface{}` 作为参数，那么他可以接受任意类型的值作为参数，如果一个函数返回 `interface{}`,\n那么也就可以返回任意类型的值。\n\n`interface{}` 可以存储任意类型，那么怎么判断存储了什么类型？\n\n\n### error 接口\nGo 内置了错误接口。\n```go\ntype error interface {\n  Error() string\n}\n```\n创建一个 `error` 最简单的方法就是调用 `errors.New` 函数。\n\n`error`包：\n```go\npackage errors\n\nfunc New(text string) error { return &errorString{text} }\n\ntype errorString struct { text string }\n\nfunc (e *errorString) Error() string { return e.text }\n```\n\n`fmt.Errorf` 封装了 `errors.New` 函数，它会处理字符串格式化。**当我们想通过模板化的方式生成错误信息，并得到错误值时，\n可以使用`fmt.Errorf`函数。该函数所做的其实就是先调用 `fmt.Sprintf` 函数，得到确切的错误信息；再调用 `errors.New` 函数，\n得到包含该错误信息的 `error` 类型值，最后返回该值**。\n\n实际上，`error` 类型值的 `Error` 方法就相当于其他类型值的 `String` 方法。\n\n### 接口的实际用途\n```go\npackage main\n\nimport (\n    \"fmt\"\n)\n\n//定义 interface\ntype VowelsFinder interface {\n    FindVowels() []rune\n}\n\ntype MyString string\n\n//实现接口\nfunc (ms MyString) FindVowels() []rune {\n    var vowels []rune\n    for _, rune := range ms {\n        if rune == 'a' || rune == 'e' || rune == 'i' || rune == 'o' || rune == 'u' {\n            vowels = append(vowels, rune)\n        }\n    }\n    return vowels\n}\n\nfunc main() {\n    name := MyString(\"Sam Anderson\") // 类型转换\n    var v VowelsFinder // 定义一个接口类型的变量\n    v = name\n    fmt.Printf(\"Vowels are %c\", v.FindVowels())\n\n}\n```\n\n上面的代码 `fmt.Printf(\"Vowels are %c\", v.FindVowels())` 是可以直接使用 `fmt.Printf(\"Vowels are %c\", name.FindVowels())`\n的，那么我们定义的变量 `V` 没有没有了意义。看下面的代码：\n```go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\n// 薪资计算器接口\ntype SalaryCalculator interface {\n\tCalculateSalary() int\n}\n// 普通挖掘机员工\ntype Contract struct {\n\tempId  int\n\tbasicpay int\n}\n// 有蓝翔技校证的员工\ntype Permanent struct {\n\tempId  int\n\tbasicpay int\n\tjj int // 奖金\n}\n\nfunc (p Permanent) CalculateSalary() int {\n\treturn p.basicpay + p.jj\n}\n\nfunc (c Contract) CalculateSalary() int {\n\treturn c.basicpay\n}\n// 总开支\nfunc totalExpense(s []SalaryCalculator) {\n\texpense := 0\n\tfor _, v := range s {\n\t\texpense = expense + v.CalculateSalary()\n\t}\n\tfmt.Printf(\"总开支 $%d\", expense)\n}\n\nfunc main() {\n\tpemp1 := Permanent{1,3000,10000}\n\tpemp2 := Permanent{2, 3000, 20000}\n\tcemp1 := Contract{3, 3000}\n\temployees := []SalaryCalculator{pemp1, pemp2, cemp1}\n\ttotalExpense(employees)\n}\n```\n\n这个时候体现出了接口的作用，`Contract` 和 `Permanent` 是不一样的结构体类型，但是可以定义一个 `SalaryCalculator` 接口类\n型的数组，就可以在 `totalExpense` 中调用元素的 `CalculateSalary` 方法。","source":"basic/interface.md","raw":"---\ntitle: 接口\n---\n\n# 接口\n\nGo 支持接口数据类型，接口类型是一种抽象的类型。接口类型具体描述了一系列方法的集合，任何其他类型只要实现了这些方法就是实\n现了这个接口，无须显示声明。**接口只有当有两个或两个以上的具体类型必须以相同的方式进行处理时才需要**。\n\n接口的零值就是它的类型和值的部分都是 `nil`。\n\n简单的说，`interface` 是一组 `method` 的组合，我们通过 `interface` 来定义对象的一组行为。\n\n定义接口：\n```go\ntype 接口名 interface {\n  方法名1 [返回类型]\n  方法名2 [返回类型]\n  方法名3 [返回类型]\n  ...\n}\n\n/* 定义结构体 */\ntype struct_name struct {\n   /* variables */\n}\n\n/* 实现接口方法 */\nfunc (struct_name_variable struct_name) 方法名1() [返回类型] {\n   /* 方法实现 */\n}\n...\nfunc (struct_name_variable struct_name) 方法名2() [返回类型] {\n   /* 方法实现*/\n}\n```\n\n实例：\n```go\ntype Phone interface {\n  call()\n}\n\ntype NokiaPhone struct {\n}\n\nfunc (nokiaPhone NokiaPhone) call() {\n  fmt.Println(\"I am Nokia, I can call you!\")\n}\n\ntype IPhone struct {\n}\n\nfunc (iPhone IPhone) call() {\n  fmt.Println(\"I am iPhone, I can call you!\")\n}\n\nfunc main() {\n  var phone Phone\n\n  phone = new(NokiaPhone)\n  phone.call()\n\n  phone = new(IPhone)\n  phone.call()\n}\n```\n\n接口类型也可以通过组合已有的接口来定义：\n```go\ntype Reader interface {\n  Read(p []byte) (n int, err error)\n}\ntype Closer interface {\n  Close() error\n}\n\n\ntype ReadWriteCloser interface {\n  Reader\n  Writer\n  Closer\n}\n\n// 混合\ntype ReadWriter interface {\n  Read(p []byte) (n int, err error)\n  Writer\n}\n```\n\n### 空接口类型\n`interface {}` 被称为空接口类型，它没有任何方法。所有的类型都实现了空 `interface`，\n空 `interface` 在我们需要存储任意类型的数值的时候相当有用，因为它可以存储任意类型的数值。\n```go\n// 定义a为空接口\nvar a interface{}\nvar i int = 5\ns := \"Hello world\"\n// a可以存储任意类型的数值\na = i\na = s\n```\n一个函数把 `interface{}` 作为参数，那么他可以接受任意类型的值作为参数，如果一个函数返回 `interface{}`,\n那么也就可以返回任意类型的值。\n\n`interface{}` 可以存储任意类型，那么怎么判断存储了什么类型？\n\n\n### error 接口\nGo 内置了错误接口。\n```go\ntype error interface {\n  Error() string\n}\n```\n创建一个 `error` 最简单的方法就是调用 `errors.New` 函数。\n\n`error`包：\n```go\npackage errors\n\nfunc New(text string) error { return &errorString{text} }\n\ntype errorString struct { text string }\n\nfunc (e *errorString) Error() string { return e.text }\n```\n\n`fmt.Errorf` 封装了 `errors.New` 函数，它会处理字符串格式化。**当我们想通过模板化的方式生成错误信息，并得到错误值时，\n可以使用`fmt.Errorf`函数。该函数所做的其实就是先调用 `fmt.Sprintf` 函数，得到确切的错误信息；再调用 `errors.New` 函数，\n得到包含该错误信息的 `error` 类型值，最后返回该值**。\n\n实际上，`error` 类型值的 `Error` 方法就相当于其他类型值的 `String` 方法。\n\n### 接口的实际用途\n```go\npackage main\n\nimport (\n    \"fmt\"\n)\n\n//定义 interface\ntype VowelsFinder interface {\n    FindVowels() []rune\n}\n\ntype MyString string\n\n//实现接口\nfunc (ms MyString) FindVowels() []rune {\n    var vowels []rune\n    for _, rune := range ms {\n        if rune == 'a' || rune == 'e' || rune == 'i' || rune == 'o' || rune == 'u' {\n            vowels = append(vowels, rune)\n        }\n    }\n    return vowels\n}\n\nfunc main() {\n    name := MyString(\"Sam Anderson\") // 类型转换\n    var v VowelsFinder // 定义一个接口类型的变量\n    v = name\n    fmt.Printf(\"Vowels are %c\", v.FindVowels())\n\n}\n```\n\n上面的代码 `fmt.Printf(\"Vowels are %c\", v.FindVowels())` 是可以直接使用 `fmt.Printf(\"Vowels are %c\", name.FindVowels())`\n的，那么我们定义的变量 `V` 没有没有了意义。看下面的代码：\n```go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\n// 薪资计算器接口\ntype SalaryCalculator interface {\n\tCalculateSalary() int\n}\n// 普通挖掘机员工\ntype Contract struct {\n\tempId  int\n\tbasicpay int\n}\n// 有蓝翔技校证的员工\ntype Permanent struct {\n\tempId  int\n\tbasicpay int\n\tjj int // 奖金\n}\n\nfunc (p Permanent) CalculateSalary() int {\n\treturn p.basicpay + p.jj\n}\n\nfunc (c Contract) CalculateSalary() int {\n\treturn c.basicpay\n}\n// 总开支\nfunc totalExpense(s []SalaryCalculator) {\n\texpense := 0\n\tfor _, v := range s {\n\t\texpense = expense + v.CalculateSalary()\n\t}\n\tfmt.Printf(\"总开支 $%d\", expense)\n}\n\nfunc main() {\n\tpemp1 := Permanent{1,3000,10000}\n\tpemp2 := Permanent{2, 3000, 20000}\n\tcemp1 := Contract{3, 3000}\n\temployees := []SalaryCalculator{pemp1, pemp2, cemp1}\n\ttotalExpense(employees)\n}\n```\n\n这个时候体现出了接口的作用，`Contract` 和 `Permanent` 是不一样的结构体类型，但是可以定义一个 `SalaryCalculator` 接口类\n型的数组，就可以在 `totalExpense` 中调用元素的 `CalculateSalary` 方法。","date":"2019-08-28T00:15:07.509Z","updated":"2019-08-28T00:15:07.509Z","path":"basic/interface.html","comments":1,"layout":"page","_id":"ck1xm14kp000ofcw2pbc34op0","content":"<h1 id=\"接口\"><a href=\"#接口\" class=\"headerlink\" title=\"接口\"></a>接口</h1><p>Go 支持接口数据类型，接口类型是一种抽象的类型。接口类型具体描述了一系列方法的集合，任何其他类型只要实现了这些方法就是实<br>现了这个接口，无须显示声明。<strong>接口只有当有两个或两个以上的具体类型必须以相同的方式进行处理时才需要</strong>。</p>\n<p>接口的零值就是它的类型和值的部分都是 <code>nil</code>。</p>\n<p>简单的说，<code>interface</code> 是一组 <code>method</code> 的组合，我们通过 <code>interface</code> 来定义对象的一组行为。</p>\n<p>定义接口：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> 接口名 <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">  方法名<span class=\"number\">1</span> [返回类型]</span><br><span class=\"line\">  方法名<span class=\"number\">2</span> [返回类型]</span><br><span class=\"line\">  方法名<span class=\"number\">3</span> [返回类型]</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 定义结构体 */</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> struct_name <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">   <span class=\"comment\">/* variables */</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 实现接口方法 */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(struct_name_variable struct_name)</span> 方法名1<span class=\"params\">()</span> [返回类型]</span> &#123;</span><br><span class=\"line\">   <span class=\"comment\">/* 方法实现 */</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(struct_name_variable struct_name)</span> 方法名2<span class=\"params\">()</span> [返回类型]</span> &#123;</span><br><span class=\"line\">   <span class=\"comment\">/* 方法实现*/</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>实例：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Phone <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">  call()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> NokiaPhone <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(nokiaPhone NokiaPhone)</span> <span class=\"title\">call</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  fmt.Println(<span class=\"string\">\"I am Nokia, I can call you!\"</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> IPhone <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(iPhone IPhone)</span> <span class=\"title\">call</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  fmt.Println(<span class=\"string\">\"I am iPhone, I can call you!\"</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> phone Phone</span><br><span class=\"line\"></span><br><span class=\"line\">  phone = <span class=\"built_in\">new</span>(NokiaPhone)</span><br><span class=\"line\">  phone.call()</span><br><span class=\"line\"></span><br><span class=\"line\">  phone = <span class=\"built_in\">new</span>(IPhone)</span><br><span class=\"line\">  phone.call()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>接口类型也可以通过组合已有的接口来定义：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Reader <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">  Read(p []<span class=\"keyword\">byte</span>) (n <span class=\"keyword\">int</span>, err error)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">type</span> Closer <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">  Close() error</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> ReadWriteCloser <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">  Reader</span><br><span class=\"line\">  Writer</span><br><span class=\"line\">  Closer</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 混合</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> ReadWriter <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">  Read(p []<span class=\"keyword\">byte</span>) (n <span class=\"keyword\">int</span>, err error)</span><br><span class=\"line\">  Writer</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"空接口类型\"><a href=\"#空接口类型\" class=\"headerlink\" title=\"空接口类型\"></a>空接口类型</h3><p><code>interface {}</code> 被称为空接口类型，它没有任何方法。所有的类型都实现了空 <code>interface</code>，<br>空 <code>interface</code> 在我们需要存储任意类型的数值的时候相当有用，因为它可以存储任意类型的数值。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义a为空接口</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a <span class=\"keyword\">interface</span>&#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> i <span class=\"keyword\">int</span> = <span class=\"number\">5</span></span><br><span class=\"line\">s := <span class=\"string\">\"Hello world\"</span></span><br><span class=\"line\"><span class=\"comment\">// a可以存储任意类型的数值</span></span><br><span class=\"line\">a = i</span><br><span class=\"line\">a = s</span><br></pre></td></tr></table></figure></p>\n<p>一个函数把 <code>interface{}</code> 作为参数，那么他可以接受任意类型的值作为参数，如果一个函数返回 <code>interface{}</code>,<br>那么也就可以返回任意类型的值。</p>\n<p><code>interface{}</code> 可以存储任意类型，那么怎么判断存储了什么类型？</p>\n<h3 id=\"error-接口\"><a href=\"#error-接口\" class=\"headerlink\" title=\"error 接口\"></a>error 接口</h3><p>Go 内置了错误接口。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> error <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">  Error() <span class=\"keyword\">string</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>创建一个 <code>error</code> 最简单的方法就是调用 <code>errors.New</code> 函数。</p>\n<p><code>error</code>包：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> errors</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">New</span><span class=\"params\">(text <span class=\"keyword\">string</span>)</span> <span class=\"title\">error</span></span> &#123; <span class=\"keyword\">return</span> &amp;errorString&#123;text&#125; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> errorString <span class=\"keyword\">struct</span> &#123; text <span class=\"keyword\">string</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(e *errorString)</span> <span class=\"title\">Error</span><span class=\"params\">()</span> <span class=\"title\">string</span></span> &#123; <span class=\"keyword\">return</span> e.text &#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>fmt.Errorf</code> 封装了 <code>errors.New</code> 函数，它会处理字符串格式化。<strong>当我们想通过模板化的方式生成错误信息，并得到错误值时，<br>可以使用<code>fmt.Errorf</code>函数。该函数所做的其实就是先调用 <code>fmt.Sprintf</code> 函数，得到确切的错误信息；再调用 <code>errors.New</code> 函数，<br>得到包含该错误信息的 <code>error</code> 类型值，最后返回该值</strong>。</p>\n<p>实际上，<code>error</code> 类型值的 <code>Error</code> 方法就相当于其他类型值的 <code>String</code> 方法。</p>\n<h3 id=\"接口的实际用途\"><a href=\"#接口的实际用途\" class=\"headerlink\" title=\"接口的实际用途\"></a>接口的实际用途</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">\"fmt\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//定义 interface</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> VowelsFinder <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">    FindVowels() []<span class=\"keyword\">rune</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> MyString <span class=\"keyword\">string</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//实现接口</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(ms MyString)</span> <span class=\"title\">FindVowels</span><span class=\"params\">()</span> []<span class=\"title\">rune</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> vowels []<span class=\"keyword\">rune</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> _, <span class=\"keyword\">rune</span> := <span class=\"keyword\">range</span> ms &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">rune</span> == <span class=\"string\">'a'</span> || <span class=\"keyword\">rune</span> == <span class=\"string\">'e'</span> || <span class=\"keyword\">rune</span> == <span class=\"string\">'i'</span> || <span class=\"keyword\">rune</span> == <span class=\"string\">'o'</span> || <span class=\"keyword\">rune</span> == <span class=\"string\">'u'</span> &#123;</span><br><span class=\"line\">            vowels = <span class=\"built_in\">append</span>(vowels, <span class=\"keyword\">rune</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> vowels</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    name := MyString(<span class=\"string\">\"Sam Anderson\"</span>) <span class=\"comment\">// 类型转换</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> v VowelsFinder <span class=\"comment\">// 定义一个接口类型的变量</span></span><br><span class=\"line\">    v = name</span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">\"Vowels are %c\"</span>, v.FindVowels())</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的代码 <code>fmt.Printf(&quot;Vowels are %c&quot;, v.FindVowels())</code> 是可以直接使用 <code>fmt.Printf(&quot;Vowels are %c&quot;, name.FindVowels())</code><br>的，那么我们定义的变量 <code>V</code> 没有没有了意义。看下面的代码：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">\"fmt\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 薪资计算器接口</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> SalaryCalculator <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">\tCalculateSalary() <span class=\"keyword\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 普通挖掘机员工</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Contract <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tempId  <span class=\"keyword\">int</span></span><br><span class=\"line\">\tbasicpay <span class=\"keyword\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 有蓝翔技校证的员工</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Permanent <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tempId  <span class=\"keyword\">int</span></span><br><span class=\"line\">\tbasicpay <span class=\"keyword\">int</span></span><br><span class=\"line\">\tjj <span class=\"keyword\">int</span> <span class=\"comment\">// 奖金</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p Permanent)</span> <span class=\"title\">CalculateSalary</span><span class=\"params\">()</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> p.basicpay + p.jj</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c Contract)</span> <span class=\"title\">CalculateSalary</span><span class=\"params\">()</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> c.basicpay</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 总开支</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">totalExpense</span><span class=\"params\">(s []SalaryCalculator)</span></span> &#123;</span><br><span class=\"line\">\texpense := <span class=\"number\">0</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> _, v := <span class=\"keyword\">range</span> s &#123;</span><br><span class=\"line\">\t\texpense = expense + v.CalculateSalary()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"总开支 $%d\"</span>, expense)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tpemp1 := Permanent&#123;<span class=\"number\">1</span>,<span class=\"number\">3000</span>,<span class=\"number\">10000</span>&#125;</span><br><span class=\"line\">\tpemp2 := Permanent&#123;<span class=\"number\">2</span>, <span class=\"number\">3000</span>, <span class=\"number\">20000</span>&#125;</span><br><span class=\"line\">\tcemp1 := Contract&#123;<span class=\"number\">3</span>, <span class=\"number\">3000</span>&#125;</span><br><span class=\"line\">\temployees := []SalaryCalculator&#123;pemp1, pemp2, cemp1&#125;</span><br><span class=\"line\">\ttotalExpense(employees)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这个时候体现出了接口的作用，<code>Contract</code> 和 <code>Permanent</code> 是不一样的结构体类型，但是可以定义一个 <code>SalaryCalculator</code> 接口类<br>型的数组，就可以在 <code>totalExpense</code> 中调用元素的 <code>CalculateSalary</code> 方法。</p>\n","site":{"data":{"navigation":{"logo":{"text":"Golang Learn","type":"link","path":"index.html"},"main":[{"text":"Golang 基础","type":"label"},{"text":"Go 环境配置","type":"link","path":"basic/env_config.html"},{"text":"包","type":"link","path":"basic/package.html"},{"text":"基础数据类型","type":"link","path":"basic/basic_data.html"},{"text":"变量","type":"link","path":"basic/var.html"},{"text":"常量","type":"link","path":"basic/constant.html"},{"text":"控制语句","type":"link","path":"basic/flow.html"},{"text":"运算符","type":"link","path":"basic/operator.html"},{"text":"作用域","type":"link","path":"basic/scope.html"},{"text":"指针","type":"link","path":"basic/pointer.html"},{"text":"数组","type":"link","path":"basic/array.html"},{"text":"切片","type":"link","path":"basic/slice.html"},{"text":"字典","type":"link","path":"basic/map.html"},{"text":"函数","type":"link","path":"basic/function.html"},{"text":"结构体","type":"link","path":"basic/struct.html"},{"text":"接口","type":"link","path":"basic/interface.html"},{"text":"面向对象","type":"link","path":"basic/oop.html"},{"text":"错误","type":"link","path":"basic/error.html"},{"text":"序列化","type":"link","path":"basic/json.html"},{"text":"反射","type":"link","path":"basic/reflect.html"},{"text":"测试","type":"link","path":"basic/test.html"},{"text":"并发编程","type":"label"},{"text":"goroutine","type":"link","path":"concurrent/goroutine.html"},{"text":"channel","type":"link","path":"concurrent/channel.html"},{"text":"同步和锁","type":"link","path":"concurrent/sync_lock.html"},{"text":"内存分配","type":"label"},{"text":"内存分配","type":"link","path":"advance/mm.html"},{"text":"垃圾回收","type":"label"},{"text":"垃圾回收","type":"link","path":"advance/gc.html"},{"text":"标准库","type":"label"},{"text":"fmt","type":"link","path":"standards/io/fmt.html"},{"text":"io","type":"link","path":"standards/io/io.html"},{"text":"ioutil","type":"link","path":"standards/io/ioutil.html"},{"text":"bufio","type":"link","path":"standards/io/bufio.html"},{"text":"os","type":"link","path":"standards/os/os.html"},{"text":"filepath","type":"link","path":"standards/os/filepath.html"},{"text":"strings","type":"link","path":"standards/text/strings.html"},{"text":"strconv","type":"link","path":"standards/text/strconv.html"},{"text":"unicode","type":"link","path":"standards/text/unicode.html"},{"text":"log","type":"link","path":"standards/log.html"},{"text":"time","type":"link","path":"standards/time.html"},{"text":"http","type":"link","path":"standards/net/http.html"},{"text":"math","type":"link","path":"standards/data/math.html"},{"text":"sort","type":"link","path":"standards/data/sort.html"},{"text":"big","type":"link","path":"standards/data/big.html"},{"text":"container","type":"link","path":"standards/data/container.html"},{"text":"sql","type":"link","path":"standards/database/sql.html"},{"text":"THEME","type":"label"},{"text":"使用文档主题","type":"link","path":"theme/theme-usage.html"},{"text":"SUPPORT AND FEEDBACK","type":"label"},{"text":"Raise an Issue on Github","type":"link","path":"https://github.com/shipengqi/golang-learn/issues/new"}]}}},"excerpt":"","more":"<h1 id=\"接口\"><a href=\"#接口\" class=\"headerlink\" title=\"接口\"></a>接口</h1><p>Go 支持接口数据类型，接口类型是一种抽象的类型。接口类型具体描述了一系列方法的集合，任何其他类型只要实现了这些方法就是实<br>现了这个接口，无须显示声明。<strong>接口只有当有两个或两个以上的具体类型必须以相同的方式进行处理时才需要</strong>。</p>\n<p>接口的零值就是它的类型和值的部分都是 <code>nil</code>。</p>\n<p>简单的说，<code>interface</code> 是一组 <code>method</code> 的组合，我们通过 <code>interface</code> 来定义对象的一组行为。</p>\n<p>定义接口：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> 接口名 <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">  方法名<span class=\"number\">1</span> [返回类型]</span><br><span class=\"line\">  方法名<span class=\"number\">2</span> [返回类型]</span><br><span class=\"line\">  方法名<span class=\"number\">3</span> [返回类型]</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 定义结构体 */</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> struct_name <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">   <span class=\"comment\">/* variables */</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 实现接口方法 */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(struct_name_variable struct_name)</span> 方法名1<span class=\"params\">()</span> [返回类型]</span> &#123;</span><br><span class=\"line\">   <span class=\"comment\">/* 方法实现 */</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(struct_name_variable struct_name)</span> 方法名2<span class=\"params\">()</span> [返回类型]</span> &#123;</span><br><span class=\"line\">   <span class=\"comment\">/* 方法实现*/</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>实例：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Phone <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">  call()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> NokiaPhone <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(nokiaPhone NokiaPhone)</span> <span class=\"title\">call</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  fmt.Println(<span class=\"string\">\"I am Nokia, I can call you!\"</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> IPhone <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(iPhone IPhone)</span> <span class=\"title\">call</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  fmt.Println(<span class=\"string\">\"I am iPhone, I can call you!\"</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> phone Phone</span><br><span class=\"line\"></span><br><span class=\"line\">  phone = <span class=\"built_in\">new</span>(NokiaPhone)</span><br><span class=\"line\">  phone.call()</span><br><span class=\"line\"></span><br><span class=\"line\">  phone = <span class=\"built_in\">new</span>(IPhone)</span><br><span class=\"line\">  phone.call()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>接口类型也可以通过组合已有的接口来定义：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Reader <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">  Read(p []<span class=\"keyword\">byte</span>) (n <span class=\"keyword\">int</span>, err error)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">type</span> Closer <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">  Close() error</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> ReadWriteCloser <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">  Reader</span><br><span class=\"line\">  Writer</span><br><span class=\"line\">  Closer</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 混合</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> ReadWriter <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">  Read(p []<span class=\"keyword\">byte</span>) (n <span class=\"keyword\">int</span>, err error)</span><br><span class=\"line\">  Writer</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"空接口类型\"><a href=\"#空接口类型\" class=\"headerlink\" title=\"空接口类型\"></a>空接口类型</h3><p><code>interface {}</code> 被称为空接口类型，它没有任何方法。所有的类型都实现了空 <code>interface</code>，<br>空 <code>interface</code> 在我们需要存储任意类型的数值的时候相当有用，因为它可以存储任意类型的数值。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义a为空接口</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a <span class=\"keyword\">interface</span>&#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> i <span class=\"keyword\">int</span> = <span class=\"number\">5</span></span><br><span class=\"line\">s := <span class=\"string\">\"Hello world\"</span></span><br><span class=\"line\"><span class=\"comment\">// a可以存储任意类型的数值</span></span><br><span class=\"line\">a = i</span><br><span class=\"line\">a = s</span><br></pre></td></tr></table></figure></p>\n<p>一个函数把 <code>interface{}</code> 作为参数，那么他可以接受任意类型的值作为参数，如果一个函数返回 <code>interface{}</code>,<br>那么也就可以返回任意类型的值。</p>\n<p><code>interface{}</code> 可以存储任意类型，那么怎么判断存储了什么类型？</p>\n<h3 id=\"error-接口\"><a href=\"#error-接口\" class=\"headerlink\" title=\"error 接口\"></a>error 接口</h3><p>Go 内置了错误接口。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> error <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">  Error() <span class=\"keyword\">string</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>创建一个 <code>error</code> 最简单的方法就是调用 <code>errors.New</code> 函数。</p>\n<p><code>error</code>包：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> errors</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">New</span><span class=\"params\">(text <span class=\"keyword\">string</span>)</span> <span class=\"title\">error</span></span> &#123; <span class=\"keyword\">return</span> &amp;errorString&#123;text&#125; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> errorString <span class=\"keyword\">struct</span> &#123; text <span class=\"keyword\">string</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(e *errorString)</span> <span class=\"title\">Error</span><span class=\"params\">()</span> <span class=\"title\">string</span></span> &#123; <span class=\"keyword\">return</span> e.text &#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>fmt.Errorf</code> 封装了 <code>errors.New</code> 函数，它会处理字符串格式化。<strong>当我们想通过模板化的方式生成错误信息，并得到错误值时，<br>可以使用<code>fmt.Errorf</code>函数。该函数所做的其实就是先调用 <code>fmt.Sprintf</code> 函数，得到确切的错误信息；再调用 <code>errors.New</code> 函数，<br>得到包含该错误信息的 <code>error</code> 类型值，最后返回该值</strong>。</p>\n<p>实际上，<code>error</code> 类型值的 <code>Error</code> 方法就相当于其他类型值的 <code>String</code> 方法。</p>\n<h3 id=\"接口的实际用途\"><a href=\"#接口的实际用途\" class=\"headerlink\" title=\"接口的实际用途\"></a>接口的实际用途</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">\"fmt\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//定义 interface</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> VowelsFinder <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">    FindVowels() []<span class=\"keyword\">rune</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> MyString <span class=\"keyword\">string</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//实现接口</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(ms MyString)</span> <span class=\"title\">FindVowels</span><span class=\"params\">()</span> []<span class=\"title\">rune</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> vowels []<span class=\"keyword\">rune</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> _, <span class=\"keyword\">rune</span> := <span class=\"keyword\">range</span> ms &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">rune</span> == <span class=\"string\">'a'</span> || <span class=\"keyword\">rune</span> == <span class=\"string\">'e'</span> || <span class=\"keyword\">rune</span> == <span class=\"string\">'i'</span> || <span class=\"keyword\">rune</span> == <span class=\"string\">'o'</span> || <span class=\"keyword\">rune</span> == <span class=\"string\">'u'</span> &#123;</span><br><span class=\"line\">            vowels = <span class=\"built_in\">append</span>(vowels, <span class=\"keyword\">rune</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> vowels</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    name := MyString(<span class=\"string\">\"Sam Anderson\"</span>) <span class=\"comment\">// 类型转换</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> v VowelsFinder <span class=\"comment\">// 定义一个接口类型的变量</span></span><br><span class=\"line\">    v = name</span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">\"Vowels are %c\"</span>, v.FindVowels())</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的代码 <code>fmt.Printf(&quot;Vowels are %c&quot;, v.FindVowels())</code> 是可以直接使用 <code>fmt.Printf(&quot;Vowels are %c&quot;, name.FindVowels())</code><br>的，那么我们定义的变量 <code>V</code> 没有没有了意义。看下面的代码：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">\"fmt\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 薪资计算器接口</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> SalaryCalculator <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">\tCalculateSalary() <span class=\"keyword\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 普通挖掘机员工</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Contract <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tempId  <span class=\"keyword\">int</span></span><br><span class=\"line\">\tbasicpay <span class=\"keyword\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 有蓝翔技校证的员工</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Permanent <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tempId  <span class=\"keyword\">int</span></span><br><span class=\"line\">\tbasicpay <span class=\"keyword\">int</span></span><br><span class=\"line\">\tjj <span class=\"keyword\">int</span> <span class=\"comment\">// 奖金</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p Permanent)</span> <span class=\"title\">CalculateSalary</span><span class=\"params\">()</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> p.basicpay + p.jj</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c Contract)</span> <span class=\"title\">CalculateSalary</span><span class=\"params\">()</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> c.basicpay</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 总开支</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">totalExpense</span><span class=\"params\">(s []SalaryCalculator)</span></span> &#123;</span><br><span class=\"line\">\texpense := <span class=\"number\">0</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> _, v := <span class=\"keyword\">range</span> s &#123;</span><br><span class=\"line\">\t\texpense = expense + v.CalculateSalary()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"总开支 $%d\"</span>, expense)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tpemp1 := Permanent&#123;<span class=\"number\">1</span>,<span class=\"number\">3000</span>,<span class=\"number\">10000</span>&#125;</span><br><span class=\"line\">\tpemp2 := Permanent&#123;<span class=\"number\">2</span>, <span class=\"number\">3000</span>, <span class=\"number\">20000</span>&#125;</span><br><span class=\"line\">\tcemp1 := Contract&#123;<span class=\"number\">3</span>, <span class=\"number\">3000</span>&#125;</span><br><span class=\"line\">\temployees := []SalaryCalculator&#123;pemp1, pemp2, cemp1&#125;</span><br><span class=\"line\">\ttotalExpense(employees)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这个时候体现出了接口的作用，<code>Contract</code> 和 <code>Permanent</code> 是不一样的结构体类型，但是可以定义一个 <code>SalaryCalculator</code> 接口类<br>型的数组，就可以在 <code>totalExpense</code> 中调用元素的 <code>CalculateSalary</code> 方法。</p>\n"},{"title":"变量","_content":"# 变量\n`var` 声明变量，必须使用空格隔开：\n```go\nvar 变量名字 类型 = 表达式\n```\n**类型**或者**表达式**可以省略其中的一个。也就是如果没有类型，可以通过表达式推断出类型，**没有表达式，将会根据类型初始化为对应的零值**。\n\n“零值”，所指并非是空值，而是一种“变量未填充前”的默认值，通常为 `0`，对应关系：\n- 数值类型：`0`\n- 布尔类型：`false`\n- 字符串: `\"\"`\n- 接口或引用类型（包括 `slice`、指针、`map`、`chan` 和函数）：`nil`\n\n## 声明一组变量\n```go\nvar 变量名字, 变量名字, 变量名字 ... 类型 = 表达式, 表达式, 表达式, ...\n```\n比如：\n```go\n// 声明一组 `int` 类型\nvar i, j, k int                 // int, int, int\n\n// 声明一组不同类型\nvar b, f, s = true, 2.3, \"four\" // bool, float64, string\n\nvar (\n  i int\n  pi float32\n  prefix string\n)\n```\n\n## 简短声明\n**`:=` 只能在函数内使用，不能提供数据类型**，Go 会自动推断类型：\n```go\n变量名字 := 表达式\n```\n\n```go\nvar x = 100\n\nfunc main() {\n\tfmt.Println(&x, x)\n\tx := \"abc\"\n\tfmt.Println(&x, x)\n}\n```\n上面的代码中 `x := \"abc\"` 相当于重新定义并初始化了同名的局部变量 `x`，因为**不在同一个作用域**，所以打印出来的结果完全不同。\n\n简短声明，并不总是重新定义比变量，要避免重新定义，首先要在同一个作用域中，至少有一个新的变量被定义：\n```go\nfunc main() {\n\tx := 100\n\tfmt.Println(&x, x)\n\tx, y := 200, 300   // 一个新的变量 y，这里的简短声明 x 就是赋值操作\n\tfmt.Println(&x, x)\n}\n```\n\n如果重复使用简短声明定义一个变量，会报错：\n```go\nx := 100\nfmt.Println(&x)\nx := 200 // 错误， no new variables on left side of :=\n```\n\n## 赋值\n常见的赋值的方式：\n```go\nx = 1                       // 命名变量的赋值\n*p = true                   // 通过指针间接赋值\nperson.name = \"bob\"         // 结构体字段赋值\ncount[x] = count[x] * scale // 数组、slice 或 map 的元素赋值\ncount[x] *= scale           // 等价于 count[x] = count[x] * scale，但是省去了对变量表达式的重复计算\nx, y = y, x                 // 交换值\nf, err = os.Open(\"foo.txt\") // 左边变量的数目必须和右边一致，函数一般会返回一个 error 类型\nv, ok = m[key]              // map 查找，返回布尔值类表示操作是否成功\nv = m[key]                  // map 查找，也可以返回一个值，失败时返回零值\n```\n\n不管是隐式还是显式地赋值，在赋值语句左边的变量和右边最终的求到的值必须有相同的数据类型。这就是**可赋值性**。\n\n进行**多变量赋值**时，首先计算出所有右值，然后再依次赋值：\n```go\nx, y := 1, 2\nx, y = y+3, x+2 // 先计算出 y+3, x+2, 然后赋值\n```","source":"basic/var.md","raw":"---\ntitle: 变量\n---\n# 变量\n`var` 声明变量，必须使用空格隔开：\n```go\nvar 变量名字 类型 = 表达式\n```\n**类型**或者**表达式**可以省略其中的一个。也就是如果没有类型，可以通过表达式推断出类型，**没有表达式，将会根据类型初始化为对应的零值**。\n\n“零值”，所指并非是空值，而是一种“变量未填充前”的默认值，通常为 `0`，对应关系：\n- 数值类型：`0`\n- 布尔类型：`false`\n- 字符串: `\"\"`\n- 接口或引用类型（包括 `slice`、指针、`map`、`chan` 和函数）：`nil`\n\n## 声明一组变量\n```go\nvar 变量名字, 变量名字, 变量名字 ... 类型 = 表达式, 表达式, 表达式, ...\n```\n比如：\n```go\n// 声明一组 `int` 类型\nvar i, j, k int                 // int, int, int\n\n// 声明一组不同类型\nvar b, f, s = true, 2.3, \"four\" // bool, float64, string\n\nvar (\n  i int\n  pi float32\n  prefix string\n)\n```\n\n## 简短声明\n**`:=` 只能在函数内使用，不能提供数据类型**，Go 会自动推断类型：\n```go\n变量名字 := 表达式\n```\n\n```go\nvar x = 100\n\nfunc main() {\n\tfmt.Println(&x, x)\n\tx := \"abc\"\n\tfmt.Println(&x, x)\n}\n```\n上面的代码中 `x := \"abc\"` 相当于重新定义并初始化了同名的局部变量 `x`，因为**不在同一个作用域**，所以打印出来的结果完全不同。\n\n简短声明，并不总是重新定义比变量，要避免重新定义，首先要在同一个作用域中，至少有一个新的变量被定义：\n```go\nfunc main() {\n\tx := 100\n\tfmt.Println(&x, x)\n\tx, y := 200, 300   // 一个新的变量 y，这里的简短声明 x 就是赋值操作\n\tfmt.Println(&x, x)\n}\n```\n\n如果重复使用简短声明定义一个变量，会报错：\n```go\nx := 100\nfmt.Println(&x)\nx := 200 // 错误， no new variables on left side of :=\n```\n\n## 赋值\n常见的赋值的方式：\n```go\nx = 1                       // 命名变量的赋值\n*p = true                   // 通过指针间接赋值\nperson.name = \"bob\"         // 结构体字段赋值\ncount[x] = count[x] * scale // 数组、slice 或 map 的元素赋值\ncount[x] *= scale           // 等价于 count[x] = count[x] * scale，但是省去了对变量表达式的重复计算\nx, y = y, x                 // 交换值\nf, err = os.Open(\"foo.txt\") // 左边变量的数目必须和右边一致，函数一般会返回一个 error 类型\nv, ok = m[key]              // map 查找，返回布尔值类表示操作是否成功\nv = m[key]                  // map 查找，也可以返回一个值，失败时返回零值\n```\n\n不管是隐式还是显式地赋值，在赋值语句左边的变量和右边最终的求到的值必须有相同的数据类型。这就是**可赋值性**。\n\n进行**多变量赋值**时，首先计算出所有右值，然后再依次赋值：\n```go\nx, y := 1, 2\nx, y = y+3, x+2 // 先计算出 y+3, x+2, 然后赋值\n```","date":"2019-08-28T00:15:07.512Z","updated":"2019-08-28T00:15:07.512Z","path":"basic/var.html","comments":1,"layout":"page","_id":"ck1xm14kp000pfcw2u2fx341v","content":"<h1 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h1><p><code>var</code> 声明变量，必须使用空格隔开：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> 变量名字 类型 = 表达式</span><br></pre></td></tr></table></figure></p>\n<p><strong>类型</strong>或者<strong>表达式</strong>可以省略其中的一个。也就是如果没有类型，可以通过表达式推断出类型，<strong>没有表达式，将会根据类型初始化为对应的零值</strong>。</p>\n<p>“零值”，所指并非是空值，而是一种“变量未填充前”的默认值，通常为 <code>0</code>，对应关系：</p>\n<ul>\n<li>数值类型：<code>0</code></li>\n<li>布尔类型：<code>false</code></li>\n<li>字符串: <code>&quot;&quot;</code></li>\n<li>接口或引用类型（包括 <code>slice</code>、指针、<code>map</code>、<code>chan</code> 和函数）：<code>nil</code></li>\n</ul>\n<h2 id=\"声明一组变量\"><a href=\"#声明一组变量\" class=\"headerlink\" title=\"声明一组变量\"></a>声明一组变量</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> 变量名字, 变量名字, 变量名字 ... 类型 = 表达式, 表达式, 表达式, ...</span><br></pre></td></tr></table></figure>\n<p>比如：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 声明一组 `int` 类型</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> i, j, k <span class=\"keyword\">int</span>                 <span class=\"comment\">// int, int, int</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 声明一组不同类型</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> b, f, s = <span class=\"literal\">true</span>, <span class=\"number\">2.3</span>, <span class=\"string\">\"four\"</span> <span class=\"comment\">// bool, float64, string</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> (</span><br><span class=\"line\">  i <span class=\"keyword\">int</span></span><br><span class=\"line\">  pi <span class=\"keyword\">float32</span></span><br><span class=\"line\">  prefix <span class=\"keyword\">string</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"简短声明\"><a href=\"#简短声明\" class=\"headerlink\" title=\"简短声明\"></a>简短声明</h2><p><strong><code>:=</code> 只能在函数内使用，不能提供数据类型</strong>，Go 会自动推断类型：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">变量名字 := 表达式</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"number\">100</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tfmt.Println(&amp;x, x)</span><br><span class=\"line\">\tx := <span class=\"string\">\"abc\"</span></span><br><span class=\"line\">\tfmt.Println(&amp;x, x)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的代码中 <code>x := &quot;abc&quot;</code> 相当于重新定义并初始化了同名的局部变量 <code>x</code>，因为<strong>不在同一个作用域</strong>，所以打印出来的结果完全不同。</p>\n<p>简短声明，并不总是重新定义比变量，要避免重新定义，首先要在同一个作用域中，至少有一个新的变量被定义：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tx := <span class=\"number\">100</span></span><br><span class=\"line\">\tfmt.Println(&amp;x, x)</span><br><span class=\"line\">\tx, y := <span class=\"number\">200</span>, <span class=\"number\">300</span>   <span class=\"comment\">// 一个新的变量 y，这里的简短声明 x 就是赋值操作</span></span><br><span class=\"line\">\tfmt.Println(&amp;x, x)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>如果重复使用简短声明定义一个变量，会报错：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x := <span class=\"number\">100</span></span><br><span class=\"line\">fmt.Println(&amp;x)</span><br><span class=\"line\">x := <span class=\"number\">200</span> <span class=\"comment\">// 错误， no new variables on left side of :=</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"赋值\"><a href=\"#赋值\" class=\"headerlink\" title=\"赋值\"></a>赋值</h2><p>常见的赋值的方式：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x = <span class=\"number\">1</span>                       <span class=\"comment\">// 命名变量的赋值</span></span><br><span class=\"line\">*p = <span class=\"literal\">true</span>                   <span class=\"comment\">// 通过指针间接赋值</span></span><br><span class=\"line\">person.name = <span class=\"string\">\"bob\"</span>         <span class=\"comment\">// 结构体字段赋值</span></span><br><span class=\"line\">count[x] = count[x] * scale <span class=\"comment\">// 数组、slice 或 map 的元素赋值</span></span><br><span class=\"line\">count[x] *= scale           <span class=\"comment\">// 等价于 count[x] = count[x] * scale，但是省去了对变量表达式的重复计算</span></span><br><span class=\"line\">x, y = y, x                 <span class=\"comment\">// 交换值</span></span><br><span class=\"line\">f, err = os.Open(<span class=\"string\">\"foo.txt\"</span>) <span class=\"comment\">// 左边变量的数目必须和右边一致，函数一般会返回一个 error 类型</span></span><br><span class=\"line\">v, ok = m[key]              <span class=\"comment\">// map 查找，返回布尔值类表示操作是否成功</span></span><br><span class=\"line\">v = m[key]                  <span class=\"comment\">// map 查找，也可以返回一个值，失败时返回零值</span></span><br></pre></td></tr></table></figure></p>\n<p>不管是隐式还是显式地赋值，在赋值语句左边的变量和右边最终的求到的值必须有相同的数据类型。这就是<strong>可赋值性</strong>。</p>\n<p>进行<strong>多变量赋值</strong>时，首先计算出所有右值，然后再依次赋值：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x, y := <span class=\"number\">1</span>, <span class=\"number\">2</span></span><br><span class=\"line\">x, y = y+<span class=\"number\">3</span>, x+<span class=\"number\">2</span> <span class=\"comment\">// 先计算出 y+3, x+2, 然后赋值</span></span><br></pre></td></tr></table></figure></p>\n","site":{"data":{"navigation":{"logo":{"text":"Golang Learn","type":"link","path":"index.html"},"main":[{"text":"Golang 基础","type":"label"},{"text":"Go 环境配置","type":"link","path":"basic/env_config.html"},{"text":"包","type":"link","path":"basic/package.html"},{"text":"基础数据类型","type":"link","path":"basic/basic_data.html"},{"text":"变量","type":"link","path":"basic/var.html"},{"text":"常量","type":"link","path":"basic/constant.html"},{"text":"控制语句","type":"link","path":"basic/flow.html"},{"text":"运算符","type":"link","path":"basic/operator.html"},{"text":"作用域","type":"link","path":"basic/scope.html"},{"text":"指针","type":"link","path":"basic/pointer.html"},{"text":"数组","type":"link","path":"basic/array.html"},{"text":"切片","type":"link","path":"basic/slice.html"},{"text":"字典","type":"link","path":"basic/map.html"},{"text":"函数","type":"link","path":"basic/function.html"},{"text":"结构体","type":"link","path":"basic/struct.html"},{"text":"接口","type":"link","path":"basic/interface.html"},{"text":"面向对象","type":"link","path":"basic/oop.html"},{"text":"错误","type":"link","path":"basic/error.html"},{"text":"序列化","type":"link","path":"basic/json.html"},{"text":"反射","type":"link","path":"basic/reflect.html"},{"text":"测试","type":"link","path":"basic/test.html"},{"text":"并发编程","type":"label"},{"text":"goroutine","type":"link","path":"concurrent/goroutine.html"},{"text":"channel","type":"link","path":"concurrent/channel.html"},{"text":"同步和锁","type":"link","path":"concurrent/sync_lock.html"},{"text":"内存分配","type":"label"},{"text":"内存分配","type":"link","path":"advance/mm.html"},{"text":"垃圾回收","type":"label"},{"text":"垃圾回收","type":"link","path":"advance/gc.html"},{"text":"标准库","type":"label"},{"text":"fmt","type":"link","path":"standards/io/fmt.html"},{"text":"io","type":"link","path":"standards/io/io.html"},{"text":"ioutil","type":"link","path":"standards/io/ioutil.html"},{"text":"bufio","type":"link","path":"standards/io/bufio.html"},{"text":"os","type":"link","path":"standards/os/os.html"},{"text":"filepath","type":"link","path":"standards/os/filepath.html"},{"text":"strings","type":"link","path":"standards/text/strings.html"},{"text":"strconv","type":"link","path":"standards/text/strconv.html"},{"text":"unicode","type":"link","path":"standards/text/unicode.html"},{"text":"log","type":"link","path":"standards/log.html"},{"text":"time","type":"link","path":"standards/time.html"},{"text":"http","type":"link","path":"standards/net/http.html"},{"text":"math","type":"link","path":"standards/data/math.html"},{"text":"sort","type":"link","path":"standards/data/sort.html"},{"text":"big","type":"link","path":"standards/data/big.html"},{"text":"container","type":"link","path":"standards/data/container.html"},{"text":"sql","type":"link","path":"standards/database/sql.html"},{"text":"THEME","type":"label"},{"text":"使用文档主题","type":"link","path":"theme/theme-usage.html"},{"text":"SUPPORT AND FEEDBACK","type":"label"},{"text":"Raise an Issue on Github","type":"link","path":"https://github.com/shipengqi/golang-learn/issues/new"}]}}},"excerpt":"","more":"<h1 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h1><p><code>var</code> 声明变量，必须使用空格隔开：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> 变量名字 类型 = 表达式</span><br></pre></td></tr></table></figure></p>\n<p><strong>类型</strong>或者<strong>表达式</strong>可以省略其中的一个。也就是如果没有类型，可以通过表达式推断出类型，<strong>没有表达式，将会根据类型初始化为对应的零值</strong>。</p>\n<p>“零值”，所指并非是空值，而是一种“变量未填充前”的默认值，通常为 <code>0</code>，对应关系：</p>\n<ul>\n<li>数值类型：<code>0</code></li>\n<li>布尔类型：<code>false</code></li>\n<li>字符串: <code>&quot;&quot;</code></li>\n<li>接口或引用类型（包括 <code>slice</code>、指针、<code>map</code>、<code>chan</code> 和函数）：<code>nil</code></li>\n</ul>\n<h2 id=\"声明一组变量\"><a href=\"#声明一组变量\" class=\"headerlink\" title=\"声明一组变量\"></a>声明一组变量</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> 变量名字, 变量名字, 变量名字 ... 类型 = 表达式, 表达式, 表达式, ...</span><br></pre></td></tr></table></figure>\n<p>比如：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 声明一组 `int` 类型</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> i, j, k <span class=\"keyword\">int</span>                 <span class=\"comment\">// int, int, int</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 声明一组不同类型</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> b, f, s = <span class=\"literal\">true</span>, <span class=\"number\">2.3</span>, <span class=\"string\">\"four\"</span> <span class=\"comment\">// bool, float64, string</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> (</span><br><span class=\"line\">  i <span class=\"keyword\">int</span></span><br><span class=\"line\">  pi <span class=\"keyword\">float32</span></span><br><span class=\"line\">  prefix <span class=\"keyword\">string</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"简短声明\"><a href=\"#简短声明\" class=\"headerlink\" title=\"简短声明\"></a>简短声明</h2><p><strong><code>:=</code> 只能在函数内使用，不能提供数据类型</strong>，Go 会自动推断类型：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">变量名字 := 表达式</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"number\">100</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tfmt.Println(&amp;x, x)</span><br><span class=\"line\">\tx := <span class=\"string\">\"abc\"</span></span><br><span class=\"line\">\tfmt.Println(&amp;x, x)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的代码中 <code>x := &quot;abc&quot;</code> 相当于重新定义并初始化了同名的局部变量 <code>x</code>，因为<strong>不在同一个作用域</strong>，所以打印出来的结果完全不同。</p>\n<p>简短声明，并不总是重新定义比变量，要避免重新定义，首先要在同一个作用域中，至少有一个新的变量被定义：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tx := <span class=\"number\">100</span></span><br><span class=\"line\">\tfmt.Println(&amp;x, x)</span><br><span class=\"line\">\tx, y := <span class=\"number\">200</span>, <span class=\"number\">300</span>   <span class=\"comment\">// 一个新的变量 y，这里的简短声明 x 就是赋值操作</span></span><br><span class=\"line\">\tfmt.Println(&amp;x, x)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>如果重复使用简短声明定义一个变量，会报错：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x := <span class=\"number\">100</span></span><br><span class=\"line\">fmt.Println(&amp;x)</span><br><span class=\"line\">x := <span class=\"number\">200</span> <span class=\"comment\">// 错误， no new variables on left side of :=</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"赋值\"><a href=\"#赋值\" class=\"headerlink\" title=\"赋值\"></a>赋值</h2><p>常见的赋值的方式：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x = <span class=\"number\">1</span>                       <span class=\"comment\">// 命名变量的赋值</span></span><br><span class=\"line\">*p = <span class=\"literal\">true</span>                   <span class=\"comment\">// 通过指针间接赋值</span></span><br><span class=\"line\">person.name = <span class=\"string\">\"bob\"</span>         <span class=\"comment\">// 结构体字段赋值</span></span><br><span class=\"line\">count[x] = count[x] * scale <span class=\"comment\">// 数组、slice 或 map 的元素赋值</span></span><br><span class=\"line\">count[x] *= scale           <span class=\"comment\">// 等价于 count[x] = count[x] * scale，但是省去了对变量表达式的重复计算</span></span><br><span class=\"line\">x, y = y, x                 <span class=\"comment\">// 交换值</span></span><br><span class=\"line\">f, err = os.Open(<span class=\"string\">\"foo.txt\"</span>) <span class=\"comment\">// 左边变量的数目必须和右边一致，函数一般会返回一个 error 类型</span></span><br><span class=\"line\">v, ok = m[key]              <span class=\"comment\">// map 查找，返回布尔值类表示操作是否成功</span></span><br><span class=\"line\">v = m[key]                  <span class=\"comment\">// map 查找，也可以返回一个值，失败时返回零值</span></span><br></pre></td></tr></table></figure></p>\n<p>不管是隐式还是显式地赋值，在赋值语句左边的变量和右边最终的求到的值必须有相同的数据类型。这就是<strong>可赋值性</strong>。</p>\n<p>进行<strong>多变量赋值</strong>时，首先计算出所有右值，然后再依次赋值：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x, y := <span class=\"number\">1</span>, <span class=\"number\">2</span></span><br><span class=\"line\">x, y = y+<span class=\"number\">3</span>, x+<span class=\"number\">2</span> <span class=\"comment\">// 先计算出 y+3, x+2, 然后赋值</span></span><br></pre></td></tr></table></figure></p>\n"},{"title":"log","_content":"\n# log\nlog 模块用于在程序中输出日志。\n\n```go\npackage main\n\nimport \"log\"\n\nfunc main() { \n    log.Print(\"Hello World\") // 2019/09/12 13:56:36 Hello World\n}\n```\n\n## Logger\n通过 `New` 函数可以创建多个 `Logger` 实例，函数声明如下：\n```go\nfunc New(out io.Writer, prefix string, flag int) *Logger\n```\n\n参数：\n- `out`：日志输出的 IO 对象，通常是标准输出 `os.Stdout`，`os.Stderr`，或者绑定到文件的 IO。\n- `prefix`：日志前缀，可以是任意字符串。\n- `flag`：日志包含的通用信息标识位\n\n一条日志的结构：\n```\n{日志前缀} {标识1} {标识2} ... {标识n} {日志内容}\n```\n\n标识通过 `flag` 参数设置，当某个标识被设置，会在日志中进行显示，log 模块中已经提供了如下标识，多个标识通过 `|` 组合：\n- Ldate 显示当前日期（当前时区）\n- Ltime 显示当前时间（当前时区）\n- microseconds 显示当前时间（微秒）\n- Llongfile 包含路径的完整文件名\n- Lshortfile 不包含路径的文件名\n- LUTC Ldata 和 Ltime 使用 UTC 时间\n- LstdFlags 标准 Logger 的标识，等价于 Ldate | Ltime\n\n```go\npackage main\n\nimport (\n\t\"log\"\n    \"os\"\n)\n\nfunc main() {\n    prefix := \"[THIS IS THE LOG]\"\n    logger := log.New(os.Stdout, prefix, log.LstdFlags | log.Lshortfile)\n    logger.Print(\"Hello World\") // [THIS IS THE LOG]22019/09/12 12:34:07 log.go:11: Hello World\n}\n```\n\n## 分类\nlog 模块中日志输出分为三类，\n- Print，输出日志。\n- Fatal，在执行完 Print 之后，执行 `os.Exit(1)`。\n- Panic。在执行完 Print 之后调用 `panic()` 方法。\n\n除了基础的 `Print` 之外，还有 `Printf` 和 `Println` 方法对输出进格式化，`Fatal` 和 `Panic` 也类似。\n\n## Level\n`log` 包没有提供日志分级的功能，需要自己实现：\n```go\npackage main\n\nimport (\n\t\"log\"\n    \"os\"\n)\n\nfunc main() {\n    var (\n\tlogger = log.New(os.Stdout, \"INFO: \", log.Lshortfile)\n\tinfof = func(info string) {\n\t\tlogger.Print(info)\n\t}\n    )\n    infof(\"Hello world\")\n}\n```","source":"standards/log.md","raw":"---\ntitle: log\n---\n\n# log\nlog 模块用于在程序中输出日志。\n\n```go\npackage main\n\nimport \"log\"\n\nfunc main() { \n    log.Print(\"Hello World\") // 2019/09/12 13:56:36 Hello World\n}\n```\n\n## Logger\n通过 `New` 函数可以创建多个 `Logger` 实例，函数声明如下：\n```go\nfunc New(out io.Writer, prefix string, flag int) *Logger\n```\n\n参数：\n- `out`：日志输出的 IO 对象，通常是标准输出 `os.Stdout`，`os.Stderr`，或者绑定到文件的 IO。\n- `prefix`：日志前缀，可以是任意字符串。\n- `flag`：日志包含的通用信息标识位\n\n一条日志的结构：\n```\n{日志前缀} {标识1} {标识2} ... {标识n} {日志内容}\n```\n\n标识通过 `flag` 参数设置，当某个标识被设置，会在日志中进行显示，log 模块中已经提供了如下标识，多个标识通过 `|` 组合：\n- Ldate 显示当前日期（当前时区）\n- Ltime 显示当前时间（当前时区）\n- microseconds 显示当前时间（微秒）\n- Llongfile 包含路径的完整文件名\n- Lshortfile 不包含路径的文件名\n- LUTC Ldata 和 Ltime 使用 UTC 时间\n- LstdFlags 标准 Logger 的标识，等价于 Ldate | Ltime\n\n```go\npackage main\n\nimport (\n\t\"log\"\n    \"os\"\n)\n\nfunc main() {\n    prefix := \"[THIS IS THE LOG]\"\n    logger := log.New(os.Stdout, prefix, log.LstdFlags | log.Lshortfile)\n    logger.Print(\"Hello World\") // [THIS IS THE LOG]22019/09/12 12:34:07 log.go:11: Hello World\n}\n```\n\n## 分类\nlog 模块中日志输出分为三类，\n- Print，输出日志。\n- Fatal，在执行完 Print 之后，执行 `os.Exit(1)`。\n- Panic。在执行完 Print 之后调用 `panic()` 方法。\n\n除了基础的 `Print` 之外，还有 `Printf` 和 `Println` 方法对输出进格式化，`Fatal` 和 `Panic` 也类似。\n\n## Level\n`log` 包没有提供日志分级的功能，需要自己实现：\n```go\npackage main\n\nimport (\n\t\"log\"\n    \"os\"\n)\n\nfunc main() {\n    var (\n\tlogger = log.New(os.Stdout, \"INFO: \", log.Lshortfile)\n\tinfof = func(info string) {\n\t\tlogger.Print(info)\n\t}\n    )\n    infof(\"Hello world\")\n}\n```","date":"2019-10-19T13:40:15.180Z","updated":"2019-10-19T13:40:15.180Z","path":"standards/log.html","comments":1,"layout":"page","_id":"ck1xm14kq000qfcw2dloyaeoe","content":"<h1 id=\"log\"><a href=\"#log\" class=\"headerlink\" title=\"log\"></a>log</h1><p>log 模块用于在程序中输出日志。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"log\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123; </span><br><span class=\"line\">    log.Print(<span class=\"string\">\"Hello World\"</span>) <span class=\"comment\">// 2019/09/12 13:56:36 Hello World</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Logger\"><a href=\"#Logger\" class=\"headerlink\" title=\"Logger\"></a>Logger</h2><p>通过 <code>New</code> 函数可以创建多个 <code>Logger</code> 实例，函数声明如下：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">New</span><span class=\"params\">(out io.Writer, prefix <span class=\"keyword\">string</span>, flag <span class=\"keyword\">int</span>)</span> *<span class=\"title\">Logger</span></span></span><br></pre></td></tr></table></figure></p>\n<p>参数：</p>\n<ul>\n<li><code>out</code>：日志输出的 IO 对象，通常是标准输出 <code>os.Stdout</code>，<code>os.Stderr</code>，或者绑定到文件的 IO。</li>\n<li><code>prefix</code>：日志前缀，可以是任意字符串。</li>\n<li><code>flag</code>：日志包含的通用信息标识位</li>\n</ul>\n<p>一条日志的结构：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;日志前缀&#125; &#123;标识1&#125; &#123;标识2&#125; ... &#123;标识n&#125; &#123;日志内容&#125;</span><br></pre></td></tr></table></figure></p>\n<p>标识通过 <code>flag</code> 参数设置，当某个标识被设置，会在日志中进行显示，log 模块中已经提供了如下标识，多个标识通过 <code>|</code> 组合：</p>\n<ul>\n<li>Ldate 显示当前日期（当前时区）</li>\n<li>Ltime 显示当前时间（当前时区）</li>\n<li>microseconds 显示当前时间（微秒）</li>\n<li>Llongfile 包含路径的完整文件名</li>\n<li>Lshortfile 不包含路径的文件名</li>\n<li>LUTC Ldata 和 Ltime 使用 UTC 时间</li>\n<li>LstdFlags 标准 Logger 的标识，等价于 Ldate | Ltime</li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">\"log\"</span></span><br><span class=\"line\">    <span class=\"string\">\"os\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    prefix := <span class=\"string\">\"[THIS IS THE LOG]\"</span></span><br><span class=\"line\">    logger := log.New(os.Stdout, prefix, log.LstdFlags | log.Lshortfile)</span><br><span class=\"line\">    logger.Print(<span class=\"string\">\"Hello World\"</span>) <span class=\"comment\">// [THIS IS THE LOG]22019/09/12 12:34:07 log.go:11: Hello World</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"分类\"><a href=\"#分类\" class=\"headerlink\" title=\"分类\"></a>分类</h2><p>log 模块中日志输出分为三类，</p>\n<ul>\n<li>Print，输出日志。</li>\n<li>Fatal，在执行完 Print 之后，执行 <code>os.Exit(1)</code>。</li>\n<li>Panic。在执行完 Print 之后调用 <code>panic()</code> 方法。</li>\n</ul>\n<p>除了基础的 <code>Print</code> 之外，还有 <code>Printf</code> 和 <code>Println</code> 方法对输出进格式化，<code>Fatal</code> 和 <code>Panic</code> 也类似。</p>\n<h2 id=\"Level\"><a href=\"#Level\" class=\"headerlink\" title=\"Level\"></a>Level</h2><p><code>log</code> 包没有提供日志分级的功能，需要自己实现：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">\"log\"</span></span><br><span class=\"line\">    <span class=\"string\">\"os\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> (</span><br><span class=\"line\">\tlogger = log.New(os.Stdout, <span class=\"string\">\"INFO: \"</span>, log.Lshortfile)</span><br><span class=\"line\">\tinfof = <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(info <span class=\"keyword\">string</span>)</span></span> &#123;</span><br><span class=\"line\">\t\tlogger.Print(info)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    )</span><br><span class=\"line\">    infof(<span class=\"string\">\"Hello world\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{"navigation":{"logo":{"text":"Golang Learn","type":"link","path":"index.html"},"main":[{"text":"Golang 基础","type":"label"},{"text":"Go 环境配置","type":"link","path":"basic/env_config.html"},{"text":"包","type":"link","path":"basic/package.html"},{"text":"基础数据类型","type":"link","path":"basic/basic_data.html"},{"text":"变量","type":"link","path":"basic/var.html"},{"text":"常量","type":"link","path":"basic/constant.html"},{"text":"控制语句","type":"link","path":"basic/flow.html"},{"text":"运算符","type":"link","path":"basic/operator.html"},{"text":"作用域","type":"link","path":"basic/scope.html"},{"text":"指针","type":"link","path":"basic/pointer.html"},{"text":"数组","type":"link","path":"basic/array.html"},{"text":"切片","type":"link","path":"basic/slice.html"},{"text":"字典","type":"link","path":"basic/map.html"},{"text":"函数","type":"link","path":"basic/function.html"},{"text":"结构体","type":"link","path":"basic/struct.html"},{"text":"接口","type":"link","path":"basic/interface.html"},{"text":"面向对象","type":"link","path":"basic/oop.html"},{"text":"错误","type":"link","path":"basic/error.html"},{"text":"序列化","type":"link","path":"basic/json.html"},{"text":"反射","type":"link","path":"basic/reflect.html"},{"text":"测试","type":"link","path":"basic/test.html"},{"text":"并发编程","type":"label"},{"text":"goroutine","type":"link","path":"concurrent/goroutine.html"},{"text":"channel","type":"link","path":"concurrent/channel.html"},{"text":"同步和锁","type":"link","path":"concurrent/sync_lock.html"},{"text":"内存分配","type":"label"},{"text":"内存分配","type":"link","path":"advance/mm.html"},{"text":"垃圾回收","type":"label"},{"text":"垃圾回收","type":"link","path":"advance/gc.html"},{"text":"标准库","type":"label"},{"text":"fmt","type":"link","path":"standards/io/fmt.html"},{"text":"io","type":"link","path":"standards/io/io.html"},{"text":"ioutil","type":"link","path":"standards/io/ioutil.html"},{"text":"bufio","type":"link","path":"standards/io/bufio.html"},{"text":"os","type":"link","path":"standards/os/os.html"},{"text":"filepath","type":"link","path":"standards/os/filepath.html"},{"text":"strings","type":"link","path":"standards/text/strings.html"},{"text":"strconv","type":"link","path":"standards/text/strconv.html"},{"text":"unicode","type":"link","path":"standards/text/unicode.html"},{"text":"log","type":"link","path":"standards/log.html"},{"text":"time","type":"link","path":"standards/time.html"},{"text":"http","type":"link","path":"standards/net/http.html"},{"text":"math","type":"link","path":"standards/data/math.html"},{"text":"sort","type":"link","path":"standards/data/sort.html"},{"text":"big","type":"link","path":"standards/data/big.html"},{"text":"container","type":"link","path":"standards/data/container.html"},{"text":"sql","type":"link","path":"standards/database/sql.html"},{"text":"THEME","type":"label"},{"text":"使用文档主题","type":"link","path":"theme/theme-usage.html"},{"text":"SUPPORT AND FEEDBACK","type":"label"},{"text":"Raise an Issue on Github","type":"link","path":"https://github.com/shipengqi/golang-learn/issues/new"}]}}},"excerpt":"","more":"<h1 id=\"log\"><a href=\"#log\" class=\"headerlink\" title=\"log\"></a>log</h1><p>log 模块用于在程序中输出日志。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"log\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123; </span><br><span class=\"line\">    log.Print(<span class=\"string\">\"Hello World\"</span>) <span class=\"comment\">// 2019/09/12 13:56:36 Hello World</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Logger\"><a href=\"#Logger\" class=\"headerlink\" title=\"Logger\"></a>Logger</h2><p>通过 <code>New</code> 函数可以创建多个 <code>Logger</code> 实例，函数声明如下：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">New</span><span class=\"params\">(out io.Writer, prefix <span class=\"keyword\">string</span>, flag <span class=\"keyword\">int</span>)</span> *<span class=\"title\">Logger</span></span></span><br></pre></td></tr></table></figure></p>\n<p>参数：</p>\n<ul>\n<li><code>out</code>：日志输出的 IO 对象，通常是标准输出 <code>os.Stdout</code>，<code>os.Stderr</code>，或者绑定到文件的 IO。</li>\n<li><code>prefix</code>：日志前缀，可以是任意字符串。</li>\n<li><code>flag</code>：日志包含的通用信息标识位</li>\n</ul>\n<p>一条日志的结构：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;日志前缀&#125; &#123;标识1&#125; &#123;标识2&#125; ... &#123;标识n&#125; &#123;日志内容&#125;</span><br></pre></td></tr></table></figure></p>\n<p>标识通过 <code>flag</code> 参数设置，当某个标识被设置，会在日志中进行显示，log 模块中已经提供了如下标识，多个标识通过 <code>|</code> 组合：</p>\n<ul>\n<li>Ldate 显示当前日期（当前时区）</li>\n<li>Ltime 显示当前时间（当前时区）</li>\n<li>microseconds 显示当前时间（微秒）</li>\n<li>Llongfile 包含路径的完整文件名</li>\n<li>Lshortfile 不包含路径的文件名</li>\n<li>LUTC Ldata 和 Ltime 使用 UTC 时间</li>\n<li>LstdFlags 标准 Logger 的标识，等价于 Ldate | Ltime</li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">\"log\"</span></span><br><span class=\"line\">    <span class=\"string\">\"os\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    prefix := <span class=\"string\">\"[THIS IS THE LOG]\"</span></span><br><span class=\"line\">    logger := log.New(os.Stdout, prefix, log.LstdFlags | log.Lshortfile)</span><br><span class=\"line\">    logger.Print(<span class=\"string\">\"Hello World\"</span>) <span class=\"comment\">// [THIS IS THE LOG]22019/09/12 12:34:07 log.go:11: Hello World</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"分类\"><a href=\"#分类\" class=\"headerlink\" title=\"分类\"></a>分类</h2><p>log 模块中日志输出分为三类，</p>\n<ul>\n<li>Print，输出日志。</li>\n<li>Fatal，在执行完 Print 之后，执行 <code>os.Exit(1)</code>。</li>\n<li>Panic。在执行完 Print 之后调用 <code>panic()</code> 方法。</li>\n</ul>\n<p>除了基础的 <code>Print</code> 之外，还有 <code>Printf</code> 和 <code>Println</code> 方法对输出进格式化，<code>Fatal</code> 和 <code>Panic</code> 也类似。</p>\n<h2 id=\"Level\"><a href=\"#Level\" class=\"headerlink\" title=\"Level\"></a>Level</h2><p><code>log</code> 包没有提供日志分级的功能，需要自己实现：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">\"log\"</span></span><br><span class=\"line\">    <span class=\"string\">\"os\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> (</span><br><span class=\"line\">\tlogger = log.New(os.Stdout, <span class=\"string\">\"INFO: \"</span>, log.Lshortfile)</span><br><span class=\"line\">\tinfof = <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(info <span class=\"keyword\">string</span>)</span></span> &#123;</span><br><span class=\"line\">\t\tlogger.Print(info)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    )</span><br><span class=\"line\">    infof(<span class=\"string\">\"Hello world\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n"},{"title":"使用文档主题","_content":"# 使用文档主题\n\n本文档使用 [Hexo Doc Theme](https://zalando-incubator.github.io/hexo-theme-doc/index.html) 搭建。\n\n## Quick Start\n1. 获取源码\n```sh\n$ git clone git@github.com:zalando-incubator/hexo-theme-doc-seed.git\n```\n\n2. `hexo-theme-doc-seed` 的以下文件拷贝到项目 root 目录下，例如 `kubernetes-learn`：\n- `source` 目录\n- `_data` 目录\n- `images` 目录\n- `package.json`\n- `_config.yaml`\n- `.zappr.yaml`\n\n3. 安装依赖\n```sh\n$ yarn\n```\n\n4. 修改 `package.json`，否则 `hexo server` 或者 `hexo s` 可能会找不到命令。\n```js\n  \"hexo\": {\n    \"version\": \"3.9.0\"\n  },\n  \"scripts\": {\n    \"start\": \"hexo s -p 8082\"\n  },\n```\n\n5. 修改 `_config.yml`\n```yml\ntheme: ../node_modules/hexo-theme-doc\n\n# 如果你的网站存放在子目录中，例如 http://yoursite.com/blog\n# 则 url 设为 http://yoursite.com/blog 并把 root 设为 /blog/\nurl: http://www.shipengqi.top/kubernetes-learn\nroot: /kubernetes-learn/\n\n# deploy\ndeploy:\n- type: git\n  repo: git@github.com:shipengqi/kubernetes-learn.git\n  branch: gh-pages\n```\n\n6. 启动开发服务，访问 http://localhost:8082 。\n```sh\n$ yarn start\n```\n\n## Index\n`source` 目录下创建 `index.md` 文件。这个 `index.md` 文件就是文档首页。\n\n## 添加文档\n`source` 目录下创建 `markdown` 文件，例如：\n\n```md\n---\ntitle: Lorem Ipsum\n---\n\n# Lorem Ipsum\n\nLorem ipsum\n```\n也可以创建文档子目录，例如 `source/usage`。\n\n## Sidebar\n`source` 目录下的 `_data` 目录下的 `navigation.yaml` 设置 `sidebar` 和其他的一些配置。\n\n```yml\nlogo:\n  text: My Documentation\n  type: link\n  path: index.html\n\nmain:\n- text: PROJECTS\n  type: label\n- text: My Awesome Projects\n  type: link\n  path: projects/my-awesome-project.html\n  children:\n  - text: My Awesome Projects Page 1\n    type: link\n    path: projects/my-awesome-project-page-1.html\n```\n\n- **logo**: navigation Logo\n- **main**: left sidebar\n\n对于每个导航项，必须定义一个 `type`，并根据类型定义 `text` 和 `path` 等其他属性。\n每个导航项，也可以定义一个 `children`，这个属性可以嵌套导航项。\n\n### type\n`type` 有两种类型：\n- **label**: 导航项的标签\n- **link**: 导航项下级文档 link\n\n**`link` 类型的导航项的 `path` 的值是文件的路径，但注意扩展名为`.html`**。\n\n## Favicon\n```yml\ntheme_config:\n  favicon: images/favicon.ico\n```","source":"theme/theme-usage.md","raw":"---\ntitle: 使用文档主题\n---\n# 使用文档主题\n\n本文档使用 [Hexo Doc Theme](https://zalando-incubator.github.io/hexo-theme-doc/index.html) 搭建。\n\n## Quick Start\n1. 获取源码\n```sh\n$ git clone git@github.com:zalando-incubator/hexo-theme-doc-seed.git\n```\n\n2. `hexo-theme-doc-seed` 的以下文件拷贝到项目 root 目录下，例如 `kubernetes-learn`：\n- `source` 目录\n- `_data` 目录\n- `images` 目录\n- `package.json`\n- `_config.yaml`\n- `.zappr.yaml`\n\n3. 安装依赖\n```sh\n$ yarn\n```\n\n4. 修改 `package.json`，否则 `hexo server` 或者 `hexo s` 可能会找不到命令。\n```js\n  \"hexo\": {\n    \"version\": \"3.9.0\"\n  },\n  \"scripts\": {\n    \"start\": \"hexo s -p 8082\"\n  },\n```\n\n5. 修改 `_config.yml`\n```yml\ntheme: ../node_modules/hexo-theme-doc\n\n# 如果你的网站存放在子目录中，例如 http://yoursite.com/blog\n# 则 url 设为 http://yoursite.com/blog 并把 root 设为 /blog/\nurl: http://www.shipengqi.top/kubernetes-learn\nroot: /kubernetes-learn/\n\n# deploy\ndeploy:\n- type: git\n  repo: git@github.com:shipengqi/kubernetes-learn.git\n  branch: gh-pages\n```\n\n6. 启动开发服务，访问 http://localhost:8082 。\n```sh\n$ yarn start\n```\n\n## Index\n`source` 目录下创建 `index.md` 文件。这个 `index.md` 文件就是文档首页。\n\n## 添加文档\n`source` 目录下创建 `markdown` 文件，例如：\n\n```md\n---\ntitle: Lorem Ipsum\n---\n\n# Lorem Ipsum\n\nLorem ipsum\n```\n也可以创建文档子目录，例如 `source/usage`。\n\n## Sidebar\n`source` 目录下的 `_data` 目录下的 `navigation.yaml` 设置 `sidebar` 和其他的一些配置。\n\n```yml\nlogo:\n  text: My Documentation\n  type: link\n  path: index.html\n\nmain:\n- text: PROJECTS\n  type: label\n- text: My Awesome Projects\n  type: link\n  path: projects/my-awesome-project.html\n  children:\n  - text: My Awesome Projects Page 1\n    type: link\n    path: projects/my-awesome-project-page-1.html\n```\n\n- **logo**: navigation Logo\n- **main**: left sidebar\n\n对于每个导航项，必须定义一个 `type`，并根据类型定义 `text` 和 `path` 等其他属性。\n每个导航项，也可以定义一个 `children`，这个属性可以嵌套导航项。\n\n### type\n`type` 有两种类型：\n- **label**: 导航项的标签\n- **link**: 导航项下级文档 link\n\n**`link` 类型的导航项的 `path` 的值是文件的路径，但注意扩展名为`.html`**。\n\n## Favicon\n```yml\ntheme_config:\n  favicon: images/favicon.ico\n```","date":"2019-08-24T00:49:42.157Z","updated":"2019-08-24T00:49:42.157Z","path":"theme/theme-usage.html","comments":1,"layout":"page","_id":"ck1xm14kr000rfcw229pfnzis","content":"<h1 id=\"使用文档主题\"><a href=\"#使用文档主题\" class=\"headerlink\" title=\"使用文档主题\"></a>使用文档主题</h1><p>本文档使用 <a href=\"https://zalando-incubator.github.io/hexo-theme-doc/index.html\" target=\"_blank\" rel=\"noopener\">Hexo Doc Theme</a> 搭建。</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><ol>\n<li><p>获取源码</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git <span class=\"built_in\">clone</span> git@github.com:zalando-incubator/hexo-theme-doc-seed.git</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>hexo-theme-doc-seed</code> 的以下文件拷贝到项目 root 目录下，例如 <code>kubernetes-learn</code>：</p>\n</li>\n</ol>\n<ul>\n<li><code>source</code> 目录</li>\n<li><code>_data</code> 目录</li>\n<li><code>images</code> 目录</li>\n<li><code>package.json</code></li>\n<li><code>_config.yaml</code></li>\n<li><code>.zappr.yaml</code></li>\n</ul>\n<ol start=\"3\">\n<li><p>安装依赖</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ yarn</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>修改 <code>package.json</code>，否则 <code>hexo server</code> 或者 <code>hexo s</code> 可能会找不到命令。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"hexo\"</span>: &#123;</span><br><span class=\"line\">  <span class=\"string\">\"version\"</span>: <span class=\"string\">\"3.9.0\"</span></span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"><span class=\"string\">\"scripts\"</span>: &#123;</span><br><span class=\"line\">  <span class=\"string\">\"start\"</span>: <span class=\"string\">\"hexo s -p 8082\"</span></span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>修改 <code>_config.yml</code></p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">theme:</span> <span class=\"string\">../node_modules/hexo-theme-doc</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 如果你的网站存放在子目录中，例如 http://yoursite.com/blog</span></span><br><span class=\"line\"><span class=\"comment\"># 则 url 设为 http://yoursite.com/blog 并把 root 设为 /blog/</span></span><br><span class=\"line\"><span class=\"attr\">url:</span> <span class=\"attr\">http://www.shipengqi.top/kubernetes-learn</span></span><br><span class=\"line\"><span class=\"attr\">root:</span> <span class=\"string\">/kubernetes-learn/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># deploy</span></span><br><span class=\"line\"><span class=\"attr\">deploy:</span></span><br><span class=\"line\"><span class=\"attr\">- type:</span> <span class=\"string\">git</span></span><br><span class=\"line\"><span class=\"attr\">  repo:</span> <span class=\"string\">git@github.com:shipengqi/kubernetes-learn.git</span></span><br><span class=\"line\"><span class=\"attr\">  branch:</span> <span class=\"string\">gh-pages</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>启动开发服务，访问 <a href=\"http://localhost:8082\" target=\"_blank\" rel=\"noopener\">http://localhost:8082</a> 。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ yarn start</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"Index\"><a href=\"#Index\" class=\"headerlink\" title=\"Index\"></a>Index</h2><p><code>source</code> 目录下创建 <code>index.md</code> 文件。这个 <code>index.md</code> 文件就是文档首页。</p>\n<h2 id=\"添加文档\"><a href=\"#添加文档\" class=\"headerlink\" title=\"添加文档\"></a>添加文档</h2><p><code>source</code> 目录下创建 <code>markdown</code> 文件，例如：</p>\n<figure class=\"highlight md\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">title: Lorem Ipsum</span><br><span class=\"line\">---</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\"># Lorem Ipsum</span></span><br><span class=\"line\"></span><br><span class=\"line\">Lorem ipsum</span><br></pre></td></tr></table></figure>\n<p>也可以创建文档子目录，例如 <code>source/usage</code>。</p>\n<h2 id=\"Sidebar\"><a href=\"#Sidebar\" class=\"headerlink\" title=\"Sidebar\"></a>Sidebar</h2><p><code>source</code> 目录下的 <code>_data</code> 目录下的 <code>navigation.yaml</code> 设置 <code>sidebar</code> 和其他的一些配置。</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">logo:</span></span><br><span class=\"line\"><span class=\"attr\">  text:</span> <span class=\"string\">My</span> <span class=\"string\">Documentation</span></span><br><span class=\"line\"><span class=\"attr\">  type:</span> <span class=\"string\">link</span></span><br><span class=\"line\"><span class=\"attr\">  path:</span> <span class=\"string\">index.html</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">main:</span></span><br><span class=\"line\"><span class=\"attr\">- text:</span> <span class=\"string\">PROJECTS</span></span><br><span class=\"line\"><span class=\"attr\">  type:</span> <span class=\"string\">label</span></span><br><span class=\"line\"><span class=\"attr\">- text:</span> <span class=\"string\">My</span> <span class=\"string\">Awesome</span> <span class=\"string\">Projects</span></span><br><span class=\"line\"><span class=\"attr\">  type:</span> <span class=\"string\">link</span></span><br><span class=\"line\"><span class=\"attr\">  path:</span> <span class=\"string\">projects/my-awesome-project.html</span></span><br><span class=\"line\"><span class=\"attr\">  children:</span></span><br><span class=\"line\"><span class=\"attr\">  - text:</span> <span class=\"string\">My</span> <span class=\"string\">Awesome</span> <span class=\"string\">Projects</span> <span class=\"string\">Page</span> <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"attr\">    type:</span> <span class=\"string\">link</span></span><br><span class=\"line\"><span class=\"attr\">    path:</span> <span class=\"string\">projects/my-awesome-project-page-1.html</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><strong>logo</strong>: navigation Logo</li>\n<li><strong>main</strong>: left sidebar</li>\n</ul>\n<p>对于每个导航项，必须定义一个 <code>type</code>，并根据类型定义 <code>text</code> 和 <code>path</code> 等其他属性。<br>每个导航项，也可以定义一个 <code>children</code>，这个属性可以嵌套导航项。</p>\n<h3 id=\"type\"><a href=\"#type\" class=\"headerlink\" title=\"type\"></a>type</h3><p><code>type</code> 有两种类型：</p>\n<ul>\n<li><strong>label</strong>: 导航项的标签</li>\n<li><strong>link</strong>: 导航项下级文档 link</li>\n</ul>\n<p><strong><code>link</code> 类型的导航项的 <code>path</code> 的值是文件的路径，但注意扩展名为<code>.html</code></strong>。</p>\n<h2 id=\"Favicon\"><a href=\"#Favicon\" class=\"headerlink\" title=\"Favicon\"></a>Favicon</h2><figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">theme_config:</span></span><br><span class=\"line\"><span class=\"attr\">  favicon:</span> <span class=\"string\">images/favicon.ico</span></span><br></pre></td></tr></table></figure>","site":{"data":{"navigation":{"logo":{"text":"Golang Learn","type":"link","path":"index.html"},"main":[{"text":"Golang 基础","type":"label"},{"text":"Go 环境配置","type":"link","path":"basic/env_config.html"},{"text":"包","type":"link","path":"basic/package.html"},{"text":"基础数据类型","type":"link","path":"basic/basic_data.html"},{"text":"变量","type":"link","path":"basic/var.html"},{"text":"常量","type":"link","path":"basic/constant.html"},{"text":"控制语句","type":"link","path":"basic/flow.html"},{"text":"运算符","type":"link","path":"basic/operator.html"},{"text":"作用域","type":"link","path":"basic/scope.html"},{"text":"指针","type":"link","path":"basic/pointer.html"},{"text":"数组","type":"link","path":"basic/array.html"},{"text":"切片","type":"link","path":"basic/slice.html"},{"text":"字典","type":"link","path":"basic/map.html"},{"text":"函数","type":"link","path":"basic/function.html"},{"text":"结构体","type":"link","path":"basic/struct.html"},{"text":"接口","type":"link","path":"basic/interface.html"},{"text":"面向对象","type":"link","path":"basic/oop.html"},{"text":"错误","type":"link","path":"basic/error.html"},{"text":"序列化","type":"link","path":"basic/json.html"},{"text":"反射","type":"link","path":"basic/reflect.html"},{"text":"测试","type":"link","path":"basic/test.html"},{"text":"并发编程","type":"label"},{"text":"goroutine","type":"link","path":"concurrent/goroutine.html"},{"text":"channel","type":"link","path":"concurrent/channel.html"},{"text":"同步和锁","type":"link","path":"concurrent/sync_lock.html"},{"text":"内存分配","type":"label"},{"text":"内存分配","type":"link","path":"advance/mm.html"},{"text":"垃圾回收","type":"label"},{"text":"垃圾回收","type":"link","path":"advance/gc.html"},{"text":"标准库","type":"label"},{"text":"fmt","type":"link","path":"standards/io/fmt.html"},{"text":"io","type":"link","path":"standards/io/io.html"},{"text":"ioutil","type":"link","path":"standards/io/ioutil.html"},{"text":"bufio","type":"link","path":"standards/io/bufio.html"},{"text":"os","type":"link","path":"standards/os/os.html"},{"text":"filepath","type":"link","path":"standards/os/filepath.html"},{"text":"strings","type":"link","path":"standards/text/strings.html"},{"text":"strconv","type":"link","path":"standards/text/strconv.html"},{"text":"unicode","type":"link","path":"standards/text/unicode.html"},{"text":"log","type":"link","path":"standards/log.html"},{"text":"time","type":"link","path":"standards/time.html"},{"text":"http","type":"link","path":"standards/net/http.html"},{"text":"math","type":"link","path":"standards/data/math.html"},{"text":"sort","type":"link","path":"standards/data/sort.html"},{"text":"big","type":"link","path":"standards/data/big.html"},{"text":"container","type":"link","path":"standards/data/container.html"},{"text":"sql","type":"link","path":"standards/database/sql.html"},{"text":"THEME","type":"label"},{"text":"使用文档主题","type":"link","path":"theme/theme-usage.html"},{"text":"SUPPORT AND FEEDBACK","type":"label"},{"text":"Raise an Issue on Github","type":"link","path":"https://github.com/shipengqi/golang-learn/issues/new"}]}}},"excerpt":"","more":"<h1 id=\"使用文档主题\"><a href=\"#使用文档主题\" class=\"headerlink\" title=\"使用文档主题\"></a>使用文档主题</h1><p>本文档使用 <a href=\"https://zalando-incubator.github.io/hexo-theme-doc/index.html\" target=\"_blank\" rel=\"noopener\">Hexo Doc Theme</a> 搭建。</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><ol>\n<li><p>获取源码</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git <span class=\"built_in\">clone</span> git@github.com:zalando-incubator/hexo-theme-doc-seed.git</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>hexo-theme-doc-seed</code> 的以下文件拷贝到项目 root 目录下，例如 <code>kubernetes-learn</code>：</p>\n</li>\n</ol>\n<ul>\n<li><code>source</code> 目录</li>\n<li><code>_data</code> 目录</li>\n<li><code>images</code> 目录</li>\n<li><code>package.json</code></li>\n<li><code>_config.yaml</code></li>\n<li><code>.zappr.yaml</code></li>\n</ul>\n<ol start=\"3\">\n<li><p>安装依赖</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ yarn</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>修改 <code>package.json</code>，否则 <code>hexo server</code> 或者 <code>hexo s</code> 可能会找不到命令。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"hexo\"</span>: &#123;</span><br><span class=\"line\">  <span class=\"string\">\"version\"</span>: <span class=\"string\">\"3.9.0\"</span></span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"><span class=\"string\">\"scripts\"</span>: &#123;</span><br><span class=\"line\">  <span class=\"string\">\"start\"</span>: <span class=\"string\">\"hexo s -p 8082\"</span></span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>修改 <code>_config.yml</code></p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">theme:</span> <span class=\"string\">../node_modules/hexo-theme-doc</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 如果你的网站存放在子目录中，例如 http://yoursite.com/blog</span></span><br><span class=\"line\"><span class=\"comment\"># 则 url 设为 http://yoursite.com/blog 并把 root 设为 /blog/</span></span><br><span class=\"line\"><span class=\"attr\">url:</span> <span class=\"attr\">http://www.shipengqi.top/kubernetes-learn</span></span><br><span class=\"line\"><span class=\"attr\">root:</span> <span class=\"string\">/kubernetes-learn/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># deploy</span></span><br><span class=\"line\"><span class=\"attr\">deploy:</span></span><br><span class=\"line\"><span class=\"attr\">- type:</span> <span class=\"string\">git</span></span><br><span class=\"line\"><span class=\"attr\">  repo:</span> <span class=\"string\">git@github.com:shipengqi/kubernetes-learn.git</span></span><br><span class=\"line\"><span class=\"attr\">  branch:</span> <span class=\"string\">gh-pages</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>启动开发服务，访问 <a href=\"http://localhost:8082\" target=\"_blank\" rel=\"noopener\">http://localhost:8082</a> 。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ yarn start</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"Index\"><a href=\"#Index\" class=\"headerlink\" title=\"Index\"></a>Index</h2><p><code>source</code> 目录下创建 <code>index.md</code> 文件。这个 <code>index.md</code> 文件就是文档首页。</p>\n<h2 id=\"添加文档\"><a href=\"#添加文档\" class=\"headerlink\" title=\"添加文档\"></a>添加文档</h2><p><code>source</code> 目录下创建 <code>markdown</code> 文件，例如：</p>\n<figure class=\"highlight md\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">title: Lorem Ipsum</span><br><span class=\"line\">---</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\"># Lorem Ipsum</span></span><br><span class=\"line\"></span><br><span class=\"line\">Lorem ipsum</span><br></pre></td></tr></table></figure>\n<p>也可以创建文档子目录，例如 <code>source/usage</code>。</p>\n<h2 id=\"Sidebar\"><a href=\"#Sidebar\" class=\"headerlink\" title=\"Sidebar\"></a>Sidebar</h2><p><code>source</code> 目录下的 <code>_data</code> 目录下的 <code>navigation.yaml</code> 设置 <code>sidebar</code> 和其他的一些配置。</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">logo:</span></span><br><span class=\"line\"><span class=\"attr\">  text:</span> <span class=\"string\">My</span> <span class=\"string\">Documentation</span></span><br><span class=\"line\"><span class=\"attr\">  type:</span> <span class=\"string\">link</span></span><br><span class=\"line\"><span class=\"attr\">  path:</span> <span class=\"string\">index.html</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">main:</span></span><br><span class=\"line\"><span class=\"attr\">- text:</span> <span class=\"string\">PROJECTS</span></span><br><span class=\"line\"><span class=\"attr\">  type:</span> <span class=\"string\">label</span></span><br><span class=\"line\"><span class=\"attr\">- text:</span> <span class=\"string\">My</span> <span class=\"string\">Awesome</span> <span class=\"string\">Projects</span></span><br><span class=\"line\"><span class=\"attr\">  type:</span> <span class=\"string\">link</span></span><br><span class=\"line\"><span class=\"attr\">  path:</span> <span class=\"string\">projects/my-awesome-project.html</span></span><br><span class=\"line\"><span class=\"attr\">  children:</span></span><br><span class=\"line\"><span class=\"attr\">  - text:</span> <span class=\"string\">My</span> <span class=\"string\">Awesome</span> <span class=\"string\">Projects</span> <span class=\"string\">Page</span> <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"attr\">    type:</span> <span class=\"string\">link</span></span><br><span class=\"line\"><span class=\"attr\">    path:</span> <span class=\"string\">projects/my-awesome-project-page-1.html</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><strong>logo</strong>: navigation Logo</li>\n<li><strong>main</strong>: left sidebar</li>\n</ul>\n<p>对于每个导航项，必须定义一个 <code>type</code>，并根据类型定义 <code>text</code> 和 <code>path</code> 等其他属性。<br>每个导航项，也可以定义一个 <code>children</code>，这个属性可以嵌套导航项。</p>\n<h3 id=\"type\"><a href=\"#type\" class=\"headerlink\" title=\"type\"></a>type</h3><p><code>type</code> 有两种类型：</p>\n<ul>\n<li><strong>label</strong>: 导航项的标签</li>\n<li><strong>link</strong>: 导航项下级文档 link</li>\n</ul>\n<p><strong><code>link</code> 类型的导航项的 <code>path</code> 的值是文件的路径，但注意扩展名为<code>.html</code></strong>。</p>\n<h2 id=\"Favicon\"><a href=\"#Favicon\" class=\"headerlink\" title=\"Favicon\"></a>Favicon</h2><figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">theme_config:</span></span><br><span class=\"line\"><span class=\"attr\">  favicon:</span> <span class=\"string\">images/favicon.ico</span></span><br></pre></td></tr></table></figure>"},{"_content":"## 命令\n## 工具\nGo 命令：\n```bash\n$ go\nGo is a tool for managing Go source code.\n\nUsage:\n\n        go command [arguments]\n\nThe commands are:\n\n        build       compile packages and dependencies\n        clean       remove object files and cached files\n        doc         show documentation for package or symbol\n        env         print Go environment information\n        bug         start a bug report\n        fix         update packages to use new APIs\n        fmt         gofmt (reformat) package sources\n        generate    generate Go files by processing source\n        get         download and install packages and dependencies\n        install     compile and install packages and dependencies\n        list        list packages\n        run         compile and run Go program\n        test        test packages\n        tool        run specified go tool\n        version     print Go version\n        vet         report likely mistakes in packages\n\nUse \"go help [command]\" for more information about a command.\n\nAdditional help topics:\n\n        c           calling between Go and C\n        buildmode   build modes\n        cache       build and test caching\n        filetype    file types\n        gopath      GOPATH environment variable\n        environment environment variables\n        importpath  import path syntax\n        packages    package lists\n        testflag    testing flags\n        testfunc    testing functions\n\nUse \"go help [topic]\" for more information about that topic.\n```\n\n### 下载包\n使用`go get`命令下载一个包。如`go get github.com/golang/lint/golint`下载了`golint`包，`src`目录下会有`github.com/golang/lint/golint`包目录。\n`bin`目录下可以看到`golint`可执行程序。\n\n`go get`本质上可以理解为首先第一步是通过源码工具`clone`代码到`src`下面，然后执行`go install`。\n\n**OPTIONS**\n- `-u` 保证每个包是最新版本。\n\n### 构建包\n主要用于编译代码，使用`go build`命令编译，命令行参数指定的每个包。\n有两种情况：\n- `main`包，`go build`将调用链接器在当前目录创建一个可执行程序，以导入路径的最后一段作为可执行程序的名字。\n- 如果包是一个库，则忽略输出结果；这可以用于检测包是可以正确编译的。\n\n被编译的包会被保存到`$GOPATH/pkg`目录下，目录路径和`src`目录路径对应，可执行程序被保存到`$GOPATH/bin`目录。\n\n**OPTIONS**\n- `-o` 指定输出的文件名，可以带上路径，例如`go build -o a/b/c`\n- `-i` 安装相应的包，编译并且`go install`\n- `-a` 更新全部已经是最新的包的，但是对标准包不适用\n- `-n` 把需要执行的编译命令打印出来，但是不执行，这样就可以很容易的知道底层是如何运行的\n- `-p n` 指定可以并行可运行的编译数目，默认是CPU数目\n- `-race` 开启编译的时候自动检测数据竞争的情况，目前只支持64位的机器\n- `-v` 打印出来我们正在编译的包名\n- `-work` 打印出来编译时候的临时文件夹名称，并且如果已经存在的话就不要删除\n- `-x` 打印出来执行的命令，其实就是和-n的结果类似，只是这个会执行\n- `-ccflags 'arg list'` 传递参数给5c, 6c, 8c 调用\n- `-compiler name` 指定相应的编译器，gccgo还是gc\n- `-gccgoflags 'arg list'` 传递参数给gccgo编译连接调用\n- `-gcflags 'arg list'` 传递参数给5g, 6g, 8g 调用\n- `-installsuffix suffix` 为了和默认的安装包区别开来，采用这个前缀来重新安装那些依赖的包，-race的时候默认已经是-installsuffix race,大家可以通过-n命令来验证\n- `-ldflags 'flag list'` 传递参数给5l, 6l, 8l 调用\n- `-tags 'tag list'` 设置在编译的时候可以适配的那些tag，详细的tag限制参考里面的 Build Constraints\n\n### 运行\n`go run`命令实际上是结合了构建和运行的两个步骤。\n\n### install\n`go install`命令和`go build`命令相似，不同的是`go install`会保存每个包的编译成果，并把`main`包生产的可执行程序放到`bin`目录，\n这样就可以在任意目录执行编译好的命令。\n\n### clean\n`go clean` 用来移除当前源码包和关联源码包里面编译生成的文件。文件包括：\n```\n_obj/            旧的object目录，由Makefiles遗留\n_test/           旧的test目录，由Makefiles遗留\n_testmain.go     旧的gotest文件，由Makefiles遗留\ntest.out         旧的test记录，由Makefiles遗留\nbuild.out        旧的test记录，由Makefiles遗留\n*.[568ao]        object文件，由Makefiles遗留\n\nDIR(.exe)        由go build产生\nDIR.test(.exe)   由go test -c产生\nMAINFILE(.exe)   由go build MAINFILE.go产生\n*.so             由 SWIG 产生\n```\n\n一般都是利用这个命令清除编译文件。\n\n**OPTIONS**\n- `-i` 清除关联的安装的包和可运行文件，也就是通过`go install`安装的文件\n- `-n` 把需要执行的清除命令打印出来，但是不执行，这样就可以很容易的知道底层是如何运行的\n- `-r` 循环的清除在`import`中引入的包\n- `-x` 打印出来执行的详细命令，其实就是`-n`打印的执行版本\n\n### go fmt\n\n`go fmt`命令 它可以帮你格式化你写好的代码文件，使你写代码的时候不需要关心格式，你只需要在写完之后执行`go fmt <文件名>.go`，\n你的代码就被修改成了标准格式。\n\n**OPTIONS**\n- `-l` 显示那些需要格式化的文件\n- `-w` 把改写后的内容直接写入到文件中，而不是作为结果打印到标准输出。\n- `-r` 添加形如“a[b:len(a)] -> a[b:]”的重写规则，方便我们做批量替换\n- `-s` 简化文件中的代码\n- `-d` 显示格式化前后的diff而不是写入文件，默认是`false`\n- `-e` 打印所有的语法错误到标准输出。如果不使用此标记，则只会打印不同行的前10个错误。\n- `-cpuprofile` 支持调试模式，写入相应的cpufile到指定的文件\n\n### 包文档\n#### 注释\n在代码中添加注释，用于生成文档。Go 中的文档注释一般是完整的句子，**第一行通常是摘要说明，以被注释者的名字开头。**\n注释中函数的参数或其它的标识符并不需要额外的引号或其它标记注明。例如`fmt.Fprintf`的文档注释：\n```go\n// Fprintf formats according to a format specifier and writes to w.\n// It returns the number of bytes written and any write error encountered.\nfunc Fprintf(w io.Writer, format string, a ...interface{}) (int, error)\n```\n\n如果注释后仅跟着包声明语句，那注释对应整个包的文档。包文档注释只能有一个。可以在任意的源文件中。\n\n但是如果包的注释较长，一般会放到一个叫做`doc.go`的源文件中。\n\n#### go doc 命令\n`go doc`打印文档。\n```bash\n# 指定包\ngo doc time\n\n# 指定包成员\ngo doc time.Since\n\n# 一个方法\ngo doc time.Duration.Seconds\n```\n#### godoc服务\n`godoc`服务提供可以相互交叉引用的 HTML 页面，godoc的[在线服务](https://godoc.org)。包含了成千上万的开源包的检索工具。\n\n也可以在启动本地的`godoc`服务：\n```bash\n# 在工作区目录下运行\ngodoc -http :8080\n```\n\n然后访问`http://localhost:8000/pkg`。\n\n### 内部包\nGo 的构建工具对包含`internal`名字的路径段的包导入路径做了特殊处理。这种包叫`internal`包。如`net/http/internal/chunked`。\n一个`internal`包只能被和`internal`目录有同一个父目录的包所导入。如：`net/http/internal/chunked`只能被`net/http`包或者`net/http`下的包导入。\n\n什么时候使用`internal`包？\n当我们并不想将内部的子包结构暴露出去。同时，我们可能还希望在内部子包之间共享一些通用的处理包时。\n\n### 查询包\n使用`go list`命令查询可用包的信息。如`go list github.com/go-sql-driver/mysql`\n\n```bash\n# 列出工作区中的所有包\ngo list ...\n\n# 列出指定目录下的所有包\ngo list gopl.io/ch3/...\n\n# 某个主题相关的所有包\ngo list ...xml...\n\n# 获取包完整的元信息 -json 参数表示用JSON格式打印每个包的元信息\ngo list -json hash\n```\n### 查看 Go 相关环境变量\n使用 `go env` 命令查看 Go 所有相关的环境变量。\n\n### 版本\n`go version` 查看go当前的版本","source":"commands/build.md","raw":"## 命令\n## 工具\nGo 命令：\n```bash\n$ go\nGo is a tool for managing Go source code.\n\nUsage:\n\n        go command [arguments]\n\nThe commands are:\n\n        build       compile packages and dependencies\n        clean       remove object files and cached files\n        doc         show documentation for package or symbol\n        env         print Go environment information\n        bug         start a bug report\n        fix         update packages to use new APIs\n        fmt         gofmt (reformat) package sources\n        generate    generate Go files by processing source\n        get         download and install packages and dependencies\n        install     compile and install packages and dependencies\n        list        list packages\n        run         compile and run Go program\n        test        test packages\n        tool        run specified go tool\n        version     print Go version\n        vet         report likely mistakes in packages\n\nUse \"go help [command]\" for more information about a command.\n\nAdditional help topics:\n\n        c           calling between Go and C\n        buildmode   build modes\n        cache       build and test caching\n        filetype    file types\n        gopath      GOPATH environment variable\n        environment environment variables\n        importpath  import path syntax\n        packages    package lists\n        testflag    testing flags\n        testfunc    testing functions\n\nUse \"go help [topic]\" for more information about that topic.\n```\n\n### 下载包\n使用`go get`命令下载一个包。如`go get github.com/golang/lint/golint`下载了`golint`包，`src`目录下会有`github.com/golang/lint/golint`包目录。\n`bin`目录下可以看到`golint`可执行程序。\n\n`go get`本质上可以理解为首先第一步是通过源码工具`clone`代码到`src`下面，然后执行`go install`。\n\n**OPTIONS**\n- `-u` 保证每个包是最新版本。\n\n### 构建包\n主要用于编译代码，使用`go build`命令编译，命令行参数指定的每个包。\n有两种情况：\n- `main`包，`go build`将调用链接器在当前目录创建一个可执行程序，以导入路径的最后一段作为可执行程序的名字。\n- 如果包是一个库，则忽略输出结果；这可以用于检测包是可以正确编译的。\n\n被编译的包会被保存到`$GOPATH/pkg`目录下，目录路径和`src`目录路径对应，可执行程序被保存到`$GOPATH/bin`目录。\n\n**OPTIONS**\n- `-o` 指定输出的文件名，可以带上路径，例如`go build -o a/b/c`\n- `-i` 安装相应的包，编译并且`go install`\n- `-a` 更新全部已经是最新的包的，但是对标准包不适用\n- `-n` 把需要执行的编译命令打印出来，但是不执行，这样就可以很容易的知道底层是如何运行的\n- `-p n` 指定可以并行可运行的编译数目，默认是CPU数目\n- `-race` 开启编译的时候自动检测数据竞争的情况，目前只支持64位的机器\n- `-v` 打印出来我们正在编译的包名\n- `-work` 打印出来编译时候的临时文件夹名称，并且如果已经存在的话就不要删除\n- `-x` 打印出来执行的命令，其实就是和-n的结果类似，只是这个会执行\n- `-ccflags 'arg list'` 传递参数给5c, 6c, 8c 调用\n- `-compiler name` 指定相应的编译器，gccgo还是gc\n- `-gccgoflags 'arg list'` 传递参数给gccgo编译连接调用\n- `-gcflags 'arg list'` 传递参数给5g, 6g, 8g 调用\n- `-installsuffix suffix` 为了和默认的安装包区别开来，采用这个前缀来重新安装那些依赖的包，-race的时候默认已经是-installsuffix race,大家可以通过-n命令来验证\n- `-ldflags 'flag list'` 传递参数给5l, 6l, 8l 调用\n- `-tags 'tag list'` 设置在编译的时候可以适配的那些tag，详细的tag限制参考里面的 Build Constraints\n\n### 运行\n`go run`命令实际上是结合了构建和运行的两个步骤。\n\n### install\n`go install`命令和`go build`命令相似，不同的是`go install`会保存每个包的编译成果，并把`main`包生产的可执行程序放到`bin`目录，\n这样就可以在任意目录执行编译好的命令。\n\n### clean\n`go clean` 用来移除当前源码包和关联源码包里面编译生成的文件。文件包括：\n```\n_obj/            旧的object目录，由Makefiles遗留\n_test/           旧的test目录，由Makefiles遗留\n_testmain.go     旧的gotest文件，由Makefiles遗留\ntest.out         旧的test记录，由Makefiles遗留\nbuild.out        旧的test记录，由Makefiles遗留\n*.[568ao]        object文件，由Makefiles遗留\n\nDIR(.exe)        由go build产生\nDIR.test(.exe)   由go test -c产生\nMAINFILE(.exe)   由go build MAINFILE.go产生\n*.so             由 SWIG 产生\n```\n\n一般都是利用这个命令清除编译文件。\n\n**OPTIONS**\n- `-i` 清除关联的安装的包和可运行文件，也就是通过`go install`安装的文件\n- `-n` 把需要执行的清除命令打印出来，但是不执行，这样就可以很容易的知道底层是如何运行的\n- `-r` 循环的清除在`import`中引入的包\n- `-x` 打印出来执行的详细命令，其实就是`-n`打印的执行版本\n\n### go fmt\n\n`go fmt`命令 它可以帮你格式化你写好的代码文件，使你写代码的时候不需要关心格式，你只需要在写完之后执行`go fmt <文件名>.go`，\n你的代码就被修改成了标准格式。\n\n**OPTIONS**\n- `-l` 显示那些需要格式化的文件\n- `-w` 把改写后的内容直接写入到文件中，而不是作为结果打印到标准输出。\n- `-r` 添加形如“a[b:len(a)] -> a[b:]”的重写规则，方便我们做批量替换\n- `-s` 简化文件中的代码\n- `-d` 显示格式化前后的diff而不是写入文件，默认是`false`\n- `-e` 打印所有的语法错误到标准输出。如果不使用此标记，则只会打印不同行的前10个错误。\n- `-cpuprofile` 支持调试模式，写入相应的cpufile到指定的文件\n\n### 包文档\n#### 注释\n在代码中添加注释，用于生成文档。Go 中的文档注释一般是完整的句子，**第一行通常是摘要说明，以被注释者的名字开头。**\n注释中函数的参数或其它的标识符并不需要额外的引号或其它标记注明。例如`fmt.Fprintf`的文档注释：\n```go\n// Fprintf formats according to a format specifier and writes to w.\n// It returns the number of bytes written and any write error encountered.\nfunc Fprintf(w io.Writer, format string, a ...interface{}) (int, error)\n```\n\n如果注释后仅跟着包声明语句，那注释对应整个包的文档。包文档注释只能有一个。可以在任意的源文件中。\n\n但是如果包的注释较长，一般会放到一个叫做`doc.go`的源文件中。\n\n#### go doc 命令\n`go doc`打印文档。\n```bash\n# 指定包\ngo doc time\n\n# 指定包成员\ngo doc time.Since\n\n# 一个方法\ngo doc time.Duration.Seconds\n```\n#### godoc服务\n`godoc`服务提供可以相互交叉引用的 HTML 页面，godoc的[在线服务](https://godoc.org)。包含了成千上万的开源包的检索工具。\n\n也可以在启动本地的`godoc`服务：\n```bash\n# 在工作区目录下运行\ngodoc -http :8080\n```\n\n然后访问`http://localhost:8000/pkg`。\n\n### 内部包\nGo 的构建工具对包含`internal`名字的路径段的包导入路径做了特殊处理。这种包叫`internal`包。如`net/http/internal/chunked`。\n一个`internal`包只能被和`internal`目录有同一个父目录的包所导入。如：`net/http/internal/chunked`只能被`net/http`包或者`net/http`下的包导入。\n\n什么时候使用`internal`包？\n当我们并不想将内部的子包结构暴露出去。同时，我们可能还希望在内部子包之间共享一些通用的处理包时。\n\n### 查询包\n使用`go list`命令查询可用包的信息。如`go list github.com/go-sql-driver/mysql`\n\n```bash\n# 列出工作区中的所有包\ngo list ...\n\n# 列出指定目录下的所有包\ngo list gopl.io/ch3/...\n\n# 某个主题相关的所有包\ngo list ...xml...\n\n# 获取包完整的元信息 -json 参数表示用JSON格式打印每个包的元信息\ngo list -json hash\n```\n### 查看 Go 相关环境变量\n使用 `go env` 命令查看 Go 所有相关的环境变量。\n\n### 版本\n`go version` 查看go当前的版本","date":"2019-08-24T02:08:28.702Z","updated":"2019-08-24T02:08:28.685Z","path":"commands/build.html","title":"","comments":1,"layout":"page","_id":"ck1xm14ky000sfcw2r1gygxpv","content":"<h2 id=\"命令\"><a href=\"#命令\" class=\"headerlink\" title=\"命令\"></a>命令</h2><h2 id=\"工具\"><a href=\"#工具\" class=\"headerlink\" title=\"工具\"></a>工具</h2><p>Go 命令：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ go</span><br><span class=\"line\">Go is a tool <span class=\"keyword\">for</span> managing Go <span class=\"built_in\">source</span> code.</span><br><span class=\"line\"></span><br><span class=\"line\">Usage:</span><br><span class=\"line\"></span><br><span class=\"line\">        go <span class=\"built_in\">command</span> [arguments]</span><br><span class=\"line\"></span><br><span class=\"line\">The commands are:</span><br><span class=\"line\"></span><br><span class=\"line\">        build       compile packages and dependencies</span><br><span class=\"line\">        clean       remove object files and cached files</span><br><span class=\"line\">        doc         show documentation <span class=\"keyword\">for</span> package or symbol</span><br><span class=\"line\">        env         <span class=\"built_in\">print</span> Go environment information</span><br><span class=\"line\">        bug         start a bug report</span><br><span class=\"line\">        fix         update packages to use new APIs</span><br><span class=\"line\">        fmt         gofmt (reformat) package sources</span><br><span class=\"line\">        generate    generate Go files by processing <span class=\"built_in\">source</span></span><br><span class=\"line\">        get         download and install packages and dependencies</span><br><span class=\"line\">        install     compile and install packages and dependencies</span><br><span class=\"line\">        list        list packages</span><br><span class=\"line\">        run         compile and run Go program</span><br><span class=\"line\">        <span class=\"built_in\">test</span>        <span class=\"built_in\">test</span> packages</span><br><span class=\"line\">        tool        run specified go tool</span><br><span class=\"line\">        version     <span class=\"built_in\">print</span> Go version</span><br><span class=\"line\">        vet         report likely mistakes <span class=\"keyword\">in</span> packages</span><br><span class=\"line\"></span><br><span class=\"line\">Use <span class=\"string\">\"go help [command]\"</span> <span class=\"keyword\">for</span> more information about a <span class=\"built_in\">command</span>.</span><br><span class=\"line\"></span><br><span class=\"line\">Additional <span class=\"built_in\">help</span> topics:</span><br><span class=\"line\"></span><br><span class=\"line\">        c           calling between Go and C</span><br><span class=\"line\">        buildmode   build modes</span><br><span class=\"line\">        cache       build and <span class=\"built_in\">test</span> caching</span><br><span class=\"line\">        filetype    file types</span><br><span class=\"line\">        gopath      GOPATH environment variable</span><br><span class=\"line\">        environment environment variables</span><br><span class=\"line\">        importpath  import path syntax</span><br><span class=\"line\">        packages    package lists</span><br><span class=\"line\">        testflag    testing flags</span><br><span class=\"line\">        testfunc    testing <span class=\"built_in\">functions</span></span><br><span class=\"line\"></span><br><span class=\"line\">Use <span class=\"string\">\"go help [topic]\"</span> <span class=\"keyword\">for</span> more information about that topic.</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"下载包\"><a href=\"#下载包\" class=\"headerlink\" title=\"下载包\"></a>下载包</h3><p>使用<code>go get</code>命令下载一个包。如<code>go get github.com/golang/lint/golint</code>下载了<code>golint</code>包，<code>src</code>目录下会有<code>github.com/golang/lint/golint</code>包目录。<br><code>bin</code>目录下可以看到<code>golint</code>可执行程序。</p>\n<p><code>go get</code>本质上可以理解为首先第一步是通过源码工具<code>clone</code>代码到<code>src</code>下面，然后执行<code>go install</code>。</p>\n<p><strong>OPTIONS</strong></p>\n<ul>\n<li><code>-u</code> 保证每个包是最新版本。</li>\n</ul>\n<h3 id=\"构建包\"><a href=\"#构建包\" class=\"headerlink\" title=\"构建包\"></a>构建包</h3><p>主要用于编译代码，使用<code>go build</code>命令编译，命令行参数指定的每个包。<br>有两种情况：</p>\n<ul>\n<li><code>main</code>包，<code>go build</code>将调用链接器在当前目录创建一个可执行程序，以导入路径的最后一段作为可执行程序的名字。</li>\n<li>如果包是一个库，则忽略输出结果；这可以用于检测包是可以正确编译的。</li>\n</ul>\n<p>被编译的包会被保存到<code>$GOPATH/pkg</code>目录下，目录路径和<code>src</code>目录路径对应，可执行程序被保存到<code>$GOPATH/bin</code>目录。</p>\n<p><strong>OPTIONS</strong></p>\n<ul>\n<li><code>-o</code> 指定输出的文件名，可以带上路径，例如<code>go build -o a/b/c</code></li>\n<li><code>-i</code> 安装相应的包，编译并且<code>go install</code></li>\n<li><code>-a</code> 更新全部已经是最新的包的，但是对标准包不适用</li>\n<li><code>-n</code> 把需要执行的编译命令打印出来，但是不执行，这样就可以很容易的知道底层是如何运行的</li>\n<li><code>-p n</code> 指定可以并行可运行的编译数目，默认是CPU数目</li>\n<li><code>-race</code> 开启编译的时候自动检测数据竞争的情况，目前只支持64位的机器</li>\n<li><code>-v</code> 打印出来我们正在编译的包名</li>\n<li><code>-work</code> 打印出来编译时候的临时文件夹名称，并且如果已经存在的话就不要删除</li>\n<li><code>-x</code> 打印出来执行的命令，其实就是和-n的结果类似，只是这个会执行</li>\n<li><code>-ccflags &#39;arg list&#39;</code> 传递参数给5c, 6c, 8c 调用</li>\n<li><code>-compiler name</code> 指定相应的编译器，gccgo还是gc</li>\n<li><code>-gccgoflags &#39;arg list&#39;</code> 传递参数给gccgo编译连接调用</li>\n<li><code>-gcflags &#39;arg list&#39;</code> 传递参数给5g, 6g, 8g 调用</li>\n<li><code>-installsuffix suffix</code> 为了和默认的安装包区别开来，采用这个前缀来重新安装那些依赖的包，-race的时候默认已经是-installsuffix race,大家可以通过-n命令来验证</li>\n<li><code>-ldflags &#39;flag list&#39;</code> 传递参数给5l, 6l, 8l 调用</li>\n<li><code>-tags &#39;tag list&#39;</code> 设置在编译的时候可以适配的那些tag，详细的tag限制参考里面的 Build Constraints</li>\n</ul>\n<h3 id=\"运行\"><a href=\"#运行\" class=\"headerlink\" title=\"运行\"></a>运行</h3><p><code>go run</code>命令实际上是结合了构建和运行的两个步骤。</p>\n<h3 id=\"install\"><a href=\"#install\" class=\"headerlink\" title=\"install\"></a>install</h3><p><code>go install</code>命令和<code>go build</code>命令相似，不同的是<code>go install</code>会保存每个包的编译成果，并把<code>main</code>包生产的可执行程序放到<code>bin</code>目录，<br>这样就可以在任意目录执行编译好的命令。</p>\n<h3 id=\"clean\"><a href=\"#clean\" class=\"headerlink\" title=\"clean\"></a>clean</h3><p><code>go clean</code> 用来移除当前源码包和关联源码包里面编译生成的文件。文件包括：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_obj/            旧的object目录，由Makefiles遗留</span><br><span class=\"line\">_test/           旧的test目录，由Makefiles遗留</span><br><span class=\"line\">_testmain.go     旧的gotest文件，由Makefiles遗留</span><br><span class=\"line\">test.out         旧的test记录，由Makefiles遗留</span><br><span class=\"line\">build.out        旧的test记录，由Makefiles遗留</span><br><span class=\"line\">*.[568ao]        object文件，由Makefiles遗留</span><br><span class=\"line\"></span><br><span class=\"line\">DIR(.exe)        由go build产生</span><br><span class=\"line\">DIR.test(.exe)   由go test -c产生</span><br><span class=\"line\">MAINFILE(.exe)   由go build MAINFILE.go产生</span><br><span class=\"line\">*.so             由 SWIG 产生</span><br></pre></td></tr></table></figure></p>\n<p>一般都是利用这个命令清除编译文件。</p>\n<p><strong>OPTIONS</strong></p>\n<ul>\n<li><code>-i</code> 清除关联的安装的包和可运行文件，也就是通过<code>go install</code>安装的文件</li>\n<li><code>-n</code> 把需要执行的清除命令打印出来，但是不执行，这样就可以很容易的知道底层是如何运行的</li>\n<li><code>-r</code> 循环的清除在<code>import</code>中引入的包</li>\n<li><code>-x</code> 打印出来执行的详细命令，其实就是<code>-n</code>打印的执行版本</li>\n</ul>\n<h3 id=\"go-fmt\"><a href=\"#go-fmt\" class=\"headerlink\" title=\"go fmt\"></a>go fmt</h3><p><code>go fmt</code>命令 它可以帮你格式化你写好的代码文件，使你写代码的时候不需要关心格式，你只需要在写完之后执行<code>go fmt &lt;文件名&gt;.go</code>，<br>你的代码就被修改成了标准格式。</p>\n<p><strong>OPTIONS</strong></p>\n<ul>\n<li><code>-l</code> 显示那些需要格式化的文件</li>\n<li><code>-w</code> 把改写后的内容直接写入到文件中，而不是作为结果打印到标准输出。</li>\n<li><code>-r</code> 添加形如“a[b:len(a)] -&gt; a[b:]”的重写规则，方便我们做批量替换</li>\n<li><code>-s</code> 简化文件中的代码</li>\n<li><code>-d</code> 显示格式化前后的diff而不是写入文件，默认是<code>false</code></li>\n<li><code>-e</code> 打印所有的语法错误到标准输出。如果不使用此标记，则只会打印不同行的前10个错误。</li>\n<li><code>-cpuprofile</code> 支持调试模式，写入相应的cpufile到指定的文件</li>\n</ul>\n<h3 id=\"包文档\"><a href=\"#包文档\" class=\"headerlink\" title=\"包文档\"></a>包文档</h3><h4 id=\"注释\"><a href=\"#注释\" class=\"headerlink\" title=\"注释\"></a>注释</h4><p>在代码中添加注释，用于生成文档。Go 中的文档注释一般是完整的句子，<strong>第一行通常是摘要说明，以被注释者的名字开头。</strong><br>注释中函数的参数或其它的标识符并不需要额外的引号或其它标记注明。例如<code>fmt.Fprintf</code>的文档注释：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Fprintf formats according to a format specifier and writes to w.</span></span><br><span class=\"line\"><span class=\"comment\">// It returns the number of bytes written and any write error encountered.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Fprintf</span><span class=\"params\">(w io.Writer, format <span class=\"keyword\">string</span>, a ...<span class=\"keyword\">interface</span>&#123;&#125;)</span> <span class=\"params\">(<span class=\"keyword\">int</span>, error)</span></span></span><br></pre></td></tr></table></figure></p>\n<p>如果注释后仅跟着包声明语句，那注释对应整个包的文档。包文档注释只能有一个。可以在任意的源文件中。</p>\n<p>但是如果包的注释较长，一般会放到一个叫做<code>doc.go</code>的源文件中。</p>\n<h4 id=\"go-doc-命令\"><a href=\"#go-doc-命令\" class=\"headerlink\" title=\"go doc 命令\"></a>go doc 命令</h4><p><code>go doc</code>打印文档。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 指定包</span></span><br><span class=\"line\">go doc time</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 指定包成员</span></span><br><span class=\"line\">go doc time.Since</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 一个方法</span></span><br><span class=\"line\">go doc time.Duration.Seconds</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"godoc服务\"><a href=\"#godoc服务\" class=\"headerlink\" title=\"godoc服务\"></a>godoc服务</h4><p><code>godoc</code>服务提供可以相互交叉引用的 HTML 页面，godoc的<a href=\"https://godoc.org\" target=\"_blank\" rel=\"noopener\">在线服务</a>。包含了成千上万的开源包的检索工具。</p>\n<p>也可以在启动本地的<code>godoc</code>服务：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 在工作区目录下运行</span></span><br><span class=\"line\">godoc -http :8080</span><br></pre></td></tr></table></figure></p>\n<p>然后访问<code>http://localhost:8000/pkg</code>。</p>\n<h3 id=\"内部包\"><a href=\"#内部包\" class=\"headerlink\" title=\"内部包\"></a>内部包</h3><p>Go 的构建工具对包含<code>internal</code>名字的路径段的包导入路径做了特殊处理。这种包叫<code>internal</code>包。如<code>net/http/internal/chunked</code>。<br>一个<code>internal</code>包只能被和<code>internal</code>目录有同一个父目录的包所导入。如：<code>net/http/internal/chunked</code>只能被<code>net/http</code>包或者<code>net/http</code>下的包导入。</p>\n<p>什么时候使用<code>internal</code>包？<br>当我们并不想将内部的子包结构暴露出去。同时，我们可能还希望在内部子包之间共享一些通用的处理包时。</p>\n<h3 id=\"查询包\"><a href=\"#查询包\" class=\"headerlink\" title=\"查询包\"></a>查询包</h3><p>使用<code>go list</code>命令查询可用包的信息。如<code>go list github.com/go-sql-driver/mysql</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 列出工作区中的所有包</span></span><br><span class=\"line\">go list ...</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 列出指定目录下的所有包</span></span><br><span class=\"line\">go list gopl.io/ch3/...</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 某个主题相关的所有包</span></span><br><span class=\"line\">go list ...xml...</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 获取包完整的元信息 -json 参数表示用JSON格式打印每个包的元信息</span></span><br><span class=\"line\">go list -json <span class=\"built_in\">hash</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"查看-Go-相关环境变量\"><a href=\"#查看-Go-相关环境变量\" class=\"headerlink\" title=\"查看 Go 相关环境变量\"></a>查看 Go 相关环境变量</h3><p>使用 <code>go env</code> 命令查看 Go 所有相关的环境变量。</p>\n<h3 id=\"版本\"><a href=\"#版本\" class=\"headerlink\" title=\"版本\"></a>版本</h3><p><code>go version</code> 查看go当前的版本</p>\n","site":{"data":{"navigation":{"logo":{"text":"Golang Learn","type":"link","path":"index.html"},"main":[{"text":"Golang 基础","type":"label"},{"text":"Go 环境配置","type":"link","path":"basic/env_config.html"},{"text":"包","type":"link","path":"basic/package.html"},{"text":"基础数据类型","type":"link","path":"basic/basic_data.html"},{"text":"变量","type":"link","path":"basic/var.html"},{"text":"常量","type":"link","path":"basic/constant.html"},{"text":"控制语句","type":"link","path":"basic/flow.html"},{"text":"运算符","type":"link","path":"basic/operator.html"},{"text":"作用域","type":"link","path":"basic/scope.html"},{"text":"指针","type":"link","path":"basic/pointer.html"},{"text":"数组","type":"link","path":"basic/array.html"},{"text":"切片","type":"link","path":"basic/slice.html"},{"text":"字典","type":"link","path":"basic/map.html"},{"text":"函数","type":"link","path":"basic/function.html"},{"text":"结构体","type":"link","path":"basic/struct.html"},{"text":"接口","type":"link","path":"basic/interface.html"},{"text":"面向对象","type":"link","path":"basic/oop.html"},{"text":"错误","type":"link","path":"basic/error.html"},{"text":"序列化","type":"link","path":"basic/json.html"},{"text":"反射","type":"link","path":"basic/reflect.html"},{"text":"测试","type":"link","path":"basic/test.html"},{"text":"并发编程","type":"label"},{"text":"goroutine","type":"link","path":"concurrent/goroutine.html"},{"text":"channel","type":"link","path":"concurrent/channel.html"},{"text":"同步和锁","type":"link","path":"concurrent/sync_lock.html"},{"text":"内存分配","type":"label"},{"text":"内存分配","type":"link","path":"advance/mm.html"},{"text":"垃圾回收","type":"label"},{"text":"垃圾回收","type":"link","path":"advance/gc.html"},{"text":"标准库","type":"label"},{"text":"fmt","type":"link","path":"standards/io/fmt.html"},{"text":"io","type":"link","path":"standards/io/io.html"},{"text":"ioutil","type":"link","path":"standards/io/ioutil.html"},{"text":"bufio","type":"link","path":"standards/io/bufio.html"},{"text":"os","type":"link","path":"standards/os/os.html"},{"text":"filepath","type":"link","path":"standards/os/filepath.html"},{"text":"strings","type":"link","path":"standards/text/strings.html"},{"text":"strconv","type":"link","path":"standards/text/strconv.html"},{"text":"unicode","type":"link","path":"standards/text/unicode.html"},{"text":"log","type":"link","path":"standards/log.html"},{"text":"time","type":"link","path":"standards/time.html"},{"text":"http","type":"link","path":"standards/net/http.html"},{"text":"math","type":"link","path":"standards/data/math.html"},{"text":"sort","type":"link","path":"standards/data/sort.html"},{"text":"big","type":"link","path":"standards/data/big.html"},{"text":"container","type":"link","path":"standards/data/container.html"},{"text":"sql","type":"link","path":"standards/database/sql.html"},{"text":"THEME","type":"label"},{"text":"使用文档主题","type":"link","path":"theme/theme-usage.html"},{"text":"SUPPORT AND FEEDBACK","type":"label"},{"text":"Raise an Issue on Github","type":"link","path":"https://github.com/shipengqi/golang-learn/issues/new"}]}}},"excerpt":"","more":"<h2 id=\"命令\"><a href=\"#命令\" class=\"headerlink\" title=\"命令\"></a>命令</h2><h2 id=\"工具\"><a href=\"#工具\" class=\"headerlink\" title=\"工具\"></a>工具</h2><p>Go 命令：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ go</span><br><span class=\"line\">Go is a tool <span class=\"keyword\">for</span> managing Go <span class=\"built_in\">source</span> code.</span><br><span class=\"line\"></span><br><span class=\"line\">Usage:</span><br><span class=\"line\"></span><br><span class=\"line\">        go <span class=\"built_in\">command</span> [arguments]</span><br><span class=\"line\"></span><br><span class=\"line\">The commands are:</span><br><span class=\"line\"></span><br><span class=\"line\">        build       compile packages and dependencies</span><br><span class=\"line\">        clean       remove object files and cached files</span><br><span class=\"line\">        doc         show documentation <span class=\"keyword\">for</span> package or symbol</span><br><span class=\"line\">        env         <span class=\"built_in\">print</span> Go environment information</span><br><span class=\"line\">        bug         start a bug report</span><br><span class=\"line\">        fix         update packages to use new APIs</span><br><span class=\"line\">        fmt         gofmt (reformat) package sources</span><br><span class=\"line\">        generate    generate Go files by processing <span class=\"built_in\">source</span></span><br><span class=\"line\">        get         download and install packages and dependencies</span><br><span class=\"line\">        install     compile and install packages and dependencies</span><br><span class=\"line\">        list        list packages</span><br><span class=\"line\">        run         compile and run Go program</span><br><span class=\"line\">        <span class=\"built_in\">test</span>        <span class=\"built_in\">test</span> packages</span><br><span class=\"line\">        tool        run specified go tool</span><br><span class=\"line\">        version     <span class=\"built_in\">print</span> Go version</span><br><span class=\"line\">        vet         report likely mistakes <span class=\"keyword\">in</span> packages</span><br><span class=\"line\"></span><br><span class=\"line\">Use <span class=\"string\">\"go help [command]\"</span> <span class=\"keyword\">for</span> more information about a <span class=\"built_in\">command</span>.</span><br><span class=\"line\"></span><br><span class=\"line\">Additional <span class=\"built_in\">help</span> topics:</span><br><span class=\"line\"></span><br><span class=\"line\">        c           calling between Go and C</span><br><span class=\"line\">        buildmode   build modes</span><br><span class=\"line\">        cache       build and <span class=\"built_in\">test</span> caching</span><br><span class=\"line\">        filetype    file types</span><br><span class=\"line\">        gopath      GOPATH environment variable</span><br><span class=\"line\">        environment environment variables</span><br><span class=\"line\">        importpath  import path syntax</span><br><span class=\"line\">        packages    package lists</span><br><span class=\"line\">        testflag    testing flags</span><br><span class=\"line\">        testfunc    testing <span class=\"built_in\">functions</span></span><br><span class=\"line\"></span><br><span class=\"line\">Use <span class=\"string\">\"go help [topic]\"</span> <span class=\"keyword\">for</span> more information about that topic.</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"下载包\"><a href=\"#下载包\" class=\"headerlink\" title=\"下载包\"></a>下载包</h3><p>使用<code>go get</code>命令下载一个包。如<code>go get github.com/golang/lint/golint</code>下载了<code>golint</code>包，<code>src</code>目录下会有<code>github.com/golang/lint/golint</code>包目录。<br><code>bin</code>目录下可以看到<code>golint</code>可执行程序。</p>\n<p><code>go get</code>本质上可以理解为首先第一步是通过源码工具<code>clone</code>代码到<code>src</code>下面，然后执行<code>go install</code>。</p>\n<p><strong>OPTIONS</strong></p>\n<ul>\n<li><code>-u</code> 保证每个包是最新版本。</li>\n</ul>\n<h3 id=\"构建包\"><a href=\"#构建包\" class=\"headerlink\" title=\"构建包\"></a>构建包</h3><p>主要用于编译代码，使用<code>go build</code>命令编译，命令行参数指定的每个包。<br>有两种情况：</p>\n<ul>\n<li><code>main</code>包，<code>go build</code>将调用链接器在当前目录创建一个可执行程序，以导入路径的最后一段作为可执行程序的名字。</li>\n<li>如果包是一个库，则忽略输出结果；这可以用于检测包是可以正确编译的。</li>\n</ul>\n<p>被编译的包会被保存到<code>$GOPATH/pkg</code>目录下，目录路径和<code>src</code>目录路径对应，可执行程序被保存到<code>$GOPATH/bin</code>目录。</p>\n<p><strong>OPTIONS</strong></p>\n<ul>\n<li><code>-o</code> 指定输出的文件名，可以带上路径，例如<code>go build -o a/b/c</code></li>\n<li><code>-i</code> 安装相应的包，编译并且<code>go install</code></li>\n<li><code>-a</code> 更新全部已经是最新的包的，但是对标准包不适用</li>\n<li><code>-n</code> 把需要执行的编译命令打印出来，但是不执行，这样就可以很容易的知道底层是如何运行的</li>\n<li><code>-p n</code> 指定可以并行可运行的编译数目，默认是CPU数目</li>\n<li><code>-race</code> 开启编译的时候自动检测数据竞争的情况，目前只支持64位的机器</li>\n<li><code>-v</code> 打印出来我们正在编译的包名</li>\n<li><code>-work</code> 打印出来编译时候的临时文件夹名称，并且如果已经存在的话就不要删除</li>\n<li><code>-x</code> 打印出来执行的命令，其实就是和-n的结果类似，只是这个会执行</li>\n<li><code>-ccflags &#39;arg list&#39;</code> 传递参数给5c, 6c, 8c 调用</li>\n<li><code>-compiler name</code> 指定相应的编译器，gccgo还是gc</li>\n<li><code>-gccgoflags &#39;arg list&#39;</code> 传递参数给gccgo编译连接调用</li>\n<li><code>-gcflags &#39;arg list&#39;</code> 传递参数给5g, 6g, 8g 调用</li>\n<li><code>-installsuffix suffix</code> 为了和默认的安装包区别开来，采用这个前缀来重新安装那些依赖的包，-race的时候默认已经是-installsuffix race,大家可以通过-n命令来验证</li>\n<li><code>-ldflags &#39;flag list&#39;</code> 传递参数给5l, 6l, 8l 调用</li>\n<li><code>-tags &#39;tag list&#39;</code> 设置在编译的时候可以适配的那些tag，详细的tag限制参考里面的 Build Constraints</li>\n</ul>\n<h3 id=\"运行\"><a href=\"#运行\" class=\"headerlink\" title=\"运行\"></a>运行</h3><p><code>go run</code>命令实际上是结合了构建和运行的两个步骤。</p>\n<h3 id=\"install\"><a href=\"#install\" class=\"headerlink\" title=\"install\"></a>install</h3><p><code>go install</code>命令和<code>go build</code>命令相似，不同的是<code>go install</code>会保存每个包的编译成果，并把<code>main</code>包生产的可执行程序放到<code>bin</code>目录，<br>这样就可以在任意目录执行编译好的命令。</p>\n<h3 id=\"clean\"><a href=\"#clean\" class=\"headerlink\" title=\"clean\"></a>clean</h3><p><code>go clean</code> 用来移除当前源码包和关联源码包里面编译生成的文件。文件包括：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_obj/            旧的object目录，由Makefiles遗留</span><br><span class=\"line\">_test/           旧的test目录，由Makefiles遗留</span><br><span class=\"line\">_testmain.go     旧的gotest文件，由Makefiles遗留</span><br><span class=\"line\">test.out         旧的test记录，由Makefiles遗留</span><br><span class=\"line\">build.out        旧的test记录，由Makefiles遗留</span><br><span class=\"line\">*.[568ao]        object文件，由Makefiles遗留</span><br><span class=\"line\"></span><br><span class=\"line\">DIR(.exe)        由go build产生</span><br><span class=\"line\">DIR.test(.exe)   由go test -c产生</span><br><span class=\"line\">MAINFILE(.exe)   由go build MAINFILE.go产生</span><br><span class=\"line\">*.so             由 SWIG 产生</span><br></pre></td></tr></table></figure></p>\n<p>一般都是利用这个命令清除编译文件。</p>\n<p><strong>OPTIONS</strong></p>\n<ul>\n<li><code>-i</code> 清除关联的安装的包和可运行文件，也就是通过<code>go install</code>安装的文件</li>\n<li><code>-n</code> 把需要执行的清除命令打印出来，但是不执行，这样就可以很容易的知道底层是如何运行的</li>\n<li><code>-r</code> 循环的清除在<code>import</code>中引入的包</li>\n<li><code>-x</code> 打印出来执行的详细命令，其实就是<code>-n</code>打印的执行版本</li>\n</ul>\n<h3 id=\"go-fmt\"><a href=\"#go-fmt\" class=\"headerlink\" title=\"go fmt\"></a>go fmt</h3><p><code>go fmt</code>命令 它可以帮你格式化你写好的代码文件，使你写代码的时候不需要关心格式，你只需要在写完之后执行<code>go fmt &lt;文件名&gt;.go</code>，<br>你的代码就被修改成了标准格式。</p>\n<p><strong>OPTIONS</strong></p>\n<ul>\n<li><code>-l</code> 显示那些需要格式化的文件</li>\n<li><code>-w</code> 把改写后的内容直接写入到文件中，而不是作为结果打印到标准输出。</li>\n<li><code>-r</code> 添加形如“a[b:len(a)] -&gt; a[b:]”的重写规则，方便我们做批量替换</li>\n<li><code>-s</code> 简化文件中的代码</li>\n<li><code>-d</code> 显示格式化前后的diff而不是写入文件，默认是<code>false</code></li>\n<li><code>-e</code> 打印所有的语法错误到标准输出。如果不使用此标记，则只会打印不同行的前10个错误。</li>\n<li><code>-cpuprofile</code> 支持调试模式，写入相应的cpufile到指定的文件</li>\n</ul>\n<h3 id=\"包文档\"><a href=\"#包文档\" class=\"headerlink\" title=\"包文档\"></a>包文档</h3><h4 id=\"注释\"><a href=\"#注释\" class=\"headerlink\" title=\"注释\"></a>注释</h4><p>在代码中添加注释，用于生成文档。Go 中的文档注释一般是完整的句子，<strong>第一行通常是摘要说明，以被注释者的名字开头。</strong><br>注释中函数的参数或其它的标识符并不需要额外的引号或其它标记注明。例如<code>fmt.Fprintf</code>的文档注释：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Fprintf formats according to a format specifier and writes to w.</span></span><br><span class=\"line\"><span class=\"comment\">// It returns the number of bytes written and any write error encountered.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Fprintf</span><span class=\"params\">(w io.Writer, format <span class=\"keyword\">string</span>, a ...<span class=\"keyword\">interface</span>&#123;&#125;)</span> <span class=\"params\">(<span class=\"keyword\">int</span>, error)</span></span></span><br></pre></td></tr></table></figure></p>\n<p>如果注释后仅跟着包声明语句，那注释对应整个包的文档。包文档注释只能有一个。可以在任意的源文件中。</p>\n<p>但是如果包的注释较长，一般会放到一个叫做<code>doc.go</code>的源文件中。</p>\n<h4 id=\"go-doc-命令\"><a href=\"#go-doc-命令\" class=\"headerlink\" title=\"go doc 命令\"></a>go doc 命令</h4><p><code>go doc</code>打印文档。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 指定包</span></span><br><span class=\"line\">go doc time</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 指定包成员</span></span><br><span class=\"line\">go doc time.Since</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 一个方法</span></span><br><span class=\"line\">go doc time.Duration.Seconds</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"godoc服务\"><a href=\"#godoc服务\" class=\"headerlink\" title=\"godoc服务\"></a>godoc服务</h4><p><code>godoc</code>服务提供可以相互交叉引用的 HTML 页面，godoc的<a href=\"https://godoc.org\" target=\"_blank\" rel=\"noopener\">在线服务</a>。包含了成千上万的开源包的检索工具。</p>\n<p>也可以在启动本地的<code>godoc</code>服务：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 在工作区目录下运行</span></span><br><span class=\"line\">godoc -http :8080</span><br></pre></td></tr></table></figure></p>\n<p>然后访问<code>http://localhost:8000/pkg</code>。</p>\n<h3 id=\"内部包\"><a href=\"#内部包\" class=\"headerlink\" title=\"内部包\"></a>内部包</h3><p>Go 的构建工具对包含<code>internal</code>名字的路径段的包导入路径做了特殊处理。这种包叫<code>internal</code>包。如<code>net/http/internal/chunked</code>。<br>一个<code>internal</code>包只能被和<code>internal</code>目录有同一个父目录的包所导入。如：<code>net/http/internal/chunked</code>只能被<code>net/http</code>包或者<code>net/http</code>下的包导入。</p>\n<p>什么时候使用<code>internal</code>包？<br>当我们并不想将内部的子包结构暴露出去。同时，我们可能还希望在内部子包之间共享一些通用的处理包时。</p>\n<h3 id=\"查询包\"><a href=\"#查询包\" class=\"headerlink\" title=\"查询包\"></a>查询包</h3><p>使用<code>go list</code>命令查询可用包的信息。如<code>go list github.com/go-sql-driver/mysql</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 列出工作区中的所有包</span></span><br><span class=\"line\">go list ...</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 列出指定目录下的所有包</span></span><br><span class=\"line\">go list gopl.io/ch3/...</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 某个主题相关的所有包</span></span><br><span class=\"line\">go list ...xml...</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 获取包完整的元信息 -json 参数表示用JSON格式打印每个包的元信息</span></span><br><span class=\"line\">go list -json <span class=\"built_in\">hash</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"查看-Go-相关环境变量\"><a href=\"#查看-Go-相关环境变量\" class=\"headerlink\" title=\"查看 Go 相关环境变量\"></a>查看 Go 相关环境变量</h3><p>使用 <code>go env</code> 命令查看 Go 所有相关的环境变量。</p>\n<h3 id=\"版本\"><a href=\"#版本\" class=\"headerlink\" title=\"版本\"></a>版本</h3><p><code>go version</code> 查看go当前的版本</p>\n"},{"title":"channel","_content":"\n# channel\n```\nDon’t communicate by sharing memory; share memory by communicating.\n（不要通过共享内存来通信，而应该通过通信来共享内存。）\n```\n这是作为 Go 语言最重要的编程理念。\n\n通道类型的值是**并发安全**的，这也是 **Go 语言自带的、唯一一个可以满足并发安全性的类型**。\n\n`channels` 是 `goroutine` 之间的通信机制。`goroutine` 通过 `channel` 向另一个 `goroutine` 发送消息\n`channel` 和 `goroutine` 结合，可以实现用通信代替共享内存的 `CSP` 模型。\n\n创建 `channel`：\n```go\nch := make(chan int)\n\nch = make(chan int, 3) // buffered channel with capacity 3\n```\n\n上面的代码中，`int` 代表这个 `channel` 要发送的数据的类型。第二个参数代表创建一带缓存的 `channel`，容量为 `3`。\n\n`channel` 的零值是 `nil`。\n\n发送和接收两个操作使用 `<-` 运算符，一个左尖括号紧接着一个减号形象地代表了元素值的传输方向：\n```go\n// 发送一个值\nch <- x // 将数据 push 到 channel\n\n// 接受一个值\nx = <-ch // 取出 channel 的值并复制给变量x\n\n<-ch // 接受的值会被丢弃\n```\n\n### close\n\n使用 `close` 函数关闭 `channel`，`channel` 关闭后不能再发送数据，但是可以接受已经发送成功的数据，\n如果 `channel` 中没有数据，那么返回一个零值。\n\n注意，**`close` 函数不是一个清理操作，而是一个控制操作**，在确定这个 `channel` 不会继续发送数据时调用。\n\n**因为关闭操作只用于断言不再向 `channel` 发送新的数据，所以只有在 \"发送者\" 所在的 `goroutine` 才会调用 `close` 函数**，\n因此对一个只接收的 `channel` 调用 `close` 将是一个编译错误。\n\n使用 `range` 循环可直接在 `channels` 上面迭代。它依次从 `channel` 接收数据，当 `channel` 被关闭并且没有值可接收时\n跳出循环。\n```go\nnaturals := make(chan int)\nfor x := 0; x < 100; x++ {\n    naturals <- x\n}\nfor x := range naturals {\n    fmt.Println(x)\n}\n```\n\n**注意上面的代码会报 `fatal error: all goroutines are asleep - deadlock!`。这个是死锁的错误，因为 `range` 不等到信\n道关闭是不会结束读取的。也就是如果 `channel` 没有数据了，那么 `range` 就会阻塞当前 `goroutine`, 直到信道关闭，所以导\n致了死锁**。\n\n为了避免这种情况，对于有缓存的信道，显式地关闭信道:\n```go\nch := make(chan int, 3)\nch <- 1\nch <- 2\nch <- 3\n\n// 显式地关闭信道\nclose(ch)\n\nfor v := range ch {\n    fmt.Println(v)\n}\n```\n\n### 无缓存 channel\n**无缓存 `channel` 也叫做同步 `channel`**，这是因为**如果一个 `goroutine` 基于一个无缓存 `channel` 发送数据，那么就会\n阻塞，直到另一个 `goroutine` 在相同的 `channel` 上执行接收操作**。同样的，**如果一个 `goroutine` 基于一个无缓存 `channel` \n先执行了接受操作，也会阻塞，直到另一个 `goroutine` 在相同的 `channel` 上执行发送操作**。在 `channel` 成功传输之后，两个 \n`goroutine` 之后的语句才会继续执行。\n\n### 带缓存 channel\n```go\nch = make(chan int, 3)\n```\n带缓存的 `channel` 内部持有一个元素队列。`make` 函数创建 `channel` 时通过第二个参数指定队列的最大容量。\n\n发送操作会向 `channel` 的缓存队列 `push` 元素，接收操作则是 `pop` 元素，如果队列被塞满了，那么发送操作将阻\n塞直到另一个 `goroutine` 执行接收操作而释放了新的队列空间。\n相反，如果 `channel` 是空的，接收操作将阻塞直到有另一个 `goroutine` 执行发送操作而向队列插入元素。\n\n在大多数情况下，缓冲通道会作为收发双方的中间件。正如前文所述，元素值会先从发送方复制到缓冲通道，之后再由缓冲通道复制给接收方。\n\n但是，当发送操作在执行的时候发现空的通道中，正好有等待的接收操作，那么它会直接把元素值复制给接收方。\n\n### 单向 channel\n\n当一个 `channel` 作为一个函数参数时，它一般总是被专门用于**只发送或者只接收**。\n\n类型 `chan<- int` 表示一个只发送 `int` 的 `channel`。相反，类型 `<-chan int` 表示一个只接收 `int` 的 `channel`。\n\n```go\nvar uselessChan = make(chan<- int, 1)\n```\n\n### cap 和 len\n`cap` 函数可以获取 `channel` 内部缓存的容量。\n`len` 函数可以获取 `channel` 内部缓存有效元素的个数。\n\n```go\nch = make(chan int, 3)\nfmt.Println(cap(ch)) // 3\n\nch <- \"A\"\nch <- \"B\"\n\nfmt.Println(len(ch)) // 2\nfmt.Println(<-ch) // A\nfmt.Println(len(ch)) // 1\n```\n\n### 通道的发送和接收操作的特性\n1. 对于同一个通道，发送操作之间是互斥的，接收操作之间也是互斥的。Go 语言的运行时系统（以下简称运行时系统）只会执行对同一个通\n道的任意个发送操作中的某一个。直到这个元素值被完全复制进该通道之后，其他针对该通道的发送操作才可能被执行。\n2. 发送操作和接收操作中对元素值的处理都是不可分割的。发送操作要么还没复制元素值，要么已经复制完毕，绝不会出现只复制了一部分\n的情况。接收操作在准备好元素值的副本之后，一定会删除掉通道中的原值，绝不会出现通道中仍有残留的情况。\n3. 发送操作在完全完成之前会被阻塞。接收操作也是如此。\n\n**元素值从外界进入通道时会被复制。更具体地说，进入通道的并不是在接收操作符右边的那个元素值，而是它的副本**。\n\n**对于通道中的同一个元素值来说，发送操作和接收操作之间也是互斥的。例如，虽然会出现，正在被复制进通道但还未复制完成的元素值，\n但是这时它绝不会被想接收它的一方看到和取走**。\n\n### 发送操作和接收操作在什么时候可能被长时间的阻塞\n- 针对**缓冲通道**的情况。如果通道已满，那么对它的所有发送操作都会被阻塞，直到通道中有元素值被接收走。相对的，如果通道已空，\n那么对它的所有接收操作都会被阻塞，直到通道中有新的元素值出现。这时，通道会通知最早等待的那个接收操作所在的 goroutine，\n并使它再次执行接收操作。\n- 对于**非缓冲通道**，情况要简单一些。无论是发送操作还是接收操作，一开始执行就会被阻塞，直到配对的操作也开始执行，才会继续传递。\n- **对于值为 `nil` 的通道，不论它的具体类型是什么，对它的发送操作和接收操作都会永久地处于阻塞状态**。它们所属的 goroutine \n中的任何代码，都不再会被执行。注意，由于通道类型是引用类型，所以它的零值就是 `nil`。**当我们只声明该类型的变量但没\n有用 `make` 函数对它进行初始化时，该变量的值就会是 `nil`。我们一定不要忘记初始化通道**！\n\n### select 多路复用\n`select` 语句是专为通道而设计的，**所以每个 `case` 表达式中都只能包含操作通道的表达式**，比如接收表达式。\n\n```go\nselect {\n  case communication clause  :\n      ...     \n  case communication clause  :\n      ... \n  default : /* 可选 */\n\t\t\t... \n}\t\t\t\n```\n\n如果有多个 `channel` 需要接受消息，如果第一个 `channel` 没有消息发过来，那么程序会被阻塞，第二个 `channel` 的消息就也\n无法接收了。这时候就需要使用 `select` 多路复用。\n```go\nselect {\n  case <-ch1:\n      ...     \n  case x := <-ch2:\n\t\t\t... \n\tcase ch3 <- y:\n\t    ...\t\t\n  default:\n\t\t\t... \n}\t\n```\n每一个 `case` 代表一个通信操作，发送或者接收。**如果没有 `case` 可运行，它将阻塞，直到有 `case` 可运行**。\n如果多个 `case` 同时满足条件，`select` 会**随机**地选择一个执行。\n\n**为了避免因为发送或者接收导致的阻塞，尤其是当 `channel` 没有准备好写或者读时。`default` 可以设置当其它的操作\n都不能够马上被处理时程序需要执行哪些逻辑**。\n\n### 超时\n我们可以利用 `select` 来设置超时，避免 `goroutine` 阻塞的情况：\n```go\nfunc main() {\n\tc := make(chan int)\n\to := make(chan bool)\n\tgo func() {\n\t\tfor {\n\t\t\tselect {\n\t\t\t\tcase v := <- c:\n\t\t\t\t\tfmt.println(v)\n\t\t\t\tcase <- time.After(5 * time.Second):\n\t\t\t\t\tfmt.println(\"timeout\")\n\t\t\t\t\to <- true\n\t\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}()\n\t<- o\n}\n```\n\n#### 使用 select 语句的时候，需要注意的事情\n1. 如果加入了默认分支，那么无论涉及通道操作的表达式是否有阻塞，`select` 语句都不会被阻塞。如果那几个表达式都阻塞了，或者\n说都没有满足求值的条件，那么默认分支就会被选中并执行。\n2. 如果没有加入默认分支，那么一旦所有的 `case` 表达式都没有满足求值条件，那么 `select` 语句就会被阻塞。\n直到至少有一个 `case` 表达式满足条件为止。\n3. 还记得吗？我们可能会因为通道关闭了，而直接从通道接收到一个其元素类型的零值。所以，在很多时候，我们需要通过接收表达式\n的第二个结果值来判断通道是否已经关闭。一旦发现某个通道关闭了，我们就应该及时地屏蔽掉对应的分支或者采取其他措施。这对\n于程序逻辑和程序性能都是有好处的。\n4. `select` 语句只能对其中的每一个 `case` 表达式各求值一次。所以，如果我们想连续或定时地操作其中的通道的话，就往往需要\n通过在 `for` 语句中嵌入 `select` 语句的方式实现。但这时要注意，**简单地在 `select` 语句的分支中使用 `break` 语句，只能结\n束当前的 `select` 语句的执行，而并不会对外层的 `for` 语句产生作用。这种错误的用法可能会让这个 `for` 语句无休止地运行下去**。\n\n`break` 退出嵌套循环：\n```go\nI:\n\tfor i := 0; i < 2; i++ {\n\t\tfor j := 0; j < 5; j++ {\n\t\t\tif j == 2 {\n\t\t\t\tbreak I\n\t\t\t}\n\t\t\tfmt.Println(\"hello\")\n\t\t}\n\t\tfmt.Println(\"hi\")\n\t}\n```\n\n```go\nintChan := make(chan int, 1)\n// 一秒后关闭通道。\ntime.AfterFunc(time.Second, func() {\n  close(intChan)\n})\nselect {\n  case _, ok := <-intChan:\n    if !ok {\n      fmt.Println(\"The candidate case is closed.\")\n      break\n    }\n    fmt.Println(\"The candidate case is selected.\")\n}\n```\n\n上面的代码 `select` 语句只有一个候选分支，我在其中利用接收表达式的第二个结果值对 `intChan` 通道是否已关闭做了判断，并在\n得到肯定结果后，通过 `break` 语句立即结束当前 `select` 语句的执行。\n","source":"concurrent/channel.md","raw":"---\ntitle: channel\n---\n\n# channel\n```\nDon’t communicate by sharing memory; share memory by communicating.\n（不要通过共享内存来通信，而应该通过通信来共享内存。）\n```\n这是作为 Go 语言最重要的编程理念。\n\n通道类型的值是**并发安全**的，这也是 **Go 语言自带的、唯一一个可以满足并发安全性的类型**。\n\n`channels` 是 `goroutine` 之间的通信机制。`goroutine` 通过 `channel` 向另一个 `goroutine` 发送消息\n`channel` 和 `goroutine` 结合，可以实现用通信代替共享内存的 `CSP` 模型。\n\n创建 `channel`：\n```go\nch := make(chan int)\n\nch = make(chan int, 3) // buffered channel with capacity 3\n```\n\n上面的代码中，`int` 代表这个 `channel` 要发送的数据的类型。第二个参数代表创建一带缓存的 `channel`，容量为 `3`。\n\n`channel` 的零值是 `nil`。\n\n发送和接收两个操作使用 `<-` 运算符，一个左尖括号紧接着一个减号形象地代表了元素值的传输方向：\n```go\n// 发送一个值\nch <- x // 将数据 push 到 channel\n\n// 接受一个值\nx = <-ch // 取出 channel 的值并复制给变量x\n\n<-ch // 接受的值会被丢弃\n```\n\n### close\n\n使用 `close` 函数关闭 `channel`，`channel` 关闭后不能再发送数据，但是可以接受已经发送成功的数据，\n如果 `channel` 中没有数据，那么返回一个零值。\n\n注意，**`close` 函数不是一个清理操作，而是一个控制操作**，在确定这个 `channel` 不会继续发送数据时调用。\n\n**因为关闭操作只用于断言不再向 `channel` 发送新的数据，所以只有在 \"发送者\" 所在的 `goroutine` 才会调用 `close` 函数**，\n因此对一个只接收的 `channel` 调用 `close` 将是一个编译错误。\n\n使用 `range` 循环可直接在 `channels` 上面迭代。它依次从 `channel` 接收数据，当 `channel` 被关闭并且没有值可接收时\n跳出循环。\n```go\nnaturals := make(chan int)\nfor x := 0; x < 100; x++ {\n    naturals <- x\n}\nfor x := range naturals {\n    fmt.Println(x)\n}\n```\n\n**注意上面的代码会报 `fatal error: all goroutines are asleep - deadlock!`。这个是死锁的错误，因为 `range` 不等到信\n道关闭是不会结束读取的。也就是如果 `channel` 没有数据了，那么 `range` 就会阻塞当前 `goroutine`, 直到信道关闭，所以导\n致了死锁**。\n\n为了避免这种情况，对于有缓存的信道，显式地关闭信道:\n```go\nch := make(chan int, 3)\nch <- 1\nch <- 2\nch <- 3\n\n// 显式地关闭信道\nclose(ch)\n\nfor v := range ch {\n    fmt.Println(v)\n}\n```\n\n### 无缓存 channel\n**无缓存 `channel` 也叫做同步 `channel`**，这是因为**如果一个 `goroutine` 基于一个无缓存 `channel` 发送数据，那么就会\n阻塞，直到另一个 `goroutine` 在相同的 `channel` 上执行接收操作**。同样的，**如果一个 `goroutine` 基于一个无缓存 `channel` \n先执行了接受操作，也会阻塞，直到另一个 `goroutine` 在相同的 `channel` 上执行发送操作**。在 `channel` 成功传输之后，两个 \n`goroutine` 之后的语句才会继续执行。\n\n### 带缓存 channel\n```go\nch = make(chan int, 3)\n```\n带缓存的 `channel` 内部持有一个元素队列。`make` 函数创建 `channel` 时通过第二个参数指定队列的最大容量。\n\n发送操作会向 `channel` 的缓存队列 `push` 元素，接收操作则是 `pop` 元素，如果队列被塞满了，那么发送操作将阻\n塞直到另一个 `goroutine` 执行接收操作而释放了新的队列空间。\n相反，如果 `channel` 是空的，接收操作将阻塞直到有另一个 `goroutine` 执行发送操作而向队列插入元素。\n\n在大多数情况下，缓冲通道会作为收发双方的中间件。正如前文所述，元素值会先从发送方复制到缓冲通道，之后再由缓冲通道复制给接收方。\n\n但是，当发送操作在执行的时候发现空的通道中，正好有等待的接收操作，那么它会直接把元素值复制给接收方。\n\n### 单向 channel\n\n当一个 `channel` 作为一个函数参数时，它一般总是被专门用于**只发送或者只接收**。\n\n类型 `chan<- int` 表示一个只发送 `int` 的 `channel`。相反，类型 `<-chan int` 表示一个只接收 `int` 的 `channel`。\n\n```go\nvar uselessChan = make(chan<- int, 1)\n```\n\n### cap 和 len\n`cap` 函数可以获取 `channel` 内部缓存的容量。\n`len` 函数可以获取 `channel` 内部缓存有效元素的个数。\n\n```go\nch = make(chan int, 3)\nfmt.Println(cap(ch)) // 3\n\nch <- \"A\"\nch <- \"B\"\n\nfmt.Println(len(ch)) // 2\nfmt.Println(<-ch) // A\nfmt.Println(len(ch)) // 1\n```\n\n### 通道的发送和接收操作的特性\n1. 对于同一个通道，发送操作之间是互斥的，接收操作之间也是互斥的。Go 语言的运行时系统（以下简称运行时系统）只会执行对同一个通\n道的任意个发送操作中的某一个。直到这个元素值被完全复制进该通道之后，其他针对该通道的发送操作才可能被执行。\n2. 发送操作和接收操作中对元素值的处理都是不可分割的。发送操作要么还没复制元素值，要么已经复制完毕，绝不会出现只复制了一部分\n的情况。接收操作在准备好元素值的副本之后，一定会删除掉通道中的原值，绝不会出现通道中仍有残留的情况。\n3. 发送操作在完全完成之前会被阻塞。接收操作也是如此。\n\n**元素值从外界进入通道时会被复制。更具体地说，进入通道的并不是在接收操作符右边的那个元素值，而是它的副本**。\n\n**对于通道中的同一个元素值来说，发送操作和接收操作之间也是互斥的。例如，虽然会出现，正在被复制进通道但还未复制完成的元素值，\n但是这时它绝不会被想接收它的一方看到和取走**。\n\n### 发送操作和接收操作在什么时候可能被长时间的阻塞\n- 针对**缓冲通道**的情况。如果通道已满，那么对它的所有发送操作都会被阻塞，直到通道中有元素值被接收走。相对的，如果通道已空，\n那么对它的所有接收操作都会被阻塞，直到通道中有新的元素值出现。这时，通道会通知最早等待的那个接收操作所在的 goroutine，\n并使它再次执行接收操作。\n- 对于**非缓冲通道**，情况要简单一些。无论是发送操作还是接收操作，一开始执行就会被阻塞，直到配对的操作也开始执行，才会继续传递。\n- **对于值为 `nil` 的通道，不论它的具体类型是什么，对它的发送操作和接收操作都会永久地处于阻塞状态**。它们所属的 goroutine \n中的任何代码，都不再会被执行。注意，由于通道类型是引用类型，所以它的零值就是 `nil`。**当我们只声明该类型的变量但没\n有用 `make` 函数对它进行初始化时，该变量的值就会是 `nil`。我们一定不要忘记初始化通道**！\n\n### select 多路复用\n`select` 语句是专为通道而设计的，**所以每个 `case` 表达式中都只能包含操作通道的表达式**，比如接收表达式。\n\n```go\nselect {\n  case communication clause  :\n      ...     \n  case communication clause  :\n      ... \n  default : /* 可选 */\n\t\t\t... \n}\t\t\t\n```\n\n如果有多个 `channel` 需要接受消息，如果第一个 `channel` 没有消息发过来，那么程序会被阻塞，第二个 `channel` 的消息就也\n无法接收了。这时候就需要使用 `select` 多路复用。\n```go\nselect {\n  case <-ch1:\n      ...     \n  case x := <-ch2:\n\t\t\t... \n\tcase ch3 <- y:\n\t    ...\t\t\n  default:\n\t\t\t... \n}\t\n```\n每一个 `case` 代表一个通信操作，发送或者接收。**如果没有 `case` 可运行，它将阻塞，直到有 `case` 可运行**。\n如果多个 `case` 同时满足条件，`select` 会**随机**地选择一个执行。\n\n**为了避免因为发送或者接收导致的阻塞，尤其是当 `channel` 没有准备好写或者读时。`default` 可以设置当其它的操作\n都不能够马上被处理时程序需要执行哪些逻辑**。\n\n### 超时\n我们可以利用 `select` 来设置超时，避免 `goroutine` 阻塞的情况：\n```go\nfunc main() {\n\tc := make(chan int)\n\to := make(chan bool)\n\tgo func() {\n\t\tfor {\n\t\t\tselect {\n\t\t\t\tcase v := <- c:\n\t\t\t\t\tfmt.println(v)\n\t\t\t\tcase <- time.After(5 * time.Second):\n\t\t\t\t\tfmt.println(\"timeout\")\n\t\t\t\t\to <- true\n\t\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}()\n\t<- o\n}\n```\n\n#### 使用 select 语句的时候，需要注意的事情\n1. 如果加入了默认分支，那么无论涉及通道操作的表达式是否有阻塞，`select` 语句都不会被阻塞。如果那几个表达式都阻塞了，或者\n说都没有满足求值的条件，那么默认分支就会被选中并执行。\n2. 如果没有加入默认分支，那么一旦所有的 `case` 表达式都没有满足求值条件，那么 `select` 语句就会被阻塞。\n直到至少有一个 `case` 表达式满足条件为止。\n3. 还记得吗？我们可能会因为通道关闭了，而直接从通道接收到一个其元素类型的零值。所以，在很多时候，我们需要通过接收表达式\n的第二个结果值来判断通道是否已经关闭。一旦发现某个通道关闭了，我们就应该及时地屏蔽掉对应的分支或者采取其他措施。这对\n于程序逻辑和程序性能都是有好处的。\n4. `select` 语句只能对其中的每一个 `case` 表达式各求值一次。所以，如果我们想连续或定时地操作其中的通道的话，就往往需要\n通过在 `for` 语句中嵌入 `select` 语句的方式实现。但这时要注意，**简单地在 `select` 语句的分支中使用 `break` 语句，只能结\n束当前的 `select` 语句的执行，而并不会对外层的 `for` 语句产生作用。这种错误的用法可能会让这个 `for` 语句无休止地运行下去**。\n\n`break` 退出嵌套循环：\n```go\nI:\n\tfor i := 0; i < 2; i++ {\n\t\tfor j := 0; j < 5; j++ {\n\t\t\tif j == 2 {\n\t\t\t\tbreak I\n\t\t\t}\n\t\t\tfmt.Println(\"hello\")\n\t\t}\n\t\tfmt.Println(\"hi\")\n\t}\n```\n\n```go\nintChan := make(chan int, 1)\n// 一秒后关闭通道。\ntime.AfterFunc(time.Second, func() {\n  close(intChan)\n})\nselect {\n  case _, ok := <-intChan:\n    if !ok {\n      fmt.Println(\"The candidate case is closed.\")\n      break\n    }\n    fmt.Println(\"The candidate case is selected.\")\n}\n```\n\n上面的代码 `select` 语句只有一个候选分支，我在其中利用接收表达式的第二个结果值对 `intChan` 通道是否已关闭做了判断，并在\n得到肯定结果后，通过 `break` 语句立即结束当前 `select` 语句的执行。\n","date":"2019-10-19T13:40:15.172Z","updated":"2019-10-19T13:40:15.172Z","path":"concurrent/channel.html","comments":1,"layout":"page","_id":"ck1xm14ky000tfcw2qvjy20uu","content":"<h1 id=\"channel\"><a href=\"#channel\" class=\"headerlink\" title=\"channel\"></a>channel</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Don’t communicate by sharing memory; share memory by communicating.</span><br><span class=\"line\">（不要通过共享内存来通信，而应该通过通信来共享内存。）</span><br></pre></td></tr></table></figure>\n<p>这是作为 Go 语言最重要的编程理念。</p>\n<p>通道类型的值是<strong>并发安全</strong>的，这也是 <strong>Go 语言自带的、唯一一个可以满足并发安全性的类型</strong>。</p>\n<p><code>channels</code> 是 <code>goroutine</code> 之间的通信机制。<code>goroutine</code> 通过 <code>channel</code> 向另一个 <code>goroutine</code> 发送消息<br><code>channel</code> 和 <code>goroutine</code> 结合，可以实现用通信代替共享内存的 <code>CSP</code> 模型。</p>\n<p>创建 <code>channel</code>：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ch := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">ch = <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>, <span class=\"number\">3</span>) <span class=\"comment\">// buffered channel with capacity 3</span></span><br></pre></td></tr></table></figure></p>\n<p>上面的代码中，<code>int</code> 代表这个 <code>channel</code> 要发送的数据的类型。第二个参数代表创建一带缓存的 <code>channel</code>，容量为 <code>3</code>。</p>\n<p><code>channel</code> 的零值是 <code>nil</code>。</p>\n<p>发送和接收两个操作使用 <code>&lt;-</code> 运算符，一个左尖括号紧接着一个减号形象地代表了元素值的传输方向：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 发送一个值</span></span><br><span class=\"line\">ch &lt;- x <span class=\"comment\">// 将数据 push 到 channel</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 接受一个值</span></span><br><span class=\"line\">x = &lt;-ch <span class=\"comment\">// 取出 channel 的值并复制给变量x</span></span><br><span class=\"line\"></span><br><span class=\"line\">&lt;-ch <span class=\"comment\">// 接受的值会被丢弃</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"close\"><a href=\"#close\" class=\"headerlink\" title=\"close\"></a>close</h3><p>使用 <code>close</code> 函数关闭 <code>channel</code>，<code>channel</code> 关闭后不能再发送数据，但是可以接受已经发送成功的数据，<br>如果 <code>channel</code> 中没有数据，那么返回一个零值。</p>\n<p>注意，<strong><code>close</code> 函数不是一个清理操作，而是一个控制操作</strong>，在确定这个 <code>channel</code> 不会继续发送数据时调用。</p>\n<p><strong>因为关闭操作只用于断言不再向 <code>channel</code> 发送新的数据，所以只有在 “发送者” 所在的 <code>goroutine</code> 才会调用 <code>close</code> 函数</strong>，<br>因此对一个只接收的 <code>channel</code> 调用 <code>close</code> 将是一个编译错误。</p>\n<p>使用 <code>range</code> 循环可直接在 <code>channels</code> 上面迭代。它依次从 <code>channel</code> 接收数据，当 <code>channel</code> 被关闭并且没有值可接收时<br>跳出循环。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">naturals := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>)</span><br><span class=\"line\"><span class=\"keyword\">for</span> x := <span class=\"number\">0</span>; x &lt; <span class=\"number\">100</span>; x++ &#123;</span><br><span class=\"line\">    naturals &lt;- x</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">for</span> x := <span class=\"keyword\">range</span> naturals &#123;</span><br><span class=\"line\">    fmt.Println(x)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>注意上面的代码会报 <code>fatal error: all goroutines are asleep - deadlock!</code>。这个是死锁的错误，因为 <code>range</code> 不等到信<br>道关闭是不会结束读取的。也就是如果 <code>channel</code> 没有数据了，那么 <code>range</code> 就会阻塞当前 <code>goroutine</code>, 直到信道关闭，所以导<br>致了死锁</strong>。</p>\n<p>为了避免这种情况，对于有缓存的信道，显式地关闭信道:<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ch := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>, <span class=\"number\">3</span>)</span><br><span class=\"line\">ch &lt;- <span class=\"number\">1</span></span><br><span class=\"line\">ch &lt;- <span class=\"number\">2</span></span><br><span class=\"line\">ch &lt;- <span class=\"number\">3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 显式地关闭信道</span></span><br><span class=\"line\"><span class=\"built_in\">close</span>(ch)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> v := <span class=\"keyword\">range</span> ch &#123;</span><br><span class=\"line\">    fmt.Println(v)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"无缓存-channel\"><a href=\"#无缓存-channel\" class=\"headerlink\" title=\"无缓存 channel\"></a>无缓存 channel</h3><p><strong>无缓存 <code>channel</code> 也叫做同步 <code>channel</code></strong>，这是因为<strong>如果一个 <code>goroutine</code> 基于一个无缓存 <code>channel</code> 发送数据，那么就会<br>阻塞，直到另一个 <code>goroutine</code> 在相同的 <code>channel</code> 上执行接收操作</strong>。同样的，<strong>如果一个 <code>goroutine</code> 基于一个无缓存 <code>channel</code><br>先执行了接受操作，也会阻塞，直到另一个 <code>goroutine</code> 在相同的 <code>channel</code> 上执行发送操作</strong>。在 <code>channel</code> 成功传输之后，两个<br><code>goroutine</code> 之后的语句才会继续执行。</p>\n<h3 id=\"带缓存-channel\"><a href=\"#带缓存-channel\" class=\"headerlink\" title=\"带缓存 channel\"></a>带缓存 channel</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ch = <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>, <span class=\"number\">3</span>)</span><br></pre></td></tr></table></figure>\n<p>带缓存的 <code>channel</code> 内部持有一个元素队列。<code>make</code> 函数创建 <code>channel</code> 时通过第二个参数指定队列的最大容量。</p>\n<p>发送操作会向 <code>channel</code> 的缓存队列 <code>push</code> 元素，接收操作则是 <code>pop</code> 元素，如果队列被塞满了，那么发送操作将阻<br>塞直到另一个 <code>goroutine</code> 执行接收操作而释放了新的队列空间。<br>相反，如果 <code>channel</code> 是空的，接收操作将阻塞直到有另一个 <code>goroutine</code> 执行发送操作而向队列插入元素。</p>\n<p>在大多数情况下，缓冲通道会作为收发双方的中间件。正如前文所述，元素值会先从发送方复制到缓冲通道，之后再由缓冲通道复制给接收方。</p>\n<p>但是，当发送操作在执行的时候发现空的通道中，正好有等待的接收操作，那么它会直接把元素值复制给接收方。</p>\n<h3 id=\"单向-channel\"><a href=\"#单向-channel\" class=\"headerlink\" title=\"单向 channel\"></a>单向 channel</h3><p>当一个 <code>channel</code> 作为一个函数参数时，它一般总是被专门用于<strong>只发送或者只接收</strong>。</p>\n<p>类型 <code>chan&lt;- int</code> 表示一个只发送 <code>int</code> 的 <code>channel</code>。相反，类型 <code>&lt;-chan int</code> 表示一个只接收 <code>int</code> 的 <code>channel</code>。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> uselessChan = <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span>&lt;- <span class=\"keyword\">int</span>, <span class=\"number\">1</span>)</span><br></pre></td></tr></table></figure>\n<h3 id=\"cap-和-len\"><a href=\"#cap-和-len\" class=\"headerlink\" title=\"cap 和 len\"></a>cap 和 len</h3><p><code>cap</code> 函数可以获取 <code>channel</code> 内部缓存的容量。<br><code>len</code> 函数可以获取 <code>channel</code> 内部缓存有效元素的个数。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ch = <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>, <span class=\"number\">3</span>)</span><br><span class=\"line\">fmt.Println(<span class=\"built_in\">cap</span>(ch)) <span class=\"comment\">// 3</span></span><br><span class=\"line\"></span><br><span class=\"line\">ch &lt;- <span class=\"string\">\"A\"</span></span><br><span class=\"line\">ch &lt;- <span class=\"string\">\"B\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">fmt.Println(<span class=\"built_in\">len</span>(ch)) <span class=\"comment\">// 2</span></span><br><span class=\"line\">fmt.Println(&lt;-ch) <span class=\"comment\">// A</span></span><br><span class=\"line\">fmt.Println(<span class=\"built_in\">len</span>(ch)) <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"通道的发送和接收操作的特性\"><a href=\"#通道的发送和接收操作的特性\" class=\"headerlink\" title=\"通道的发送和接收操作的特性\"></a>通道的发送和接收操作的特性</h3><ol>\n<li>对于同一个通道，发送操作之间是互斥的，接收操作之间也是互斥的。Go 语言的运行时系统（以下简称运行时系统）只会执行对同一个通<br>道的任意个发送操作中的某一个。直到这个元素值被完全复制进该通道之后，其他针对该通道的发送操作才可能被执行。</li>\n<li>发送操作和接收操作中对元素值的处理都是不可分割的。发送操作要么还没复制元素值，要么已经复制完毕，绝不会出现只复制了一部分<br>的情况。接收操作在准备好元素值的副本之后，一定会删除掉通道中的原值，绝不会出现通道中仍有残留的情况。</li>\n<li>发送操作在完全完成之前会被阻塞。接收操作也是如此。</li>\n</ol>\n<p><strong>元素值从外界进入通道时会被复制。更具体地说，进入通道的并不是在接收操作符右边的那个元素值，而是它的副本</strong>。</p>\n<p><strong>对于通道中的同一个元素值来说，发送操作和接收操作之间也是互斥的。例如，虽然会出现，正在被复制进通道但还未复制完成的元素值，<br>但是这时它绝不会被想接收它的一方看到和取走</strong>。</p>\n<h3 id=\"发送操作和接收操作在什么时候可能被长时间的阻塞\"><a href=\"#发送操作和接收操作在什么时候可能被长时间的阻塞\" class=\"headerlink\" title=\"发送操作和接收操作在什么时候可能被长时间的阻塞\"></a>发送操作和接收操作在什么时候可能被长时间的阻塞</h3><ul>\n<li>针对<strong>缓冲通道</strong>的情况。如果通道已满，那么对它的所有发送操作都会被阻塞，直到通道中有元素值被接收走。相对的，如果通道已空，<br>那么对它的所有接收操作都会被阻塞，直到通道中有新的元素值出现。这时，通道会通知最早等待的那个接收操作所在的 goroutine，<br>并使它再次执行接收操作。</li>\n<li>对于<strong>非缓冲通道</strong>，情况要简单一些。无论是发送操作还是接收操作，一开始执行就会被阻塞，直到配对的操作也开始执行，才会继续传递。</li>\n<li><strong>对于值为 <code>nil</code> 的通道，不论它的具体类型是什么，对它的发送操作和接收操作都会永久地处于阻塞状态</strong>。它们所属的 goroutine<br>中的任何代码，都不再会被执行。注意，由于通道类型是引用类型，所以它的零值就是 <code>nil</code>。<strong>当我们只声明该类型的变量但没<br>有用 <code>make</code> 函数对它进行初始化时，该变量的值就会是 <code>nil</code>。我们一定不要忘记初始化通道</strong>！</li>\n</ul>\n<h3 id=\"select-多路复用\"><a href=\"#select-多路复用\" class=\"headerlink\" title=\"select 多路复用\"></a>select 多路复用</h3><p><code>select</code> 语句是专为通道而设计的，<strong>所以每个 <code>case</code> 表达式中都只能包含操作通道的表达式</strong>，比如接收表达式。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> communication clause  :</span><br><span class=\"line\">      ...     </span><br><span class=\"line\">  <span class=\"keyword\">case</span> communication clause  :</span><br><span class=\"line\">      ... </span><br><span class=\"line\">  <span class=\"keyword\">default</span> : <span class=\"comment\">/* 可选 */</span></span><br><span class=\"line\">\t\t\t... </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果有多个 <code>channel</code> 需要接受消息，如果第一个 <code>channel</code> 没有消息发过来，那么程序会被阻塞，第二个 <code>channel</code> 的消息就也<br>无法接收了。这时候就需要使用 <code>select</code> 多路复用。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> &lt;-ch1:</span><br><span class=\"line\">      ...     </span><br><span class=\"line\">  <span class=\"keyword\">case</span> x := &lt;-ch2:</span><br><span class=\"line\">\t\t\t... </span><br><span class=\"line\">\t<span class=\"keyword\">case</span> ch3 &lt;- y:</span><br><span class=\"line\">\t    ...\t\t</span><br><span class=\"line\">  <span class=\"keyword\">default</span>:</span><br><span class=\"line\">\t\t\t... </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>每一个 <code>case</code> 代表一个通信操作，发送或者接收。<strong>如果没有 <code>case</code> 可运行，它将阻塞，直到有 <code>case</code> 可运行</strong>。<br>如果多个 <code>case</code> 同时满足条件，<code>select</code> 会<strong>随机</strong>地选择一个执行。</p>\n<p><strong>为了避免因为发送或者接收导致的阻塞，尤其是当 <code>channel</code> 没有准备好写或者读时。<code>default</code> 可以设置当其它的操作<br>都不能够马上被处理时程序需要执行哪些逻辑</strong>。</p>\n<h3 id=\"超时\"><a href=\"#超时\" class=\"headerlink\" title=\"超时\"></a>超时</h3><p>我们可以利用 <code>select</code> 来设置超时，避免 <code>goroutine</code> 阻塞的情况：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tc := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>)</span><br><span class=\"line\">\to := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">bool</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">select</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">case</span> v := &lt;- c:</span><br><span class=\"line\">\t\t\t\t\tfmt.<span class=\"built_in\">println</span>(v)</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">case</span> &lt;- time.After(<span class=\"number\">5</span> * time.Second):</span><br><span class=\"line\">\t\t\t\t\tfmt.<span class=\"built_in\">println</span>(<span class=\"string\">\"timeout\"</span>)</span><br><span class=\"line\">\t\t\t\t\to &lt;- <span class=\"literal\">true</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\">\t&lt;- o</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"使用-select-语句的时候，需要注意的事情\"><a href=\"#使用-select-语句的时候，需要注意的事情\" class=\"headerlink\" title=\"使用 select 语句的时候，需要注意的事情\"></a>使用 select 语句的时候，需要注意的事情</h4><ol>\n<li>如果加入了默认分支，那么无论涉及通道操作的表达式是否有阻塞，<code>select</code> 语句都不会被阻塞。如果那几个表达式都阻塞了，或者<br>说都没有满足求值的条件，那么默认分支就会被选中并执行。</li>\n<li>如果没有加入默认分支，那么一旦所有的 <code>case</code> 表达式都没有满足求值条件，那么 <code>select</code> 语句就会被阻塞。<br>直到至少有一个 <code>case</code> 表达式满足条件为止。</li>\n<li>还记得吗？我们可能会因为通道关闭了，而直接从通道接收到一个其元素类型的零值。所以，在很多时候，我们需要通过接收表达式<br>的第二个结果值来判断通道是否已经关闭。一旦发现某个通道关闭了，我们就应该及时地屏蔽掉对应的分支或者采取其他措施。这对<br>于程序逻辑和程序性能都是有好处的。</li>\n<li><code>select</code> 语句只能对其中的每一个 <code>case</code> 表达式各求值一次。所以，如果我们想连续或定时地操作其中的通道的话，就往往需要<br>通过在 <code>for</code> 语句中嵌入 <code>select</code> 语句的方式实现。但这时要注意，<strong>简单地在 <code>select</code> 语句的分支中使用 <code>break</code> 语句，只能结<br>束当前的 <code>select</code> 语句的执行，而并不会对外层的 <code>for</code> 语句产生作用。这种错误的用法可能会让这个 <code>for</code> 语句无休止地运行下去</strong>。</li>\n</ol>\n<p><code>break</code> 退出嵌套循环：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">I:</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">2</span>; i++ &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> j := <span class=\"number\">0</span>; j &lt; <span class=\"number\">5</span>; j++ &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> j == <span class=\"number\">2</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span> I</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tfmt.Println(<span class=\"string\">\"hello\"</span>)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tfmt.Println(<span class=\"string\">\"hi\"</span>)</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">intChan := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>, <span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"comment\">// 一秒后关闭通道。</span></span><br><span class=\"line\">time.AfterFunc(time.Second, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">close</span>(intChan)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">select</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> _, ok := &lt;-intChan:</span><br><span class=\"line\">    <span class=\"keyword\">if</span> !ok &#123;</span><br><span class=\"line\">      fmt.Println(<span class=\"string\">\"The candidate case is closed.\"</span>)</span><br><span class=\"line\">      <span class=\"keyword\">break</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    fmt.Println(<span class=\"string\">\"The candidate case is selected.\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的代码 <code>select</code> 语句只有一个候选分支，我在其中利用接收表达式的第二个结果值对 <code>intChan</code> 通道是否已关闭做了判断，并在<br>得到肯定结果后，通过 <code>break</code> 语句立即结束当前 <code>select</code> 语句的执行。</p>\n","site":{"data":{"navigation":{"logo":{"text":"Golang Learn","type":"link","path":"index.html"},"main":[{"text":"Golang 基础","type":"label"},{"text":"Go 环境配置","type":"link","path":"basic/env_config.html"},{"text":"包","type":"link","path":"basic/package.html"},{"text":"基础数据类型","type":"link","path":"basic/basic_data.html"},{"text":"变量","type":"link","path":"basic/var.html"},{"text":"常量","type":"link","path":"basic/constant.html"},{"text":"控制语句","type":"link","path":"basic/flow.html"},{"text":"运算符","type":"link","path":"basic/operator.html"},{"text":"作用域","type":"link","path":"basic/scope.html"},{"text":"指针","type":"link","path":"basic/pointer.html"},{"text":"数组","type":"link","path":"basic/array.html"},{"text":"切片","type":"link","path":"basic/slice.html"},{"text":"字典","type":"link","path":"basic/map.html"},{"text":"函数","type":"link","path":"basic/function.html"},{"text":"结构体","type":"link","path":"basic/struct.html"},{"text":"接口","type":"link","path":"basic/interface.html"},{"text":"面向对象","type":"link","path":"basic/oop.html"},{"text":"错误","type":"link","path":"basic/error.html"},{"text":"序列化","type":"link","path":"basic/json.html"},{"text":"反射","type":"link","path":"basic/reflect.html"},{"text":"测试","type":"link","path":"basic/test.html"},{"text":"并发编程","type":"label"},{"text":"goroutine","type":"link","path":"concurrent/goroutine.html"},{"text":"channel","type":"link","path":"concurrent/channel.html"},{"text":"同步和锁","type":"link","path":"concurrent/sync_lock.html"},{"text":"内存分配","type":"label"},{"text":"内存分配","type":"link","path":"advance/mm.html"},{"text":"垃圾回收","type":"label"},{"text":"垃圾回收","type":"link","path":"advance/gc.html"},{"text":"标准库","type":"label"},{"text":"fmt","type":"link","path":"standards/io/fmt.html"},{"text":"io","type":"link","path":"standards/io/io.html"},{"text":"ioutil","type":"link","path":"standards/io/ioutil.html"},{"text":"bufio","type":"link","path":"standards/io/bufio.html"},{"text":"os","type":"link","path":"standards/os/os.html"},{"text":"filepath","type":"link","path":"standards/os/filepath.html"},{"text":"strings","type":"link","path":"standards/text/strings.html"},{"text":"strconv","type":"link","path":"standards/text/strconv.html"},{"text":"unicode","type":"link","path":"standards/text/unicode.html"},{"text":"log","type":"link","path":"standards/log.html"},{"text":"time","type":"link","path":"standards/time.html"},{"text":"http","type":"link","path":"standards/net/http.html"},{"text":"math","type":"link","path":"standards/data/math.html"},{"text":"sort","type":"link","path":"standards/data/sort.html"},{"text":"big","type":"link","path":"standards/data/big.html"},{"text":"container","type":"link","path":"standards/data/container.html"},{"text":"sql","type":"link","path":"standards/database/sql.html"},{"text":"THEME","type":"label"},{"text":"使用文档主题","type":"link","path":"theme/theme-usage.html"},{"text":"SUPPORT AND FEEDBACK","type":"label"},{"text":"Raise an Issue on Github","type":"link","path":"https://github.com/shipengqi/golang-learn/issues/new"}]}}},"excerpt":"","more":"<h1 id=\"channel\"><a href=\"#channel\" class=\"headerlink\" title=\"channel\"></a>channel</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Don’t communicate by sharing memory; share memory by communicating.</span><br><span class=\"line\">（不要通过共享内存来通信，而应该通过通信来共享内存。）</span><br></pre></td></tr></table></figure>\n<p>这是作为 Go 语言最重要的编程理念。</p>\n<p>通道类型的值是<strong>并发安全</strong>的，这也是 <strong>Go 语言自带的、唯一一个可以满足并发安全性的类型</strong>。</p>\n<p><code>channels</code> 是 <code>goroutine</code> 之间的通信机制。<code>goroutine</code> 通过 <code>channel</code> 向另一个 <code>goroutine</code> 发送消息<br><code>channel</code> 和 <code>goroutine</code> 结合，可以实现用通信代替共享内存的 <code>CSP</code> 模型。</p>\n<p>创建 <code>channel</code>：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ch := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">ch = <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>, <span class=\"number\">3</span>) <span class=\"comment\">// buffered channel with capacity 3</span></span><br></pre></td></tr></table></figure></p>\n<p>上面的代码中，<code>int</code> 代表这个 <code>channel</code> 要发送的数据的类型。第二个参数代表创建一带缓存的 <code>channel</code>，容量为 <code>3</code>。</p>\n<p><code>channel</code> 的零值是 <code>nil</code>。</p>\n<p>发送和接收两个操作使用 <code>&lt;-</code> 运算符，一个左尖括号紧接着一个减号形象地代表了元素值的传输方向：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 发送一个值</span></span><br><span class=\"line\">ch &lt;- x <span class=\"comment\">// 将数据 push 到 channel</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 接受一个值</span></span><br><span class=\"line\">x = &lt;-ch <span class=\"comment\">// 取出 channel 的值并复制给变量x</span></span><br><span class=\"line\"></span><br><span class=\"line\">&lt;-ch <span class=\"comment\">// 接受的值会被丢弃</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"close\"><a href=\"#close\" class=\"headerlink\" title=\"close\"></a>close</h3><p>使用 <code>close</code> 函数关闭 <code>channel</code>，<code>channel</code> 关闭后不能再发送数据，但是可以接受已经发送成功的数据，<br>如果 <code>channel</code> 中没有数据，那么返回一个零值。</p>\n<p>注意，<strong><code>close</code> 函数不是一个清理操作，而是一个控制操作</strong>，在确定这个 <code>channel</code> 不会继续发送数据时调用。</p>\n<p><strong>因为关闭操作只用于断言不再向 <code>channel</code> 发送新的数据，所以只有在 “发送者” 所在的 <code>goroutine</code> 才会调用 <code>close</code> 函数</strong>，<br>因此对一个只接收的 <code>channel</code> 调用 <code>close</code> 将是一个编译错误。</p>\n<p>使用 <code>range</code> 循环可直接在 <code>channels</code> 上面迭代。它依次从 <code>channel</code> 接收数据，当 <code>channel</code> 被关闭并且没有值可接收时<br>跳出循环。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">naturals := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>)</span><br><span class=\"line\"><span class=\"keyword\">for</span> x := <span class=\"number\">0</span>; x &lt; <span class=\"number\">100</span>; x++ &#123;</span><br><span class=\"line\">    naturals &lt;- x</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">for</span> x := <span class=\"keyword\">range</span> naturals &#123;</span><br><span class=\"line\">    fmt.Println(x)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>注意上面的代码会报 <code>fatal error: all goroutines are asleep - deadlock!</code>。这个是死锁的错误，因为 <code>range</code> 不等到信<br>道关闭是不会结束读取的。也就是如果 <code>channel</code> 没有数据了，那么 <code>range</code> 就会阻塞当前 <code>goroutine</code>, 直到信道关闭，所以导<br>致了死锁</strong>。</p>\n<p>为了避免这种情况，对于有缓存的信道，显式地关闭信道:<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ch := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>, <span class=\"number\">3</span>)</span><br><span class=\"line\">ch &lt;- <span class=\"number\">1</span></span><br><span class=\"line\">ch &lt;- <span class=\"number\">2</span></span><br><span class=\"line\">ch &lt;- <span class=\"number\">3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 显式地关闭信道</span></span><br><span class=\"line\"><span class=\"built_in\">close</span>(ch)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> v := <span class=\"keyword\">range</span> ch &#123;</span><br><span class=\"line\">    fmt.Println(v)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"无缓存-channel\"><a href=\"#无缓存-channel\" class=\"headerlink\" title=\"无缓存 channel\"></a>无缓存 channel</h3><p><strong>无缓存 <code>channel</code> 也叫做同步 <code>channel</code></strong>，这是因为<strong>如果一个 <code>goroutine</code> 基于一个无缓存 <code>channel</code> 发送数据，那么就会<br>阻塞，直到另一个 <code>goroutine</code> 在相同的 <code>channel</code> 上执行接收操作</strong>。同样的，<strong>如果一个 <code>goroutine</code> 基于一个无缓存 <code>channel</code><br>先执行了接受操作，也会阻塞，直到另一个 <code>goroutine</code> 在相同的 <code>channel</code> 上执行发送操作</strong>。在 <code>channel</code> 成功传输之后，两个<br><code>goroutine</code> 之后的语句才会继续执行。</p>\n<h3 id=\"带缓存-channel\"><a href=\"#带缓存-channel\" class=\"headerlink\" title=\"带缓存 channel\"></a>带缓存 channel</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ch = <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>, <span class=\"number\">3</span>)</span><br></pre></td></tr></table></figure>\n<p>带缓存的 <code>channel</code> 内部持有一个元素队列。<code>make</code> 函数创建 <code>channel</code> 时通过第二个参数指定队列的最大容量。</p>\n<p>发送操作会向 <code>channel</code> 的缓存队列 <code>push</code> 元素，接收操作则是 <code>pop</code> 元素，如果队列被塞满了，那么发送操作将阻<br>塞直到另一个 <code>goroutine</code> 执行接收操作而释放了新的队列空间。<br>相反，如果 <code>channel</code> 是空的，接收操作将阻塞直到有另一个 <code>goroutine</code> 执行发送操作而向队列插入元素。</p>\n<p>在大多数情况下，缓冲通道会作为收发双方的中间件。正如前文所述，元素值会先从发送方复制到缓冲通道，之后再由缓冲通道复制给接收方。</p>\n<p>但是，当发送操作在执行的时候发现空的通道中，正好有等待的接收操作，那么它会直接把元素值复制给接收方。</p>\n<h3 id=\"单向-channel\"><a href=\"#单向-channel\" class=\"headerlink\" title=\"单向 channel\"></a>单向 channel</h3><p>当一个 <code>channel</code> 作为一个函数参数时，它一般总是被专门用于<strong>只发送或者只接收</strong>。</p>\n<p>类型 <code>chan&lt;- int</code> 表示一个只发送 <code>int</code> 的 <code>channel</code>。相反，类型 <code>&lt;-chan int</code> 表示一个只接收 <code>int</code> 的 <code>channel</code>。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> uselessChan = <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span>&lt;- <span class=\"keyword\">int</span>, <span class=\"number\">1</span>)</span><br></pre></td></tr></table></figure>\n<h3 id=\"cap-和-len\"><a href=\"#cap-和-len\" class=\"headerlink\" title=\"cap 和 len\"></a>cap 和 len</h3><p><code>cap</code> 函数可以获取 <code>channel</code> 内部缓存的容量。<br><code>len</code> 函数可以获取 <code>channel</code> 内部缓存有效元素的个数。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ch = <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>, <span class=\"number\">3</span>)</span><br><span class=\"line\">fmt.Println(<span class=\"built_in\">cap</span>(ch)) <span class=\"comment\">// 3</span></span><br><span class=\"line\"></span><br><span class=\"line\">ch &lt;- <span class=\"string\">\"A\"</span></span><br><span class=\"line\">ch &lt;- <span class=\"string\">\"B\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">fmt.Println(<span class=\"built_in\">len</span>(ch)) <span class=\"comment\">// 2</span></span><br><span class=\"line\">fmt.Println(&lt;-ch) <span class=\"comment\">// A</span></span><br><span class=\"line\">fmt.Println(<span class=\"built_in\">len</span>(ch)) <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"通道的发送和接收操作的特性\"><a href=\"#通道的发送和接收操作的特性\" class=\"headerlink\" title=\"通道的发送和接收操作的特性\"></a>通道的发送和接收操作的特性</h3><ol>\n<li>对于同一个通道，发送操作之间是互斥的，接收操作之间也是互斥的。Go 语言的运行时系统（以下简称运行时系统）只会执行对同一个通<br>道的任意个发送操作中的某一个。直到这个元素值被完全复制进该通道之后，其他针对该通道的发送操作才可能被执行。</li>\n<li>发送操作和接收操作中对元素值的处理都是不可分割的。发送操作要么还没复制元素值，要么已经复制完毕，绝不会出现只复制了一部分<br>的情况。接收操作在准备好元素值的副本之后，一定会删除掉通道中的原值，绝不会出现通道中仍有残留的情况。</li>\n<li>发送操作在完全完成之前会被阻塞。接收操作也是如此。</li>\n</ol>\n<p><strong>元素值从外界进入通道时会被复制。更具体地说，进入通道的并不是在接收操作符右边的那个元素值，而是它的副本</strong>。</p>\n<p><strong>对于通道中的同一个元素值来说，发送操作和接收操作之间也是互斥的。例如，虽然会出现，正在被复制进通道但还未复制完成的元素值，<br>但是这时它绝不会被想接收它的一方看到和取走</strong>。</p>\n<h3 id=\"发送操作和接收操作在什么时候可能被长时间的阻塞\"><a href=\"#发送操作和接收操作在什么时候可能被长时间的阻塞\" class=\"headerlink\" title=\"发送操作和接收操作在什么时候可能被长时间的阻塞\"></a>发送操作和接收操作在什么时候可能被长时间的阻塞</h3><ul>\n<li>针对<strong>缓冲通道</strong>的情况。如果通道已满，那么对它的所有发送操作都会被阻塞，直到通道中有元素值被接收走。相对的，如果通道已空，<br>那么对它的所有接收操作都会被阻塞，直到通道中有新的元素值出现。这时，通道会通知最早等待的那个接收操作所在的 goroutine，<br>并使它再次执行接收操作。</li>\n<li>对于<strong>非缓冲通道</strong>，情况要简单一些。无论是发送操作还是接收操作，一开始执行就会被阻塞，直到配对的操作也开始执行，才会继续传递。</li>\n<li><strong>对于值为 <code>nil</code> 的通道，不论它的具体类型是什么，对它的发送操作和接收操作都会永久地处于阻塞状态</strong>。它们所属的 goroutine<br>中的任何代码，都不再会被执行。注意，由于通道类型是引用类型，所以它的零值就是 <code>nil</code>。<strong>当我们只声明该类型的变量但没<br>有用 <code>make</code> 函数对它进行初始化时，该变量的值就会是 <code>nil</code>。我们一定不要忘记初始化通道</strong>！</li>\n</ul>\n<h3 id=\"select-多路复用\"><a href=\"#select-多路复用\" class=\"headerlink\" title=\"select 多路复用\"></a>select 多路复用</h3><p><code>select</code> 语句是专为通道而设计的，<strong>所以每个 <code>case</code> 表达式中都只能包含操作通道的表达式</strong>，比如接收表达式。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> communication clause  :</span><br><span class=\"line\">      ...     </span><br><span class=\"line\">  <span class=\"keyword\">case</span> communication clause  :</span><br><span class=\"line\">      ... </span><br><span class=\"line\">  <span class=\"keyword\">default</span> : <span class=\"comment\">/* 可选 */</span></span><br><span class=\"line\">\t\t\t... </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果有多个 <code>channel</code> 需要接受消息，如果第一个 <code>channel</code> 没有消息发过来，那么程序会被阻塞，第二个 <code>channel</code> 的消息就也<br>无法接收了。这时候就需要使用 <code>select</code> 多路复用。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> &lt;-ch1:</span><br><span class=\"line\">      ...     </span><br><span class=\"line\">  <span class=\"keyword\">case</span> x := &lt;-ch2:</span><br><span class=\"line\">\t\t\t... </span><br><span class=\"line\">\t<span class=\"keyword\">case</span> ch3 &lt;- y:</span><br><span class=\"line\">\t    ...\t\t</span><br><span class=\"line\">  <span class=\"keyword\">default</span>:</span><br><span class=\"line\">\t\t\t... </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>每一个 <code>case</code> 代表一个通信操作，发送或者接收。<strong>如果没有 <code>case</code> 可运行，它将阻塞，直到有 <code>case</code> 可运行</strong>。<br>如果多个 <code>case</code> 同时满足条件，<code>select</code> 会<strong>随机</strong>地选择一个执行。</p>\n<p><strong>为了避免因为发送或者接收导致的阻塞，尤其是当 <code>channel</code> 没有准备好写或者读时。<code>default</code> 可以设置当其它的操作<br>都不能够马上被处理时程序需要执行哪些逻辑</strong>。</p>\n<h3 id=\"超时\"><a href=\"#超时\" class=\"headerlink\" title=\"超时\"></a>超时</h3><p>我们可以利用 <code>select</code> 来设置超时，避免 <code>goroutine</code> 阻塞的情况：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tc := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>)</span><br><span class=\"line\">\to := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">bool</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">select</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">case</span> v := &lt;- c:</span><br><span class=\"line\">\t\t\t\t\tfmt.<span class=\"built_in\">println</span>(v)</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">case</span> &lt;- time.After(<span class=\"number\">5</span> * time.Second):</span><br><span class=\"line\">\t\t\t\t\tfmt.<span class=\"built_in\">println</span>(<span class=\"string\">\"timeout\"</span>)</span><br><span class=\"line\">\t\t\t\t\to &lt;- <span class=\"literal\">true</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\">\t&lt;- o</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"使用-select-语句的时候，需要注意的事情\"><a href=\"#使用-select-语句的时候，需要注意的事情\" class=\"headerlink\" title=\"使用 select 语句的时候，需要注意的事情\"></a>使用 select 语句的时候，需要注意的事情</h4><ol>\n<li>如果加入了默认分支，那么无论涉及通道操作的表达式是否有阻塞，<code>select</code> 语句都不会被阻塞。如果那几个表达式都阻塞了，或者<br>说都没有满足求值的条件，那么默认分支就会被选中并执行。</li>\n<li>如果没有加入默认分支，那么一旦所有的 <code>case</code> 表达式都没有满足求值条件，那么 <code>select</code> 语句就会被阻塞。<br>直到至少有一个 <code>case</code> 表达式满足条件为止。</li>\n<li>还记得吗？我们可能会因为通道关闭了，而直接从通道接收到一个其元素类型的零值。所以，在很多时候，我们需要通过接收表达式<br>的第二个结果值来判断通道是否已经关闭。一旦发现某个通道关闭了，我们就应该及时地屏蔽掉对应的分支或者采取其他措施。这对<br>于程序逻辑和程序性能都是有好处的。</li>\n<li><code>select</code> 语句只能对其中的每一个 <code>case</code> 表达式各求值一次。所以，如果我们想连续或定时地操作其中的通道的话，就往往需要<br>通过在 <code>for</code> 语句中嵌入 <code>select</code> 语句的方式实现。但这时要注意，<strong>简单地在 <code>select</code> 语句的分支中使用 <code>break</code> 语句，只能结<br>束当前的 <code>select</code> 语句的执行，而并不会对外层的 <code>for</code> 语句产生作用。这种错误的用法可能会让这个 <code>for</code> 语句无休止地运行下去</strong>。</li>\n</ol>\n<p><code>break</code> 退出嵌套循环：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">I:</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">2</span>; i++ &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> j := <span class=\"number\">0</span>; j &lt; <span class=\"number\">5</span>; j++ &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> j == <span class=\"number\">2</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span> I</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tfmt.Println(<span class=\"string\">\"hello\"</span>)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tfmt.Println(<span class=\"string\">\"hi\"</span>)</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">intChan := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>, <span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"comment\">// 一秒后关闭通道。</span></span><br><span class=\"line\">time.AfterFunc(time.Second, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">close</span>(intChan)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">select</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> _, ok := &lt;-intChan:</span><br><span class=\"line\">    <span class=\"keyword\">if</span> !ok &#123;</span><br><span class=\"line\">      fmt.Println(<span class=\"string\">\"The candidate case is closed.\"</span>)</span><br><span class=\"line\">      <span class=\"keyword\">break</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    fmt.Println(<span class=\"string\">\"The candidate case is selected.\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的代码 <code>select</code> 语句只有一个候选分支，我在其中利用接收表达式的第二个结果值对 <code>intChan</code> 通道是否已关闭做了判断，并在<br>得到肯定结果后，通过 <code>break</code> 语句立即结束当前 <code>select</code> 语句的执行。</p>\n"},{"title":"函数","_content":"\n# 函数\n\n## 声明函数\n`func` 关键字声明函数：\n```go\nfunc 函数名(形式参数列表) (返回值列表) {\n    函数体\n}\n```\n如果函数返回一个无名变量或者没有返回值，返回值列表的括号可以省略。如果一个函数声明没有返回值列表，那么这个\n函数不会返回任何值。\n\n```go\n// 两个 int 类型参数 返回一个 int 类型的值\nfunc max(num1, num2 int) int {\n   /* 定义局部变量 */\n   var result int\n\n   if (num1 > num2) {\n      result = num1\n   } else {\n      result = num2\n   }\n   return result \n}\n\n// 返回多个类型的值\nfunc swap(x int, y string) (string, int) {\n   return y, x\n}\n\n// 有名返回值\nfunc Size(rect image.Rectangle) (width, height int, err error)\n```\n\n在函数体中，函数的形参作为局部变量，被初始化为调用者提供的值（函数调用必须按照声明顺序为所有参数提供实参）。函数的形参和有\n名返回值（也就是对返回值命名）作为函数最外层的局部变量，被存储在相同的词法块中。\n\n## 参数\nGo 语言使用的是**值传递**，当我们传一个参数值到被调用函数里面时，实际上是传了这个值的一份 copy，（不管是指针，引用类型还是其他类型，\n区别无非是拷贝目标对象还是拷贝指针）当在被调用函数中修改参数值的时候，调用函数中相应实参不会发生任何变化，因为数值变化只作用在 copy 上。\n但是如果是引用传递，在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。\n\n注意，如果实参是 `slice`、`map`、`function`、`channel` 等类型（**引用类型**），实参可能会由于函数的间接引用被修改。\n\n没有函数体的函数声明，这表示该函数不是以 Go 实现的。这样的声明定义了函数标识符。\n\n**表面上看，指针参数性能会更好，但是要注意被复制的指针会延长目标对象的生命周期，还可能导致它被分配到堆上，其性能消耗要加上堆内存分配和\n垃圾回收的成本**。\n\n在栈上复制小对象，要比堆上分配内存要快的多。\n## 可变参数\n**变参本质上就是一个切片，只能接受一到多个同类型参数，而且必须在参数列表的最后一个**。比如 `fmt.Printf`，`Printf` 接收一个的必备参数，之\n后接收任意个数的后续参数。\n\n在参数列表的最后一个参数类型之前加上省略符号 `...`，表示该函数会接收任意数量的该类型参数。\n```go\nfunc sum(vals ...int) int {\n\ttotal := 0\n\tfor _, val := range vals {\n\t\t\ttotal += val\n\t}\n\treturn total\n}\n\n// 调用\nfmt.Println(sum())           // \"0\"\nfmt.Println(sum(3))          // \"3\"\nfmt.Println(sum(1, 2, 3, 4)) // \"10\"\n\n// 还可以使用类似 ES6 的解构赋值的语法\nvalues := []int{1, 2, 3, 4}\nfmt.Println(sum(values...)) // \"10\"\n```\n\n## 函数作为值\nGo 函数被看作第一类值：函数像其他值一样，拥有类型，可以被赋值给其他变量，传递给函数，从函数返回。\n\n```go\nfunc main(){\n\t/* 声明函数变量 */\n\tgetSquareRoot := func(x float64) float64 {\n\t\treturn math.Sqrt(x)\n\t}\n\n\t/* 使用函数 */\n\tfmt.Println(getSquareRoot(9)) // 3\n}\n```\n\n## 函数作为参数\n声明一个名叫 `operate` 的函数类型，它有两个参数和一个结果，都是 `int` 类型的。\n```go\ntype operate func(x, y int) int\n```\n\n编写 `calculate` 函数的签名部分。这个函数除了需要两个 `int` 类型的参数之外，还应该有一个 `operate` 类型的参数。\n```go\nfunc calculate(x int, y int, op operate) (int, error) {\n    if op == nil {\n        return 0, errors.New(\"invalid operation\")\n    }\n    return op(x, y), nil\n}\n```\n\n## 闭包\nGo 语言支持匿名函数，可作为闭包。\n```go\n// 返回一个函数\nfunc getSequence() func() int { // func() 是没有参数也没有返回值的函数类型\n\t i:=0\n\t // 闭包\n   return func() int {\n      i+=1\n     return i  \n   }\n}\n```\n\n## 错误\nGo 中，对于大部分函数而言，永远无法确保能否成功运行（有一部分函数总是能成功的运行。比如 `strings.Contains` 和 \n`strconv.FormatBool`）。通常 Go 函数的最后一个返回值用来传递错误信息。如果导致失败的原因只有一个，返回值可以是一个布尔值，\n通常被命名为 `ok`。否则应该返回一个 `error` 类型。\n\n\n## 关键字 defer\n在普通函数或方法前加关键字 `defer`，会使函数或方法延迟执行，直到包含该 `defer` 语句的函数执行完毕时（**无论函数是否出错**），\n`defer` 后的函数才会被执行。\n\n`defer` 语句一般被用于处理成对的操作，如打开、关闭、连接、断开连接、加锁、释放锁。因为 `defer` 可以保证让你更任何情况下，\n资源都会被释放。\n```go\npackage ioutil\nfunc ReadFile(filename string) ([]byte, error) {\n\tf, err := os.Open(filename)\n\tif err != nil {\n\t\t\treturn nil, err\n\t}\n\tdefer f.Close()\n\treturn ReadAll(f)\n}\n\n// 互斥锁\nvar mu sync.Mutex\nvar m = make(map[string]int)\nfunc lookup(key string) int {\n\tmu.Lock()\n\tdefer mu.Unlock()\n\treturn m[key]\n}\n\n// 记录何时进入和退出函数\nfunc bigSlowOperation() {\n\tdefer trace(\"bigSlowOperation\")() // 运行 trace 函数，记录了进入函数的时间，并返回一个函数值，这个函数值会延迟执行\n\textra parentheses\n\t// ...lots of work…\n\ttime.Sleep(10 * time.Second) // simulate slow\n\toperation by sleeping\n}\nfunc trace(msg string) func() {\n\tstart := time.Now()\n\tlog.Printf(\"enter %s\", msg)\n\treturn func() { \n\t\tlog.Printf(\"exit %s (%s)\", msg,time.Since(start)) \n\t}\n}\n\n// 观察函数的返回值\nfunc double(x int) (result int) { // 有名返回值\n  // 由于 defer 在 return 之后执行，所以这里的 result 就是函数最终的返回值\n\tdefer func() { fmt.Printf(\"double(%d) = %d\\n\", x,result) }()\n\n\treturn x + x\n}\n\n_ = double(4) // 输出 \"double(4) = 8\"\n```\n上面的例子中我们知道 `defer` 函数可以观察函数返回值，`defer` 函数还可以修改函数的返回值：\n```go\nfunc triple(x int) (result int) {\n\tdefer func() { result += x }()\n\treturn double(x)\n}\nfmt.Println(triple(4)) // \"12\"\n```\n\n### 如果一个函数中有多条 defer 语句，那么那几个 defer 函数调用的执行顺序是怎样的\n在同一个函数中，**`defer` 函数调用的执行顺序与它们分别所属的 `defer` 语句的出现顺序（更严谨地说，是执行顺序）完全相反**。\n\n在 `defer` 语句每次执行的时候，Go 语言会把它携带的 `defer` 函数及其参数值另行存储到一个队列中。\n\n这个队列与该 `defer` 语句所属的函数是对应的，并且，它是先进后出（FILO）的，相当于一个栈。\n\n在需要执行某个函数中的 `defer` 函数调用的时候，Go 语言会先拿到对应的队列，然后从该队列中一个一个地取出 `defer` 函数及\n其参数值，并逐个执行调用。\n\n\n\n## 传入函数的那些参数值后来怎么样了\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tarray1 := [3]string{\"a\", \"b\", \"c\"}\n\tfmt.Printf(\"The array: %v\\n\", array1)\n\tarray2 := modifyArray(array1)\n\tfmt.Printf(\"The modified array: %v\\n\", array2)\n\tfmt.Printf(\"The original array: %v\\n\", array1)\n}\n\nfunc modifyArray(a [3]string) [3]string {\n\ta[1] = \"x\"\n\treturn a\n}\n```\n在 `main` 函数中声明了一个数组 `array1`，然后把它传给了函数 `modify`，`modify` 对参数值稍作修改后将其作为结果值返回。`main`\n 函数中的代码拿到这个结果之后打印了它（即 `array2`），以及原来的数组 `array1`。关键问题是，原数组会因 `modify` 函数对参数\n 值的修改而改变吗？\n\n答案是：原数组不会改变。为什么呢？原因是，**所有传给函数的参数值都会被复制，函数在其内部使用的并不是参数值的原值，\n而是它的副本**。\n\n由于数组是值类型，所以每一次复制都会拷贝它，以及它的所有元素值。\n\n注意，**对于引用类型，比如：切片、字典、通道，像上面那样复制它们的值，只会拷贝它们本身而已，并不会拷贝它们引用的底层数据。\n也就是说，这时只是浅表复制，而不是深层复制**。\n\n以切片值为例，如此复制的时候，只是拷贝了它指向底层数组中某一个元素的指针，以及它的长度值和容量值，而它的底层数组并不会被拷贝。","source":"basic/function.md","raw":"---\ntitle: 函数\n---\n\n# 函数\n\n## 声明函数\n`func` 关键字声明函数：\n```go\nfunc 函数名(形式参数列表) (返回值列表) {\n    函数体\n}\n```\n如果函数返回一个无名变量或者没有返回值，返回值列表的括号可以省略。如果一个函数声明没有返回值列表，那么这个\n函数不会返回任何值。\n\n```go\n// 两个 int 类型参数 返回一个 int 类型的值\nfunc max(num1, num2 int) int {\n   /* 定义局部变量 */\n   var result int\n\n   if (num1 > num2) {\n      result = num1\n   } else {\n      result = num2\n   }\n   return result \n}\n\n// 返回多个类型的值\nfunc swap(x int, y string) (string, int) {\n   return y, x\n}\n\n// 有名返回值\nfunc Size(rect image.Rectangle) (width, height int, err error)\n```\n\n在函数体中，函数的形参作为局部变量，被初始化为调用者提供的值（函数调用必须按照声明顺序为所有参数提供实参）。函数的形参和有\n名返回值（也就是对返回值命名）作为函数最外层的局部变量，被存储在相同的词法块中。\n\n## 参数\nGo 语言使用的是**值传递**，当我们传一个参数值到被调用函数里面时，实际上是传了这个值的一份 copy，（不管是指针，引用类型还是其他类型，\n区别无非是拷贝目标对象还是拷贝指针）当在被调用函数中修改参数值的时候，调用函数中相应实参不会发生任何变化，因为数值变化只作用在 copy 上。\n但是如果是引用传递，在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。\n\n注意，如果实参是 `slice`、`map`、`function`、`channel` 等类型（**引用类型**），实参可能会由于函数的间接引用被修改。\n\n没有函数体的函数声明，这表示该函数不是以 Go 实现的。这样的声明定义了函数标识符。\n\n**表面上看，指针参数性能会更好，但是要注意被复制的指针会延长目标对象的生命周期，还可能导致它被分配到堆上，其性能消耗要加上堆内存分配和\n垃圾回收的成本**。\n\n在栈上复制小对象，要比堆上分配内存要快的多。\n## 可变参数\n**变参本质上就是一个切片，只能接受一到多个同类型参数，而且必须在参数列表的最后一个**。比如 `fmt.Printf`，`Printf` 接收一个的必备参数，之\n后接收任意个数的后续参数。\n\n在参数列表的最后一个参数类型之前加上省略符号 `...`，表示该函数会接收任意数量的该类型参数。\n```go\nfunc sum(vals ...int) int {\n\ttotal := 0\n\tfor _, val := range vals {\n\t\t\ttotal += val\n\t}\n\treturn total\n}\n\n// 调用\nfmt.Println(sum())           // \"0\"\nfmt.Println(sum(3))          // \"3\"\nfmt.Println(sum(1, 2, 3, 4)) // \"10\"\n\n// 还可以使用类似 ES6 的解构赋值的语法\nvalues := []int{1, 2, 3, 4}\nfmt.Println(sum(values...)) // \"10\"\n```\n\n## 函数作为值\nGo 函数被看作第一类值：函数像其他值一样，拥有类型，可以被赋值给其他变量，传递给函数，从函数返回。\n\n```go\nfunc main(){\n\t/* 声明函数变量 */\n\tgetSquareRoot := func(x float64) float64 {\n\t\treturn math.Sqrt(x)\n\t}\n\n\t/* 使用函数 */\n\tfmt.Println(getSquareRoot(9)) // 3\n}\n```\n\n## 函数作为参数\n声明一个名叫 `operate` 的函数类型，它有两个参数和一个结果，都是 `int` 类型的。\n```go\ntype operate func(x, y int) int\n```\n\n编写 `calculate` 函数的签名部分。这个函数除了需要两个 `int` 类型的参数之外，还应该有一个 `operate` 类型的参数。\n```go\nfunc calculate(x int, y int, op operate) (int, error) {\n    if op == nil {\n        return 0, errors.New(\"invalid operation\")\n    }\n    return op(x, y), nil\n}\n```\n\n## 闭包\nGo 语言支持匿名函数，可作为闭包。\n```go\n// 返回一个函数\nfunc getSequence() func() int { // func() 是没有参数也没有返回值的函数类型\n\t i:=0\n\t // 闭包\n   return func() int {\n      i+=1\n     return i  \n   }\n}\n```\n\n## 错误\nGo 中，对于大部分函数而言，永远无法确保能否成功运行（有一部分函数总是能成功的运行。比如 `strings.Contains` 和 \n`strconv.FormatBool`）。通常 Go 函数的最后一个返回值用来传递错误信息。如果导致失败的原因只有一个，返回值可以是一个布尔值，\n通常被命名为 `ok`。否则应该返回一个 `error` 类型。\n\n\n## 关键字 defer\n在普通函数或方法前加关键字 `defer`，会使函数或方法延迟执行，直到包含该 `defer` 语句的函数执行完毕时（**无论函数是否出错**），\n`defer` 后的函数才会被执行。\n\n`defer` 语句一般被用于处理成对的操作，如打开、关闭、连接、断开连接、加锁、释放锁。因为 `defer` 可以保证让你更任何情况下，\n资源都会被释放。\n```go\npackage ioutil\nfunc ReadFile(filename string) ([]byte, error) {\n\tf, err := os.Open(filename)\n\tif err != nil {\n\t\t\treturn nil, err\n\t}\n\tdefer f.Close()\n\treturn ReadAll(f)\n}\n\n// 互斥锁\nvar mu sync.Mutex\nvar m = make(map[string]int)\nfunc lookup(key string) int {\n\tmu.Lock()\n\tdefer mu.Unlock()\n\treturn m[key]\n}\n\n// 记录何时进入和退出函数\nfunc bigSlowOperation() {\n\tdefer trace(\"bigSlowOperation\")() // 运行 trace 函数，记录了进入函数的时间，并返回一个函数值，这个函数值会延迟执行\n\textra parentheses\n\t// ...lots of work…\n\ttime.Sleep(10 * time.Second) // simulate slow\n\toperation by sleeping\n}\nfunc trace(msg string) func() {\n\tstart := time.Now()\n\tlog.Printf(\"enter %s\", msg)\n\treturn func() { \n\t\tlog.Printf(\"exit %s (%s)\", msg,time.Since(start)) \n\t}\n}\n\n// 观察函数的返回值\nfunc double(x int) (result int) { // 有名返回值\n  // 由于 defer 在 return 之后执行，所以这里的 result 就是函数最终的返回值\n\tdefer func() { fmt.Printf(\"double(%d) = %d\\n\", x,result) }()\n\n\treturn x + x\n}\n\n_ = double(4) // 输出 \"double(4) = 8\"\n```\n上面的例子中我们知道 `defer` 函数可以观察函数返回值，`defer` 函数还可以修改函数的返回值：\n```go\nfunc triple(x int) (result int) {\n\tdefer func() { result += x }()\n\treturn double(x)\n}\nfmt.Println(triple(4)) // \"12\"\n```\n\n### 如果一个函数中有多条 defer 语句，那么那几个 defer 函数调用的执行顺序是怎样的\n在同一个函数中，**`defer` 函数调用的执行顺序与它们分别所属的 `defer` 语句的出现顺序（更严谨地说，是执行顺序）完全相反**。\n\n在 `defer` 语句每次执行的时候，Go 语言会把它携带的 `defer` 函数及其参数值另行存储到一个队列中。\n\n这个队列与该 `defer` 语句所属的函数是对应的，并且，它是先进后出（FILO）的，相当于一个栈。\n\n在需要执行某个函数中的 `defer` 函数调用的时候，Go 语言会先拿到对应的队列，然后从该队列中一个一个地取出 `defer` 函数及\n其参数值，并逐个执行调用。\n\n\n\n## 传入函数的那些参数值后来怎么样了\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tarray1 := [3]string{\"a\", \"b\", \"c\"}\n\tfmt.Printf(\"The array: %v\\n\", array1)\n\tarray2 := modifyArray(array1)\n\tfmt.Printf(\"The modified array: %v\\n\", array2)\n\tfmt.Printf(\"The original array: %v\\n\", array1)\n}\n\nfunc modifyArray(a [3]string) [3]string {\n\ta[1] = \"x\"\n\treturn a\n}\n```\n在 `main` 函数中声明了一个数组 `array1`，然后把它传给了函数 `modify`，`modify` 对参数值稍作修改后将其作为结果值返回。`main`\n 函数中的代码拿到这个结果之后打印了它（即 `array2`），以及原来的数组 `array1`。关键问题是，原数组会因 `modify` 函数对参数\n 值的修改而改变吗？\n\n答案是：原数组不会改变。为什么呢？原因是，**所有传给函数的参数值都会被复制，函数在其内部使用的并不是参数值的原值，\n而是它的副本**。\n\n由于数组是值类型，所以每一次复制都会拷贝它，以及它的所有元素值。\n\n注意，**对于引用类型，比如：切片、字典、通道，像上面那样复制它们的值，只会拷贝它们本身而已，并不会拷贝它们引用的底层数据。\n也就是说，这时只是浅表复制，而不是深层复制**。\n\n以切片值为例，如此复制的时候，只是拷贝了它指向底层数组中某一个元素的指针，以及它的长度值和容量值，而它的底层数组并不会被拷贝。","date":"2019-08-28T00:15:07.507Z","updated":"2019-08-28T00:15:07.507Z","path":"basic/function.html","comments":1,"layout":"page","_id":"ck1xm14kz000ufcw2owe7na73","content":"<h1 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h1><h2 id=\"声明函数\"><a href=\"#声明函数\" class=\"headerlink\" title=\"声明函数\"></a>声明函数</h2><p><code>func</code> 关键字声明函数：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> 函数名<span class=\"params\">(形式参数列表)</span> <span class=\"params\">(返回值列表)</span></span> &#123;</span><br><span class=\"line\">    函数体</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>如果函数返回一个无名变量或者没有返回值，返回值列表的括号可以省略。如果一个函数声明没有返回值列表，那么这个<br>函数不会返回任何值。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 两个 int 类型参数 返回一个 int 类型的值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">max</span><span class=\"params\">(num1, num2 <span class=\"keyword\">int</span>)</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">   <span class=\"comment\">/* 定义局部变量 */</span></span><br><span class=\"line\">   <span class=\"keyword\">var</span> result <span class=\"keyword\">int</span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">if</span> (num1 &gt; num2) &#123;</span><br><span class=\"line\">      result = num1</span><br><span class=\"line\">   &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      result = num2</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> result </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 返回多个类型的值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">swap</span><span class=\"params\">(x <span class=\"keyword\">int</span>, y <span class=\"keyword\">string</span>)</span> <span class=\"params\">(<span class=\"keyword\">string</span>, <span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> y, x</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 有名返回值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Size</span><span class=\"params\">(rect image.Rectangle)</span> <span class=\"params\">(width, height <span class=\"keyword\">int</span>, err error)</span></span></span><br></pre></td></tr></table></figure>\n<p>在函数体中，函数的形参作为局部变量，被初始化为调用者提供的值（函数调用必须按照声明顺序为所有参数提供实参）。函数的形参和有<br>名返回值（也就是对返回值命名）作为函数最外层的局部变量，被存储在相同的词法块中。</p>\n<h2 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h2><p>Go 语言使用的是<strong>值传递</strong>，当我们传一个参数值到被调用函数里面时，实际上是传了这个值的一份 copy，（不管是指针，引用类型还是其他类型，<br>区别无非是拷贝目标对象还是拷贝指针）当在被调用函数中修改参数值的时候，调用函数中相应实参不会发生任何变化，因为数值变化只作用在 copy 上。<br>但是如果是引用传递，在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。</p>\n<p>注意，如果实参是 <code>slice</code>、<code>map</code>、<code>function</code>、<code>channel</code> 等类型（<strong>引用类型</strong>），实参可能会由于函数的间接引用被修改。</p>\n<p>没有函数体的函数声明，这表示该函数不是以 Go 实现的。这样的声明定义了函数标识符。</p>\n<p><strong>表面上看，指针参数性能会更好，但是要注意被复制的指针会延长目标对象的生命周期，还可能导致它被分配到堆上，其性能消耗要加上堆内存分配和<br>垃圾回收的成本</strong>。</p>\n<p>在栈上复制小对象，要比堆上分配内存要快的多。</p>\n<h2 id=\"可变参数\"><a href=\"#可变参数\" class=\"headerlink\" title=\"可变参数\"></a>可变参数</h2><p><strong>变参本质上就是一个切片，只能接受一到多个同类型参数，而且必须在参数列表的最后一个</strong>。比如 <code>fmt.Printf</code>，<code>Printf</code> 接收一个的必备参数，之<br>后接收任意个数的后续参数。</p>\n<p>在参数列表的最后一个参数类型之前加上省略符号 <code>...</code>，表示该函数会接收任意数量的该类型参数。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">sum</span><span class=\"params\">(vals ...<span class=\"keyword\">int</span>)</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">\ttotal := <span class=\"number\">0</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> _, val := <span class=\"keyword\">range</span> vals &#123;</span><br><span class=\"line\">\t\t\ttotal += val</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> total</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 调用</span></span><br><span class=\"line\">fmt.Println(sum())           <span class=\"comment\">// \"0\"</span></span><br><span class=\"line\">fmt.Println(sum(<span class=\"number\">3</span>))          <span class=\"comment\">// \"3\"</span></span><br><span class=\"line\">fmt.Println(sum(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>)) <span class=\"comment\">// \"10\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 还可以使用类似 ES6 的解构赋值的语法</span></span><br><span class=\"line\">values := []<span class=\"keyword\">int</span>&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>&#125;</span><br><span class=\"line\">fmt.Println(sum(values...)) <span class=\"comment\">// \"10\"</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"函数作为值\"><a href=\"#函数作为值\" class=\"headerlink\" title=\"函数作为值\"></a>函数作为值</h2><p>Go 函数被看作第一类值：函数像其他值一样，拥有类型，可以被赋值给其他变量，传递给函数，从函数返回。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">/* 声明函数变量 */</span></span><br><span class=\"line\">\tgetSquareRoot := <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(x <span class=\"keyword\">float64</span>)</span> <span class=\"title\">float64</span></span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> math.Sqrt(x)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/* 使用函数 */</span></span><br><span class=\"line\">\tfmt.Println(getSquareRoot(<span class=\"number\">9</span>)) <span class=\"comment\">// 3</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"函数作为参数\"><a href=\"#函数作为参数\" class=\"headerlink\" title=\"函数作为参数\"></a>函数作为参数</h2><p>声明一个名叫 <code>operate</code> 的函数类型，它有两个参数和一个结果，都是 <code>int</code> 类型的。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> operate <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(x, y <span class=\"keyword\">int</span>)</span> <span class=\"title\">int</span></span></span><br></pre></td></tr></table></figure></p>\n<p>编写 <code>calculate</code> 函数的签名部分。这个函数除了需要两个 <code>int</code> 类型的参数之外，还应该有一个 <code>operate</code> 类型的参数。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">calculate</span><span class=\"params\">(x <span class=\"keyword\">int</span>, y <span class=\"keyword\">int</span>, op operate)</span> <span class=\"params\">(<span class=\"keyword\">int</span>, error)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> op == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>, errors.New(<span class=\"string\">\"invalid operation\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> op(x, y), <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h2><p>Go 语言支持匿名函数，可作为闭包。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 返回一个函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">getSequence</span><span class=\"params\">()</span> <span class=\"title\">func</span><span class=\"params\">()</span> <span class=\"title\">int</span></span> &#123; <span class=\"comment\">// func() 是没有参数也没有返回值的函数类型</span></span><br><span class=\"line\">\t i:=<span class=\"number\">0</span></span><br><span class=\"line\">\t <span class=\"comment\">// 闭包</span></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">      i+=<span class=\"number\">1</span></span><br><span class=\"line\">     <span class=\"keyword\">return</span> i  </span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"错误\"><a href=\"#错误\" class=\"headerlink\" title=\"错误\"></a>错误</h2><p>Go 中，对于大部分函数而言，永远无法确保能否成功运行（有一部分函数总是能成功的运行。比如 <code>strings.Contains</code> 和<br><code>strconv.FormatBool</code>）。通常 Go 函数的最后一个返回值用来传递错误信息。如果导致失败的原因只有一个，返回值可以是一个布尔值，<br>通常被命名为 <code>ok</code>。否则应该返回一个 <code>error</code> 类型。</p>\n<h2 id=\"关键字-defer\"><a href=\"#关键字-defer\" class=\"headerlink\" title=\"关键字 defer\"></a>关键字 defer</h2><p>在普通函数或方法前加关键字 <code>defer</code>，会使函数或方法延迟执行，直到包含该 <code>defer</code> 语句的函数执行完毕时（<strong>无论函数是否出错</strong>），<br><code>defer</code> 后的函数才会被执行。</p>\n<p><code>defer</code> 语句一般被用于处理成对的操作，如打开、关闭、连接、断开连接、加锁、释放锁。因为 <code>defer</code> 可以保证让你更任何情况下，<br>资源都会被释放。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> ioutil</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">ReadFile</span><span class=\"params\">(filename <span class=\"keyword\">string</span>)</span> <span class=\"params\">([]<span class=\"keyword\">byte</span>, error)</span></span> &#123;</span><br><span class=\"line\">\tf, err := os.Open(filename)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> f.Close()</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ReadAll(f)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 互斥锁</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> mu sync.Mutex</span><br><span class=\"line\"><span class=\"keyword\">var</span> m = <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">int</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">lookup</span><span class=\"params\">(key <span class=\"keyword\">string</span>)</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">\tmu.Lock()</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> mu.Unlock()</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> m[key]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 记录何时进入和退出函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">bigSlowOperation</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> trace(<span class=\"string\">\"bigSlowOperation\"</span>)() <span class=\"comment\">// 运行 trace 函数，记录了进入函数的时间，并返回一个函数值，这个函数值会延迟执行</span></span><br><span class=\"line\">\textra parentheses</span><br><span class=\"line\">\t<span class=\"comment\">// ...lots of work…</span></span><br><span class=\"line\">\ttime.Sleep(<span class=\"number\">10</span> * time.Second) <span class=\"comment\">// simulate slow</span></span><br><span class=\"line\">\toperation by sleeping</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">trace</span><span class=\"params\">(msg <span class=\"keyword\">string</span>)</span> <span class=\"title\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tstart := time.Now()</span><br><span class=\"line\">\tlog.Printf(<span class=\"string\">\"enter %s\"</span>, msg)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123; </span><br><span class=\"line\">\t\tlog.Printf(<span class=\"string\">\"exit %s (%s)\"</span>, msg,time.Since(start)) </span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 观察函数的返回值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">double</span><span class=\"params\">(x <span class=\"keyword\">int</span>)</span> <span class=\"params\">(result <span class=\"keyword\">int</span>)</span></span> &#123; <span class=\"comment\">// 有名返回值</span></span><br><span class=\"line\">  <span class=\"comment\">// 由于 defer 在 return 之后执行，所以这里的 result 就是函数最终的返回值</span></span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123; fmt.Printf(<span class=\"string\">\"double(%d) = %d\\n\"</span>, x,result) &#125;()</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> x + x</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">_ = double(<span class=\"number\">4</span>) <span class=\"comment\">// 输出 \"double(4) = 8\"</span></span><br></pre></td></tr></table></figure></p>\n<p>上面的例子中我们知道 <code>defer</code> 函数可以观察函数返回值，<code>defer</code> 函数还可以修改函数的返回值：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">triple</span><span class=\"params\">(x <span class=\"keyword\">int</span>)</span> <span class=\"params\">(result <span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123; result += x &#125;()</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> double(x)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fmt.Println(triple(<span class=\"number\">4</span>)) <span class=\"comment\">// \"12\"</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"如果一个函数中有多条-defer-语句，那么那几个-defer-函数调用的执行顺序是怎样的\"><a href=\"#如果一个函数中有多条-defer-语句，那么那几个-defer-函数调用的执行顺序是怎样的\" class=\"headerlink\" title=\"如果一个函数中有多条 defer 语句，那么那几个 defer 函数调用的执行顺序是怎样的\"></a>如果一个函数中有多条 defer 语句，那么那几个 defer 函数调用的执行顺序是怎样的</h3><p>在同一个函数中，<strong><code>defer</code> 函数调用的执行顺序与它们分别所属的 <code>defer</code> 语句的出现顺序（更严谨地说，是执行顺序）完全相反</strong>。</p>\n<p>在 <code>defer</code> 语句每次执行的时候，Go 语言会把它携带的 <code>defer</code> 函数及其参数值另行存储到一个队列中。</p>\n<p>这个队列与该 <code>defer</code> 语句所属的函数是对应的，并且，它是先进后出（FILO）的，相当于一个栈。</p>\n<p>在需要执行某个函数中的 <code>defer</code> 函数调用的时候，Go 语言会先拿到对应的队列，然后从该队列中一个一个地取出 <code>defer</code> 函数及<br>其参数值，并逐个执行调用。</p>\n<h2 id=\"传入函数的那些参数值后来怎么样了\"><a href=\"#传入函数的那些参数值后来怎么样了\" class=\"headerlink\" title=\"传入函数的那些参数值后来怎么样了\"></a>传入函数的那些参数值后来怎么样了</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"fmt\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tarray1 := [<span class=\"number\">3</span>]<span class=\"keyword\">string</span>&#123;<span class=\"string\">\"a\"</span>, <span class=\"string\">\"b\"</span>, <span class=\"string\">\"c\"</span>&#125;</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"The array: %v\\n\"</span>, array1)</span><br><span class=\"line\">\tarray2 := modifyArray(array1)</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"The modified array: %v\\n\"</span>, array2)</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"The original array: %v\\n\"</span>, array1)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">modifyArray</span><span class=\"params\">(a [3]<span class=\"keyword\">string</span>)</span> [3]<span class=\"title\">string</span></span> &#123;</span><br><span class=\"line\">\ta[<span class=\"number\">1</span>] = <span class=\"string\">\"x\"</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> a</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 <code>main</code> 函数中声明了一个数组 <code>array1</code>，然后把它传给了函数 <code>modify</code>，<code>modify</code> 对参数值稍作修改后将其作为结果值返回。<code>main</code><br> 函数中的代码拿到这个结果之后打印了它（即 <code>array2</code>），以及原来的数组 <code>array1</code>。关键问题是，原数组会因 <code>modify</code> 函数对参数<br> 值的修改而改变吗？</p>\n<p>答案是：原数组不会改变。为什么呢？原因是，<strong>所有传给函数的参数值都会被复制，函数在其内部使用的并不是参数值的原值，<br>而是它的副本</strong>。</p>\n<p>由于数组是值类型，所以每一次复制都会拷贝它，以及它的所有元素值。</p>\n<p>注意，<strong>对于引用类型，比如：切片、字典、通道，像上面那样复制它们的值，只会拷贝它们本身而已，并不会拷贝它们引用的底层数据。<br>也就是说，这时只是浅表复制，而不是深层复制</strong>。</p>\n<p>以切片值为例，如此复制的时候，只是拷贝了它指向底层数组中某一个元素的指针，以及它的长度值和容量值，而它的底层数组并不会被拷贝。</p>\n","site":{"data":{"navigation":{"logo":{"text":"Golang Learn","type":"link","path":"index.html"},"main":[{"text":"Golang 基础","type":"label"},{"text":"Go 环境配置","type":"link","path":"basic/env_config.html"},{"text":"包","type":"link","path":"basic/package.html"},{"text":"基础数据类型","type":"link","path":"basic/basic_data.html"},{"text":"变量","type":"link","path":"basic/var.html"},{"text":"常量","type":"link","path":"basic/constant.html"},{"text":"控制语句","type":"link","path":"basic/flow.html"},{"text":"运算符","type":"link","path":"basic/operator.html"},{"text":"作用域","type":"link","path":"basic/scope.html"},{"text":"指针","type":"link","path":"basic/pointer.html"},{"text":"数组","type":"link","path":"basic/array.html"},{"text":"切片","type":"link","path":"basic/slice.html"},{"text":"字典","type":"link","path":"basic/map.html"},{"text":"函数","type":"link","path":"basic/function.html"},{"text":"结构体","type":"link","path":"basic/struct.html"},{"text":"接口","type":"link","path":"basic/interface.html"},{"text":"面向对象","type":"link","path":"basic/oop.html"},{"text":"错误","type":"link","path":"basic/error.html"},{"text":"序列化","type":"link","path":"basic/json.html"},{"text":"反射","type":"link","path":"basic/reflect.html"},{"text":"测试","type":"link","path":"basic/test.html"},{"text":"并发编程","type":"label"},{"text":"goroutine","type":"link","path":"concurrent/goroutine.html"},{"text":"channel","type":"link","path":"concurrent/channel.html"},{"text":"同步和锁","type":"link","path":"concurrent/sync_lock.html"},{"text":"内存分配","type":"label"},{"text":"内存分配","type":"link","path":"advance/mm.html"},{"text":"垃圾回收","type":"label"},{"text":"垃圾回收","type":"link","path":"advance/gc.html"},{"text":"标准库","type":"label"},{"text":"fmt","type":"link","path":"standards/io/fmt.html"},{"text":"io","type":"link","path":"standards/io/io.html"},{"text":"ioutil","type":"link","path":"standards/io/ioutil.html"},{"text":"bufio","type":"link","path":"standards/io/bufio.html"},{"text":"os","type":"link","path":"standards/os/os.html"},{"text":"filepath","type":"link","path":"standards/os/filepath.html"},{"text":"strings","type":"link","path":"standards/text/strings.html"},{"text":"strconv","type":"link","path":"standards/text/strconv.html"},{"text":"unicode","type":"link","path":"standards/text/unicode.html"},{"text":"log","type":"link","path":"standards/log.html"},{"text":"time","type":"link","path":"standards/time.html"},{"text":"http","type":"link","path":"standards/net/http.html"},{"text":"math","type":"link","path":"standards/data/math.html"},{"text":"sort","type":"link","path":"standards/data/sort.html"},{"text":"big","type":"link","path":"standards/data/big.html"},{"text":"container","type":"link","path":"standards/data/container.html"},{"text":"sql","type":"link","path":"standards/database/sql.html"},{"text":"THEME","type":"label"},{"text":"使用文档主题","type":"link","path":"theme/theme-usage.html"},{"text":"SUPPORT AND FEEDBACK","type":"label"},{"text":"Raise an Issue on Github","type":"link","path":"https://github.com/shipengqi/golang-learn/issues/new"}]}}},"excerpt":"","more":"<h1 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h1><h2 id=\"声明函数\"><a href=\"#声明函数\" class=\"headerlink\" title=\"声明函数\"></a>声明函数</h2><p><code>func</code> 关键字声明函数：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> 函数名<span class=\"params\">(形式参数列表)</span> <span class=\"params\">(返回值列表)</span></span> &#123;</span><br><span class=\"line\">    函数体</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>如果函数返回一个无名变量或者没有返回值，返回值列表的括号可以省略。如果一个函数声明没有返回值列表，那么这个<br>函数不会返回任何值。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 两个 int 类型参数 返回一个 int 类型的值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">max</span><span class=\"params\">(num1, num2 <span class=\"keyword\">int</span>)</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">   <span class=\"comment\">/* 定义局部变量 */</span></span><br><span class=\"line\">   <span class=\"keyword\">var</span> result <span class=\"keyword\">int</span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">if</span> (num1 &gt; num2) &#123;</span><br><span class=\"line\">      result = num1</span><br><span class=\"line\">   &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      result = num2</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> result </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 返回多个类型的值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">swap</span><span class=\"params\">(x <span class=\"keyword\">int</span>, y <span class=\"keyword\">string</span>)</span> <span class=\"params\">(<span class=\"keyword\">string</span>, <span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> y, x</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 有名返回值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Size</span><span class=\"params\">(rect image.Rectangle)</span> <span class=\"params\">(width, height <span class=\"keyword\">int</span>, err error)</span></span></span><br></pre></td></tr></table></figure>\n<p>在函数体中，函数的形参作为局部变量，被初始化为调用者提供的值（函数调用必须按照声明顺序为所有参数提供实参）。函数的形参和有<br>名返回值（也就是对返回值命名）作为函数最外层的局部变量，被存储在相同的词法块中。</p>\n<h2 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h2><p>Go 语言使用的是<strong>值传递</strong>，当我们传一个参数值到被调用函数里面时，实际上是传了这个值的一份 copy，（不管是指针，引用类型还是其他类型，<br>区别无非是拷贝目标对象还是拷贝指针）当在被调用函数中修改参数值的时候，调用函数中相应实参不会发生任何变化，因为数值变化只作用在 copy 上。<br>但是如果是引用传递，在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。</p>\n<p>注意，如果实参是 <code>slice</code>、<code>map</code>、<code>function</code>、<code>channel</code> 等类型（<strong>引用类型</strong>），实参可能会由于函数的间接引用被修改。</p>\n<p>没有函数体的函数声明，这表示该函数不是以 Go 实现的。这样的声明定义了函数标识符。</p>\n<p><strong>表面上看，指针参数性能会更好，但是要注意被复制的指针会延长目标对象的生命周期，还可能导致它被分配到堆上，其性能消耗要加上堆内存分配和<br>垃圾回收的成本</strong>。</p>\n<p>在栈上复制小对象，要比堆上分配内存要快的多。</p>\n<h2 id=\"可变参数\"><a href=\"#可变参数\" class=\"headerlink\" title=\"可变参数\"></a>可变参数</h2><p><strong>变参本质上就是一个切片，只能接受一到多个同类型参数，而且必须在参数列表的最后一个</strong>。比如 <code>fmt.Printf</code>，<code>Printf</code> 接收一个的必备参数，之<br>后接收任意个数的后续参数。</p>\n<p>在参数列表的最后一个参数类型之前加上省略符号 <code>...</code>，表示该函数会接收任意数量的该类型参数。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">sum</span><span class=\"params\">(vals ...<span class=\"keyword\">int</span>)</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">\ttotal := <span class=\"number\">0</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> _, val := <span class=\"keyword\">range</span> vals &#123;</span><br><span class=\"line\">\t\t\ttotal += val</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> total</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 调用</span></span><br><span class=\"line\">fmt.Println(sum())           <span class=\"comment\">// \"0\"</span></span><br><span class=\"line\">fmt.Println(sum(<span class=\"number\">3</span>))          <span class=\"comment\">// \"3\"</span></span><br><span class=\"line\">fmt.Println(sum(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>)) <span class=\"comment\">// \"10\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 还可以使用类似 ES6 的解构赋值的语法</span></span><br><span class=\"line\">values := []<span class=\"keyword\">int</span>&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>&#125;</span><br><span class=\"line\">fmt.Println(sum(values...)) <span class=\"comment\">// \"10\"</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"函数作为值\"><a href=\"#函数作为值\" class=\"headerlink\" title=\"函数作为值\"></a>函数作为值</h2><p>Go 函数被看作第一类值：函数像其他值一样，拥有类型，可以被赋值给其他变量，传递给函数，从函数返回。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">/* 声明函数变量 */</span></span><br><span class=\"line\">\tgetSquareRoot := <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(x <span class=\"keyword\">float64</span>)</span> <span class=\"title\">float64</span></span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> math.Sqrt(x)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/* 使用函数 */</span></span><br><span class=\"line\">\tfmt.Println(getSquareRoot(<span class=\"number\">9</span>)) <span class=\"comment\">// 3</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"函数作为参数\"><a href=\"#函数作为参数\" class=\"headerlink\" title=\"函数作为参数\"></a>函数作为参数</h2><p>声明一个名叫 <code>operate</code> 的函数类型，它有两个参数和一个结果，都是 <code>int</code> 类型的。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> operate <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(x, y <span class=\"keyword\">int</span>)</span> <span class=\"title\">int</span></span></span><br></pre></td></tr></table></figure></p>\n<p>编写 <code>calculate</code> 函数的签名部分。这个函数除了需要两个 <code>int</code> 类型的参数之外，还应该有一个 <code>operate</code> 类型的参数。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">calculate</span><span class=\"params\">(x <span class=\"keyword\">int</span>, y <span class=\"keyword\">int</span>, op operate)</span> <span class=\"params\">(<span class=\"keyword\">int</span>, error)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> op == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>, errors.New(<span class=\"string\">\"invalid operation\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> op(x, y), <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h2><p>Go 语言支持匿名函数，可作为闭包。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 返回一个函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">getSequence</span><span class=\"params\">()</span> <span class=\"title\">func</span><span class=\"params\">()</span> <span class=\"title\">int</span></span> &#123; <span class=\"comment\">// func() 是没有参数也没有返回值的函数类型</span></span><br><span class=\"line\">\t i:=<span class=\"number\">0</span></span><br><span class=\"line\">\t <span class=\"comment\">// 闭包</span></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">      i+=<span class=\"number\">1</span></span><br><span class=\"line\">     <span class=\"keyword\">return</span> i  </span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"错误\"><a href=\"#错误\" class=\"headerlink\" title=\"错误\"></a>错误</h2><p>Go 中，对于大部分函数而言，永远无法确保能否成功运行（有一部分函数总是能成功的运行。比如 <code>strings.Contains</code> 和<br><code>strconv.FormatBool</code>）。通常 Go 函数的最后一个返回值用来传递错误信息。如果导致失败的原因只有一个，返回值可以是一个布尔值，<br>通常被命名为 <code>ok</code>。否则应该返回一个 <code>error</code> 类型。</p>\n<h2 id=\"关键字-defer\"><a href=\"#关键字-defer\" class=\"headerlink\" title=\"关键字 defer\"></a>关键字 defer</h2><p>在普通函数或方法前加关键字 <code>defer</code>，会使函数或方法延迟执行，直到包含该 <code>defer</code> 语句的函数执行完毕时（<strong>无论函数是否出错</strong>），<br><code>defer</code> 后的函数才会被执行。</p>\n<p><code>defer</code> 语句一般被用于处理成对的操作，如打开、关闭、连接、断开连接、加锁、释放锁。因为 <code>defer</code> 可以保证让你更任何情况下，<br>资源都会被释放。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> ioutil</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">ReadFile</span><span class=\"params\">(filename <span class=\"keyword\">string</span>)</span> <span class=\"params\">([]<span class=\"keyword\">byte</span>, error)</span></span> &#123;</span><br><span class=\"line\">\tf, err := os.Open(filename)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> f.Close()</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ReadAll(f)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 互斥锁</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> mu sync.Mutex</span><br><span class=\"line\"><span class=\"keyword\">var</span> m = <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">int</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">lookup</span><span class=\"params\">(key <span class=\"keyword\">string</span>)</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">\tmu.Lock()</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> mu.Unlock()</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> m[key]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 记录何时进入和退出函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">bigSlowOperation</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> trace(<span class=\"string\">\"bigSlowOperation\"</span>)() <span class=\"comment\">// 运行 trace 函数，记录了进入函数的时间，并返回一个函数值，这个函数值会延迟执行</span></span><br><span class=\"line\">\textra parentheses</span><br><span class=\"line\">\t<span class=\"comment\">// ...lots of work…</span></span><br><span class=\"line\">\ttime.Sleep(<span class=\"number\">10</span> * time.Second) <span class=\"comment\">// simulate slow</span></span><br><span class=\"line\">\toperation by sleeping</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">trace</span><span class=\"params\">(msg <span class=\"keyword\">string</span>)</span> <span class=\"title\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tstart := time.Now()</span><br><span class=\"line\">\tlog.Printf(<span class=\"string\">\"enter %s\"</span>, msg)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123; </span><br><span class=\"line\">\t\tlog.Printf(<span class=\"string\">\"exit %s (%s)\"</span>, msg,time.Since(start)) </span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 观察函数的返回值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">double</span><span class=\"params\">(x <span class=\"keyword\">int</span>)</span> <span class=\"params\">(result <span class=\"keyword\">int</span>)</span></span> &#123; <span class=\"comment\">// 有名返回值</span></span><br><span class=\"line\">  <span class=\"comment\">// 由于 defer 在 return 之后执行，所以这里的 result 就是函数最终的返回值</span></span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123; fmt.Printf(<span class=\"string\">\"double(%d) = %d\\n\"</span>, x,result) &#125;()</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> x + x</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">_ = double(<span class=\"number\">4</span>) <span class=\"comment\">// 输出 \"double(4) = 8\"</span></span><br></pre></td></tr></table></figure></p>\n<p>上面的例子中我们知道 <code>defer</code> 函数可以观察函数返回值，<code>defer</code> 函数还可以修改函数的返回值：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">triple</span><span class=\"params\">(x <span class=\"keyword\">int</span>)</span> <span class=\"params\">(result <span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123; result += x &#125;()</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> double(x)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fmt.Println(triple(<span class=\"number\">4</span>)) <span class=\"comment\">// \"12\"</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"如果一个函数中有多条-defer-语句，那么那几个-defer-函数调用的执行顺序是怎样的\"><a href=\"#如果一个函数中有多条-defer-语句，那么那几个-defer-函数调用的执行顺序是怎样的\" class=\"headerlink\" title=\"如果一个函数中有多条 defer 语句，那么那几个 defer 函数调用的执行顺序是怎样的\"></a>如果一个函数中有多条 defer 语句，那么那几个 defer 函数调用的执行顺序是怎样的</h3><p>在同一个函数中，<strong><code>defer</code> 函数调用的执行顺序与它们分别所属的 <code>defer</code> 语句的出现顺序（更严谨地说，是执行顺序）完全相反</strong>。</p>\n<p>在 <code>defer</code> 语句每次执行的时候，Go 语言会把它携带的 <code>defer</code> 函数及其参数值另行存储到一个队列中。</p>\n<p>这个队列与该 <code>defer</code> 语句所属的函数是对应的，并且，它是先进后出（FILO）的，相当于一个栈。</p>\n<p>在需要执行某个函数中的 <code>defer</code> 函数调用的时候，Go 语言会先拿到对应的队列，然后从该队列中一个一个地取出 <code>defer</code> 函数及<br>其参数值，并逐个执行调用。</p>\n<h2 id=\"传入函数的那些参数值后来怎么样了\"><a href=\"#传入函数的那些参数值后来怎么样了\" class=\"headerlink\" title=\"传入函数的那些参数值后来怎么样了\"></a>传入函数的那些参数值后来怎么样了</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"fmt\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tarray1 := [<span class=\"number\">3</span>]<span class=\"keyword\">string</span>&#123;<span class=\"string\">\"a\"</span>, <span class=\"string\">\"b\"</span>, <span class=\"string\">\"c\"</span>&#125;</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"The array: %v\\n\"</span>, array1)</span><br><span class=\"line\">\tarray2 := modifyArray(array1)</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"The modified array: %v\\n\"</span>, array2)</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"The original array: %v\\n\"</span>, array1)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">modifyArray</span><span class=\"params\">(a [3]<span class=\"keyword\">string</span>)</span> [3]<span class=\"title\">string</span></span> &#123;</span><br><span class=\"line\">\ta[<span class=\"number\">1</span>] = <span class=\"string\">\"x\"</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> a</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 <code>main</code> 函数中声明了一个数组 <code>array1</code>，然后把它传给了函数 <code>modify</code>，<code>modify</code> 对参数值稍作修改后将其作为结果值返回。<code>main</code><br> 函数中的代码拿到这个结果之后打印了它（即 <code>array2</code>），以及原来的数组 <code>array1</code>。关键问题是，原数组会因 <code>modify</code> 函数对参数<br> 值的修改而改变吗？</p>\n<p>答案是：原数组不会改变。为什么呢？原因是，<strong>所有传给函数的参数值都会被复制，函数在其内部使用的并不是参数值的原值，<br>而是它的副本</strong>。</p>\n<p>由于数组是值类型，所以每一次复制都会拷贝它，以及它的所有元素值。</p>\n<p>注意，<strong>对于引用类型，比如：切片、字典、通道，像上面那样复制它们的值，只会拷贝它们本身而已，并不会拷贝它们引用的底层数据。<br>也就是说，这时只是浅表复制，而不是深层复制</strong>。</p>\n<p>以切片值为例，如此复制的时候，只是拷贝了它指向底层数组中某一个元素的指针，以及它的长度值和容量值，而它的底层数组并不会被拷贝。</p>\n"},{"title":"time","_content":"\n# time\n\n`time` 提供了一个数据类型 `time.Time`（作为值使用）以及显示和测量时间和日期的功能函数，比如：\n- `time.Now()` 获取当前时间。\n- `t.Day()`、`t.Minute()` 获取时间的一部分。\n- `time.After`、`time.Ticker` 在经过一定时间或周期执行某项任务（事件处理的特例）。\n- `time.Sleep（Duration d）` 暂停某个进程（ goroutine），暂停时长为 `d`。\n- `Duration` 代表两个时间点之间经过的时间，以**纳秒**为单位，类型为 `int64`。\n- `Location` 类型映射某个时区的时间，UTC 表示通用协调世界时间。\n\n## 时区\nGo 语言使用 `Location` 来表示地区相关的时区，一个 `Location` 可能表示多个时区。\n\n`time` 包提供了 `Location` 的两个实例：\n- `Local` 代表当前系统本地时区；\n- `UTC` 代表通用协调时间，也就是零时区。`time` 包默认（为显示提供时区）使用 `UTC` 时区。\n\n### Local 是如何做到表示本地时区的？\n\n在初始化 `Local` 时，通过读取 `/etc/localtime` （这是一个符号链接，指向 `/usr/share/zoneinfo` 中某一个时区）可以获取到系统本地时区。\n\n如果设置了**环境变量 `TZ`**，则会优先使用它。\n\n```go\ntz, ok := syscall.Getenv(\"TZ\")\nswitch {\ncase !ok:\n\tz, err := loadZoneFile(\"\", \"/etc/localtime\")\n\tif err == nil {\n\t\tlocalLoc = *z\n\t\tlocalLoc.name = \"Local\"\n\t\treturn\n\t}\ncase tz != \"\" && tz != \"UTC\":\n\tif z, err := loadLocation(tz); err == nil {\n\t\tlocalLoc = *z\n\t\treturn\n\t}\n}\n```\n### 获得特定时区的实例\n\n函数 `LoadLocation` 可以根据名称获取特定时区的实例：\n```go\nfunc LoadLocation(name string) (*Location, error)\n```\n\n如果 `name` 是 \"\" 或 \"UTC\"，返回 UTC；\n如果 `name` 是 \"Local\"，返回 `Local`；\n否则 `name` 应该是 IANA 时区数据库里有记录的地点名（该数据库记录了地点和对应的时区），如 \"America/New_York\"。\n\n## Time\n`Time` 代表一个纳秒精度的时间点。程序中应使用 `time.Time` 类型值来保存和传递时间，而不是指针。\n程序中应使用 Time 类型值来保存和传递时间，而不是指针。\n一个 Time 类型值可以被多个 go 协程同时使用。时间点可以使用 Before、After 和 Equal 方法进行比较。Sub 方法让两个时间点相减，\n生成一个 Duration 类型值（代表时间段）。Add 方法给一个时间点加上一个时间段，生成一个新的 Time 类型时间点。\n\n`Time` 零值代表时间点 `January 1, year 1, 00:00:00.000000000 UTC`。因为本时间点一般不会出现在使用中，`IsZero` 方法提供\n了检验时间是否是显式初始化的一个简单途径。\n\n每一个 `Time` 都具有一个地点信息（即对应地点的时区信息），当计算时间的表示格式时，如 Format、Hour 和 Year 等方法，\n都会考虑该信息。Local、UTC 和 In 方法返回一个指定时区（但指向同一时间点）的 Time。修改地点 / 时区信息只是会改变其表示；不会修改被表\n示的时间点，因此也不会影响其计算。\n\n通过 `==` 比较 Time 时，Location 信息也会参与比较，因此 Time 不应该作为 map 的 key。\n\n```go\ntype Time struct {\n\t// sec gives the number of seconds elapsed since\n\t// January 1, year 1 00:00:00 UTC.\n\tsec int64\n\n\t// nsec specifies a non-negative nanosecond\n\t// offset within the second named by Seconds.\n\t// It must be in the range [0, 999999999].\n\tnsec int32\n\n\t// loc specifies the Location that should be used to\n\t// determine the minute, hour, month, day, and year\n\t// that correspond to this Time.\n\t// Only the zero Time has a nil Location.\n\t// In that case it is interpreted to mean UTC.\n\tloc *Location\n}\n```\n\n先看 `time.Now()` 函数。\n\n```go\n// Now returns the current local time.\nfunc Now() Time {\n\tsec, nsec := now()\n\treturn Time{sec + unixToInternal, nsec, Local}\n}\n```\n`now()` 的具体实现在 `runtime` 包中。从 `Time{sec + unixToInternal, nsec, Local}` 可以看出，`Time` 结构的 `sec` 并非 Unix \n时间戳，实际上，加上的 `unixToInternal` 是 `1-1-1` 到 `1970-1-1` 经历的秒数。也就是 `Time` 中的 `sec` 是从 `1-1-1` 算起的秒数，\n而不是 Unix 时间戳。\n\n`Time` 的最后一个字段表示地点时区信息。本章后面会专门介绍。\n\n### 常用方法\n\n- `Time.IsZero()` 函数用于判断 Time 表示的时间是否是 0 值。表示 1 年 1 月 1 日。\n- `time.Unix(sec, nsec int64`) 通过 Unix 时间戳生成 `time.Time` 实例；\n- `time.Time.Unix()` 得到 Unix 时间戳；\n- `time.Time.UnixNano()` 得到 Unix 时间戳的纳秒表示；\n- `time.Parse` 和 `time.ParseInLocation`\n- `time.Time.Format`\n\n```go\nt, _ := time.Parse(\"2006-01-02 15:04:05\", \"2016-06-13 09:14:00\")\nfmt.Println(time.Now().Sub(t).Hours())\n```\n这段代码的结果跟预期的不一样。原因是 `time.Now()` 的时区是 `time.Local`，而 `time.Parse` 解析出来的时区却是 `time.UTC`\n（可以通过 `Time.Location()` 函数知道是哪个时区）。在中国，它们相差 8 小时。\n\n所以，一般的，我们应该总是使用 `time.ParseInLocation` 来解析时间，并给第三个参数传递 `time.Local`。\n\n#### 为什么是 2006-01-02 15:04:05\n\n可能你已经注意到：`2006-01-02 15:04:05` 这个字符串了。没错，这是固定写法，类似于其他语言中 `Y-m-d H:i:s` 等。为什么采用这种形式？\n又为什么是这个时间点而不是其他时间点？\n\n- 官方说，使用具体的时间，比使用 `Y-m-d H:i:s` 更容易理解和记忆；\n- 而选择这个时间点，也是出于好记的考虑，官方的例子：`Mon Jan 2 15:04:05 MST 2006`，很好记：2006 年 1 月 2 日 3 点 4 分 5 秒\n\n\n#### Round 和 Truncate 方法\n\n比如，有这么个需求：获取当前时间整点的 `Time` 实例。例如，当前时间是 `15:54:23`，需要的是 `15:00:00`。我们可以这么做：\n\n```\nt, _ := time.ParseInLocation(\"2006-01-02 15:04:05\", time.Now().Format(\"2006-01-02 15:00:00\"), time.Local)\nfmt.Println(t)\n```\n实际上，`time` 包给我们提供了专门的方法，功能更强大，性能也更好，这就是 `Round` 和 `Trunate`，它们区别，一个是取最接近的，一个是向下取整。\n\n```go\nt, _ := time.ParseInLocation(\"2006-01-02 15:04:05\", \"2016-06-13 15:34:39\", time.Local)\n// 整点（向下取整）\nfmt.Println(t.Truncate(1 * time.Hour))\n// 整点（最接近）\nfmt.Println(t.Round(1 * time.Hour))\n\n// 整分（向下取整）\nfmt.Println(t.Truncate(1 * time.Minute))\n// 整分（最接近）\nfmt.Println(t.Round(1 * time.Minute))\n\nt2, _ := time.ParseInLocation(\"2006-01-02 15:04:05\", t.Format(\"2006-01-02 15:00:00\"), time.Local)\nfmt.Println(t2)\n```\n\n#### Format\n自定义时间格式化字符串，例如： `fmt.Printf(\"%02d.%02d.%4d\\n\", t.Day(), t.Month(), t.Year())` 将会输出 `21.07.2011`。\n\n包中的一个预定义函数 `func (t Time) Format(layout string) string` 可以根据一个格式化字符串来将一个时间 t 转换为相应\n格式的字符串，你可以使用一些预定义的格式，如：`time.ANSIC` 或 `time.RFC822`。\n\n一般的格式化设计是通过对于一个标准时间的格式化描述来展现的，示例：\n\n```go\nfmt.Println(t.Format(\"02 Jan 2006 15:04\")) // 21 Jul 2011 10:31\n```\n\n示例：\n\n```go\npackage main\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nvar week time.Duration\nfunc main() {\n\tt := time.Now()\n\tfmt.Println(t) // e.g. Wed Dec 21 09:52:14 +0100 RST 2011\n\tfmt.Printf(\"%02d.%02d.%4d\\n\", t.Day(), t.Month(), t.Year())\n\t// 21.12.2011\n\tt = time.Now().UTC()\n\tfmt.Println(t) // Wed Dec 21 08:52:14 +0000 UTC 2011\n\tfmt.Println(time.Now()) // Wed Dec 21 09:52:14 +0100 RST 2011\n\t// calculating times:\n\tweek = 60 * 60 * 24 * 7 * 1e9 // must be in nanosec\n\tweek_from_now := t.Add(time.Duration(week))\n\tfmt.Println(week_from_now) // Wed Dec 28 08:52:14 +0000 UTC 2011\n\t// formatting times:\n\tfmt.Println(t.Format(time.RFC822)) // 21 Dec 11 0852 UTC\n\tfmt.Println(t.Format(time.ANSIC)) // Wed Dec 21 08:56:34 2011\n\tfmt.Println(t.Format(\"02 Jan 2006 15:04\")) // 21 Dec 2011 08:52\n\ts := t.Format(\"20060102\")\n\tfmt.Println(t, \"=>\", s)\n\t// Wed Dec 21 08:52:14 +0000 UTC 2011 => 20111221\n}\n```\n\n示例，计算函数执行时间：\n```go\nstart := time.Now() // 起始时间\nlongCalculation()\nend := time.Now() // 结束时间\ndelta := end.Sub(start) // 消耗时间\nfmt.Printf(\"longCalculation took this amount of time: %s\\n\", delta)\n```\n\n## 定时器\n`time` 包有两种定时器：\n- `Timer`（到达指定时间触发且只触发一次）\n- `Ticker`（间隔特定时间触发）。\n\n### Timer\n```go\ntype Timer struct {\n\tC <-chan Time\t // The channel on which the time is delivered.\n\tr runtimeTimer\n}\n```\n\n`Timer` 的实例必须通过 `NewTimer` 或 `AfterFunc` 获得。\n**当 `Timer` 到期时，当时的时间会被发送给 `C` (channel)，除非 `Timer` 是被 `AfterFunc` 函数创建的**。\n\n`runtimeTimer` 定义在 `sleep.go` 文件中，必须和 `runtime` 包中 `time.go` 文件中的 `timer` 保持一致：\n```go\ntype timer struct {\n\ti int // heap index\n\n\t// Timer wakes up at when, and then at when+period, ... (period > 0 only)\n\t// each time calling f(now, arg) in the timer goroutine, so f must be\n\t// a well-behaved function and not block.\n\twhen   int64\n\tperiod int64\n\tf      func(interface{}, uintptr)\n\targ    interface{}\n\tseq    uintptr\n}\n```\n\n通过 `NewTimer()` 来看这些字段：\n\n```go\n// NewTimer creates a new Timer that will send\n// the current time on its channel after at least duration d.\nfunc NewTimer(d Duration) *Timer {\n\tc := make(chan Time, 1)\n\tt := &Timer{\n\t\tC: c,\n\t\tr: runtimeTimer{\n\t\t\twhen: when(d),\n\t\t\tf:    sendTime,\n\t\t\targ:  c,\n\t\t},\n\t}\n\tstartTimer(&t.r)\n\treturn t\n}\n```\n\n在 `when` 表示的时间到时，会往 `Timer.C` 中发送当前时间。`when` 表示的时间是纳秒时间，正常通过 `runtimeNano() + int64(d)` 赋值。\n\n`f` 参数的值是 `sendTime`，定时器时间到时，会调用 `f`，并将 `arg` 和 `seq` 传给 `f`。\n\n因为 `Timer` 是一次性的，所以 `period` 保留默认值 0。\n\n\n### 常用方法\n#### time.After\n`time.After` 模拟超时：\n```go\nc := make(chan int)\n\ngo func() {\n\t// time.Sleep(1 * time.Second)\n\ttime.Sleep(3 * time.Second)\n\t<-c\n}()\n\nselect {\ncase c <- 1:\n\tfmt.Println(\"channel...\")\ncase <-time.After(2 * time.Second):\n\tclose(c)\n\tfmt.Println(\"timeout...\")\n}\n```\n\n#### time.Stop 和 time.Reset\n```go\nstart := time.Now()\ntimer := time.AfterFunc(2*time.Second, func() {\n\tfmt.Println(\"after func callback, elaspe:\", time.Now().Sub(start))\n})\n\ntime.Sleep(1 * time.Second)\n// time.Sleep(3*time.Second)\n// Reset 在 Timer 还未触发时返回 true；触发了或 Stop 了，返回 false\nif timer.Reset(3 * time.Second) {\n\tfmt.Println(\"timer has not trigger!\")\n} else {\n\tfmt.Println(\"timer had expired or stop!\")\n}\n\ntime.Sleep(10 * time.Second)\n\n// output:\n// timer has not trigger!\n// after func callback, elaspe: 4.00026461s\n```\n\n`timer.Stop()` 不会关闭 `Timer.C` 这个 channel，可以使用 `timer.Reset(0)` 代替 `timer.Stop()` 来停止定时器。\n\n#### Sleep\n\n`Sleep` 的是通过 `Timer` 实现的（查看 `runtime/time.go` 文件）。用于暂停当前 `goroutine`。\n\n## Ticker\n\n`Ticker` 和 `Timer` 类似，区别是：`Ticker` 中的 `runtimeTimer` 字段的 `period` 字段会赋值为 `NewTicker(d Duration)` 中的 `d`，\n表示每间隔 `d` 纳秒，定时器就会触发一次。\n\n除非程序终止前定时器一直需要触发，否则，不需要时应该调用 `Ticker.Stop` 来释放相关资源。\n\n如果程序终止前需要定时器一直触发，可以使用更简单方便的 `time.Tick` 函数，因为 `Ticker` 实例隐藏起来了，因此，该函数启动的定时器无法停止。\n","source":"standards/time.md","raw":"---\ntitle: time\n---\n\n# time\n\n`time` 提供了一个数据类型 `time.Time`（作为值使用）以及显示和测量时间和日期的功能函数，比如：\n- `time.Now()` 获取当前时间。\n- `t.Day()`、`t.Minute()` 获取时间的一部分。\n- `time.After`、`time.Ticker` 在经过一定时间或周期执行某项任务（事件处理的特例）。\n- `time.Sleep（Duration d）` 暂停某个进程（ goroutine），暂停时长为 `d`。\n- `Duration` 代表两个时间点之间经过的时间，以**纳秒**为单位，类型为 `int64`。\n- `Location` 类型映射某个时区的时间，UTC 表示通用协调世界时间。\n\n## 时区\nGo 语言使用 `Location` 来表示地区相关的时区，一个 `Location` 可能表示多个时区。\n\n`time` 包提供了 `Location` 的两个实例：\n- `Local` 代表当前系统本地时区；\n- `UTC` 代表通用协调时间，也就是零时区。`time` 包默认（为显示提供时区）使用 `UTC` 时区。\n\n### Local 是如何做到表示本地时区的？\n\n在初始化 `Local` 时，通过读取 `/etc/localtime` （这是一个符号链接，指向 `/usr/share/zoneinfo` 中某一个时区）可以获取到系统本地时区。\n\n如果设置了**环境变量 `TZ`**，则会优先使用它。\n\n```go\ntz, ok := syscall.Getenv(\"TZ\")\nswitch {\ncase !ok:\n\tz, err := loadZoneFile(\"\", \"/etc/localtime\")\n\tif err == nil {\n\t\tlocalLoc = *z\n\t\tlocalLoc.name = \"Local\"\n\t\treturn\n\t}\ncase tz != \"\" && tz != \"UTC\":\n\tif z, err := loadLocation(tz); err == nil {\n\t\tlocalLoc = *z\n\t\treturn\n\t}\n}\n```\n### 获得特定时区的实例\n\n函数 `LoadLocation` 可以根据名称获取特定时区的实例：\n```go\nfunc LoadLocation(name string) (*Location, error)\n```\n\n如果 `name` 是 \"\" 或 \"UTC\"，返回 UTC；\n如果 `name` 是 \"Local\"，返回 `Local`；\n否则 `name` 应该是 IANA 时区数据库里有记录的地点名（该数据库记录了地点和对应的时区），如 \"America/New_York\"。\n\n## Time\n`Time` 代表一个纳秒精度的时间点。程序中应使用 `time.Time` 类型值来保存和传递时间，而不是指针。\n程序中应使用 Time 类型值来保存和传递时间，而不是指针。\n一个 Time 类型值可以被多个 go 协程同时使用。时间点可以使用 Before、After 和 Equal 方法进行比较。Sub 方法让两个时间点相减，\n生成一个 Duration 类型值（代表时间段）。Add 方法给一个时间点加上一个时间段，生成一个新的 Time 类型时间点。\n\n`Time` 零值代表时间点 `January 1, year 1, 00:00:00.000000000 UTC`。因为本时间点一般不会出现在使用中，`IsZero` 方法提供\n了检验时间是否是显式初始化的一个简单途径。\n\n每一个 `Time` 都具有一个地点信息（即对应地点的时区信息），当计算时间的表示格式时，如 Format、Hour 和 Year 等方法，\n都会考虑该信息。Local、UTC 和 In 方法返回一个指定时区（但指向同一时间点）的 Time。修改地点 / 时区信息只是会改变其表示；不会修改被表\n示的时间点，因此也不会影响其计算。\n\n通过 `==` 比较 Time 时，Location 信息也会参与比较，因此 Time 不应该作为 map 的 key。\n\n```go\ntype Time struct {\n\t// sec gives the number of seconds elapsed since\n\t// January 1, year 1 00:00:00 UTC.\n\tsec int64\n\n\t// nsec specifies a non-negative nanosecond\n\t// offset within the second named by Seconds.\n\t// It must be in the range [0, 999999999].\n\tnsec int32\n\n\t// loc specifies the Location that should be used to\n\t// determine the minute, hour, month, day, and year\n\t// that correspond to this Time.\n\t// Only the zero Time has a nil Location.\n\t// In that case it is interpreted to mean UTC.\n\tloc *Location\n}\n```\n\n先看 `time.Now()` 函数。\n\n```go\n// Now returns the current local time.\nfunc Now() Time {\n\tsec, nsec := now()\n\treturn Time{sec + unixToInternal, nsec, Local}\n}\n```\n`now()` 的具体实现在 `runtime` 包中。从 `Time{sec + unixToInternal, nsec, Local}` 可以看出，`Time` 结构的 `sec` 并非 Unix \n时间戳，实际上，加上的 `unixToInternal` 是 `1-1-1` 到 `1970-1-1` 经历的秒数。也就是 `Time` 中的 `sec` 是从 `1-1-1` 算起的秒数，\n而不是 Unix 时间戳。\n\n`Time` 的最后一个字段表示地点时区信息。本章后面会专门介绍。\n\n### 常用方法\n\n- `Time.IsZero()` 函数用于判断 Time 表示的时间是否是 0 值。表示 1 年 1 月 1 日。\n- `time.Unix(sec, nsec int64`) 通过 Unix 时间戳生成 `time.Time` 实例；\n- `time.Time.Unix()` 得到 Unix 时间戳；\n- `time.Time.UnixNano()` 得到 Unix 时间戳的纳秒表示；\n- `time.Parse` 和 `time.ParseInLocation`\n- `time.Time.Format`\n\n```go\nt, _ := time.Parse(\"2006-01-02 15:04:05\", \"2016-06-13 09:14:00\")\nfmt.Println(time.Now().Sub(t).Hours())\n```\n这段代码的结果跟预期的不一样。原因是 `time.Now()` 的时区是 `time.Local`，而 `time.Parse` 解析出来的时区却是 `time.UTC`\n（可以通过 `Time.Location()` 函数知道是哪个时区）。在中国，它们相差 8 小时。\n\n所以，一般的，我们应该总是使用 `time.ParseInLocation` 来解析时间，并给第三个参数传递 `time.Local`。\n\n#### 为什么是 2006-01-02 15:04:05\n\n可能你已经注意到：`2006-01-02 15:04:05` 这个字符串了。没错，这是固定写法，类似于其他语言中 `Y-m-d H:i:s` 等。为什么采用这种形式？\n又为什么是这个时间点而不是其他时间点？\n\n- 官方说，使用具体的时间，比使用 `Y-m-d H:i:s` 更容易理解和记忆；\n- 而选择这个时间点，也是出于好记的考虑，官方的例子：`Mon Jan 2 15:04:05 MST 2006`，很好记：2006 年 1 月 2 日 3 点 4 分 5 秒\n\n\n#### Round 和 Truncate 方法\n\n比如，有这么个需求：获取当前时间整点的 `Time` 实例。例如，当前时间是 `15:54:23`，需要的是 `15:00:00`。我们可以这么做：\n\n```\nt, _ := time.ParseInLocation(\"2006-01-02 15:04:05\", time.Now().Format(\"2006-01-02 15:00:00\"), time.Local)\nfmt.Println(t)\n```\n实际上，`time` 包给我们提供了专门的方法，功能更强大，性能也更好，这就是 `Round` 和 `Trunate`，它们区别，一个是取最接近的，一个是向下取整。\n\n```go\nt, _ := time.ParseInLocation(\"2006-01-02 15:04:05\", \"2016-06-13 15:34:39\", time.Local)\n// 整点（向下取整）\nfmt.Println(t.Truncate(1 * time.Hour))\n// 整点（最接近）\nfmt.Println(t.Round(1 * time.Hour))\n\n// 整分（向下取整）\nfmt.Println(t.Truncate(1 * time.Minute))\n// 整分（最接近）\nfmt.Println(t.Round(1 * time.Minute))\n\nt2, _ := time.ParseInLocation(\"2006-01-02 15:04:05\", t.Format(\"2006-01-02 15:00:00\"), time.Local)\nfmt.Println(t2)\n```\n\n#### Format\n自定义时间格式化字符串，例如： `fmt.Printf(\"%02d.%02d.%4d\\n\", t.Day(), t.Month(), t.Year())` 将会输出 `21.07.2011`。\n\n包中的一个预定义函数 `func (t Time) Format(layout string) string` 可以根据一个格式化字符串来将一个时间 t 转换为相应\n格式的字符串，你可以使用一些预定义的格式，如：`time.ANSIC` 或 `time.RFC822`。\n\n一般的格式化设计是通过对于一个标准时间的格式化描述来展现的，示例：\n\n```go\nfmt.Println(t.Format(\"02 Jan 2006 15:04\")) // 21 Jul 2011 10:31\n```\n\n示例：\n\n```go\npackage main\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nvar week time.Duration\nfunc main() {\n\tt := time.Now()\n\tfmt.Println(t) // e.g. Wed Dec 21 09:52:14 +0100 RST 2011\n\tfmt.Printf(\"%02d.%02d.%4d\\n\", t.Day(), t.Month(), t.Year())\n\t// 21.12.2011\n\tt = time.Now().UTC()\n\tfmt.Println(t) // Wed Dec 21 08:52:14 +0000 UTC 2011\n\tfmt.Println(time.Now()) // Wed Dec 21 09:52:14 +0100 RST 2011\n\t// calculating times:\n\tweek = 60 * 60 * 24 * 7 * 1e9 // must be in nanosec\n\tweek_from_now := t.Add(time.Duration(week))\n\tfmt.Println(week_from_now) // Wed Dec 28 08:52:14 +0000 UTC 2011\n\t// formatting times:\n\tfmt.Println(t.Format(time.RFC822)) // 21 Dec 11 0852 UTC\n\tfmt.Println(t.Format(time.ANSIC)) // Wed Dec 21 08:56:34 2011\n\tfmt.Println(t.Format(\"02 Jan 2006 15:04\")) // 21 Dec 2011 08:52\n\ts := t.Format(\"20060102\")\n\tfmt.Println(t, \"=>\", s)\n\t// Wed Dec 21 08:52:14 +0000 UTC 2011 => 20111221\n}\n```\n\n示例，计算函数执行时间：\n```go\nstart := time.Now() // 起始时间\nlongCalculation()\nend := time.Now() // 结束时间\ndelta := end.Sub(start) // 消耗时间\nfmt.Printf(\"longCalculation took this amount of time: %s\\n\", delta)\n```\n\n## 定时器\n`time` 包有两种定时器：\n- `Timer`（到达指定时间触发且只触发一次）\n- `Ticker`（间隔特定时间触发）。\n\n### Timer\n```go\ntype Timer struct {\n\tC <-chan Time\t // The channel on which the time is delivered.\n\tr runtimeTimer\n}\n```\n\n`Timer` 的实例必须通过 `NewTimer` 或 `AfterFunc` 获得。\n**当 `Timer` 到期时，当时的时间会被发送给 `C` (channel)，除非 `Timer` 是被 `AfterFunc` 函数创建的**。\n\n`runtimeTimer` 定义在 `sleep.go` 文件中，必须和 `runtime` 包中 `time.go` 文件中的 `timer` 保持一致：\n```go\ntype timer struct {\n\ti int // heap index\n\n\t// Timer wakes up at when, and then at when+period, ... (period > 0 only)\n\t// each time calling f(now, arg) in the timer goroutine, so f must be\n\t// a well-behaved function and not block.\n\twhen   int64\n\tperiod int64\n\tf      func(interface{}, uintptr)\n\targ    interface{}\n\tseq    uintptr\n}\n```\n\n通过 `NewTimer()` 来看这些字段：\n\n```go\n// NewTimer creates a new Timer that will send\n// the current time on its channel after at least duration d.\nfunc NewTimer(d Duration) *Timer {\n\tc := make(chan Time, 1)\n\tt := &Timer{\n\t\tC: c,\n\t\tr: runtimeTimer{\n\t\t\twhen: when(d),\n\t\t\tf:    sendTime,\n\t\t\targ:  c,\n\t\t},\n\t}\n\tstartTimer(&t.r)\n\treturn t\n}\n```\n\n在 `when` 表示的时间到时，会往 `Timer.C` 中发送当前时间。`when` 表示的时间是纳秒时间，正常通过 `runtimeNano() + int64(d)` 赋值。\n\n`f` 参数的值是 `sendTime`，定时器时间到时，会调用 `f`，并将 `arg` 和 `seq` 传给 `f`。\n\n因为 `Timer` 是一次性的，所以 `period` 保留默认值 0。\n\n\n### 常用方法\n#### time.After\n`time.After` 模拟超时：\n```go\nc := make(chan int)\n\ngo func() {\n\t// time.Sleep(1 * time.Second)\n\ttime.Sleep(3 * time.Second)\n\t<-c\n}()\n\nselect {\ncase c <- 1:\n\tfmt.Println(\"channel...\")\ncase <-time.After(2 * time.Second):\n\tclose(c)\n\tfmt.Println(\"timeout...\")\n}\n```\n\n#### time.Stop 和 time.Reset\n```go\nstart := time.Now()\ntimer := time.AfterFunc(2*time.Second, func() {\n\tfmt.Println(\"after func callback, elaspe:\", time.Now().Sub(start))\n})\n\ntime.Sleep(1 * time.Second)\n// time.Sleep(3*time.Second)\n// Reset 在 Timer 还未触发时返回 true；触发了或 Stop 了，返回 false\nif timer.Reset(3 * time.Second) {\n\tfmt.Println(\"timer has not trigger!\")\n} else {\n\tfmt.Println(\"timer had expired or stop!\")\n}\n\ntime.Sleep(10 * time.Second)\n\n// output:\n// timer has not trigger!\n// after func callback, elaspe: 4.00026461s\n```\n\n`timer.Stop()` 不会关闭 `Timer.C` 这个 channel，可以使用 `timer.Reset(0)` 代替 `timer.Stop()` 来停止定时器。\n\n#### Sleep\n\n`Sleep` 的是通过 `Timer` 实现的（查看 `runtime/time.go` 文件）。用于暂停当前 `goroutine`。\n\n## Ticker\n\n`Ticker` 和 `Timer` 类似，区别是：`Ticker` 中的 `runtimeTimer` 字段的 `period` 字段会赋值为 `NewTicker(d Duration)` 中的 `d`，\n表示每间隔 `d` 纳秒，定时器就会触发一次。\n\n除非程序终止前定时器一直需要触发，否则，不需要时应该调用 `Ticker.Stop` 来释放相关资源。\n\n如果程序终止前需要定时器一直触发，可以使用更简单方便的 `time.Tick` 函数，因为 `Ticker` 实例隐藏起来了，因此，该函数启动的定时器无法停止。\n","date":"2019-10-19T13:40:15.184Z","updated":"2019-10-19T13:40:15.184Z","path":"standards/time.html","comments":1,"layout":"page","_id":"ck1xm14l0000vfcw2vf6x09i5","content":"<h1 id=\"time\"><a href=\"#time\" class=\"headerlink\" title=\"time\"></a>time</h1><p><code>time</code> 提供了一个数据类型 <code>time.Time</code>（作为值使用）以及显示和测量时间和日期的功能函数，比如：</p>\n<ul>\n<li><code>time.Now()</code> 获取当前时间。</li>\n<li><code>t.Day()</code>、<code>t.Minute()</code> 获取时间的一部分。</li>\n<li><code>time.After</code>、<code>time.Ticker</code> 在经过一定时间或周期执行某项任务（事件处理的特例）。</li>\n<li><code>time.Sleep（Duration d）</code> 暂停某个进程（ goroutine），暂停时长为 <code>d</code>。</li>\n<li><code>Duration</code> 代表两个时间点之间经过的时间，以<strong>纳秒</strong>为单位，类型为 <code>int64</code>。</li>\n<li><code>Location</code> 类型映射某个时区的时间，UTC 表示通用协调世界时间。</li>\n</ul>\n<h2 id=\"时区\"><a href=\"#时区\" class=\"headerlink\" title=\"时区\"></a>时区</h2><p>Go 语言使用 <code>Location</code> 来表示地区相关的时区，一个 <code>Location</code> 可能表示多个时区。</p>\n<p><code>time</code> 包提供了 <code>Location</code> 的两个实例：</p>\n<ul>\n<li><code>Local</code> 代表当前系统本地时区；</li>\n<li><code>UTC</code> 代表通用协调时间，也就是零时区。<code>time</code> 包默认（为显示提供时区）使用 <code>UTC</code> 时区。</li>\n</ul>\n<h3 id=\"Local-是如何做到表示本地时区的？\"><a href=\"#Local-是如何做到表示本地时区的？\" class=\"headerlink\" title=\"Local 是如何做到表示本地时区的？\"></a>Local 是如何做到表示本地时区的？</h3><p>在初始化 <code>Local</code> 时，通过读取 <code>/etc/localtime</code> （这是一个符号链接，指向 <code>/usr/share/zoneinfo</code> 中某一个时区）可以获取到系统本地时区。</p>\n<p>如果设置了<strong>环境变量 <code>TZ</code></strong>，则会优先使用它。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tz, ok := syscall.Getenv(<span class=\"string\">\"TZ\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">switch</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">case</span> !ok:</span><br><span class=\"line\">\tz, err := loadZoneFile(<span class=\"string\">\"\"</span>, <span class=\"string\">\"/etc/localtime\"</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlocalLoc = *z</span><br><span class=\"line\">\t\tlocalLoc.name = <span class=\"string\">\"Local\"</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"><span class=\"keyword\">case</span> tz != <span class=\"string\">\"\"</span> &amp;&amp; tz != <span class=\"string\">\"UTC\"</span>:</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> z, err := loadLocation(tz); err == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlocalLoc = *z</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"获得特定时区的实例\"><a href=\"#获得特定时区的实例\" class=\"headerlink\" title=\"获得特定时区的实例\"></a>获得特定时区的实例</h3><p>函数 <code>LoadLocation</code> 可以根据名称获取特定时区的实例：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">LoadLocation</span><span class=\"params\">(name <span class=\"keyword\">string</span>)</span> <span class=\"params\">(*Location, error)</span></span></span><br></pre></td></tr></table></figure></p>\n<p>如果 <code>name</code> 是 “” 或 “UTC”，返回 UTC；<br>如果 <code>name</code> 是 “Local”，返回 <code>Local</code>；<br>否则 <code>name</code> 应该是 IANA 时区数据库里有记录的地点名（该数据库记录了地点和对应的时区），如 “America/New_York”。</p>\n<h2 id=\"Time\"><a href=\"#Time\" class=\"headerlink\" title=\"Time\"></a>Time</h2><p><code>Time</code> 代表一个纳秒精度的时间点。程序中应使用 <code>time.Time</code> 类型值来保存和传递时间，而不是指针。<br>程序中应使用 Time 类型值来保存和传递时间，而不是指针。<br>一个 Time 类型值可以被多个 go 协程同时使用。时间点可以使用 Before、After 和 Equal 方法进行比较。Sub 方法让两个时间点相减，<br>生成一个 Duration 类型值（代表时间段）。Add 方法给一个时间点加上一个时间段，生成一个新的 Time 类型时间点。</p>\n<p><code>Time</code> 零值代表时间点 <code>January 1, year 1, 00:00:00.000000000 UTC</code>。因为本时间点一般不会出现在使用中，<code>IsZero</code> 方法提供<br>了检验时间是否是显式初始化的一个简单途径。</p>\n<p>每一个 <code>Time</code> 都具有一个地点信息（即对应地点的时区信息），当计算时间的表示格式时，如 Format、Hour 和 Year 等方法，<br>都会考虑该信息。Local、UTC 和 In 方法返回一个指定时区（但指向同一时间点）的 Time。修改地点 / 时区信息只是会改变其表示；不会修改被表<br>示的时间点，因此也不会影响其计算。</p>\n<p>通过 <code>==</code> 比较 Time 时，Location 信息也会参与比较，因此 Time 不应该作为 map 的 key。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Time <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// sec gives the number of seconds elapsed since</span></span><br><span class=\"line\">\t<span class=\"comment\">// January 1, year 1 00:00:00 UTC.</span></span><br><span class=\"line\">\tsec <span class=\"keyword\">int64</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// nsec specifies a non-negative nanosecond</span></span><br><span class=\"line\">\t<span class=\"comment\">// offset within the second named by Seconds.</span></span><br><span class=\"line\">\t<span class=\"comment\">// It must be in the range [0, 999999999].</span></span><br><span class=\"line\">\tnsec <span class=\"keyword\">int32</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// loc specifies the Location that should be used to</span></span><br><span class=\"line\">\t<span class=\"comment\">// determine the minute, hour, month, day, and year</span></span><br><span class=\"line\">\t<span class=\"comment\">// that correspond to this Time.</span></span><br><span class=\"line\">\t<span class=\"comment\">// Only the zero Time has a nil Location.</span></span><br><span class=\"line\">\t<span class=\"comment\">// In that case it is interpreted to mean UTC.</span></span><br><span class=\"line\">\tloc *Location</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>先看 <code>time.Now()</code> 函数。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Now returns the current local time.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Now</span><span class=\"params\">()</span> <span class=\"title\">Time</span></span> &#123;</span><br><span class=\"line\">\tsec, nsec := now()</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> Time&#123;sec + unixToInternal, nsec, Local&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>now()</code> 的具体实现在 <code>runtime</code> 包中。从 <code>Time{sec + unixToInternal, nsec, Local}</code> 可以看出，<code>Time</code> 结构的 <code>sec</code> 并非 Unix<br>时间戳，实际上，加上的 <code>unixToInternal</code> 是 <code>1-1-1</code> 到 <code>1970-1-1</code> 经历的秒数。也就是 <code>Time</code> 中的 <code>sec</code> 是从 <code>1-1-1</code> 算起的秒数，<br>而不是 Unix 时间戳。</p>\n<p><code>Time</code> 的最后一个字段表示地点时区信息。本章后面会专门介绍。</p>\n<h3 id=\"常用方法\"><a href=\"#常用方法\" class=\"headerlink\" title=\"常用方法\"></a>常用方法</h3><ul>\n<li><code>Time.IsZero()</code> 函数用于判断 Time 表示的时间是否是 0 值。表示 1 年 1 月 1 日。</li>\n<li><code>time.Unix(sec, nsec int64</code>) 通过 Unix 时间戳生成 <code>time.Time</code> 实例；</li>\n<li><code>time.Time.Unix()</code> 得到 Unix 时间戳；</li>\n<li><code>time.Time.UnixNano()</code> 得到 Unix 时间戳的纳秒表示；</li>\n<li><code>time.Parse</code> 和 <code>time.ParseInLocation</code></li>\n<li><code>time.Time.Format</code></li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">t, _ := time.Parse(<span class=\"string\">\"2006-01-02 15:04:05\"</span>, <span class=\"string\">\"2016-06-13 09:14:00\"</span>)</span><br><span class=\"line\">fmt.Println(time.Now().Sub(t).Hours())</span><br></pre></td></tr></table></figure>\n<p>这段代码的结果跟预期的不一样。原因是 <code>time.Now()</code> 的时区是 <code>time.Local</code>，而 <code>time.Parse</code> 解析出来的时区却是 <code>time.UTC</code><br>（可以通过 <code>Time.Location()</code> 函数知道是哪个时区）。在中国，它们相差 8 小时。</p>\n<p>所以，一般的，我们应该总是使用 <code>time.ParseInLocation</code> 来解析时间，并给第三个参数传递 <code>time.Local</code>。</p>\n<h4 id=\"为什么是-2006-01-02-15-04-05\"><a href=\"#为什么是-2006-01-02-15-04-05\" class=\"headerlink\" title=\"为什么是 2006-01-02 15:04:05\"></a>为什么是 2006-01-02 15:04:05</h4><p>可能你已经注意到：<code>2006-01-02 15:04:05</code> 这个字符串了。没错，这是固定写法，类似于其他语言中 <code>Y-m-d H:i:s</code> 等。为什么采用这种形式？<br>又为什么是这个时间点而不是其他时间点？</p>\n<ul>\n<li>官方说，使用具体的时间，比使用 <code>Y-m-d H:i:s</code> 更容易理解和记忆；</li>\n<li>而选择这个时间点，也是出于好记的考虑，官方的例子：<code>Mon Jan 2 15:04:05 MST 2006</code>，很好记：2006 年 1 月 2 日 3 点 4 分 5 秒</li>\n</ul>\n<h4 id=\"Round-和-Truncate-方法\"><a href=\"#Round-和-Truncate-方法\" class=\"headerlink\" title=\"Round 和 Truncate 方法\"></a>Round 和 Truncate 方法</h4><p>比如，有这么个需求：获取当前时间整点的 <code>Time</code> 实例。例如，当前时间是 <code>15:54:23</code>，需要的是 <code>15:00:00</code>。我们可以这么做：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">t, _ := time.ParseInLocation(&quot;2006-01-02 15:04:05&quot;, time.Now().Format(&quot;2006-01-02 15:00:00&quot;), time.Local)</span><br><span class=\"line\">fmt.Println(t)</span><br></pre></td></tr></table></figure>\n<p>实际上，<code>time</code> 包给我们提供了专门的方法，功能更强大，性能也更好，这就是 <code>Round</code> 和 <code>Trunate</code>，它们区别，一个是取最接近的，一个是向下取整。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">t, _ := time.ParseInLocation(<span class=\"string\">\"2006-01-02 15:04:05\"</span>, <span class=\"string\">\"2016-06-13 15:34:39\"</span>, time.Local)</span><br><span class=\"line\"><span class=\"comment\">// 整点（向下取整）</span></span><br><span class=\"line\">fmt.Println(t.Truncate(<span class=\"number\">1</span> * time.Hour))</span><br><span class=\"line\"><span class=\"comment\">// 整点（最接近）</span></span><br><span class=\"line\">fmt.Println(t.Round(<span class=\"number\">1</span> * time.Hour))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 整分（向下取整）</span></span><br><span class=\"line\">fmt.Println(t.Truncate(<span class=\"number\">1</span> * time.Minute))</span><br><span class=\"line\"><span class=\"comment\">// 整分（最接近）</span></span><br><span class=\"line\">fmt.Println(t.Round(<span class=\"number\">1</span> * time.Minute))</span><br><span class=\"line\"></span><br><span class=\"line\">t2, _ := time.ParseInLocation(<span class=\"string\">\"2006-01-02 15:04:05\"</span>, t.Format(<span class=\"string\">\"2006-01-02 15:00:00\"</span>), time.Local)</span><br><span class=\"line\">fmt.Println(t2)</span><br></pre></td></tr></table></figure>\n<h4 id=\"Format\"><a href=\"#Format\" class=\"headerlink\" title=\"Format\"></a>Format</h4><p>自定义时间格式化字符串，例如： <code>fmt.Printf(&quot;%02d.%02d.%4d\\n&quot;, t.Day(), t.Month(), t.Year())</code> 将会输出 <code>21.07.2011</code>。</p>\n<p>包中的一个预定义函数 <code>func (t Time) Format(layout string) string</code> 可以根据一个格式化字符串来将一个时间 t 转换为相应<br>格式的字符串，你可以使用一些预定义的格式，如：<code>time.ANSIC</code> 或 <code>time.RFC822</code>。</p>\n<p>一般的格式化设计是通过对于一个标准时间的格式化描述来展现的，示例：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fmt.Println(t.Format(<span class=\"string\">\"02 Jan 2006 15:04\"</span>)) <span class=\"comment\">// 21 Jul 2011 10:31</span></span><br></pre></td></tr></table></figure>\n<p>示例：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">\"fmt\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"time\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> week time.Duration</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tt := time.Now()</span><br><span class=\"line\">\tfmt.Println(t) <span class=\"comment\">// e.g. Wed Dec 21 09:52:14 +0100 RST 2011</span></span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"%02d.%02d.%4d\\n\"</span>, t.Day(), t.Month(), t.Year())</span><br><span class=\"line\">\t<span class=\"comment\">// 21.12.2011</span></span><br><span class=\"line\">\tt = time.Now().UTC()</span><br><span class=\"line\">\tfmt.Println(t) <span class=\"comment\">// Wed Dec 21 08:52:14 +0000 UTC 2011</span></span><br><span class=\"line\">\tfmt.Println(time.Now()) <span class=\"comment\">// Wed Dec 21 09:52:14 +0100 RST 2011</span></span><br><span class=\"line\">\t<span class=\"comment\">// calculating times:</span></span><br><span class=\"line\">\tweek = <span class=\"number\">60</span> * <span class=\"number\">60</span> * <span class=\"number\">24</span> * <span class=\"number\">7</span> * <span class=\"number\">1e9</span> <span class=\"comment\">// must be in nanosec</span></span><br><span class=\"line\">\tweek_from_now := t.Add(time.Duration(week))</span><br><span class=\"line\">\tfmt.Println(week_from_now) <span class=\"comment\">// Wed Dec 28 08:52:14 +0000 UTC 2011</span></span><br><span class=\"line\">\t<span class=\"comment\">// formatting times:</span></span><br><span class=\"line\">\tfmt.Println(t.Format(time.RFC822)) <span class=\"comment\">// 21 Dec 11 0852 UTC</span></span><br><span class=\"line\">\tfmt.Println(t.Format(time.ANSIC)) <span class=\"comment\">// Wed Dec 21 08:56:34 2011</span></span><br><span class=\"line\">\tfmt.Println(t.Format(<span class=\"string\">\"02 Jan 2006 15:04\"</span>)) <span class=\"comment\">// 21 Dec 2011 08:52</span></span><br><span class=\"line\">\ts := t.Format(<span class=\"string\">\"20060102\"</span>)</span><br><span class=\"line\">\tfmt.Println(t, <span class=\"string\">\"=&gt;\"</span>, s)</span><br><span class=\"line\">\t<span class=\"comment\">// Wed Dec 21 08:52:14 +0000 UTC 2011 =&gt; 20111221</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>示例，计算函数执行时间：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">start := time.Now() <span class=\"comment\">// 起始时间</span></span><br><span class=\"line\">longCalculation()</span><br><span class=\"line\">end := time.Now() <span class=\"comment\">// 结束时间</span></span><br><span class=\"line\">delta := end.Sub(start) <span class=\"comment\">// 消耗时间</span></span><br><span class=\"line\">fmt.Printf(<span class=\"string\">\"longCalculation took this amount of time: %s\\n\"</span>, delta)</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"定时器\"><a href=\"#定时器\" class=\"headerlink\" title=\"定时器\"></a>定时器</h2><p><code>time</code> 包有两种定时器：</p>\n<ul>\n<li><code>Timer</code>（到达指定时间触发且只触发一次）</li>\n<li><code>Ticker</code>（间隔特定时间触发）。</li>\n</ul>\n<h3 id=\"Timer\"><a href=\"#Timer\" class=\"headerlink\" title=\"Timer\"></a>Timer</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Timer <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tC &lt;-<span class=\"keyword\">chan</span> Time\t <span class=\"comment\">// The channel on which the time is delivered.</span></span><br><span class=\"line\">\tr runtimeTimer</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>Timer</code> 的实例必须通过 <code>NewTimer</code> 或 <code>AfterFunc</code> 获得。<br><strong>当 <code>Timer</code> 到期时，当时的时间会被发送给 <code>C</code> (channel)，除非 <code>Timer</code> 是被 <code>AfterFunc</code> 函数创建的</strong>。</p>\n<p><code>runtimeTimer</code> 定义在 <code>sleep.go</code> 文件中，必须和 <code>runtime</code> 包中 <code>time.go</code> 文件中的 <code>timer</code> 保持一致：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> timer <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\ti <span class=\"keyword\">int</span> <span class=\"comment\">// heap index</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// Timer wakes up at when, and then at when+period, ... (period &gt; 0 only)</span></span><br><span class=\"line\">\t<span class=\"comment\">// each time calling f(now, arg) in the timer goroutine, so f must be</span></span><br><span class=\"line\">\t<span class=\"comment\">// a well-behaved function and not block.</span></span><br><span class=\"line\">\twhen   <span class=\"keyword\">int64</span></span><br><span class=\"line\">\tperiod <span class=\"keyword\">int64</span></span><br><span class=\"line\">\tf      <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(<span class=\"keyword\">interface</span>&#123;&#125;, <span class=\"keyword\">uintptr</span>)</span></span></span><br><span class=\"line\"><span class=\"function\">\t<span class=\"title\">arg</span>    <span class=\"title\">interface</span></span>&#123;&#125;</span><br><span class=\"line\">\tseq    <span class=\"keyword\">uintptr</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>通过 <code>NewTimer()</code> 来看这些字段：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// NewTimer creates a new Timer that will send</span></span><br><span class=\"line\"><span class=\"comment\">// the current time on its channel after at least duration d.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewTimer</span><span class=\"params\">(d Duration)</span> *<span class=\"title\">Timer</span></span> &#123;</span><br><span class=\"line\">\tc := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> Time, <span class=\"number\">1</span>)</span><br><span class=\"line\">\tt := &amp;Timer&#123;</span><br><span class=\"line\">\t\tC: c,</span><br><span class=\"line\">\t\tr: runtimeTimer&#123;</span><br><span class=\"line\">\t\t\twhen: when(d),</span><br><span class=\"line\">\t\t\tf:    sendTime,</span><br><span class=\"line\">\t\t\targ:  c,</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tstartTimer(&amp;t.r)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 <code>when</code> 表示的时间到时，会往 <code>Timer.C</code> 中发送当前时间。<code>when</code> 表示的时间是纳秒时间，正常通过 <code>runtimeNano() + int64(d)</code> 赋值。</p>\n<p><code>f</code> 参数的值是 <code>sendTime</code>，定时器时间到时，会调用 <code>f</code>，并将 <code>arg</code> 和 <code>seq</code> 传给 <code>f</code>。</p>\n<p>因为 <code>Timer</code> 是一次性的，所以 <code>period</code> 保留默认值 0。</p>\n<h3 id=\"常用方法-1\"><a href=\"#常用方法-1\" class=\"headerlink\" title=\"常用方法\"></a>常用方法</h3><h4 id=\"time-After\"><a href=\"#time-After\" class=\"headerlink\" title=\"time.After\"></a>time.After</h4><p><code>time.After</code> 模拟超时：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">c := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// time.Sleep(1 * time.Second)</span></span><br><span class=\"line\">\ttime.Sleep(<span class=\"number\">3</span> * time.Second)</span><br><span class=\"line\">\t&lt;-c</span><br><span class=\"line\">&#125;()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">select</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">case</span> c &lt;- <span class=\"number\">1</span>:</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">\"channel...\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">case</span> &lt;-time.After(<span class=\"number\">2</span> * time.Second):</span><br><span class=\"line\">\t<span class=\"built_in\">close</span>(c)</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">\"timeout...\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"time-Stop-和-time-Reset\"><a href=\"#time-Stop-和-time-Reset\" class=\"headerlink\" title=\"time.Stop 和 time.Reset\"></a>time.Stop 和 time.Reset</h4><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">start := time.Now()</span><br><span class=\"line\">timer := time.AfterFunc(<span class=\"number\">2</span>*time.Second, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">\"after func callback, elaspe:\"</span>, time.Now().Sub(start))</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">time.Sleep(<span class=\"number\">1</span> * time.Second)</span><br><span class=\"line\"><span class=\"comment\">// time.Sleep(3*time.Second)</span></span><br><span class=\"line\"><span class=\"comment\">// Reset 在 Timer 还未触发时返回 true；触发了或 Stop 了，返回 false</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> timer.Reset(<span class=\"number\">3</span> * time.Second) &#123;</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">\"timer has not trigger!\"</span>)</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">\"timer had expired or stop!\"</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">time.Sleep(<span class=\"number\">10</span> * time.Second)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// output:</span></span><br><span class=\"line\"><span class=\"comment\">// timer has not trigger!</span></span><br><span class=\"line\"><span class=\"comment\">// after func callback, elaspe: 4.00026461s</span></span><br></pre></td></tr></table></figure>\n<p><code>timer.Stop()</code> 不会关闭 <code>Timer.C</code> 这个 channel，可以使用 <code>timer.Reset(0)</code> 代替 <code>timer.Stop()</code> 来停止定时器。</p>\n<h4 id=\"Sleep\"><a href=\"#Sleep\" class=\"headerlink\" title=\"Sleep\"></a>Sleep</h4><p><code>Sleep</code> 的是通过 <code>Timer</code> 实现的（查看 <code>runtime/time.go</code> 文件）。用于暂停当前 <code>goroutine</code>。</p>\n<h2 id=\"Ticker\"><a href=\"#Ticker\" class=\"headerlink\" title=\"Ticker\"></a>Ticker</h2><p><code>Ticker</code> 和 <code>Timer</code> 类似，区别是：<code>Ticker</code> 中的 <code>runtimeTimer</code> 字段的 <code>period</code> 字段会赋值为 <code>NewTicker(d Duration)</code> 中的 <code>d</code>，<br>表示每间隔 <code>d</code> 纳秒，定时器就会触发一次。</p>\n<p>除非程序终止前定时器一直需要触发，否则，不需要时应该调用 <code>Ticker.Stop</code> 来释放相关资源。</p>\n<p>如果程序终止前需要定时器一直触发，可以使用更简单方便的 <code>time.Tick</code> 函数，因为 <code>Ticker</code> 实例隐藏起来了，因此，该函数启动的定时器无法停止。</p>\n","site":{"data":{"navigation":{"logo":{"text":"Golang Learn","type":"link","path":"index.html"},"main":[{"text":"Golang 基础","type":"label"},{"text":"Go 环境配置","type":"link","path":"basic/env_config.html"},{"text":"包","type":"link","path":"basic/package.html"},{"text":"基础数据类型","type":"link","path":"basic/basic_data.html"},{"text":"变量","type":"link","path":"basic/var.html"},{"text":"常量","type":"link","path":"basic/constant.html"},{"text":"控制语句","type":"link","path":"basic/flow.html"},{"text":"运算符","type":"link","path":"basic/operator.html"},{"text":"作用域","type":"link","path":"basic/scope.html"},{"text":"指针","type":"link","path":"basic/pointer.html"},{"text":"数组","type":"link","path":"basic/array.html"},{"text":"切片","type":"link","path":"basic/slice.html"},{"text":"字典","type":"link","path":"basic/map.html"},{"text":"函数","type":"link","path":"basic/function.html"},{"text":"结构体","type":"link","path":"basic/struct.html"},{"text":"接口","type":"link","path":"basic/interface.html"},{"text":"面向对象","type":"link","path":"basic/oop.html"},{"text":"错误","type":"link","path":"basic/error.html"},{"text":"序列化","type":"link","path":"basic/json.html"},{"text":"反射","type":"link","path":"basic/reflect.html"},{"text":"测试","type":"link","path":"basic/test.html"},{"text":"并发编程","type":"label"},{"text":"goroutine","type":"link","path":"concurrent/goroutine.html"},{"text":"channel","type":"link","path":"concurrent/channel.html"},{"text":"同步和锁","type":"link","path":"concurrent/sync_lock.html"},{"text":"内存分配","type":"label"},{"text":"内存分配","type":"link","path":"advance/mm.html"},{"text":"垃圾回收","type":"label"},{"text":"垃圾回收","type":"link","path":"advance/gc.html"},{"text":"标准库","type":"label"},{"text":"fmt","type":"link","path":"standards/io/fmt.html"},{"text":"io","type":"link","path":"standards/io/io.html"},{"text":"ioutil","type":"link","path":"standards/io/ioutil.html"},{"text":"bufio","type":"link","path":"standards/io/bufio.html"},{"text":"os","type":"link","path":"standards/os/os.html"},{"text":"filepath","type":"link","path":"standards/os/filepath.html"},{"text":"strings","type":"link","path":"standards/text/strings.html"},{"text":"strconv","type":"link","path":"standards/text/strconv.html"},{"text":"unicode","type":"link","path":"standards/text/unicode.html"},{"text":"log","type":"link","path":"standards/log.html"},{"text":"time","type":"link","path":"standards/time.html"},{"text":"http","type":"link","path":"standards/net/http.html"},{"text":"math","type":"link","path":"standards/data/math.html"},{"text":"sort","type":"link","path":"standards/data/sort.html"},{"text":"big","type":"link","path":"standards/data/big.html"},{"text":"container","type":"link","path":"standards/data/container.html"},{"text":"sql","type":"link","path":"standards/database/sql.html"},{"text":"THEME","type":"label"},{"text":"使用文档主题","type":"link","path":"theme/theme-usage.html"},{"text":"SUPPORT AND FEEDBACK","type":"label"},{"text":"Raise an Issue on Github","type":"link","path":"https://github.com/shipengqi/golang-learn/issues/new"}]}}},"excerpt":"","more":"<h1 id=\"time\"><a href=\"#time\" class=\"headerlink\" title=\"time\"></a>time</h1><p><code>time</code> 提供了一个数据类型 <code>time.Time</code>（作为值使用）以及显示和测量时间和日期的功能函数，比如：</p>\n<ul>\n<li><code>time.Now()</code> 获取当前时间。</li>\n<li><code>t.Day()</code>、<code>t.Minute()</code> 获取时间的一部分。</li>\n<li><code>time.After</code>、<code>time.Ticker</code> 在经过一定时间或周期执行某项任务（事件处理的特例）。</li>\n<li><code>time.Sleep（Duration d）</code> 暂停某个进程（ goroutine），暂停时长为 <code>d</code>。</li>\n<li><code>Duration</code> 代表两个时间点之间经过的时间，以<strong>纳秒</strong>为单位，类型为 <code>int64</code>。</li>\n<li><code>Location</code> 类型映射某个时区的时间，UTC 表示通用协调世界时间。</li>\n</ul>\n<h2 id=\"时区\"><a href=\"#时区\" class=\"headerlink\" title=\"时区\"></a>时区</h2><p>Go 语言使用 <code>Location</code> 来表示地区相关的时区，一个 <code>Location</code> 可能表示多个时区。</p>\n<p><code>time</code> 包提供了 <code>Location</code> 的两个实例：</p>\n<ul>\n<li><code>Local</code> 代表当前系统本地时区；</li>\n<li><code>UTC</code> 代表通用协调时间，也就是零时区。<code>time</code> 包默认（为显示提供时区）使用 <code>UTC</code> 时区。</li>\n</ul>\n<h3 id=\"Local-是如何做到表示本地时区的？\"><a href=\"#Local-是如何做到表示本地时区的？\" class=\"headerlink\" title=\"Local 是如何做到表示本地时区的？\"></a>Local 是如何做到表示本地时区的？</h3><p>在初始化 <code>Local</code> 时，通过读取 <code>/etc/localtime</code> （这是一个符号链接，指向 <code>/usr/share/zoneinfo</code> 中某一个时区）可以获取到系统本地时区。</p>\n<p>如果设置了<strong>环境变量 <code>TZ</code></strong>，则会优先使用它。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tz, ok := syscall.Getenv(<span class=\"string\">\"TZ\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">switch</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">case</span> !ok:</span><br><span class=\"line\">\tz, err := loadZoneFile(<span class=\"string\">\"\"</span>, <span class=\"string\">\"/etc/localtime\"</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlocalLoc = *z</span><br><span class=\"line\">\t\tlocalLoc.name = <span class=\"string\">\"Local\"</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"><span class=\"keyword\">case</span> tz != <span class=\"string\">\"\"</span> &amp;&amp; tz != <span class=\"string\">\"UTC\"</span>:</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> z, err := loadLocation(tz); err == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlocalLoc = *z</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"获得特定时区的实例\"><a href=\"#获得特定时区的实例\" class=\"headerlink\" title=\"获得特定时区的实例\"></a>获得特定时区的实例</h3><p>函数 <code>LoadLocation</code> 可以根据名称获取特定时区的实例：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">LoadLocation</span><span class=\"params\">(name <span class=\"keyword\">string</span>)</span> <span class=\"params\">(*Location, error)</span></span></span><br></pre></td></tr></table></figure></p>\n<p>如果 <code>name</code> 是 “” 或 “UTC”，返回 UTC；<br>如果 <code>name</code> 是 “Local”，返回 <code>Local</code>；<br>否则 <code>name</code> 应该是 IANA 时区数据库里有记录的地点名（该数据库记录了地点和对应的时区），如 “America/New_York”。</p>\n<h2 id=\"Time\"><a href=\"#Time\" class=\"headerlink\" title=\"Time\"></a>Time</h2><p><code>Time</code> 代表一个纳秒精度的时间点。程序中应使用 <code>time.Time</code> 类型值来保存和传递时间，而不是指针。<br>程序中应使用 Time 类型值来保存和传递时间，而不是指针。<br>一个 Time 类型值可以被多个 go 协程同时使用。时间点可以使用 Before、After 和 Equal 方法进行比较。Sub 方法让两个时间点相减，<br>生成一个 Duration 类型值（代表时间段）。Add 方法给一个时间点加上一个时间段，生成一个新的 Time 类型时间点。</p>\n<p><code>Time</code> 零值代表时间点 <code>January 1, year 1, 00:00:00.000000000 UTC</code>。因为本时间点一般不会出现在使用中，<code>IsZero</code> 方法提供<br>了检验时间是否是显式初始化的一个简单途径。</p>\n<p>每一个 <code>Time</code> 都具有一个地点信息（即对应地点的时区信息），当计算时间的表示格式时，如 Format、Hour 和 Year 等方法，<br>都会考虑该信息。Local、UTC 和 In 方法返回一个指定时区（但指向同一时间点）的 Time。修改地点 / 时区信息只是会改变其表示；不会修改被表<br>示的时间点，因此也不会影响其计算。</p>\n<p>通过 <code>==</code> 比较 Time 时，Location 信息也会参与比较，因此 Time 不应该作为 map 的 key。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Time <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// sec gives the number of seconds elapsed since</span></span><br><span class=\"line\">\t<span class=\"comment\">// January 1, year 1 00:00:00 UTC.</span></span><br><span class=\"line\">\tsec <span class=\"keyword\">int64</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// nsec specifies a non-negative nanosecond</span></span><br><span class=\"line\">\t<span class=\"comment\">// offset within the second named by Seconds.</span></span><br><span class=\"line\">\t<span class=\"comment\">// It must be in the range [0, 999999999].</span></span><br><span class=\"line\">\tnsec <span class=\"keyword\">int32</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// loc specifies the Location that should be used to</span></span><br><span class=\"line\">\t<span class=\"comment\">// determine the minute, hour, month, day, and year</span></span><br><span class=\"line\">\t<span class=\"comment\">// that correspond to this Time.</span></span><br><span class=\"line\">\t<span class=\"comment\">// Only the zero Time has a nil Location.</span></span><br><span class=\"line\">\t<span class=\"comment\">// In that case it is interpreted to mean UTC.</span></span><br><span class=\"line\">\tloc *Location</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>先看 <code>time.Now()</code> 函数。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Now returns the current local time.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Now</span><span class=\"params\">()</span> <span class=\"title\">Time</span></span> &#123;</span><br><span class=\"line\">\tsec, nsec := now()</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> Time&#123;sec + unixToInternal, nsec, Local&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>now()</code> 的具体实现在 <code>runtime</code> 包中。从 <code>Time{sec + unixToInternal, nsec, Local}</code> 可以看出，<code>Time</code> 结构的 <code>sec</code> 并非 Unix<br>时间戳，实际上，加上的 <code>unixToInternal</code> 是 <code>1-1-1</code> 到 <code>1970-1-1</code> 经历的秒数。也就是 <code>Time</code> 中的 <code>sec</code> 是从 <code>1-1-1</code> 算起的秒数，<br>而不是 Unix 时间戳。</p>\n<p><code>Time</code> 的最后一个字段表示地点时区信息。本章后面会专门介绍。</p>\n<h3 id=\"常用方法\"><a href=\"#常用方法\" class=\"headerlink\" title=\"常用方法\"></a>常用方法</h3><ul>\n<li><code>Time.IsZero()</code> 函数用于判断 Time 表示的时间是否是 0 值。表示 1 年 1 月 1 日。</li>\n<li><code>time.Unix(sec, nsec int64</code>) 通过 Unix 时间戳生成 <code>time.Time</code> 实例；</li>\n<li><code>time.Time.Unix()</code> 得到 Unix 时间戳；</li>\n<li><code>time.Time.UnixNano()</code> 得到 Unix 时间戳的纳秒表示；</li>\n<li><code>time.Parse</code> 和 <code>time.ParseInLocation</code></li>\n<li><code>time.Time.Format</code></li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">t, _ := time.Parse(<span class=\"string\">\"2006-01-02 15:04:05\"</span>, <span class=\"string\">\"2016-06-13 09:14:00\"</span>)</span><br><span class=\"line\">fmt.Println(time.Now().Sub(t).Hours())</span><br></pre></td></tr></table></figure>\n<p>这段代码的结果跟预期的不一样。原因是 <code>time.Now()</code> 的时区是 <code>time.Local</code>，而 <code>time.Parse</code> 解析出来的时区却是 <code>time.UTC</code><br>（可以通过 <code>Time.Location()</code> 函数知道是哪个时区）。在中国，它们相差 8 小时。</p>\n<p>所以，一般的，我们应该总是使用 <code>time.ParseInLocation</code> 来解析时间，并给第三个参数传递 <code>time.Local</code>。</p>\n<h4 id=\"为什么是-2006-01-02-15-04-05\"><a href=\"#为什么是-2006-01-02-15-04-05\" class=\"headerlink\" title=\"为什么是 2006-01-02 15:04:05\"></a>为什么是 2006-01-02 15:04:05</h4><p>可能你已经注意到：<code>2006-01-02 15:04:05</code> 这个字符串了。没错，这是固定写法，类似于其他语言中 <code>Y-m-d H:i:s</code> 等。为什么采用这种形式？<br>又为什么是这个时间点而不是其他时间点？</p>\n<ul>\n<li>官方说，使用具体的时间，比使用 <code>Y-m-d H:i:s</code> 更容易理解和记忆；</li>\n<li>而选择这个时间点，也是出于好记的考虑，官方的例子：<code>Mon Jan 2 15:04:05 MST 2006</code>，很好记：2006 年 1 月 2 日 3 点 4 分 5 秒</li>\n</ul>\n<h4 id=\"Round-和-Truncate-方法\"><a href=\"#Round-和-Truncate-方法\" class=\"headerlink\" title=\"Round 和 Truncate 方法\"></a>Round 和 Truncate 方法</h4><p>比如，有这么个需求：获取当前时间整点的 <code>Time</code> 实例。例如，当前时间是 <code>15:54:23</code>，需要的是 <code>15:00:00</code>。我们可以这么做：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">t, _ := time.ParseInLocation(&quot;2006-01-02 15:04:05&quot;, time.Now().Format(&quot;2006-01-02 15:00:00&quot;), time.Local)</span><br><span class=\"line\">fmt.Println(t)</span><br></pre></td></tr></table></figure>\n<p>实际上，<code>time</code> 包给我们提供了专门的方法，功能更强大，性能也更好，这就是 <code>Round</code> 和 <code>Trunate</code>，它们区别，一个是取最接近的，一个是向下取整。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">t, _ := time.ParseInLocation(<span class=\"string\">\"2006-01-02 15:04:05\"</span>, <span class=\"string\">\"2016-06-13 15:34:39\"</span>, time.Local)</span><br><span class=\"line\"><span class=\"comment\">// 整点（向下取整）</span></span><br><span class=\"line\">fmt.Println(t.Truncate(<span class=\"number\">1</span> * time.Hour))</span><br><span class=\"line\"><span class=\"comment\">// 整点（最接近）</span></span><br><span class=\"line\">fmt.Println(t.Round(<span class=\"number\">1</span> * time.Hour))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 整分（向下取整）</span></span><br><span class=\"line\">fmt.Println(t.Truncate(<span class=\"number\">1</span> * time.Minute))</span><br><span class=\"line\"><span class=\"comment\">// 整分（最接近）</span></span><br><span class=\"line\">fmt.Println(t.Round(<span class=\"number\">1</span> * time.Minute))</span><br><span class=\"line\"></span><br><span class=\"line\">t2, _ := time.ParseInLocation(<span class=\"string\">\"2006-01-02 15:04:05\"</span>, t.Format(<span class=\"string\">\"2006-01-02 15:00:00\"</span>), time.Local)</span><br><span class=\"line\">fmt.Println(t2)</span><br></pre></td></tr></table></figure>\n<h4 id=\"Format\"><a href=\"#Format\" class=\"headerlink\" title=\"Format\"></a>Format</h4><p>自定义时间格式化字符串，例如： <code>fmt.Printf(&quot;%02d.%02d.%4d\\n&quot;, t.Day(), t.Month(), t.Year())</code> 将会输出 <code>21.07.2011</code>。</p>\n<p>包中的一个预定义函数 <code>func (t Time) Format(layout string) string</code> 可以根据一个格式化字符串来将一个时间 t 转换为相应<br>格式的字符串，你可以使用一些预定义的格式，如：<code>time.ANSIC</code> 或 <code>time.RFC822</code>。</p>\n<p>一般的格式化设计是通过对于一个标准时间的格式化描述来展现的，示例：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fmt.Println(t.Format(<span class=\"string\">\"02 Jan 2006 15:04\"</span>)) <span class=\"comment\">// 21 Jul 2011 10:31</span></span><br></pre></td></tr></table></figure>\n<p>示例：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">\"fmt\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"time\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> week time.Duration</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tt := time.Now()</span><br><span class=\"line\">\tfmt.Println(t) <span class=\"comment\">// e.g. Wed Dec 21 09:52:14 +0100 RST 2011</span></span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"%02d.%02d.%4d\\n\"</span>, t.Day(), t.Month(), t.Year())</span><br><span class=\"line\">\t<span class=\"comment\">// 21.12.2011</span></span><br><span class=\"line\">\tt = time.Now().UTC()</span><br><span class=\"line\">\tfmt.Println(t) <span class=\"comment\">// Wed Dec 21 08:52:14 +0000 UTC 2011</span></span><br><span class=\"line\">\tfmt.Println(time.Now()) <span class=\"comment\">// Wed Dec 21 09:52:14 +0100 RST 2011</span></span><br><span class=\"line\">\t<span class=\"comment\">// calculating times:</span></span><br><span class=\"line\">\tweek = <span class=\"number\">60</span> * <span class=\"number\">60</span> * <span class=\"number\">24</span> * <span class=\"number\">7</span> * <span class=\"number\">1e9</span> <span class=\"comment\">// must be in nanosec</span></span><br><span class=\"line\">\tweek_from_now := t.Add(time.Duration(week))</span><br><span class=\"line\">\tfmt.Println(week_from_now) <span class=\"comment\">// Wed Dec 28 08:52:14 +0000 UTC 2011</span></span><br><span class=\"line\">\t<span class=\"comment\">// formatting times:</span></span><br><span class=\"line\">\tfmt.Println(t.Format(time.RFC822)) <span class=\"comment\">// 21 Dec 11 0852 UTC</span></span><br><span class=\"line\">\tfmt.Println(t.Format(time.ANSIC)) <span class=\"comment\">// Wed Dec 21 08:56:34 2011</span></span><br><span class=\"line\">\tfmt.Println(t.Format(<span class=\"string\">\"02 Jan 2006 15:04\"</span>)) <span class=\"comment\">// 21 Dec 2011 08:52</span></span><br><span class=\"line\">\ts := t.Format(<span class=\"string\">\"20060102\"</span>)</span><br><span class=\"line\">\tfmt.Println(t, <span class=\"string\">\"=&gt;\"</span>, s)</span><br><span class=\"line\">\t<span class=\"comment\">// Wed Dec 21 08:52:14 +0000 UTC 2011 =&gt; 20111221</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>示例，计算函数执行时间：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">start := time.Now() <span class=\"comment\">// 起始时间</span></span><br><span class=\"line\">longCalculation()</span><br><span class=\"line\">end := time.Now() <span class=\"comment\">// 结束时间</span></span><br><span class=\"line\">delta := end.Sub(start) <span class=\"comment\">// 消耗时间</span></span><br><span class=\"line\">fmt.Printf(<span class=\"string\">\"longCalculation took this amount of time: %s\\n\"</span>, delta)</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"定时器\"><a href=\"#定时器\" class=\"headerlink\" title=\"定时器\"></a>定时器</h2><p><code>time</code> 包有两种定时器：</p>\n<ul>\n<li><code>Timer</code>（到达指定时间触发且只触发一次）</li>\n<li><code>Ticker</code>（间隔特定时间触发）。</li>\n</ul>\n<h3 id=\"Timer\"><a href=\"#Timer\" class=\"headerlink\" title=\"Timer\"></a>Timer</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Timer <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tC &lt;-<span class=\"keyword\">chan</span> Time\t <span class=\"comment\">// The channel on which the time is delivered.</span></span><br><span class=\"line\">\tr runtimeTimer</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>Timer</code> 的实例必须通过 <code>NewTimer</code> 或 <code>AfterFunc</code> 获得。<br><strong>当 <code>Timer</code> 到期时，当时的时间会被发送给 <code>C</code> (channel)，除非 <code>Timer</code> 是被 <code>AfterFunc</code> 函数创建的</strong>。</p>\n<p><code>runtimeTimer</code> 定义在 <code>sleep.go</code> 文件中，必须和 <code>runtime</code> 包中 <code>time.go</code> 文件中的 <code>timer</code> 保持一致：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> timer <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\ti <span class=\"keyword\">int</span> <span class=\"comment\">// heap index</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// Timer wakes up at when, and then at when+period, ... (period &gt; 0 only)</span></span><br><span class=\"line\">\t<span class=\"comment\">// each time calling f(now, arg) in the timer goroutine, so f must be</span></span><br><span class=\"line\">\t<span class=\"comment\">// a well-behaved function and not block.</span></span><br><span class=\"line\">\twhen   <span class=\"keyword\">int64</span></span><br><span class=\"line\">\tperiod <span class=\"keyword\">int64</span></span><br><span class=\"line\">\tf      <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(<span class=\"keyword\">interface</span>&#123;&#125;, <span class=\"keyword\">uintptr</span>)</span></span></span><br><span class=\"line\"><span class=\"function\">\t<span class=\"title\">arg</span>    <span class=\"title\">interface</span></span>&#123;&#125;</span><br><span class=\"line\">\tseq    <span class=\"keyword\">uintptr</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>通过 <code>NewTimer()</code> 来看这些字段：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// NewTimer creates a new Timer that will send</span></span><br><span class=\"line\"><span class=\"comment\">// the current time on its channel after at least duration d.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewTimer</span><span class=\"params\">(d Duration)</span> *<span class=\"title\">Timer</span></span> &#123;</span><br><span class=\"line\">\tc := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> Time, <span class=\"number\">1</span>)</span><br><span class=\"line\">\tt := &amp;Timer&#123;</span><br><span class=\"line\">\t\tC: c,</span><br><span class=\"line\">\t\tr: runtimeTimer&#123;</span><br><span class=\"line\">\t\t\twhen: when(d),</span><br><span class=\"line\">\t\t\tf:    sendTime,</span><br><span class=\"line\">\t\t\targ:  c,</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tstartTimer(&amp;t.r)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 <code>when</code> 表示的时间到时，会往 <code>Timer.C</code> 中发送当前时间。<code>when</code> 表示的时间是纳秒时间，正常通过 <code>runtimeNano() + int64(d)</code> 赋值。</p>\n<p><code>f</code> 参数的值是 <code>sendTime</code>，定时器时间到时，会调用 <code>f</code>，并将 <code>arg</code> 和 <code>seq</code> 传给 <code>f</code>。</p>\n<p>因为 <code>Timer</code> 是一次性的，所以 <code>period</code> 保留默认值 0。</p>\n<h3 id=\"常用方法-1\"><a href=\"#常用方法-1\" class=\"headerlink\" title=\"常用方法\"></a>常用方法</h3><h4 id=\"time-After\"><a href=\"#time-After\" class=\"headerlink\" title=\"time.After\"></a>time.After</h4><p><code>time.After</code> 模拟超时：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">c := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// time.Sleep(1 * time.Second)</span></span><br><span class=\"line\">\ttime.Sleep(<span class=\"number\">3</span> * time.Second)</span><br><span class=\"line\">\t&lt;-c</span><br><span class=\"line\">&#125;()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">select</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">case</span> c &lt;- <span class=\"number\">1</span>:</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">\"channel...\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">case</span> &lt;-time.After(<span class=\"number\">2</span> * time.Second):</span><br><span class=\"line\">\t<span class=\"built_in\">close</span>(c)</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">\"timeout...\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"time-Stop-和-time-Reset\"><a href=\"#time-Stop-和-time-Reset\" class=\"headerlink\" title=\"time.Stop 和 time.Reset\"></a>time.Stop 和 time.Reset</h4><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">start := time.Now()</span><br><span class=\"line\">timer := time.AfterFunc(<span class=\"number\">2</span>*time.Second, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">\"after func callback, elaspe:\"</span>, time.Now().Sub(start))</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">time.Sleep(<span class=\"number\">1</span> * time.Second)</span><br><span class=\"line\"><span class=\"comment\">// time.Sleep(3*time.Second)</span></span><br><span class=\"line\"><span class=\"comment\">// Reset 在 Timer 还未触发时返回 true；触发了或 Stop 了，返回 false</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> timer.Reset(<span class=\"number\">3</span> * time.Second) &#123;</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">\"timer has not trigger!\"</span>)</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">\"timer had expired or stop!\"</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">time.Sleep(<span class=\"number\">10</span> * time.Second)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// output:</span></span><br><span class=\"line\"><span class=\"comment\">// timer has not trigger!</span></span><br><span class=\"line\"><span class=\"comment\">// after func callback, elaspe: 4.00026461s</span></span><br></pre></td></tr></table></figure>\n<p><code>timer.Stop()</code> 不会关闭 <code>Timer.C</code> 这个 channel，可以使用 <code>timer.Reset(0)</code> 代替 <code>timer.Stop()</code> 来停止定时器。</p>\n<h4 id=\"Sleep\"><a href=\"#Sleep\" class=\"headerlink\" title=\"Sleep\"></a>Sleep</h4><p><code>Sleep</code> 的是通过 <code>Timer</code> 实现的（查看 <code>runtime/time.go</code> 文件）。用于暂停当前 <code>goroutine</code>。</p>\n<h2 id=\"Ticker\"><a href=\"#Ticker\" class=\"headerlink\" title=\"Ticker\"></a>Ticker</h2><p><code>Ticker</code> 和 <code>Timer</code> 类似，区别是：<code>Ticker</code> 中的 <code>runtimeTimer</code> 字段的 <code>period</code> 字段会赋值为 <code>NewTicker(d Duration)</code> 中的 <code>d</code>，<br>表示每间隔 <code>d</code> 纳秒，定时器就会触发一次。</p>\n<p>除非程序终止前定时器一直需要触发，否则，不需要时应该调用 <code>Ticker.Stop</code> 来释放相关资源。</p>\n<p>如果程序终止前需要定时器一直触发，可以使用更简单方便的 <code>time.Tick</code> 函数，因为 <code>Ticker</code> 实例隐藏起来了，因此，该函数启动的定时器无法停止。</p>\n"},{"title":"基础据类型","_content":"\n# 基础据类型\n\n## 数值类型\n### 整型\n- `uint`，无符号 32 或 64 位整型\n- `uint8`，无符号 8 位整型 (0 到 255)\n- `uint16`，无符号 16 位整型 (0 到 65535)\n- `uint32`，无符号 32 位整型 (0 到 4294967295)\n- `uint64`，无符号 64 位整型 (0 到 18446744073709551615)\n- `int`，有符号 32 或 64 位整型\n- `int8`，有符号 8 位整型 (-128 到 127)\n- `int16`，有符号 16 位整型 (-32768 到 32767)\n- `int32`，有符号 32 位整型 (-2147483648 到 2147483647)\n- `int64`，有符号 64 位整型 (-9223372036854775808 到 9223372036854775807)\n\n`int` 和 `uint` 对应的是 CPU 平台机器的字大小。\n\n### 浮点数\n- `float32`，IEEE-754 32 位浮点型数，`math.MaxFloat32` 表示 `float32` 能表示的最大数值，大约是 `3.4e38`。\n- `float64`，IEEE-754 64 位浮点型数，`math.MaxFloat64` 表示 `float64` 能表示的最大数值，大约是 `1.8e308`。\n\n### 复数\n- `complex64`，对应 `float32` 浮点数精度。\n- `complex128`，对应 `float64` 浮点数精度。\n\n内置 `complex` 函数创建复数。`math/cmplx` 包提供了复数处理的许多函数。\n\n### 其他数值类型\n- **`byte`，`uint8`的别名**，通常用于表示一个 `Unicode` 码点。\n- **`rune`，`int32`的别名**，一般用于强调数值是一个原始的数据而不是一个小的整数。\n- `uintptr`，无符号整型，用于存放一个指针，没有指定具体的 `bit` 大小。\n\n## 布尔类型\n布尔类型的值只有两种：`true` 和 `false`。\n\n## 字符串\n字符串就是一串固定长度的字符连接起来的字符序列，不可改变。Go 的字符串是由单个字节连接起来的。Go 的字符串的字节使\n用 `UTF-8` 编码标识 `Unicode` 文本。\n\n**一个原生的字符串面值形式是 \\`...\\`，使用反引号代替双引号。在原生的字符串面值中，没有转义操作；全部的内容都是字面的意思，\n包含退格和换行**。\n\n### 字符串操作\n- 内置函数 `len` 可以获取字符串的长度。\n- **可以通过 `string[index]` 获取某个索引位置的字节值，字符串是不可修改的，不能使用 `string[index] = \"string2\"`\n这种方式改变字符串**，要修改字符串，必须将其转为可变类型（`[]rune` 或 `[]byte`），完成后再转回来。\n- `string[i, l]` 获取 `string` 从第 `i` 个字节位置开始的 `l` 个字节，返回一个新的字符串。如：\n  ```go\n    s := \"hello, world\"\n    fmt.Println(s[0:5]) // \"hello\"\n    \n    fmt.Println(s[:5]) // \"hello\"\n    fmt.Println(s[7:]) // \"world\"\n    fmt.Println(s[:])  // \"hello, world\"\n  ```\n- `+` 拼接字符串，如 `fmt.Println(\"goodbye\" + s[5:])` 输出 `\"goodbye, world\"`。这种方式每次运算都会产生一个新的字\n符串，需要重新分配内存，会给内存分配和 GC 带来额外的负担，所以性能比较差。\n- `fmt.Sprintf()` 拼接字符串，内部使用 `[]byte` 实现，不像直接运算符这种会产生很多临时的字符串，但是内部的逻辑比较复杂，有很\n多额外的判断，还用到了 `interface`，所以性能一般。\n- `strings.Join()` 拼接字符串，`Join` 会先根据字符串数组的内容，计算出一个拼接之后的长度，然后申请对应大小的内存，一个一个字符\n串填入，在已有一个数组的情况下，这种效率会很高，但是本来没有，去构造这个数据的代价也不小。\n- `bytes.Buffer` 拼接字符串，比较理想，可以当成可变字符使用，对内存的增长也有优化，如果能预估字符串的长度，还可\n以用 `buffer.Grow()` 接口来设置 `capacity`。\n```go\nvar buffer bytes.Buffer\nbuffer.WriteString(\"hello\")\nbuffer.WriteString(\", \")\nbuffer.WriteString(\"world\")\n\nfmt.Print(buffer.String())\n```\n- `strings.Builder` 内部通过 `slice` 来保存和管理内容。`slice` 内部则是通过一个指针指向实际保存内容的数组。`strings.Builder` \n是非线程安全，性能上和 `bytes.Buffer` 相差无几。\n```go\nvar b1 strings.Builder\nb1.WriteString(\"ABC\")\nb1.WriteString(\"DEF\")\n\nfmt.Print(b1.String())\n```\n- 使用 `==` 和 `<` 进行字符串比较。\n\n### strings 包与字符串操作\n```go\n/*字符串基本操作--strings*/\nstr := \"wangdy\"\n//是否包含\nfmt.Println(strings.Contains(str, \"wang\"), strings.Contains(str, \"123\")) //true false\n//获取字符串长度\nfmt.Println(len(str)) //6\n//获取字符在字符串的位置 从0开始,如果不存在，返回-1\nfmt.Println(strings.Index(str, \"g\")) //3\nfmt.Println(strings.Index(str, \"x\")) //-1\n//判断字符串是否以 xx 开头\nfmt.Println(strings.HasPrefix(str, \"wa\")) //true\n//判断字符串是否以 xx 结尾\nfmt.Println(strings.HasSuffix(str, \"dy\")) //true\n//判断2个字符串大小，相等0，左边大于右边-1，其他1\nstr2 := \"hahaha\"\nfmt.Println(strings.Compare(str, str2)) //1\n//分割字符串\nstrSplit := strings.Split(\"1-2-3-4-a\", \"-\")\nfmt.Println(strSplit) //[1 2 3 4 a]\n//组装字符串\nfmt.Println(strings.Join(strSplit, \"#\")) //1#2#3#4#a\n//去除字符串2端空格\nfmt.Printf(\"%s,%s\\n\", strings.Trim(\"  我的2边有空格   1  \", \" \"), \"/////\") //我的2边有空格   1,/////\n//大小写转换\nfmt.Println(strings.ToUpper(\"abDCaE\")) //ABDCAE\nfmt.Println(strings.ToLower(\"abDCaE\")) //abdcae\n//字符串替换:意思是：在sourceStr中，把oldStr的前n个替换成newStr，返回一个新字符串，如果n<0则全部替换\nsourceStr := \"123123123\"\noldStr := \"12\"\nnewStr := \"ab\"\nn := 2\nfmt.Println(strings.Replace(sourceStr, oldStr, newStr, n))\n```\n\n在 Go 语言中，**`string` 类型的值是不可变的。如果我们想获得一个不一样的字符串，那么就只能基于原字符串进行裁剪、拼接等操作，\n从而生成一个新的字符串**。裁剪操作可以使用切片表达式，而拼接操作可以用操作符`+`实现。\n\n在底层，一个 `string` 值的内容会被存储到一块连续的内存空间中。同时，这块内存容纳的字节数量也会被记录下来，并用于表示\n该 `string` 值的长度。\n\n你可以把这块内存的内容看成一个字节数组，而相应的 `string` 值则包含了指向字节数组头部的指针值。如此一来，**我们在\n一个 `string` 值上应用切片表达式，就相当于在对其底层的字节数组做切片**。\n\n另一方面，我们在**进行字符串拼接的时候，Go 语言会把所有被拼接的字符串依次拷贝到一个崭新且足够大的连续内存空间中，\n并把持有相应指针值的 `string` 值作为结果返回**。\n\n显然，当**程序中存在过多的字符串拼接操作的时候，会对内存的分配产生非常大的压力**。\n\n#### 与 `string` 值相比，`strings.Builder` 类型的值有哪些优势\n- 已存在的内容不可变，但可以拼接更多的内容；\n- 减少了内存分配和内容拷贝的次数；\n- 可将内容重置，可重用值。\n\n`Builder` 值中有一个用于承载内容的容器（以下简称内容容器）。它是一个以 `byte` 为元素类型的切片（以下简称字节切片）。\n\n**由于这样的字节切片的底层数组就是一个字节数组，所以我们可以说它与 `string` 值存储内容的方式是一样的**。实际上，它们都是通过\n一个 `unsafe.Pointer` 类型的字段来持有那个指向了底层字节数组的指针值的。\n\n因为这样的内部构造，`Builder` 值同样拥有高效利用内存的前提条件。\n\n已存在于 `Builder` 值中的内容是不可变的。因此，我们可以利用 `Builder` 值提供的方法拼接更多的内容，而丝毫不用担心这些方法\n会影响到已存在的内容。\n\n`Builder` 值拥有的一系列指针方法，包括：`Write`、`WriteByte`、`WriteRune` 和 `WriteString`。我们可以把它们统称\n为**拼接方法**。\n\n调用上述方法把新的内容拼接到已存在的内容的尾部（也就是右边）。这时，如有必要，`Builder` 值会自动地对自身的内容容器进行扩容。\n这里的自动扩容策略与切片的扩容策略一致。\n\n除了 `Builder` 值的自动扩容，我们还可以选择手动扩容，这通过调用 `Builder` 值的 `Grow` 方法就可以做到。`Grow` 方法也可以被称\n为**扩容方法**，它接受一个 `int` 类型的参数 `n`，该参数用于代表将要扩充的字节数量。\n\n`Grow` 方法会把其所属值中内容容器的容量增加 `n` 个字节。更具体地讲，它会生成一个字节切片作为新的内容容器，该切片的容量会是原\n容器容量的二倍再加上 `n`。之后，它会把原容器中的所有字节全部拷贝到新容器中。\n\n#### 使用 `strings.Builder` 类型的约束\n**只要调用了 `Builder` 值的拼接方法或扩容方法，就不能再以任何的方式对其所属值进行复制了**。否则，只要在任何副本上调用上述方\n法就都会引发 panic。这里所说的复制方式，包括但不限于在函数间传递值、通过通道传递值、把值赋予变量等等。\n\n正是由于已使用的 `Builder` 值不能再被复制，所以肯定不会出现多个 `Builder` 值中的内容容器（也就是那个字节切片）共用一个底层字\n节数组的情况。这样也就避免了多个同源的` Builder` 值在拼接内容时可能产生的冲突问题。\n\n**不过，虽然已使用的 `Builder` 值不能再被复制，但是它的指针值却可以。无论什么时候，我们都可以通过任何方式复制这样的指针值**。\n注意，这样的指针值指向的都会是同一个 `Builder` 值。\n\n### `strings.Reader` 类型\n`strings.Reader` 类型是为了高效读取字符串而存在的。可以让我们很方便地读取一个字符串中的内容。在读取的过程中，`Reader` 值会\n保存已读取的字节的计数（以下简称已读计数）。\n\n**已读计数也代表着下一次读取的起始索引位置。`Reader` 值正是依靠这样一个计数，以及针对字符串值的切片表达式，从而实现快速读取**。\n### bytes 包与字节串操作\n`strings` 包和 `bytes` 包可以说是一对孪生兄弟，它们在 API 方面非常的相似。单从它们提供的函数的数量和功能上讲，差别微乎其微。\n只不过，`strings`包主要面向的是 `Unicode` 字符和经过 `UTF-8` 编码的字符串，而 `bytes` 包面对的则主要是字节和字节切片。\n\n\n#### `bytes.Buffer`\n`bytes.Buffer` 类型的用途主要是作为字节序列的缓冲区。`bytes.Buffer` 是开箱即用的。`bytes.Buffer` 不但可以拼接、截断其中\n的字节序列，以各种形式导出其中的内容，还可以顺序地读取其中的子序列。\n\n在内部，`bytes.Buffer` 类型同样是使用字节切片作为内容容器的。并且，与 `strings.Reader` 类型类似，`bytes.Buffer` 有一个 `int` \n类型的字段，用于代表已读字节的计数，可以简称为**已读计数**。\n\n**注意，与 `strings.Reader` 类型的 `Len` 方法一样，`bytes.Buffer` 的` Len` 方法返回的也是内容容器中未被读取部分的长度，\n而不是其中已存内容的总长度（以下简称内容长度）。**\n\n```go\n// 示例1。\nvar buffer1 bytes.Buffer\ncontents := \"Simple byte buffer for marshaling data.\"\nfmt.Printf(\"Write contents %q ...\\n\", contents)\nbuffer1.WriteString(contents)\nfmt.Printf(\"The length of buffer: %d\\n\", buffer1.Len()) // => 39\nfmt.Printf(\"The capacity of buffer: %d\\n\", buffer1.Cap()) // => 64\nfmt.Println()\n\n// 示例2。\np1 := make([]byte, 7)\nn, _ := buffer1.Read(p1)\nfmt.Printf(\"%d bytes were read. (call Read)\\n\", n)\nfmt.Printf(\"The length of buffer: %d\\n\", buffer1.Len()) // => 32\nfmt.Printf(\"The capacity of buffer: %d\\n\", buffer1.Cap()) // => 64\n```\n上面的代码，示例一输出 39 和 64，但是示例二，从` buffer1` 中读取一部分内容，并用它们填满长度为7的字节切片 `p1` 之后，\n`buffer1` 的 `Len` 方法返回的结果值变为了 32。因为我们并没有再向该缓冲区中写入任何内容，所以它的容量会保持不变，仍是 64。\n\n> 对于处在零值状态的 `Buffer` 值来说，如果第一次扩容时的另需字节数不大于 64，那么该值就会基于一个预先定义好的、长度为 64 \n的字节数组来创建内容容器。\n\n由于 `strings.Reader` 还有一个 `Size` 方法可以给出内容长度的值，所以我们用内容长度减去未读部分的长度，就可以很方便地得\n到它的已读计数。\n\n然而，`bytes.Buffer` 类型却没有这样一个方法，它只有 `Cap` 方法。可是 `Cap` 方法提供的是内容容器的容量，也不是内容长度。\n\n#### bytes.Buffer 的扩容策略\n`Buffer` 值既可以被手动扩容，也可以进行自动扩容。并且，这两种扩容方式的策略是基本一致的。所以，除非我们完全确定后续内容所需\n的字节数，否则让 `Buffer` 值自动去扩容就好了。\n\n在扩容的时候，`Buffer` 值中相应的代码（以下简称扩容代码）会先判断内容容器的剩余容量，是否可以满足调用方的要求，或者是否足\n够容纳新的内容。\n\n如果可以，那么扩容代码会在当前的内容容器之上，进行长度扩充。更具体地说，如果内容容器的容量与其长度的差，大于或等于另需的字\n节数，那么扩容代码就会通过切片操作对原有的内容容器的长度进行扩充，就像下面这样：\n```go\nb.buf = b.buf[:length+need]\n```\n反之，如果内容容器的剩余容量不够了，那么扩容代码可能就会用新的内容容器去替代原有的内容容器，从而实现扩容。不过，这里还一步优化。\n\n如果当前内容容器的容量的一半仍然大于或等于其现有长度再加上另需的字节数的和，即：\n```go\ncap(b.buf)/2 >= len(b.buf)+need\n```\n那么，扩容代码就会复用现有的内容容器，并把容器中的未读内容拷贝到它的头部位置。这也意味着其中的已读内容，将会全部被未读内容和\n之后的新内容覆盖掉。\n\n这样的复用预计可以至少节省掉一次后续的扩容所带来的内存分配，以及若干字节的拷贝。\n\n若这一步优化未能达成，也就是说，当前内容容器的容量小于新长度的二倍，那么扩容代码就只能再创建一个新的内容容器，并把原有容器\n中的未读内容拷贝进去，最后再用新的容器替换掉原有的容器。这个新容器的容量将会等于原有容量的二倍再加上另需字节数的和。\n```\n新容器的容量 =2* 原有容量 + 所需字节数\n```\n\n#### bytes.Buffer 中的哪些方法可能会造成内容的泄露\n什么叫内容泄露？这里所说的内容泄露是指，使用 `Buffer` 值的一方通过某种非标准的（或者说不正式的）方式得到了本不该得到的内容。\n\n在` bytes.Buffer` 中，**`Bytes` 方法和` Next`方法都可能会造成内容的泄露**。原因在于，它们都把基于内容容器的切片直接返\n回给了方法的调用方。\n\n我们都知道，**通过切片，我们可以直接访问和操纵它的底层数组。不论这个切片是基于某个数组得来的，还是通过对另一个切片做切片操作\n获得的**，都是如此。\n```go\ncontents := \"ab\"\nbuffer1 := bytes.NewBufferString(contents)\nfmt.Printf(\"The capacity of new buffer with contents %q: %d\\n\",\n    contents, buffer1.Cap()) // 内容容器的容量为：8。\nfmt.Println()\n\nunreadBytes := buffer1.Bytes()\nfmt.Printf(\"The unread bytes of the buffer: %v\\n\", unreadBytes)\n```\n\n前面通过调用 `buffer1` 的` Bytes` 方法得到的结果值 `unreadBytes`，包含了在那时其中的所有未读内容。\n\n但是，由于这个结果值与 `buffer1` 的内容容器在此时还共用着同一个底层数组，所以，我只需通过简单的再切片操作，就可以利用这个\n结果值拿到 `buffer1` 在此时的所有未读内容。如此一来，`buffer1` 的新内容就被泄露出来了。\n### 一个 `string` 类型的值在底层怎样被表达\n在底层，一个 `string` 类型的值是由一系列相对应的 Unicode 代码点的 UTF-8 编码值来表达的。\n\n一个 `string` 类型的值既可以被拆分为一个包含多个字符的序列，也可以被拆分为一个包含多个字节的序列。\n前者可以由一个以 `rune`（`int32` 的别名）为元素类型的切片来表示，而后者则可以由一个以 `byte` 为元素类型的切片代表。\n\n`rune` 是 Go 语言特有的一个基本数据类型，它的一个值就代表一个字符，即：一个 Unicode 字符。比如，'G'、'o'、'爱'、'好'、\n'者'代表的就都是一个 Unicode 字符。一个 `rune` 类型的值会由四个字节宽度的空间来存储。它的存储空间总是能够存下一\n个 UTF-8 编码值。\n\n**一个 `rune` 类型的值在底层其实就是一个 UTF-8 编码值**。前者是（便于我们人类理解的）外部展现，后者是（便于计算机系统理解的）\n内在表达。\n\n```go\nstr := \"Go 爱好者 \"\nfmt.Printf(\"The string: %q\\n\", str)\nfmt.Printf(\"  => runes(char): %q\\n\", []rune(str))\nfmt.Printf(\"  => runes(hex): %x\\n\", []rune(str))\nfmt.Printf(\"  => bytes(hex): [% x]\\n\", []byte(str))\n```\n字符串值 \"Go 爱好者\" 如果被转换为 `[]rune` 类型的值的话，其中的每一个字符（不论是英文字符还是中文字符）就都会独立成为一\n个 `rune` 类型的元素值。因\n此，这段代码打印出的第二行内容就会如下所示：\n```bash\n=> runes(char): ['G' 'o' '爱' '好' '者']\n```\n又由于，每个 `rune` 类型的值在底层都是由一个 UTF-8 编码值来表达的，所以我们可以换一种方式来展现这个字符序列：\n```bash\n=> runes(hex): [47 6f 7231 597d 8005]\n```\n我们还可以进一步地拆分，把每个字符的 UTF-8 编码值都拆成相应的字节序列。上述代码中的第五行就是这么做的。它会得到如下的输出：\n```bash\n=> bytes(hex): [47 6f e7 88 b1 e5 a5 bd e8 80 85]\n```","source":"basic/basic_data.md","raw":"---\ntitle: 基础据类型\n---\n\n# 基础据类型\n\n## 数值类型\n### 整型\n- `uint`，无符号 32 或 64 位整型\n- `uint8`，无符号 8 位整型 (0 到 255)\n- `uint16`，无符号 16 位整型 (0 到 65535)\n- `uint32`，无符号 32 位整型 (0 到 4294967295)\n- `uint64`，无符号 64 位整型 (0 到 18446744073709551615)\n- `int`，有符号 32 或 64 位整型\n- `int8`，有符号 8 位整型 (-128 到 127)\n- `int16`，有符号 16 位整型 (-32768 到 32767)\n- `int32`，有符号 32 位整型 (-2147483648 到 2147483647)\n- `int64`，有符号 64 位整型 (-9223372036854775808 到 9223372036854775807)\n\n`int` 和 `uint` 对应的是 CPU 平台机器的字大小。\n\n### 浮点数\n- `float32`，IEEE-754 32 位浮点型数，`math.MaxFloat32` 表示 `float32` 能表示的最大数值，大约是 `3.4e38`。\n- `float64`，IEEE-754 64 位浮点型数，`math.MaxFloat64` 表示 `float64` 能表示的最大数值，大约是 `1.8e308`。\n\n### 复数\n- `complex64`，对应 `float32` 浮点数精度。\n- `complex128`，对应 `float64` 浮点数精度。\n\n内置 `complex` 函数创建复数。`math/cmplx` 包提供了复数处理的许多函数。\n\n### 其他数值类型\n- **`byte`，`uint8`的别名**，通常用于表示一个 `Unicode` 码点。\n- **`rune`，`int32`的别名**，一般用于强调数值是一个原始的数据而不是一个小的整数。\n- `uintptr`，无符号整型，用于存放一个指针，没有指定具体的 `bit` 大小。\n\n## 布尔类型\n布尔类型的值只有两种：`true` 和 `false`。\n\n## 字符串\n字符串就是一串固定长度的字符连接起来的字符序列，不可改变。Go 的字符串是由单个字节连接起来的。Go 的字符串的字节使\n用 `UTF-8` 编码标识 `Unicode` 文本。\n\n**一个原生的字符串面值形式是 \\`...\\`，使用反引号代替双引号。在原生的字符串面值中，没有转义操作；全部的内容都是字面的意思，\n包含退格和换行**。\n\n### 字符串操作\n- 内置函数 `len` 可以获取字符串的长度。\n- **可以通过 `string[index]` 获取某个索引位置的字节值，字符串是不可修改的，不能使用 `string[index] = \"string2\"`\n这种方式改变字符串**，要修改字符串，必须将其转为可变类型（`[]rune` 或 `[]byte`），完成后再转回来。\n- `string[i, l]` 获取 `string` 从第 `i` 个字节位置开始的 `l` 个字节，返回一个新的字符串。如：\n  ```go\n    s := \"hello, world\"\n    fmt.Println(s[0:5]) // \"hello\"\n    \n    fmt.Println(s[:5]) // \"hello\"\n    fmt.Println(s[7:]) // \"world\"\n    fmt.Println(s[:])  // \"hello, world\"\n  ```\n- `+` 拼接字符串，如 `fmt.Println(\"goodbye\" + s[5:])` 输出 `\"goodbye, world\"`。这种方式每次运算都会产生一个新的字\n符串，需要重新分配内存，会给内存分配和 GC 带来额外的负担，所以性能比较差。\n- `fmt.Sprintf()` 拼接字符串，内部使用 `[]byte` 实现，不像直接运算符这种会产生很多临时的字符串，但是内部的逻辑比较复杂，有很\n多额外的判断，还用到了 `interface`，所以性能一般。\n- `strings.Join()` 拼接字符串，`Join` 会先根据字符串数组的内容，计算出一个拼接之后的长度，然后申请对应大小的内存，一个一个字符\n串填入，在已有一个数组的情况下，这种效率会很高，但是本来没有，去构造这个数据的代价也不小。\n- `bytes.Buffer` 拼接字符串，比较理想，可以当成可变字符使用，对内存的增长也有优化，如果能预估字符串的长度，还可\n以用 `buffer.Grow()` 接口来设置 `capacity`。\n```go\nvar buffer bytes.Buffer\nbuffer.WriteString(\"hello\")\nbuffer.WriteString(\", \")\nbuffer.WriteString(\"world\")\n\nfmt.Print(buffer.String())\n```\n- `strings.Builder` 内部通过 `slice` 来保存和管理内容。`slice` 内部则是通过一个指针指向实际保存内容的数组。`strings.Builder` \n是非线程安全，性能上和 `bytes.Buffer` 相差无几。\n```go\nvar b1 strings.Builder\nb1.WriteString(\"ABC\")\nb1.WriteString(\"DEF\")\n\nfmt.Print(b1.String())\n```\n- 使用 `==` 和 `<` 进行字符串比较。\n\n### strings 包与字符串操作\n```go\n/*字符串基本操作--strings*/\nstr := \"wangdy\"\n//是否包含\nfmt.Println(strings.Contains(str, \"wang\"), strings.Contains(str, \"123\")) //true false\n//获取字符串长度\nfmt.Println(len(str)) //6\n//获取字符在字符串的位置 从0开始,如果不存在，返回-1\nfmt.Println(strings.Index(str, \"g\")) //3\nfmt.Println(strings.Index(str, \"x\")) //-1\n//判断字符串是否以 xx 开头\nfmt.Println(strings.HasPrefix(str, \"wa\")) //true\n//判断字符串是否以 xx 结尾\nfmt.Println(strings.HasSuffix(str, \"dy\")) //true\n//判断2个字符串大小，相等0，左边大于右边-1，其他1\nstr2 := \"hahaha\"\nfmt.Println(strings.Compare(str, str2)) //1\n//分割字符串\nstrSplit := strings.Split(\"1-2-3-4-a\", \"-\")\nfmt.Println(strSplit) //[1 2 3 4 a]\n//组装字符串\nfmt.Println(strings.Join(strSplit, \"#\")) //1#2#3#4#a\n//去除字符串2端空格\nfmt.Printf(\"%s,%s\\n\", strings.Trim(\"  我的2边有空格   1  \", \" \"), \"/////\") //我的2边有空格   1,/////\n//大小写转换\nfmt.Println(strings.ToUpper(\"abDCaE\")) //ABDCAE\nfmt.Println(strings.ToLower(\"abDCaE\")) //abdcae\n//字符串替换:意思是：在sourceStr中，把oldStr的前n个替换成newStr，返回一个新字符串，如果n<0则全部替换\nsourceStr := \"123123123\"\noldStr := \"12\"\nnewStr := \"ab\"\nn := 2\nfmt.Println(strings.Replace(sourceStr, oldStr, newStr, n))\n```\n\n在 Go 语言中，**`string` 类型的值是不可变的。如果我们想获得一个不一样的字符串，那么就只能基于原字符串进行裁剪、拼接等操作，\n从而生成一个新的字符串**。裁剪操作可以使用切片表达式，而拼接操作可以用操作符`+`实现。\n\n在底层，一个 `string` 值的内容会被存储到一块连续的内存空间中。同时，这块内存容纳的字节数量也会被记录下来，并用于表示\n该 `string` 值的长度。\n\n你可以把这块内存的内容看成一个字节数组，而相应的 `string` 值则包含了指向字节数组头部的指针值。如此一来，**我们在\n一个 `string` 值上应用切片表达式，就相当于在对其底层的字节数组做切片**。\n\n另一方面，我们在**进行字符串拼接的时候，Go 语言会把所有被拼接的字符串依次拷贝到一个崭新且足够大的连续内存空间中，\n并把持有相应指针值的 `string` 值作为结果返回**。\n\n显然，当**程序中存在过多的字符串拼接操作的时候，会对内存的分配产生非常大的压力**。\n\n#### 与 `string` 值相比，`strings.Builder` 类型的值有哪些优势\n- 已存在的内容不可变，但可以拼接更多的内容；\n- 减少了内存分配和内容拷贝的次数；\n- 可将内容重置，可重用值。\n\n`Builder` 值中有一个用于承载内容的容器（以下简称内容容器）。它是一个以 `byte` 为元素类型的切片（以下简称字节切片）。\n\n**由于这样的字节切片的底层数组就是一个字节数组，所以我们可以说它与 `string` 值存储内容的方式是一样的**。实际上，它们都是通过\n一个 `unsafe.Pointer` 类型的字段来持有那个指向了底层字节数组的指针值的。\n\n因为这样的内部构造，`Builder` 值同样拥有高效利用内存的前提条件。\n\n已存在于 `Builder` 值中的内容是不可变的。因此，我们可以利用 `Builder` 值提供的方法拼接更多的内容，而丝毫不用担心这些方法\n会影响到已存在的内容。\n\n`Builder` 值拥有的一系列指针方法，包括：`Write`、`WriteByte`、`WriteRune` 和 `WriteString`。我们可以把它们统称\n为**拼接方法**。\n\n调用上述方法把新的内容拼接到已存在的内容的尾部（也就是右边）。这时，如有必要，`Builder` 值会自动地对自身的内容容器进行扩容。\n这里的自动扩容策略与切片的扩容策略一致。\n\n除了 `Builder` 值的自动扩容，我们还可以选择手动扩容，这通过调用 `Builder` 值的 `Grow` 方法就可以做到。`Grow` 方法也可以被称\n为**扩容方法**，它接受一个 `int` 类型的参数 `n`，该参数用于代表将要扩充的字节数量。\n\n`Grow` 方法会把其所属值中内容容器的容量增加 `n` 个字节。更具体地讲，它会生成一个字节切片作为新的内容容器，该切片的容量会是原\n容器容量的二倍再加上 `n`。之后，它会把原容器中的所有字节全部拷贝到新容器中。\n\n#### 使用 `strings.Builder` 类型的约束\n**只要调用了 `Builder` 值的拼接方法或扩容方法，就不能再以任何的方式对其所属值进行复制了**。否则，只要在任何副本上调用上述方\n法就都会引发 panic。这里所说的复制方式，包括但不限于在函数间传递值、通过通道传递值、把值赋予变量等等。\n\n正是由于已使用的 `Builder` 值不能再被复制，所以肯定不会出现多个 `Builder` 值中的内容容器（也就是那个字节切片）共用一个底层字\n节数组的情况。这样也就避免了多个同源的` Builder` 值在拼接内容时可能产生的冲突问题。\n\n**不过，虽然已使用的 `Builder` 值不能再被复制，但是它的指针值却可以。无论什么时候，我们都可以通过任何方式复制这样的指针值**。\n注意，这样的指针值指向的都会是同一个 `Builder` 值。\n\n### `strings.Reader` 类型\n`strings.Reader` 类型是为了高效读取字符串而存在的。可以让我们很方便地读取一个字符串中的内容。在读取的过程中，`Reader` 值会\n保存已读取的字节的计数（以下简称已读计数）。\n\n**已读计数也代表着下一次读取的起始索引位置。`Reader` 值正是依靠这样一个计数，以及针对字符串值的切片表达式，从而实现快速读取**。\n### bytes 包与字节串操作\n`strings` 包和 `bytes` 包可以说是一对孪生兄弟，它们在 API 方面非常的相似。单从它们提供的函数的数量和功能上讲，差别微乎其微。\n只不过，`strings`包主要面向的是 `Unicode` 字符和经过 `UTF-8` 编码的字符串，而 `bytes` 包面对的则主要是字节和字节切片。\n\n\n#### `bytes.Buffer`\n`bytes.Buffer` 类型的用途主要是作为字节序列的缓冲区。`bytes.Buffer` 是开箱即用的。`bytes.Buffer` 不但可以拼接、截断其中\n的字节序列，以各种形式导出其中的内容，还可以顺序地读取其中的子序列。\n\n在内部，`bytes.Buffer` 类型同样是使用字节切片作为内容容器的。并且，与 `strings.Reader` 类型类似，`bytes.Buffer` 有一个 `int` \n类型的字段，用于代表已读字节的计数，可以简称为**已读计数**。\n\n**注意，与 `strings.Reader` 类型的 `Len` 方法一样，`bytes.Buffer` 的` Len` 方法返回的也是内容容器中未被读取部分的长度，\n而不是其中已存内容的总长度（以下简称内容长度）。**\n\n```go\n// 示例1。\nvar buffer1 bytes.Buffer\ncontents := \"Simple byte buffer for marshaling data.\"\nfmt.Printf(\"Write contents %q ...\\n\", contents)\nbuffer1.WriteString(contents)\nfmt.Printf(\"The length of buffer: %d\\n\", buffer1.Len()) // => 39\nfmt.Printf(\"The capacity of buffer: %d\\n\", buffer1.Cap()) // => 64\nfmt.Println()\n\n// 示例2。\np1 := make([]byte, 7)\nn, _ := buffer1.Read(p1)\nfmt.Printf(\"%d bytes were read. (call Read)\\n\", n)\nfmt.Printf(\"The length of buffer: %d\\n\", buffer1.Len()) // => 32\nfmt.Printf(\"The capacity of buffer: %d\\n\", buffer1.Cap()) // => 64\n```\n上面的代码，示例一输出 39 和 64，但是示例二，从` buffer1` 中读取一部分内容，并用它们填满长度为7的字节切片 `p1` 之后，\n`buffer1` 的 `Len` 方法返回的结果值变为了 32。因为我们并没有再向该缓冲区中写入任何内容，所以它的容量会保持不变，仍是 64。\n\n> 对于处在零值状态的 `Buffer` 值来说，如果第一次扩容时的另需字节数不大于 64，那么该值就会基于一个预先定义好的、长度为 64 \n的字节数组来创建内容容器。\n\n由于 `strings.Reader` 还有一个 `Size` 方法可以给出内容长度的值，所以我们用内容长度减去未读部分的长度，就可以很方便地得\n到它的已读计数。\n\n然而，`bytes.Buffer` 类型却没有这样一个方法，它只有 `Cap` 方法。可是 `Cap` 方法提供的是内容容器的容量，也不是内容长度。\n\n#### bytes.Buffer 的扩容策略\n`Buffer` 值既可以被手动扩容，也可以进行自动扩容。并且，这两种扩容方式的策略是基本一致的。所以，除非我们完全确定后续内容所需\n的字节数，否则让 `Buffer` 值自动去扩容就好了。\n\n在扩容的时候，`Buffer` 值中相应的代码（以下简称扩容代码）会先判断内容容器的剩余容量，是否可以满足调用方的要求，或者是否足\n够容纳新的内容。\n\n如果可以，那么扩容代码会在当前的内容容器之上，进行长度扩充。更具体地说，如果内容容器的容量与其长度的差，大于或等于另需的字\n节数，那么扩容代码就会通过切片操作对原有的内容容器的长度进行扩充，就像下面这样：\n```go\nb.buf = b.buf[:length+need]\n```\n反之，如果内容容器的剩余容量不够了，那么扩容代码可能就会用新的内容容器去替代原有的内容容器，从而实现扩容。不过，这里还一步优化。\n\n如果当前内容容器的容量的一半仍然大于或等于其现有长度再加上另需的字节数的和，即：\n```go\ncap(b.buf)/2 >= len(b.buf)+need\n```\n那么，扩容代码就会复用现有的内容容器，并把容器中的未读内容拷贝到它的头部位置。这也意味着其中的已读内容，将会全部被未读内容和\n之后的新内容覆盖掉。\n\n这样的复用预计可以至少节省掉一次后续的扩容所带来的内存分配，以及若干字节的拷贝。\n\n若这一步优化未能达成，也就是说，当前内容容器的容量小于新长度的二倍，那么扩容代码就只能再创建一个新的内容容器，并把原有容器\n中的未读内容拷贝进去，最后再用新的容器替换掉原有的容器。这个新容器的容量将会等于原有容量的二倍再加上另需字节数的和。\n```\n新容器的容量 =2* 原有容量 + 所需字节数\n```\n\n#### bytes.Buffer 中的哪些方法可能会造成内容的泄露\n什么叫内容泄露？这里所说的内容泄露是指，使用 `Buffer` 值的一方通过某种非标准的（或者说不正式的）方式得到了本不该得到的内容。\n\n在` bytes.Buffer` 中，**`Bytes` 方法和` Next`方法都可能会造成内容的泄露**。原因在于，它们都把基于内容容器的切片直接返\n回给了方法的调用方。\n\n我们都知道，**通过切片，我们可以直接访问和操纵它的底层数组。不论这个切片是基于某个数组得来的，还是通过对另一个切片做切片操作\n获得的**，都是如此。\n```go\ncontents := \"ab\"\nbuffer1 := bytes.NewBufferString(contents)\nfmt.Printf(\"The capacity of new buffer with contents %q: %d\\n\",\n    contents, buffer1.Cap()) // 内容容器的容量为：8。\nfmt.Println()\n\nunreadBytes := buffer1.Bytes()\nfmt.Printf(\"The unread bytes of the buffer: %v\\n\", unreadBytes)\n```\n\n前面通过调用 `buffer1` 的` Bytes` 方法得到的结果值 `unreadBytes`，包含了在那时其中的所有未读内容。\n\n但是，由于这个结果值与 `buffer1` 的内容容器在此时还共用着同一个底层数组，所以，我只需通过简单的再切片操作，就可以利用这个\n结果值拿到 `buffer1` 在此时的所有未读内容。如此一来，`buffer1` 的新内容就被泄露出来了。\n### 一个 `string` 类型的值在底层怎样被表达\n在底层，一个 `string` 类型的值是由一系列相对应的 Unicode 代码点的 UTF-8 编码值来表达的。\n\n一个 `string` 类型的值既可以被拆分为一个包含多个字符的序列，也可以被拆分为一个包含多个字节的序列。\n前者可以由一个以 `rune`（`int32` 的别名）为元素类型的切片来表示，而后者则可以由一个以 `byte` 为元素类型的切片代表。\n\n`rune` 是 Go 语言特有的一个基本数据类型，它的一个值就代表一个字符，即：一个 Unicode 字符。比如，'G'、'o'、'爱'、'好'、\n'者'代表的就都是一个 Unicode 字符。一个 `rune` 类型的值会由四个字节宽度的空间来存储。它的存储空间总是能够存下一\n个 UTF-8 编码值。\n\n**一个 `rune` 类型的值在底层其实就是一个 UTF-8 编码值**。前者是（便于我们人类理解的）外部展现，后者是（便于计算机系统理解的）\n内在表达。\n\n```go\nstr := \"Go 爱好者 \"\nfmt.Printf(\"The string: %q\\n\", str)\nfmt.Printf(\"  => runes(char): %q\\n\", []rune(str))\nfmt.Printf(\"  => runes(hex): %x\\n\", []rune(str))\nfmt.Printf(\"  => bytes(hex): [% x]\\n\", []byte(str))\n```\n字符串值 \"Go 爱好者\" 如果被转换为 `[]rune` 类型的值的话，其中的每一个字符（不论是英文字符还是中文字符）就都会独立成为一\n个 `rune` 类型的元素值。因\n此，这段代码打印出的第二行内容就会如下所示：\n```bash\n=> runes(char): ['G' 'o' '爱' '好' '者']\n```\n又由于，每个 `rune` 类型的值在底层都是由一个 UTF-8 编码值来表达的，所以我们可以换一种方式来展现这个字符序列：\n```bash\n=> runes(hex): [47 6f 7231 597d 8005]\n```\n我们还可以进一步地拆分，把每个字符的 UTF-8 编码值都拆成相应的字节序列。上述代码中的第五行就是这么做的。它会得到如下的输出：\n```bash\n=> bytes(hex): [47 6f e7 88 b1 e5 a5 bd e8 80 85]\n```","date":"2019-08-28T00:15:07.506Z","updated":"2019-08-28T00:15:07.506Z","path":"basic/basic_data.html","comments":1,"layout":"page","_id":"ck1xm14l5000wfcw24s6x8p4w","content":"<h1 id=\"基础据类型\"><a href=\"#基础据类型\" class=\"headerlink\" title=\"基础据类型\"></a>基础据类型</h1><h2 id=\"数值类型\"><a href=\"#数值类型\" class=\"headerlink\" title=\"数值类型\"></a>数值类型</h2><h3 id=\"整型\"><a href=\"#整型\" class=\"headerlink\" title=\"整型\"></a>整型</h3><ul>\n<li><code>uint</code>，无符号 32 或 64 位整型</li>\n<li><code>uint8</code>，无符号 8 位整型 (0 到 255)</li>\n<li><code>uint16</code>，无符号 16 位整型 (0 到 65535)</li>\n<li><code>uint32</code>，无符号 32 位整型 (0 到 4294967295)</li>\n<li><code>uint64</code>，无符号 64 位整型 (0 到 18446744073709551615)</li>\n<li><code>int</code>，有符号 32 或 64 位整型</li>\n<li><code>int8</code>，有符号 8 位整型 (-128 到 127)</li>\n<li><code>int16</code>，有符号 16 位整型 (-32768 到 32767)</li>\n<li><code>int32</code>，有符号 32 位整型 (-2147483648 到 2147483647)</li>\n<li><code>int64</code>，有符号 64 位整型 (-9223372036854775808 到 9223372036854775807)</li>\n</ul>\n<p><code>int</code> 和 <code>uint</code> 对应的是 CPU 平台机器的字大小。</p>\n<h3 id=\"浮点数\"><a href=\"#浮点数\" class=\"headerlink\" title=\"浮点数\"></a>浮点数</h3><ul>\n<li><code>float32</code>，IEEE-754 32 位浮点型数，<code>math.MaxFloat32</code> 表示 <code>float32</code> 能表示的最大数值，大约是 <code>3.4e38</code>。</li>\n<li><code>float64</code>，IEEE-754 64 位浮点型数，<code>math.MaxFloat64</code> 表示 <code>float64</code> 能表示的最大数值，大约是 <code>1.8e308</code>。</li>\n</ul>\n<h3 id=\"复数\"><a href=\"#复数\" class=\"headerlink\" title=\"复数\"></a>复数</h3><ul>\n<li><code>complex64</code>，对应 <code>float32</code> 浮点数精度。</li>\n<li><code>complex128</code>，对应 <code>float64</code> 浮点数精度。</li>\n</ul>\n<p>内置 <code>complex</code> 函数创建复数。<code>math/cmplx</code> 包提供了复数处理的许多函数。</p>\n<h3 id=\"其他数值类型\"><a href=\"#其他数值类型\" class=\"headerlink\" title=\"其他数值类型\"></a>其他数值类型</h3><ul>\n<li><strong><code>byte</code>，<code>uint8</code>的别名</strong>，通常用于表示一个 <code>Unicode</code> 码点。</li>\n<li><strong><code>rune</code>，<code>int32</code>的别名</strong>，一般用于强调数值是一个原始的数据而不是一个小的整数。</li>\n<li><code>uintptr</code>，无符号整型，用于存放一个指针，没有指定具体的 <code>bit</code> 大小。</li>\n</ul>\n<h2 id=\"布尔类型\"><a href=\"#布尔类型\" class=\"headerlink\" title=\"布尔类型\"></a>布尔类型</h2><p>布尔类型的值只有两种：<code>true</code> 和 <code>false</code>。</p>\n<h2 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h2><p>字符串就是一串固定长度的字符连接起来的字符序列，不可改变。Go 的字符串是由单个字节连接起来的。Go 的字符串的字节使<br>用 <code>UTF-8</code> 编码标识 <code>Unicode</code> 文本。</p>\n<p><strong>一个原生的字符串面值形式是 `…`，使用反引号代替双引号。在原生的字符串面值中，没有转义操作；全部的内容都是字面的意思，<br>包含退格和换行</strong>。</p>\n<h3 id=\"字符串操作\"><a href=\"#字符串操作\" class=\"headerlink\" title=\"字符串操作\"></a>字符串操作</h3><ul>\n<li>内置函数 <code>len</code> 可以获取字符串的长度。</li>\n<li><strong>可以通过 <code>string[index]</code> 获取某个索引位置的字节值，字符串是不可修改的，不能使用 <code>string[index] = &quot;string2&quot;</code><br>这种方式改变字符串</strong>，要修改字符串，必须将其转为可变类型（<code>[]rune</code> 或 <code>[]byte</code>），完成后再转回来。</li>\n<li><p><code>string[i, l]</code> 获取 <code>string</code> 从第 <code>i</code> 个字节位置开始的 <code>l</code> 个字节，返回一个新的字符串。如：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s := <span class=\"string\">\"hello, world\"</span></span><br><span class=\"line\">fmt.Println(s[<span class=\"number\">0</span>:<span class=\"number\">5</span>]) <span class=\"comment\">// \"hello\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">fmt.Println(s[:<span class=\"number\">5</span>]) <span class=\"comment\">// \"hello\"</span></span><br><span class=\"line\">fmt.Println(s[<span class=\"number\">7</span>:]) <span class=\"comment\">// \"world\"</span></span><br><span class=\"line\">fmt.Println(s[:])  <span class=\"comment\">// \"hello, world\"</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>+</code> 拼接字符串，如 <code>fmt.Println(&quot;goodbye&quot; + s[5:])</code> 输出 <code>&quot;goodbye, world&quot;</code>。这种方式每次运算都会产生一个新的字<br>符串，需要重新分配内存，会给内存分配和 GC 带来额外的负担，所以性能比较差。</p>\n</li>\n<li><code>fmt.Sprintf()</code> 拼接字符串，内部使用 <code>[]byte</code> 实现，不像直接运算符这种会产生很多临时的字符串，但是内部的逻辑比较复杂，有很<br>多额外的判断，还用到了 <code>interface</code>，所以性能一般。</li>\n<li><code>strings.Join()</code> 拼接字符串，<code>Join</code> 会先根据字符串数组的内容，计算出一个拼接之后的长度，然后申请对应大小的内存，一个一个字符<br>串填入，在已有一个数组的情况下，这种效率会很高，但是本来没有，去构造这个数据的代价也不小。</li>\n<li><p><code>bytes.Buffer</code> 拼接字符串，比较理想，可以当成可变字符使用，对内存的增长也有优化，如果能预估字符串的长度，还可<br>以用 <code>buffer.Grow()</code> 接口来设置 <code>capacity</code>。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> buffer bytes.Buffer</span><br><span class=\"line\">buffer.WriteString(<span class=\"string\">\"hello\"</span>)</span><br><span class=\"line\">buffer.WriteString(<span class=\"string\">\", \"</span>)</span><br><span class=\"line\">buffer.WriteString(<span class=\"string\">\"world\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">fmt.Print(buffer.String())</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>strings.Builder</code> 内部通过 <code>slice</code> 来保存和管理内容。<code>slice</code> 内部则是通过一个指针指向实际保存内容的数组。<code>strings.Builder</code><br>是非线程安全，性能上和 <code>bytes.Buffer</code> 相差无几。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> b1 strings.Builder</span><br><span class=\"line\">b1.WriteString(<span class=\"string\">\"ABC\"</span>)</span><br><span class=\"line\">b1.WriteString(<span class=\"string\">\"DEF\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">fmt.Print(b1.String())</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用 <code>==</code> 和 <code>&lt;</code> 进行字符串比较。</p>\n</li>\n</ul>\n<h3 id=\"strings-包与字符串操作\"><a href=\"#strings-包与字符串操作\" class=\"headerlink\" title=\"strings 包与字符串操作\"></a>strings 包与字符串操作</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*字符串基本操作--strings*/</span></span><br><span class=\"line\">str := <span class=\"string\">\"wangdy\"</span></span><br><span class=\"line\"><span class=\"comment\">//是否包含</span></span><br><span class=\"line\">fmt.Println(strings.Contains(str, <span class=\"string\">\"wang\"</span>), strings.Contains(str, <span class=\"string\">\"123\"</span>)) <span class=\"comment\">//true false</span></span><br><span class=\"line\"><span class=\"comment\">//获取字符串长度</span></span><br><span class=\"line\">fmt.Println(<span class=\"built_in\">len</span>(str)) <span class=\"comment\">//6</span></span><br><span class=\"line\"><span class=\"comment\">//获取字符在字符串的位置 从0开始,如果不存在，返回-1</span></span><br><span class=\"line\">fmt.Println(strings.Index(str, <span class=\"string\">\"g\"</span>)) <span class=\"comment\">//3</span></span><br><span class=\"line\">fmt.Println(strings.Index(str, <span class=\"string\">\"x\"</span>)) <span class=\"comment\">//-1</span></span><br><span class=\"line\"><span class=\"comment\">//判断字符串是否以 xx 开头</span></span><br><span class=\"line\">fmt.Println(strings.HasPrefix(str, <span class=\"string\">\"wa\"</span>)) <span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"comment\">//判断字符串是否以 xx 结尾</span></span><br><span class=\"line\">fmt.Println(strings.HasSuffix(str, <span class=\"string\">\"dy\"</span>)) <span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"comment\">//判断2个字符串大小，相等0，左边大于右边-1，其他1</span></span><br><span class=\"line\">str2 := <span class=\"string\">\"hahaha\"</span></span><br><span class=\"line\">fmt.Println(strings.Compare(str, str2)) <span class=\"comment\">//1</span></span><br><span class=\"line\"><span class=\"comment\">//分割字符串</span></span><br><span class=\"line\">strSplit := strings.Split(<span class=\"string\">\"1-2-3-4-a\"</span>, <span class=\"string\">\"-\"</span>)</span><br><span class=\"line\">fmt.Println(strSplit) <span class=\"comment\">//[1 2 3 4 a]</span></span><br><span class=\"line\"><span class=\"comment\">//组装字符串</span></span><br><span class=\"line\">fmt.Println(strings.Join(strSplit, <span class=\"string\">\"#\"</span>)) <span class=\"comment\">//1#2#3#4#a</span></span><br><span class=\"line\"><span class=\"comment\">//去除字符串2端空格</span></span><br><span class=\"line\">fmt.Printf(<span class=\"string\">\"%s,%s\\n\"</span>, strings.Trim(<span class=\"string\">\"  我的2边有空格   1  \"</span>, <span class=\"string\">\" \"</span>), <span class=\"string\">\"/////\"</span>) <span class=\"comment\">//我的2边有空格   1,/////</span></span><br><span class=\"line\"><span class=\"comment\">//大小写转换</span></span><br><span class=\"line\">fmt.Println(strings.ToUpper(<span class=\"string\">\"abDCaE\"</span>)) <span class=\"comment\">//ABDCAE</span></span><br><span class=\"line\">fmt.Println(strings.ToLower(<span class=\"string\">\"abDCaE\"</span>)) <span class=\"comment\">//abdcae</span></span><br><span class=\"line\"><span class=\"comment\">//字符串替换:意思是：在sourceStr中，把oldStr的前n个替换成newStr，返回一个新字符串，如果n&lt;0则全部替换</span></span><br><span class=\"line\">sourceStr := <span class=\"string\">\"123123123\"</span></span><br><span class=\"line\">oldStr := <span class=\"string\">\"12\"</span></span><br><span class=\"line\">newStr := <span class=\"string\">\"ab\"</span></span><br><span class=\"line\">n := <span class=\"number\">2</span></span><br><span class=\"line\">fmt.Println(strings.Replace(sourceStr, oldStr, newStr, n))</span><br></pre></td></tr></table></figure>\n<p>在 Go 语言中，<strong><code>string</code> 类型的值是不可变的。如果我们想获得一个不一样的字符串，那么就只能基于原字符串进行裁剪、拼接等操作，<br>从而生成一个新的字符串</strong>。裁剪操作可以使用切片表达式，而拼接操作可以用操作符<code>+</code>实现。</p>\n<p>在底层，一个 <code>string</code> 值的内容会被存储到一块连续的内存空间中。同时，这块内存容纳的字节数量也会被记录下来，并用于表示<br>该 <code>string</code> 值的长度。</p>\n<p>你可以把这块内存的内容看成一个字节数组，而相应的 <code>string</code> 值则包含了指向字节数组头部的指针值。如此一来，<strong>我们在<br>一个 <code>string</code> 值上应用切片表达式，就相当于在对其底层的字节数组做切片</strong>。</p>\n<p>另一方面，我们在<strong>进行字符串拼接的时候，Go 语言会把所有被拼接的字符串依次拷贝到一个崭新且足够大的连续内存空间中，<br>并把持有相应指针值的 <code>string</code> 值作为结果返回</strong>。</p>\n<p>显然，当<strong>程序中存在过多的字符串拼接操作的时候，会对内存的分配产生非常大的压力</strong>。</p>\n<h4 id=\"与-string-值相比，strings-Builder-类型的值有哪些优势\"><a href=\"#与-string-值相比，strings-Builder-类型的值有哪些优势\" class=\"headerlink\" title=\"与 string 值相比，strings.Builder 类型的值有哪些优势\"></a>与 <code>string</code> 值相比，<code>strings.Builder</code> 类型的值有哪些优势</h4><ul>\n<li>已存在的内容不可变，但可以拼接更多的内容；</li>\n<li>减少了内存分配和内容拷贝的次数；</li>\n<li>可将内容重置，可重用值。</li>\n</ul>\n<p><code>Builder</code> 值中有一个用于承载内容的容器（以下简称内容容器）。它是一个以 <code>byte</code> 为元素类型的切片（以下简称字节切片）。</p>\n<p><strong>由于这样的字节切片的底层数组就是一个字节数组，所以我们可以说它与 <code>string</code> 值存储内容的方式是一样的</strong>。实际上，它们都是通过<br>一个 <code>unsafe.Pointer</code> 类型的字段来持有那个指向了底层字节数组的指针值的。</p>\n<p>因为这样的内部构造，<code>Builder</code> 值同样拥有高效利用内存的前提条件。</p>\n<p>已存在于 <code>Builder</code> 值中的内容是不可变的。因此，我们可以利用 <code>Builder</code> 值提供的方法拼接更多的内容，而丝毫不用担心这些方法<br>会影响到已存在的内容。</p>\n<p><code>Builder</code> 值拥有的一系列指针方法，包括：<code>Write</code>、<code>WriteByte</code>、<code>WriteRune</code> 和 <code>WriteString</code>。我们可以把它们统称<br>为<strong>拼接方法</strong>。</p>\n<p>调用上述方法把新的内容拼接到已存在的内容的尾部（也就是右边）。这时，如有必要，<code>Builder</code> 值会自动地对自身的内容容器进行扩容。<br>这里的自动扩容策略与切片的扩容策略一致。</p>\n<p>除了 <code>Builder</code> 值的自动扩容，我们还可以选择手动扩容，这通过调用 <code>Builder</code> 值的 <code>Grow</code> 方法就可以做到。<code>Grow</code> 方法也可以被称<br>为<strong>扩容方法</strong>，它接受一个 <code>int</code> 类型的参数 <code>n</code>，该参数用于代表将要扩充的字节数量。</p>\n<p><code>Grow</code> 方法会把其所属值中内容容器的容量增加 <code>n</code> 个字节。更具体地讲，它会生成一个字节切片作为新的内容容器，该切片的容量会是原<br>容器容量的二倍再加上 <code>n</code>。之后，它会把原容器中的所有字节全部拷贝到新容器中。</p>\n<h4 id=\"使用-strings-Builder-类型的约束\"><a href=\"#使用-strings-Builder-类型的约束\" class=\"headerlink\" title=\"使用 strings.Builder 类型的约束\"></a>使用 <code>strings.Builder</code> 类型的约束</h4><p><strong>只要调用了 <code>Builder</code> 值的拼接方法或扩容方法，就不能再以任何的方式对其所属值进行复制了</strong>。否则，只要在任何副本上调用上述方<br>法就都会引发 panic。这里所说的复制方式，包括但不限于在函数间传递值、通过通道传递值、把值赋予变量等等。</p>\n<p>正是由于已使用的 <code>Builder</code> 值不能再被复制，所以肯定不会出现多个 <code>Builder</code> 值中的内容容器（也就是那个字节切片）共用一个底层字<br>节数组的情况。这样也就避免了多个同源的<code>Builder</code> 值在拼接内容时可能产生的冲突问题。</p>\n<p><strong>不过，虽然已使用的 <code>Builder</code> 值不能再被复制，但是它的指针值却可以。无论什么时候，我们都可以通过任何方式复制这样的指针值</strong>。<br>注意，这样的指针值指向的都会是同一个 <code>Builder</code> 值。</p>\n<h3 id=\"strings-Reader-类型\"><a href=\"#strings-Reader-类型\" class=\"headerlink\" title=\"strings.Reader 类型\"></a><code>strings.Reader</code> 类型</h3><p><code>strings.Reader</code> 类型是为了高效读取字符串而存在的。可以让我们很方便地读取一个字符串中的内容。在读取的过程中，<code>Reader</code> 值会<br>保存已读取的字节的计数（以下简称已读计数）。</p>\n<p><strong>已读计数也代表着下一次读取的起始索引位置。<code>Reader</code> 值正是依靠这样一个计数，以及针对字符串值的切片表达式，从而实现快速读取</strong>。</p>\n<h3 id=\"bytes-包与字节串操作\"><a href=\"#bytes-包与字节串操作\" class=\"headerlink\" title=\"bytes 包与字节串操作\"></a>bytes 包与字节串操作</h3><p><code>strings</code> 包和 <code>bytes</code> 包可以说是一对孪生兄弟，它们在 API 方面非常的相似。单从它们提供的函数的数量和功能上讲，差别微乎其微。<br>只不过，<code>strings</code>包主要面向的是 <code>Unicode</code> 字符和经过 <code>UTF-8</code> 编码的字符串，而 <code>bytes</code> 包面对的则主要是字节和字节切片。</p>\n<h4 id=\"bytes-Buffer\"><a href=\"#bytes-Buffer\" class=\"headerlink\" title=\"bytes.Buffer\"></a><code>bytes.Buffer</code></h4><p><code>bytes.Buffer</code> 类型的用途主要是作为字节序列的缓冲区。<code>bytes.Buffer</code> 是开箱即用的。<code>bytes.Buffer</code> 不但可以拼接、截断其中<br>的字节序列，以各种形式导出其中的内容，还可以顺序地读取其中的子序列。</p>\n<p>在内部，<code>bytes.Buffer</code> 类型同样是使用字节切片作为内容容器的。并且，与 <code>strings.Reader</code> 类型类似，<code>bytes.Buffer</code> 有一个 <code>int</code><br>类型的字段，用于代表已读字节的计数，可以简称为<strong>已读计数</strong>。</p>\n<p><strong>注意，与 <code>strings.Reader</code> 类型的 <code>Len</code> 方法一样，<code>bytes.Buffer</code> 的<code>Len</code> 方法返回的也是内容容器中未被读取部分的长度，<br>而不是其中已存内容的总长度（以下简称内容长度）。</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 示例1。</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> buffer1 bytes.Buffer</span><br><span class=\"line\">contents := <span class=\"string\">\"Simple byte buffer for marshaling data.\"</span></span><br><span class=\"line\">fmt.Printf(<span class=\"string\">\"Write contents %q ...\\n\"</span>, contents)</span><br><span class=\"line\">buffer1.WriteString(contents)</span><br><span class=\"line\">fmt.Printf(<span class=\"string\">\"The length of buffer: %d\\n\"</span>, buffer1.Len()) <span class=\"comment\">// =&gt; 39</span></span><br><span class=\"line\">fmt.Printf(<span class=\"string\">\"The capacity of buffer: %d\\n\"</span>, buffer1.Cap()) <span class=\"comment\">// =&gt; 64</span></span><br><span class=\"line\">fmt.Println()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 示例2。</span></span><br><span class=\"line\">p1 := <span class=\"built_in\">make</span>([]<span class=\"keyword\">byte</span>, <span class=\"number\">7</span>)</span><br><span class=\"line\">n, _ := buffer1.Read(p1)</span><br><span class=\"line\">fmt.Printf(<span class=\"string\">\"%d bytes were read. (call Read)\\n\"</span>, n)</span><br><span class=\"line\">fmt.Printf(<span class=\"string\">\"The length of buffer: %d\\n\"</span>, buffer1.Len()) <span class=\"comment\">// =&gt; 32</span></span><br><span class=\"line\">fmt.Printf(<span class=\"string\">\"The capacity of buffer: %d\\n\"</span>, buffer1.Cap()) <span class=\"comment\">// =&gt; 64</span></span><br></pre></td></tr></table></figure>\n<p>上面的代码，示例一输出 39 和 64，但是示例二，从<code>buffer1</code> 中读取一部分内容，并用它们填满长度为7的字节切片 <code>p1</code> 之后，<br><code>buffer1</code> 的 <code>Len</code> 方法返回的结果值变为了 32。因为我们并没有再向该缓冲区中写入任何内容，所以它的容量会保持不变，仍是 64。</p>\n<blockquote>\n<p>对于处在零值状态的 <code>Buffer</code> 值来说，如果第一次扩容时的另需字节数不大于 64，那么该值就会基于一个预先定义好的、长度为 64<br>的字节数组来创建内容容器。</p>\n</blockquote>\n<p>由于 <code>strings.Reader</code> 还有一个 <code>Size</code> 方法可以给出内容长度的值，所以我们用内容长度减去未读部分的长度，就可以很方便地得<br>到它的已读计数。</p>\n<p>然而，<code>bytes.Buffer</code> 类型却没有这样一个方法，它只有 <code>Cap</code> 方法。可是 <code>Cap</code> 方法提供的是内容容器的容量，也不是内容长度。</p>\n<h4 id=\"bytes-Buffer-的扩容策略\"><a href=\"#bytes-Buffer-的扩容策略\" class=\"headerlink\" title=\"bytes.Buffer 的扩容策略\"></a>bytes.Buffer 的扩容策略</h4><p><code>Buffer</code> 值既可以被手动扩容，也可以进行自动扩容。并且，这两种扩容方式的策略是基本一致的。所以，除非我们完全确定后续内容所需<br>的字节数，否则让 <code>Buffer</code> 值自动去扩容就好了。</p>\n<p>在扩容的时候，<code>Buffer</code> 值中相应的代码（以下简称扩容代码）会先判断内容容器的剩余容量，是否可以满足调用方的要求，或者是否足<br>够容纳新的内容。</p>\n<p>如果可以，那么扩容代码会在当前的内容容器之上，进行长度扩充。更具体地说，如果内容容器的容量与其长度的差，大于或等于另需的字<br>节数，那么扩容代码就会通过切片操作对原有的内容容器的长度进行扩充，就像下面这样：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">b.buf = b.buf[:length+need]</span><br></pre></td></tr></table></figure></p>\n<p>反之，如果内容容器的剩余容量不够了，那么扩容代码可能就会用新的内容容器去替代原有的内容容器，从而实现扩容。不过，这里还一步优化。</p>\n<p>如果当前内容容器的容量的一半仍然大于或等于其现有长度再加上另需的字节数的和，即：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cap</span>(b.buf)/<span class=\"number\">2</span> &gt;= <span class=\"built_in\">len</span>(b.buf)+need</span><br></pre></td></tr></table></figure></p>\n<p>那么，扩容代码就会复用现有的内容容器，并把容器中的未读内容拷贝到它的头部位置。这也意味着其中的已读内容，将会全部被未读内容和<br>之后的新内容覆盖掉。</p>\n<p>这样的复用预计可以至少节省掉一次后续的扩容所带来的内存分配，以及若干字节的拷贝。</p>\n<p>若这一步优化未能达成，也就是说，当前内容容器的容量小于新长度的二倍，那么扩容代码就只能再创建一个新的内容容器，并把原有容器<br>中的未读内容拷贝进去，最后再用新的容器替换掉原有的容器。这个新容器的容量将会等于原有容量的二倍再加上另需字节数的和。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">新容器的容量 =2* 原有容量 + 所需字节数</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"bytes-Buffer-中的哪些方法可能会造成内容的泄露\"><a href=\"#bytes-Buffer-中的哪些方法可能会造成内容的泄露\" class=\"headerlink\" title=\"bytes.Buffer 中的哪些方法可能会造成内容的泄露\"></a>bytes.Buffer 中的哪些方法可能会造成内容的泄露</h4><p>什么叫内容泄露？这里所说的内容泄露是指，使用 <code>Buffer</code> 值的一方通过某种非标准的（或者说不正式的）方式得到了本不该得到的内容。</p>\n<p>在<code>bytes.Buffer</code> 中，<strong><code>Bytes</code> 方法和<code>Next</code>方法都可能会造成内容的泄露</strong>。原因在于，它们都把基于内容容器的切片直接返<br>回给了方法的调用方。</p>\n<p>我们都知道，<strong>通过切片，我们可以直接访问和操纵它的底层数组。不论这个切片是基于某个数组得来的，还是通过对另一个切片做切片操作<br>获得的</strong>，都是如此。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">contents := <span class=\"string\">\"ab\"</span></span><br><span class=\"line\">buffer1 := bytes.NewBufferString(contents)</span><br><span class=\"line\">fmt.Printf(<span class=\"string\">\"The capacity of new buffer with contents %q: %d\\n\"</span>,</span><br><span class=\"line\">    contents, buffer1.Cap()) <span class=\"comment\">// 内容容器的容量为：8。</span></span><br><span class=\"line\">fmt.Println()</span><br><span class=\"line\"></span><br><span class=\"line\">unreadBytes := buffer1.Bytes()</span><br><span class=\"line\">fmt.Printf(<span class=\"string\">\"The unread bytes of the buffer: %v\\n\"</span>, unreadBytes)</span><br></pre></td></tr></table></figure></p>\n<p>前面通过调用 <code>buffer1</code> 的<code>Bytes</code> 方法得到的结果值 <code>unreadBytes</code>，包含了在那时其中的所有未读内容。</p>\n<p>但是，由于这个结果值与 <code>buffer1</code> 的内容容器在此时还共用着同一个底层数组，所以，我只需通过简单的再切片操作，就可以利用这个<br>结果值拿到 <code>buffer1</code> 在此时的所有未读内容。如此一来，<code>buffer1</code> 的新内容就被泄露出来了。</p>\n<h3 id=\"一个-string-类型的值在底层怎样被表达\"><a href=\"#一个-string-类型的值在底层怎样被表达\" class=\"headerlink\" title=\"一个 string 类型的值在底层怎样被表达\"></a>一个 <code>string</code> 类型的值在底层怎样被表达</h3><p>在底层，一个 <code>string</code> 类型的值是由一系列相对应的 Unicode 代码点的 UTF-8 编码值来表达的。</p>\n<p>一个 <code>string</code> 类型的值既可以被拆分为一个包含多个字符的序列，也可以被拆分为一个包含多个字节的序列。<br>前者可以由一个以 <code>rune</code>（<code>int32</code> 的别名）为元素类型的切片来表示，而后者则可以由一个以 <code>byte</code> 为元素类型的切片代表。</p>\n<p><code>rune</code> 是 Go 语言特有的一个基本数据类型，它的一个值就代表一个字符，即：一个 Unicode 字符。比如，’G’、’o’、’爱’、’好’、<br>‘者’代表的就都是一个 Unicode 字符。一个 <code>rune</code> 类型的值会由四个字节宽度的空间来存储。它的存储空间总是能够存下一<br>个 UTF-8 编码值。</p>\n<p><strong>一个 <code>rune</code> 类型的值在底层其实就是一个 UTF-8 编码值</strong>。前者是（便于我们人类理解的）外部展现，后者是（便于计算机系统理解的）<br>内在表达。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str := <span class=\"string\">\"Go 爱好者 \"</span></span><br><span class=\"line\">fmt.Printf(<span class=\"string\">\"The string: %q\\n\"</span>, str)</span><br><span class=\"line\">fmt.Printf(<span class=\"string\">\"  =&gt; runes(char): %q\\n\"</span>, []<span class=\"keyword\">rune</span>(str))</span><br><span class=\"line\">fmt.Printf(<span class=\"string\">\"  =&gt; runes(hex): %x\\n\"</span>, []<span class=\"keyword\">rune</span>(str))</span><br><span class=\"line\">fmt.Printf(<span class=\"string\">\"  =&gt; bytes(hex): [% x]\\n\"</span>, []<span class=\"keyword\">byte</span>(str))</span><br></pre></td></tr></table></figure>\n<p>字符串值 “Go 爱好者” 如果被转换为 <code>[]rune</code> 类型的值的话，其中的每一个字符（不论是英文字符还是中文字符）就都会独立成为一<br>个 <code>rune</code> 类型的元素值。因<br>此，这段代码打印出的第二行内容就会如下所示：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">=&gt; runes(char): [<span class=\"string\">'G'</span> <span class=\"string\">'o'</span> <span class=\"string\">'爱'</span> <span class=\"string\">'好'</span> <span class=\"string\">'者'</span>]</span><br></pre></td></tr></table></figure></p>\n<p>又由于，每个 <code>rune</code> 类型的值在底层都是由一个 UTF-8 编码值来表达的，所以我们可以换一种方式来展现这个字符序列：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">=&gt; runes(hex): [47 6f 7231 597d 8005]</span><br></pre></td></tr></table></figure></p>\n<p>我们还可以进一步地拆分，把每个字符的 UTF-8 编码值都拆成相应的字节序列。上述代码中的第五行就是这么做的。它会得到如下的输出：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">=&gt; bytes(hex): [47 6f e7 88 b1 e5 a5 bd e8 80 85]</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{"navigation":{"logo":{"text":"Golang Learn","type":"link","path":"index.html"},"main":[{"text":"Golang 基础","type":"label"},{"text":"Go 环境配置","type":"link","path":"basic/env_config.html"},{"text":"包","type":"link","path":"basic/package.html"},{"text":"基础数据类型","type":"link","path":"basic/basic_data.html"},{"text":"变量","type":"link","path":"basic/var.html"},{"text":"常量","type":"link","path":"basic/constant.html"},{"text":"控制语句","type":"link","path":"basic/flow.html"},{"text":"运算符","type":"link","path":"basic/operator.html"},{"text":"作用域","type":"link","path":"basic/scope.html"},{"text":"指针","type":"link","path":"basic/pointer.html"},{"text":"数组","type":"link","path":"basic/array.html"},{"text":"切片","type":"link","path":"basic/slice.html"},{"text":"字典","type":"link","path":"basic/map.html"},{"text":"函数","type":"link","path":"basic/function.html"},{"text":"结构体","type":"link","path":"basic/struct.html"},{"text":"接口","type":"link","path":"basic/interface.html"},{"text":"面向对象","type":"link","path":"basic/oop.html"},{"text":"错误","type":"link","path":"basic/error.html"},{"text":"序列化","type":"link","path":"basic/json.html"},{"text":"反射","type":"link","path":"basic/reflect.html"},{"text":"测试","type":"link","path":"basic/test.html"},{"text":"并发编程","type":"label"},{"text":"goroutine","type":"link","path":"concurrent/goroutine.html"},{"text":"channel","type":"link","path":"concurrent/channel.html"},{"text":"同步和锁","type":"link","path":"concurrent/sync_lock.html"},{"text":"内存分配","type":"label"},{"text":"内存分配","type":"link","path":"advance/mm.html"},{"text":"垃圾回收","type":"label"},{"text":"垃圾回收","type":"link","path":"advance/gc.html"},{"text":"标准库","type":"label"},{"text":"fmt","type":"link","path":"standards/io/fmt.html"},{"text":"io","type":"link","path":"standards/io/io.html"},{"text":"ioutil","type":"link","path":"standards/io/ioutil.html"},{"text":"bufio","type":"link","path":"standards/io/bufio.html"},{"text":"os","type":"link","path":"standards/os/os.html"},{"text":"filepath","type":"link","path":"standards/os/filepath.html"},{"text":"strings","type":"link","path":"standards/text/strings.html"},{"text":"strconv","type":"link","path":"standards/text/strconv.html"},{"text":"unicode","type":"link","path":"standards/text/unicode.html"},{"text":"log","type":"link","path":"standards/log.html"},{"text":"time","type":"link","path":"standards/time.html"},{"text":"http","type":"link","path":"standards/net/http.html"},{"text":"math","type":"link","path":"standards/data/math.html"},{"text":"sort","type":"link","path":"standards/data/sort.html"},{"text":"big","type":"link","path":"standards/data/big.html"},{"text":"container","type":"link","path":"standards/data/container.html"},{"text":"sql","type":"link","path":"standards/database/sql.html"},{"text":"THEME","type":"label"},{"text":"使用文档主题","type":"link","path":"theme/theme-usage.html"},{"text":"SUPPORT AND FEEDBACK","type":"label"},{"text":"Raise an Issue on Github","type":"link","path":"https://github.com/shipengqi/golang-learn/issues/new"}]}}},"excerpt":"","more":"<h1 id=\"基础据类型\"><a href=\"#基础据类型\" class=\"headerlink\" title=\"基础据类型\"></a>基础据类型</h1><h2 id=\"数值类型\"><a href=\"#数值类型\" class=\"headerlink\" title=\"数值类型\"></a>数值类型</h2><h3 id=\"整型\"><a href=\"#整型\" class=\"headerlink\" title=\"整型\"></a>整型</h3><ul>\n<li><code>uint</code>，无符号 32 或 64 位整型</li>\n<li><code>uint8</code>，无符号 8 位整型 (0 到 255)</li>\n<li><code>uint16</code>，无符号 16 位整型 (0 到 65535)</li>\n<li><code>uint32</code>，无符号 32 位整型 (0 到 4294967295)</li>\n<li><code>uint64</code>，无符号 64 位整型 (0 到 18446744073709551615)</li>\n<li><code>int</code>，有符号 32 或 64 位整型</li>\n<li><code>int8</code>，有符号 8 位整型 (-128 到 127)</li>\n<li><code>int16</code>，有符号 16 位整型 (-32768 到 32767)</li>\n<li><code>int32</code>，有符号 32 位整型 (-2147483648 到 2147483647)</li>\n<li><code>int64</code>，有符号 64 位整型 (-9223372036854775808 到 9223372036854775807)</li>\n</ul>\n<p><code>int</code> 和 <code>uint</code> 对应的是 CPU 平台机器的字大小。</p>\n<h3 id=\"浮点数\"><a href=\"#浮点数\" class=\"headerlink\" title=\"浮点数\"></a>浮点数</h3><ul>\n<li><code>float32</code>，IEEE-754 32 位浮点型数，<code>math.MaxFloat32</code> 表示 <code>float32</code> 能表示的最大数值，大约是 <code>3.4e38</code>。</li>\n<li><code>float64</code>，IEEE-754 64 位浮点型数，<code>math.MaxFloat64</code> 表示 <code>float64</code> 能表示的最大数值，大约是 <code>1.8e308</code>。</li>\n</ul>\n<h3 id=\"复数\"><a href=\"#复数\" class=\"headerlink\" title=\"复数\"></a>复数</h3><ul>\n<li><code>complex64</code>，对应 <code>float32</code> 浮点数精度。</li>\n<li><code>complex128</code>，对应 <code>float64</code> 浮点数精度。</li>\n</ul>\n<p>内置 <code>complex</code> 函数创建复数。<code>math/cmplx</code> 包提供了复数处理的许多函数。</p>\n<h3 id=\"其他数值类型\"><a href=\"#其他数值类型\" class=\"headerlink\" title=\"其他数值类型\"></a>其他数值类型</h3><ul>\n<li><strong><code>byte</code>，<code>uint8</code>的别名</strong>，通常用于表示一个 <code>Unicode</code> 码点。</li>\n<li><strong><code>rune</code>，<code>int32</code>的别名</strong>，一般用于强调数值是一个原始的数据而不是一个小的整数。</li>\n<li><code>uintptr</code>，无符号整型，用于存放一个指针，没有指定具体的 <code>bit</code> 大小。</li>\n</ul>\n<h2 id=\"布尔类型\"><a href=\"#布尔类型\" class=\"headerlink\" title=\"布尔类型\"></a>布尔类型</h2><p>布尔类型的值只有两种：<code>true</code> 和 <code>false</code>。</p>\n<h2 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h2><p>字符串就是一串固定长度的字符连接起来的字符序列，不可改变。Go 的字符串是由单个字节连接起来的。Go 的字符串的字节使<br>用 <code>UTF-8</code> 编码标识 <code>Unicode</code> 文本。</p>\n<p><strong>一个原生的字符串面值形式是 `…`，使用反引号代替双引号。在原生的字符串面值中，没有转义操作；全部的内容都是字面的意思，<br>包含退格和换行</strong>。</p>\n<h3 id=\"字符串操作\"><a href=\"#字符串操作\" class=\"headerlink\" title=\"字符串操作\"></a>字符串操作</h3><ul>\n<li>内置函数 <code>len</code> 可以获取字符串的长度。</li>\n<li><strong>可以通过 <code>string[index]</code> 获取某个索引位置的字节值，字符串是不可修改的，不能使用 <code>string[index] = &quot;string2&quot;</code><br>这种方式改变字符串</strong>，要修改字符串，必须将其转为可变类型（<code>[]rune</code> 或 <code>[]byte</code>），完成后再转回来。</li>\n<li><p><code>string[i, l]</code> 获取 <code>string</code> 从第 <code>i</code> 个字节位置开始的 <code>l</code> 个字节，返回一个新的字符串。如：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s := <span class=\"string\">\"hello, world\"</span></span><br><span class=\"line\">fmt.Println(s[<span class=\"number\">0</span>:<span class=\"number\">5</span>]) <span class=\"comment\">// \"hello\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">fmt.Println(s[:<span class=\"number\">5</span>]) <span class=\"comment\">// \"hello\"</span></span><br><span class=\"line\">fmt.Println(s[<span class=\"number\">7</span>:]) <span class=\"comment\">// \"world\"</span></span><br><span class=\"line\">fmt.Println(s[:])  <span class=\"comment\">// \"hello, world\"</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>+</code> 拼接字符串，如 <code>fmt.Println(&quot;goodbye&quot; + s[5:])</code> 输出 <code>&quot;goodbye, world&quot;</code>。这种方式每次运算都会产生一个新的字<br>符串，需要重新分配内存，会给内存分配和 GC 带来额外的负担，所以性能比较差。</p>\n</li>\n<li><code>fmt.Sprintf()</code> 拼接字符串，内部使用 <code>[]byte</code> 实现，不像直接运算符这种会产生很多临时的字符串，但是内部的逻辑比较复杂，有很<br>多额外的判断，还用到了 <code>interface</code>，所以性能一般。</li>\n<li><code>strings.Join()</code> 拼接字符串，<code>Join</code> 会先根据字符串数组的内容，计算出一个拼接之后的长度，然后申请对应大小的内存，一个一个字符<br>串填入，在已有一个数组的情况下，这种效率会很高，但是本来没有，去构造这个数据的代价也不小。</li>\n<li><p><code>bytes.Buffer</code> 拼接字符串，比较理想，可以当成可变字符使用，对内存的增长也有优化，如果能预估字符串的长度，还可<br>以用 <code>buffer.Grow()</code> 接口来设置 <code>capacity</code>。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> buffer bytes.Buffer</span><br><span class=\"line\">buffer.WriteString(<span class=\"string\">\"hello\"</span>)</span><br><span class=\"line\">buffer.WriteString(<span class=\"string\">\", \"</span>)</span><br><span class=\"line\">buffer.WriteString(<span class=\"string\">\"world\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">fmt.Print(buffer.String())</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>strings.Builder</code> 内部通过 <code>slice</code> 来保存和管理内容。<code>slice</code> 内部则是通过一个指针指向实际保存内容的数组。<code>strings.Builder</code><br>是非线程安全，性能上和 <code>bytes.Buffer</code> 相差无几。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> b1 strings.Builder</span><br><span class=\"line\">b1.WriteString(<span class=\"string\">\"ABC\"</span>)</span><br><span class=\"line\">b1.WriteString(<span class=\"string\">\"DEF\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">fmt.Print(b1.String())</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用 <code>==</code> 和 <code>&lt;</code> 进行字符串比较。</p>\n</li>\n</ul>\n<h3 id=\"strings-包与字符串操作\"><a href=\"#strings-包与字符串操作\" class=\"headerlink\" title=\"strings 包与字符串操作\"></a>strings 包与字符串操作</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*字符串基本操作--strings*/</span></span><br><span class=\"line\">str := <span class=\"string\">\"wangdy\"</span></span><br><span class=\"line\"><span class=\"comment\">//是否包含</span></span><br><span class=\"line\">fmt.Println(strings.Contains(str, <span class=\"string\">\"wang\"</span>), strings.Contains(str, <span class=\"string\">\"123\"</span>)) <span class=\"comment\">//true false</span></span><br><span class=\"line\"><span class=\"comment\">//获取字符串长度</span></span><br><span class=\"line\">fmt.Println(<span class=\"built_in\">len</span>(str)) <span class=\"comment\">//6</span></span><br><span class=\"line\"><span class=\"comment\">//获取字符在字符串的位置 从0开始,如果不存在，返回-1</span></span><br><span class=\"line\">fmt.Println(strings.Index(str, <span class=\"string\">\"g\"</span>)) <span class=\"comment\">//3</span></span><br><span class=\"line\">fmt.Println(strings.Index(str, <span class=\"string\">\"x\"</span>)) <span class=\"comment\">//-1</span></span><br><span class=\"line\"><span class=\"comment\">//判断字符串是否以 xx 开头</span></span><br><span class=\"line\">fmt.Println(strings.HasPrefix(str, <span class=\"string\">\"wa\"</span>)) <span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"comment\">//判断字符串是否以 xx 结尾</span></span><br><span class=\"line\">fmt.Println(strings.HasSuffix(str, <span class=\"string\">\"dy\"</span>)) <span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"comment\">//判断2个字符串大小，相等0，左边大于右边-1，其他1</span></span><br><span class=\"line\">str2 := <span class=\"string\">\"hahaha\"</span></span><br><span class=\"line\">fmt.Println(strings.Compare(str, str2)) <span class=\"comment\">//1</span></span><br><span class=\"line\"><span class=\"comment\">//分割字符串</span></span><br><span class=\"line\">strSplit := strings.Split(<span class=\"string\">\"1-2-3-4-a\"</span>, <span class=\"string\">\"-\"</span>)</span><br><span class=\"line\">fmt.Println(strSplit) <span class=\"comment\">//[1 2 3 4 a]</span></span><br><span class=\"line\"><span class=\"comment\">//组装字符串</span></span><br><span class=\"line\">fmt.Println(strings.Join(strSplit, <span class=\"string\">\"#\"</span>)) <span class=\"comment\">//1#2#3#4#a</span></span><br><span class=\"line\"><span class=\"comment\">//去除字符串2端空格</span></span><br><span class=\"line\">fmt.Printf(<span class=\"string\">\"%s,%s\\n\"</span>, strings.Trim(<span class=\"string\">\"  我的2边有空格   1  \"</span>, <span class=\"string\">\" \"</span>), <span class=\"string\">\"/////\"</span>) <span class=\"comment\">//我的2边有空格   1,/////</span></span><br><span class=\"line\"><span class=\"comment\">//大小写转换</span></span><br><span class=\"line\">fmt.Println(strings.ToUpper(<span class=\"string\">\"abDCaE\"</span>)) <span class=\"comment\">//ABDCAE</span></span><br><span class=\"line\">fmt.Println(strings.ToLower(<span class=\"string\">\"abDCaE\"</span>)) <span class=\"comment\">//abdcae</span></span><br><span class=\"line\"><span class=\"comment\">//字符串替换:意思是：在sourceStr中，把oldStr的前n个替换成newStr，返回一个新字符串，如果n&lt;0则全部替换</span></span><br><span class=\"line\">sourceStr := <span class=\"string\">\"123123123\"</span></span><br><span class=\"line\">oldStr := <span class=\"string\">\"12\"</span></span><br><span class=\"line\">newStr := <span class=\"string\">\"ab\"</span></span><br><span class=\"line\">n := <span class=\"number\">2</span></span><br><span class=\"line\">fmt.Println(strings.Replace(sourceStr, oldStr, newStr, n))</span><br></pre></td></tr></table></figure>\n<p>在 Go 语言中，<strong><code>string</code> 类型的值是不可变的。如果我们想获得一个不一样的字符串，那么就只能基于原字符串进行裁剪、拼接等操作，<br>从而生成一个新的字符串</strong>。裁剪操作可以使用切片表达式，而拼接操作可以用操作符<code>+</code>实现。</p>\n<p>在底层，一个 <code>string</code> 值的内容会被存储到一块连续的内存空间中。同时，这块内存容纳的字节数量也会被记录下来，并用于表示<br>该 <code>string</code> 值的长度。</p>\n<p>你可以把这块内存的内容看成一个字节数组，而相应的 <code>string</code> 值则包含了指向字节数组头部的指针值。如此一来，<strong>我们在<br>一个 <code>string</code> 值上应用切片表达式，就相当于在对其底层的字节数组做切片</strong>。</p>\n<p>另一方面，我们在<strong>进行字符串拼接的时候，Go 语言会把所有被拼接的字符串依次拷贝到一个崭新且足够大的连续内存空间中，<br>并把持有相应指针值的 <code>string</code> 值作为结果返回</strong>。</p>\n<p>显然，当<strong>程序中存在过多的字符串拼接操作的时候，会对内存的分配产生非常大的压力</strong>。</p>\n<h4 id=\"与-string-值相比，strings-Builder-类型的值有哪些优势\"><a href=\"#与-string-值相比，strings-Builder-类型的值有哪些优势\" class=\"headerlink\" title=\"与 string 值相比，strings.Builder 类型的值有哪些优势\"></a>与 <code>string</code> 值相比，<code>strings.Builder</code> 类型的值有哪些优势</h4><ul>\n<li>已存在的内容不可变，但可以拼接更多的内容；</li>\n<li>减少了内存分配和内容拷贝的次数；</li>\n<li>可将内容重置，可重用值。</li>\n</ul>\n<p><code>Builder</code> 值中有一个用于承载内容的容器（以下简称内容容器）。它是一个以 <code>byte</code> 为元素类型的切片（以下简称字节切片）。</p>\n<p><strong>由于这样的字节切片的底层数组就是一个字节数组，所以我们可以说它与 <code>string</code> 值存储内容的方式是一样的</strong>。实际上，它们都是通过<br>一个 <code>unsafe.Pointer</code> 类型的字段来持有那个指向了底层字节数组的指针值的。</p>\n<p>因为这样的内部构造，<code>Builder</code> 值同样拥有高效利用内存的前提条件。</p>\n<p>已存在于 <code>Builder</code> 值中的内容是不可变的。因此，我们可以利用 <code>Builder</code> 值提供的方法拼接更多的内容，而丝毫不用担心这些方法<br>会影响到已存在的内容。</p>\n<p><code>Builder</code> 值拥有的一系列指针方法，包括：<code>Write</code>、<code>WriteByte</code>、<code>WriteRune</code> 和 <code>WriteString</code>。我们可以把它们统称<br>为<strong>拼接方法</strong>。</p>\n<p>调用上述方法把新的内容拼接到已存在的内容的尾部（也就是右边）。这时，如有必要，<code>Builder</code> 值会自动地对自身的内容容器进行扩容。<br>这里的自动扩容策略与切片的扩容策略一致。</p>\n<p>除了 <code>Builder</code> 值的自动扩容，我们还可以选择手动扩容，这通过调用 <code>Builder</code> 值的 <code>Grow</code> 方法就可以做到。<code>Grow</code> 方法也可以被称<br>为<strong>扩容方法</strong>，它接受一个 <code>int</code> 类型的参数 <code>n</code>，该参数用于代表将要扩充的字节数量。</p>\n<p><code>Grow</code> 方法会把其所属值中内容容器的容量增加 <code>n</code> 个字节。更具体地讲，它会生成一个字节切片作为新的内容容器，该切片的容量会是原<br>容器容量的二倍再加上 <code>n</code>。之后，它会把原容器中的所有字节全部拷贝到新容器中。</p>\n<h4 id=\"使用-strings-Builder-类型的约束\"><a href=\"#使用-strings-Builder-类型的约束\" class=\"headerlink\" title=\"使用 strings.Builder 类型的约束\"></a>使用 <code>strings.Builder</code> 类型的约束</h4><p><strong>只要调用了 <code>Builder</code> 值的拼接方法或扩容方法，就不能再以任何的方式对其所属值进行复制了</strong>。否则，只要在任何副本上调用上述方<br>法就都会引发 panic。这里所说的复制方式，包括但不限于在函数间传递值、通过通道传递值、把值赋予变量等等。</p>\n<p>正是由于已使用的 <code>Builder</code> 值不能再被复制，所以肯定不会出现多个 <code>Builder</code> 值中的内容容器（也就是那个字节切片）共用一个底层字<br>节数组的情况。这样也就避免了多个同源的<code>Builder</code> 值在拼接内容时可能产生的冲突问题。</p>\n<p><strong>不过，虽然已使用的 <code>Builder</code> 值不能再被复制，但是它的指针值却可以。无论什么时候，我们都可以通过任何方式复制这样的指针值</strong>。<br>注意，这样的指针值指向的都会是同一个 <code>Builder</code> 值。</p>\n<h3 id=\"strings-Reader-类型\"><a href=\"#strings-Reader-类型\" class=\"headerlink\" title=\"strings.Reader 类型\"></a><code>strings.Reader</code> 类型</h3><p><code>strings.Reader</code> 类型是为了高效读取字符串而存在的。可以让我们很方便地读取一个字符串中的内容。在读取的过程中，<code>Reader</code> 值会<br>保存已读取的字节的计数（以下简称已读计数）。</p>\n<p><strong>已读计数也代表着下一次读取的起始索引位置。<code>Reader</code> 值正是依靠这样一个计数，以及针对字符串值的切片表达式，从而实现快速读取</strong>。</p>\n<h3 id=\"bytes-包与字节串操作\"><a href=\"#bytes-包与字节串操作\" class=\"headerlink\" title=\"bytes 包与字节串操作\"></a>bytes 包与字节串操作</h3><p><code>strings</code> 包和 <code>bytes</code> 包可以说是一对孪生兄弟，它们在 API 方面非常的相似。单从它们提供的函数的数量和功能上讲，差别微乎其微。<br>只不过，<code>strings</code>包主要面向的是 <code>Unicode</code> 字符和经过 <code>UTF-8</code> 编码的字符串，而 <code>bytes</code> 包面对的则主要是字节和字节切片。</p>\n<h4 id=\"bytes-Buffer\"><a href=\"#bytes-Buffer\" class=\"headerlink\" title=\"bytes.Buffer\"></a><code>bytes.Buffer</code></h4><p><code>bytes.Buffer</code> 类型的用途主要是作为字节序列的缓冲区。<code>bytes.Buffer</code> 是开箱即用的。<code>bytes.Buffer</code> 不但可以拼接、截断其中<br>的字节序列，以各种形式导出其中的内容，还可以顺序地读取其中的子序列。</p>\n<p>在内部，<code>bytes.Buffer</code> 类型同样是使用字节切片作为内容容器的。并且，与 <code>strings.Reader</code> 类型类似，<code>bytes.Buffer</code> 有一个 <code>int</code><br>类型的字段，用于代表已读字节的计数，可以简称为<strong>已读计数</strong>。</p>\n<p><strong>注意，与 <code>strings.Reader</code> 类型的 <code>Len</code> 方法一样，<code>bytes.Buffer</code> 的<code>Len</code> 方法返回的也是内容容器中未被读取部分的长度，<br>而不是其中已存内容的总长度（以下简称内容长度）。</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 示例1。</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> buffer1 bytes.Buffer</span><br><span class=\"line\">contents := <span class=\"string\">\"Simple byte buffer for marshaling data.\"</span></span><br><span class=\"line\">fmt.Printf(<span class=\"string\">\"Write contents %q ...\\n\"</span>, contents)</span><br><span class=\"line\">buffer1.WriteString(contents)</span><br><span class=\"line\">fmt.Printf(<span class=\"string\">\"The length of buffer: %d\\n\"</span>, buffer1.Len()) <span class=\"comment\">// =&gt; 39</span></span><br><span class=\"line\">fmt.Printf(<span class=\"string\">\"The capacity of buffer: %d\\n\"</span>, buffer1.Cap()) <span class=\"comment\">// =&gt; 64</span></span><br><span class=\"line\">fmt.Println()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 示例2。</span></span><br><span class=\"line\">p1 := <span class=\"built_in\">make</span>([]<span class=\"keyword\">byte</span>, <span class=\"number\">7</span>)</span><br><span class=\"line\">n, _ := buffer1.Read(p1)</span><br><span class=\"line\">fmt.Printf(<span class=\"string\">\"%d bytes were read. (call Read)\\n\"</span>, n)</span><br><span class=\"line\">fmt.Printf(<span class=\"string\">\"The length of buffer: %d\\n\"</span>, buffer1.Len()) <span class=\"comment\">// =&gt; 32</span></span><br><span class=\"line\">fmt.Printf(<span class=\"string\">\"The capacity of buffer: %d\\n\"</span>, buffer1.Cap()) <span class=\"comment\">// =&gt; 64</span></span><br></pre></td></tr></table></figure>\n<p>上面的代码，示例一输出 39 和 64，但是示例二，从<code>buffer1</code> 中读取一部分内容，并用它们填满长度为7的字节切片 <code>p1</code> 之后，<br><code>buffer1</code> 的 <code>Len</code> 方法返回的结果值变为了 32。因为我们并没有再向该缓冲区中写入任何内容，所以它的容量会保持不变，仍是 64。</p>\n<blockquote>\n<p>对于处在零值状态的 <code>Buffer</code> 值来说，如果第一次扩容时的另需字节数不大于 64，那么该值就会基于一个预先定义好的、长度为 64<br>的字节数组来创建内容容器。</p>\n</blockquote>\n<p>由于 <code>strings.Reader</code> 还有一个 <code>Size</code> 方法可以给出内容长度的值，所以我们用内容长度减去未读部分的长度，就可以很方便地得<br>到它的已读计数。</p>\n<p>然而，<code>bytes.Buffer</code> 类型却没有这样一个方法，它只有 <code>Cap</code> 方法。可是 <code>Cap</code> 方法提供的是内容容器的容量，也不是内容长度。</p>\n<h4 id=\"bytes-Buffer-的扩容策略\"><a href=\"#bytes-Buffer-的扩容策略\" class=\"headerlink\" title=\"bytes.Buffer 的扩容策略\"></a>bytes.Buffer 的扩容策略</h4><p><code>Buffer</code> 值既可以被手动扩容，也可以进行自动扩容。并且，这两种扩容方式的策略是基本一致的。所以，除非我们完全确定后续内容所需<br>的字节数，否则让 <code>Buffer</code> 值自动去扩容就好了。</p>\n<p>在扩容的时候，<code>Buffer</code> 值中相应的代码（以下简称扩容代码）会先判断内容容器的剩余容量，是否可以满足调用方的要求，或者是否足<br>够容纳新的内容。</p>\n<p>如果可以，那么扩容代码会在当前的内容容器之上，进行长度扩充。更具体地说，如果内容容器的容量与其长度的差，大于或等于另需的字<br>节数，那么扩容代码就会通过切片操作对原有的内容容器的长度进行扩充，就像下面这样：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">b.buf = b.buf[:length+need]</span><br></pre></td></tr></table></figure></p>\n<p>反之，如果内容容器的剩余容量不够了，那么扩容代码可能就会用新的内容容器去替代原有的内容容器，从而实现扩容。不过，这里还一步优化。</p>\n<p>如果当前内容容器的容量的一半仍然大于或等于其现有长度再加上另需的字节数的和，即：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cap</span>(b.buf)/<span class=\"number\">2</span> &gt;= <span class=\"built_in\">len</span>(b.buf)+need</span><br></pre></td></tr></table></figure></p>\n<p>那么，扩容代码就会复用现有的内容容器，并把容器中的未读内容拷贝到它的头部位置。这也意味着其中的已读内容，将会全部被未读内容和<br>之后的新内容覆盖掉。</p>\n<p>这样的复用预计可以至少节省掉一次后续的扩容所带来的内存分配，以及若干字节的拷贝。</p>\n<p>若这一步优化未能达成，也就是说，当前内容容器的容量小于新长度的二倍，那么扩容代码就只能再创建一个新的内容容器，并把原有容器<br>中的未读内容拷贝进去，最后再用新的容器替换掉原有的容器。这个新容器的容量将会等于原有容量的二倍再加上另需字节数的和。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">新容器的容量 =2* 原有容量 + 所需字节数</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"bytes-Buffer-中的哪些方法可能会造成内容的泄露\"><a href=\"#bytes-Buffer-中的哪些方法可能会造成内容的泄露\" class=\"headerlink\" title=\"bytes.Buffer 中的哪些方法可能会造成内容的泄露\"></a>bytes.Buffer 中的哪些方法可能会造成内容的泄露</h4><p>什么叫内容泄露？这里所说的内容泄露是指，使用 <code>Buffer</code> 值的一方通过某种非标准的（或者说不正式的）方式得到了本不该得到的内容。</p>\n<p>在<code>bytes.Buffer</code> 中，<strong><code>Bytes</code> 方法和<code>Next</code>方法都可能会造成内容的泄露</strong>。原因在于，它们都把基于内容容器的切片直接返<br>回给了方法的调用方。</p>\n<p>我们都知道，<strong>通过切片，我们可以直接访问和操纵它的底层数组。不论这个切片是基于某个数组得来的，还是通过对另一个切片做切片操作<br>获得的</strong>，都是如此。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">contents := <span class=\"string\">\"ab\"</span></span><br><span class=\"line\">buffer1 := bytes.NewBufferString(contents)</span><br><span class=\"line\">fmt.Printf(<span class=\"string\">\"The capacity of new buffer with contents %q: %d\\n\"</span>,</span><br><span class=\"line\">    contents, buffer1.Cap()) <span class=\"comment\">// 内容容器的容量为：8。</span></span><br><span class=\"line\">fmt.Println()</span><br><span class=\"line\"></span><br><span class=\"line\">unreadBytes := buffer1.Bytes()</span><br><span class=\"line\">fmt.Printf(<span class=\"string\">\"The unread bytes of the buffer: %v\\n\"</span>, unreadBytes)</span><br></pre></td></tr></table></figure></p>\n<p>前面通过调用 <code>buffer1</code> 的<code>Bytes</code> 方法得到的结果值 <code>unreadBytes</code>，包含了在那时其中的所有未读内容。</p>\n<p>但是，由于这个结果值与 <code>buffer1</code> 的内容容器在此时还共用着同一个底层数组，所以，我只需通过简单的再切片操作，就可以利用这个<br>结果值拿到 <code>buffer1</code> 在此时的所有未读内容。如此一来，<code>buffer1</code> 的新内容就被泄露出来了。</p>\n<h3 id=\"一个-string-类型的值在底层怎样被表达\"><a href=\"#一个-string-类型的值在底层怎样被表达\" class=\"headerlink\" title=\"一个 string 类型的值在底层怎样被表达\"></a>一个 <code>string</code> 类型的值在底层怎样被表达</h3><p>在底层，一个 <code>string</code> 类型的值是由一系列相对应的 Unicode 代码点的 UTF-8 编码值来表达的。</p>\n<p>一个 <code>string</code> 类型的值既可以被拆分为一个包含多个字符的序列，也可以被拆分为一个包含多个字节的序列。<br>前者可以由一个以 <code>rune</code>（<code>int32</code> 的别名）为元素类型的切片来表示，而后者则可以由一个以 <code>byte</code> 为元素类型的切片代表。</p>\n<p><code>rune</code> 是 Go 语言特有的一个基本数据类型，它的一个值就代表一个字符，即：一个 Unicode 字符。比如，’G’、’o’、’爱’、’好’、<br>‘者’代表的就都是一个 Unicode 字符。一个 <code>rune</code> 类型的值会由四个字节宽度的空间来存储。它的存储空间总是能够存下一<br>个 UTF-8 编码值。</p>\n<p><strong>一个 <code>rune</code> 类型的值在底层其实就是一个 UTF-8 编码值</strong>。前者是（便于我们人类理解的）外部展现，后者是（便于计算机系统理解的）<br>内在表达。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str := <span class=\"string\">\"Go 爱好者 \"</span></span><br><span class=\"line\">fmt.Printf(<span class=\"string\">\"The string: %q\\n\"</span>, str)</span><br><span class=\"line\">fmt.Printf(<span class=\"string\">\"  =&gt; runes(char): %q\\n\"</span>, []<span class=\"keyword\">rune</span>(str))</span><br><span class=\"line\">fmt.Printf(<span class=\"string\">\"  =&gt; runes(hex): %x\\n\"</span>, []<span class=\"keyword\">rune</span>(str))</span><br><span class=\"line\">fmt.Printf(<span class=\"string\">\"  =&gt; bytes(hex): [% x]\\n\"</span>, []<span class=\"keyword\">byte</span>(str))</span><br></pre></td></tr></table></figure>\n<p>字符串值 “Go 爱好者” 如果被转换为 <code>[]rune</code> 类型的值的话，其中的每一个字符（不论是英文字符还是中文字符）就都会独立成为一<br>个 <code>rune</code> 类型的元素值。因<br>此，这段代码打印出的第二行内容就会如下所示：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">=&gt; runes(char): [<span class=\"string\">'G'</span> <span class=\"string\">'o'</span> <span class=\"string\">'爱'</span> <span class=\"string\">'好'</span> <span class=\"string\">'者'</span>]</span><br></pre></td></tr></table></figure></p>\n<p>又由于，每个 <code>rune</code> 类型的值在底层都是由一个 UTF-8 编码值来表达的，所以我们可以换一种方式来展现这个字符序列：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">=&gt; runes(hex): [47 6f 7231 597d 8005]</span><br></pre></td></tr></table></figure></p>\n<p>我们还可以进一步地拆分，把每个字符的 UTF-8 编码值都拆成相应的字节序列。上述代码中的第五行就是这么做的。它会得到如下的输出：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">=&gt; bytes(hex): [47 6f e7 88 b1 e5 a5 bd e8 80 85]</span><br></pre></td></tr></table></figure></p>\n"},{"title":"测试","_content":"\n# 测试\n`go test` 命令测试代码，包目录内，所有以 `_test.go` 为后缀名的源文件在执行 `go build` 时不会被构建成包的一部分，\n它们是 `go test` 测试的一部分。\n\n在 `*_test.go` 文件中，有三种类型的函数：\n- 测试函数，测试程序的一些逻辑行为是否正确。`go test` 命令会调用这些测试函数并报告测试结果是 `PASS` 或 `FAIL`。\n- 基准测试函数，衡量一些函数的性能。`go test` 命令会多次运行基准函数以计算一个平均的执行时间。\n- 示例函数，提供一个由编译器保证正确性的示例文档。\n\n`go test` 会生成一个临时 `main` 包调用测试函数。\n**参数**\n- `-v`，打印每个测试函数的名字和运行时间。\n- `-run`，指定一个正则表达式，只有匹配到的测试函数名才会被 `go test` 运行，如 `go test -v -run=\"French|Canal\"`。\n- `-cover`，测试覆盖率。\n- `-bench`，运行基准测试。例如 `go test -bench=.`（如果在 Windows Powershell 环境下使用 `go test -bench=\".\"`）\n- `-c`，生成用于运行测试的可执行文件，但不执行它。这个可执行文件会被命名为 `pkg.test`，其中的 `pkg` 即为被测试代码包的\n导入路径的最后一个元素的名称。\n- `-i`，安装/重新安装运行测试所需的依赖包，但不编译和运行测试代码。\n- `-o`，指定用于运行测试的可执行文件的名称。追加该标记不会影响测试代码的运行，除非同时追加了标记 `-c` 或 `-i`。\n\n## 测试函数\n**测试函数必须导入 `testing` 包，并以 `Test` 为函数名前缀，后缀名必须以大写字母开头，并且参数列表中只应有一个 `*testing.T` \n类型的参数声明**：\n```go\nfunc TestName(t *testing.T) {\n  ...\n}\n```\n\n`t` 参数用于报告测试失败和附加的日志信息。`t.Error` 和 `t.Errorf` 打印错误日志。`t.Fatal` 或 `t.Fatalf` 停止当前测试函数\n`go test` 命令如果没有参数指定包那么将默认采用当前目录对应的包。\n\n表格驱动测试在我们要创建一系列相同测试方式的测试用例时很有用。例如:\n```go\nfunc TestIsPalindrome(t *testing.T) {\n    var tests = []struct {\n        input string\n        want  bool\n    }{\n        {\"\", true},\n        {\"a\", true},\n        {\"aa\", true},\n        {\"ab\", false},\n        {\"kayak\", true},\n        {\"detartrated\", true},\n        {\"A man, a plan, a canal: Panama\", true},\n        {\"Evil I did dwell; lewd did I live.\", true},\n        {\"Able was I ere I saw Elba\", true},\n        {\"été\", true},\n        {\"Et se resservir, ivresse reste.\", true},\n        {\"palindrome\", false}, // non-palindrome\n        {\"desserts\", false},   // semi-palindrome\n    }\n    for _, test := range tests {\n        if got := IsPalindrome(test.input); got != test.want {\n            t.Errorf(\"IsPalindrome(%q) = %v\", test.input, got)\n        }\n    }\n}\n```\n\n## 覆盖率\n`go test` 命令中集成了测试覆盖率工具。\n运行 `go tool cover`：\n```bash\n$ go tool cover\nUsage of 'go tool cover':\nGiven a coverage profile produced by 'go test':\n    go test -coverprofile=c.out\n\nOpen a web browser displaying annotated source code:\n    go tool cover -html=c.out\n```\n\n添加 `-coverprofile` 参数，统计覆盖率数据，并将统计日志数据写入指定文件，如 `go test -run=Coverage -coverprofile=c.out`。\n`-covermode=count` 参数将在每个代码块插入一个计数器而不是布尔标志量。在统计结果中记录了每个块的执行次数，\n这可以用于衡量哪些是被频繁执行的热点代码。\n\n## 基准测试\n**测试函数必须导入 `testing` 包，并以 `Benchmark` 为函数名前缀，后缀名必须以大写字母开头，并且唯一参数的类型必须\n是 `*testing.B` 类型的**：\n```go\nfunc BenchmarkName(b *testing.B) {\n  ...\n}\n```\n`*testing.B` 参数除了提供和 `*testing.T` 类似的方法，还有额外一些和性能测量相关的方法。\n\n### 运行基准测试\n运行基准测试需要使用 `-bench` 参数，指定要运行的基准测试函数。该参数是一个正则表达式，用于匹配要执行的基准测试函数的名字，\n默认值是空的。\n\n`.` 会匹配所有基准测试函数。\n\n### 剖析\n基准测试对于衡量特定操作的性能是有帮助的，Go 语言支持多种类型的剖析性能分析：\n1. CPU 剖析数据标识了最耗 CPU 时间的函数。\n2. 堆剖析则标识了最耗内存的语句。\n3. 阻塞剖析则记录阻塞 goroutine 最久的操作，例如系统调用、管道发送和接收，还有获取锁等。\n\n```bash\n$ go test -cpuprofile=cpu.out\n$ go test -blockprofile=block.out\n$ go test -memprofile=mem.out\n```\n\n#### go tool pprof\n`go tool pprof` 命令可以用来分析上面的命令生成的数据。\n\n## 示例函数\n并以 `Benchmark` 为函数名前缀，示例函数没有函数参数和返回值：\n```go\nfunc ExampleName() {\n  ...\n}\n```\n\n三个用处:\n1. 作为文档，如 `ExampleIsPalindrome` 示例函数将是 `IsPalindrome` 函数文档的一部分。\n2. `go test` 会运行示例函数测试。\n3. 提供 Go Playground，可以在浏览器中在线编辑和运行每个示例函数。\n\n## go test 命令执行的主要测试流程\n`go test` 命令在开始运行时，会先做一些准备工作，比如，确定内部需要用到的命令，检查我们指定的代码包或源码文件的有效性，\n以及判断我们给予的标记是否合法，等等。\n\n在准备工作顺利完成之后，go test 命令就会针对每个被测代码包，依次地进行构建、执行包中符合要求的测试函数，清理临时文件，\n打印测试结果。这就是通常情况下的主要测试流程。\n\n对于每个被测代码包，`go test` 命令会**串行地执行测试流程中的每个步骤**。\n\n但是，为了加快测试速度，它通常会并发地对多个被测代码包进行功能测试，只不过，在最后打印测试结果的时候，它会依照我们给定的\n顺序逐个进行，这会让我们感觉到它是在完全串行地执行测试流程。\n\n由于**并发的测试会让性能测试的结果存在偏差，所以性能测试一般都是串行进行的**。\n\n## 功能测试的测试结果\n```bash\n$ go test puzzlers/article20/q2\nok   puzzlers/article20/q2 (cached)\n```\n`(cached)` 表明，由于测试代码与被测代码都没有任何变动，所以 `go test` 命令直接把之前缓存测试成功的结果打印出来了。\n\ngo 命令通常会缓存程序构建的结果，以便在将来的构建中重用。我们可以通过运行 `go env GOCACHE` 命令来查看缓存目录的路径。\n\n运行 `go clean -testcache` 将会删除所有的测试结果缓存。不过，这样做肯定不会删除任何构建结果缓存。\n\n设置环境变量 `GODEBUG` 的值也可以稍稍地改变 go 命令的缓存行为。比如，设置值为 `gocacheverify=1` 将会导致 go 命令绕\n过任何的缓存数据，而真正地执行操作并重新生成所有结果，然后再去检查新的结果与现有的缓存数据是否一致。\n\n## 性能测试的测试结果\n```bash\n$ go test -bench=. -run=^$ puzzlers/article20/q3\ngoos: darwin\ngoarch: amd64\npkg: puzzlers/article20/q3\nBenchmarkGetPrimes-8      500000       2314 ns/op\nPASS\nok   puzzlers/article20/q3 1.192s\n```\n\n**第一个标记及其值为 `-bench=.`，只有有了这个标记，命令才会进行性能测试**。该标记的值`.`表明需要执行任意名称的性能测试函数。\n\n第二个标记及其值是 `-run=^$`，这个标记用于表明需要执行哪些功能测试函数，这同样也是以函数名称为依据的。该标记的值 `^$` 意味着：\n只执行名称为空的功能测试函数，换句话说，不执行任何功能测试函数。\n\n这两个标记的值都是正则表达式。实际上，它们只能以正则表达式为值。此外，如果运行 `go test` 命令的时候不加 `-run` 标记，\n那么就会使它执行被测代码包中的所有功能测试函数。\n\n测试结果，重点在倒数第三行的内容。`BenchmarkGetPrimes-8` 被称为单个性能测试的名称，它表示命令执行了性能测试\n函数 `BenchmarkGetPrimes`，并且当时所用的最大 P 数量为 8。\n\n最大 P 数量相当于可以同时运行 goroutine 的逻辑 CPU 的最大个数。这里的逻辑 CPU，也可以被称为 CPU 核心，但它并不等同\n于计算机中真正的 CPU 核心，只是 Go 语言运行时系统内部的一个概念，代表着它同时运行 goroutine 的能力。\n\n可以通过调用 `runtime.GOMAXPROCS` 函数改变最大 P 数量，也可以在运行 `go test` 命令时，加入标记 `-cpu` 来设置一个最大 P 数量\n的列表，以供命令在多次测试时使用。\n\n测试名称右边的是执行次数。**它指的是被测函数的执行次数，而不是性能测试函数的执行次数**。\n\n## `-parallel` 标记\n该标记的作用是：设置同一个被测代码包中的功能测试函数的最大并发执行数。\n该标记的默认值是测试运行时的最大 P 数量（这可以通过调用表达 式`runtime.GOMAXPROCS(0)` 获得）。\n\n对于功能测试，为了加快测试速度，命令通常会并发地测试多个被测代码包。但是，在默认情况下，**对于同一个被测代码包中的多个功\n能测试函数，命令会串行地执行它们**。除非我们在一些功能测试函数中显式地调用 `t.Parallel`方 法。\n\n这个时候，这些包含了 `t.Parallel` 方法调用的功能测试函数就会被 `go test` 命令并发地执行，而并发执行的最大数量正是\n由 `-parallel` 标记值决定的。要注意，同一个功能测试函数的多次执行之间一定是串行的。\n\n## 性能测试函数中的计时器\n`testing.B` 类型有这么几个指针方法：`StartTimer`、`StopTimer` 和 `ResetTimer`。这些方法都是用于操作当前的性能测试函数\n专属的计时器的。\n\n这些字段用于记录：当前测试函数在当次执行过程中耗费的时间、分配的堆内存的字节数以及分配次数。\n\n## 性能分析\nGo 语言为程序开发者们提供了丰富的性能分析 API，和非常好用的标准工具。这些 API 主要存在于：\n- `runtime/pprof`；\n- `net/http/pprof`；\n- `runtime/trace`；\n\n至于标准工具，主要有 `go tool pprof` 和 `go tool trace` 这两个。它们可以解析概要文件中的信息，并以人类易读的方式把这些\n信息展示出来。\n\n在 Go 语言中，用于分析程序性能的概要文件有三种，分别是：**CPU 概要文件（CPU Profile）、内存概要文件（Mem Profile）和阻塞概\n要文件（Block Profile）**。\n- CPU 概要文件，其中的每一段独立的概要信息都记录着，在进行某一次采样的那个时刻，CPU 上正在执行的 Go 代码。\n- 内存概要文件，其中的每一段概要信息都记载着，在某个采样时刻，正在执行的 Go 代码以及堆内存的使用情况，这里包含已分配和已释放的\n字节数量和对象数量。\n- 阻塞概要文件，其中的每一段概要信息，都代表着 Go 程序中的一个 goroutine 阻塞事件。\n\n### 程序对 CPU 概要信息进行采样\n这需要用到 `runtime/pprof` 包中的 API。想让程序开始对 CPU 概要信息进行采样的时候，需要调用这个代码包中\n的 `StartCPUProfile` 函数，而在停止采样的时候则需要调用该包中的`StopCPUProfile`函数。\n\n### 设定内存概要信息的采样频率\n针对内存概要信息的采样会按照一定比例收集 Go 程序在运行期间的堆内存使用情况。设定内存概要信息采样频率的方法很简单，\n只要为 `runtime.MemProfileRate` 变量赋值即可。\n\n这个变量的含义是，平均每分配多少个字节，就对堆内存的使用情况进行一次采样。如果把该变量的值设为0，那么，Go 语言运行时系统就\n会完全停止对内存概要信息的采样。该变量的缺省值是 512 KB，也就是 512 千字节。\n\n**如果你要设定这个采样频率，那么越早设定越好，并且只应该设定一次，否则就可能会对 Go 语言运行时系统的采样工作，造成不良影响**。\n比如，只在 `main` 函数的开始处设定一次。\n\n当我们想获取内存概要信息的时候，还需要调用 `runtime/pprof` 包中的 `WriteHeapProfile` 函数。该函数会把收集好的内存概要信息，\n写到我们指定的写入器中。\n\n注意，我们通过 **`WriteHeapProfile` 函数得到的内存概要信息并不是实时的，它是一个快照，是在最近一次的内存垃圾收集工作完成时产\n生的**。如果你想要实时的信息，那么可以调用 `runtime.ReadMemStats` 函数。不过要特别注意，该函数会引起 Go 语言调度器的短暂停顿。\n\n### 获取到阻塞概要信息\n调用 `runtime` 包中的 `SetBlockProfileRate` 函数，即可对阻塞概要信息的采样频率进行设定。该函数有一个名叫 `rate` 的参数，\n它是 `int` 类型的。\n\n这个参数的含义是，只要发现一个阻塞事件的持续时间达到了多少个纳秒，就可以对其进行采样。如果这个参数的值小于或等于0，那么就意\n味着 Go 语言运行时系统将会完全停止对阻塞概要信息的采样。\n\n当我们需要获取阻塞概要信息的时候，需要先调用 `runtime/pprof` 包中的 `Lookup` 函数并传入参数值 \"block\"，从而得到一\n个 `*runtime/pprof.Profile` 类型的值（以下简称Profile值）。在这之后，我们还需要调用这个 `Profile` 值的 `WriteTo` 方法，\n以驱使它把概要信息写进我们指定的写入器中。\n\n`WriteTo` 方法有两个参数，一个参数就是我们刚刚提到的写入器，它是 `io.Writer` 类型的。而另一个参数则是代表了概要信息\n详细程度的 `int` 类型参数 `debug`。\n\n`debug` 参数主要的可选值有两个，即：0 和 1。当 `debug` 的值为 0 时，通过 `WriteTo` 方法写进写入器的概要信息仅会包含\n `go tool pprof` 工具所需的内存地址，这些内存地址会以十六进制的形式展现出来。\n\n当该值为 1 时，相应的包名、函数名、源码文件路径、代码行号等信息就都会作为注释被加入进去。另外，`debug` 为 0 时的概要信息，\n会经由 protocol buffers 转换为字节流。而在 `debug` 为 1 的时候，`WriteTo` 方法输出的这些概要信息就是我们可以读懂\n的普通文本了。\n\n除此之外，`debug` 的值也可以是 2。这时，被输出的概要信息也会是普通的文本，并且通常会包含更多的细节。至于这些细节都包含了哪些\n内容，那就要看们调用 `runtime/pprof.Lookup` 函数的时候传入的是什么样的参数值了。","source":"basic/test.md","raw":"---\ntitle: 测试\n---\n\n# 测试\n`go test` 命令测试代码，包目录内，所有以 `_test.go` 为后缀名的源文件在执行 `go build` 时不会被构建成包的一部分，\n它们是 `go test` 测试的一部分。\n\n在 `*_test.go` 文件中，有三种类型的函数：\n- 测试函数，测试程序的一些逻辑行为是否正确。`go test` 命令会调用这些测试函数并报告测试结果是 `PASS` 或 `FAIL`。\n- 基准测试函数，衡量一些函数的性能。`go test` 命令会多次运行基准函数以计算一个平均的执行时间。\n- 示例函数，提供一个由编译器保证正确性的示例文档。\n\n`go test` 会生成一个临时 `main` 包调用测试函数。\n**参数**\n- `-v`，打印每个测试函数的名字和运行时间。\n- `-run`，指定一个正则表达式，只有匹配到的测试函数名才会被 `go test` 运行，如 `go test -v -run=\"French|Canal\"`。\n- `-cover`，测试覆盖率。\n- `-bench`，运行基准测试。例如 `go test -bench=.`（如果在 Windows Powershell 环境下使用 `go test -bench=\".\"`）\n- `-c`，生成用于运行测试的可执行文件，但不执行它。这个可执行文件会被命名为 `pkg.test`，其中的 `pkg` 即为被测试代码包的\n导入路径的最后一个元素的名称。\n- `-i`，安装/重新安装运行测试所需的依赖包，但不编译和运行测试代码。\n- `-o`，指定用于运行测试的可执行文件的名称。追加该标记不会影响测试代码的运行，除非同时追加了标记 `-c` 或 `-i`。\n\n## 测试函数\n**测试函数必须导入 `testing` 包，并以 `Test` 为函数名前缀，后缀名必须以大写字母开头，并且参数列表中只应有一个 `*testing.T` \n类型的参数声明**：\n```go\nfunc TestName(t *testing.T) {\n  ...\n}\n```\n\n`t` 参数用于报告测试失败和附加的日志信息。`t.Error` 和 `t.Errorf` 打印错误日志。`t.Fatal` 或 `t.Fatalf` 停止当前测试函数\n`go test` 命令如果没有参数指定包那么将默认采用当前目录对应的包。\n\n表格驱动测试在我们要创建一系列相同测试方式的测试用例时很有用。例如:\n```go\nfunc TestIsPalindrome(t *testing.T) {\n    var tests = []struct {\n        input string\n        want  bool\n    }{\n        {\"\", true},\n        {\"a\", true},\n        {\"aa\", true},\n        {\"ab\", false},\n        {\"kayak\", true},\n        {\"detartrated\", true},\n        {\"A man, a plan, a canal: Panama\", true},\n        {\"Evil I did dwell; lewd did I live.\", true},\n        {\"Able was I ere I saw Elba\", true},\n        {\"été\", true},\n        {\"Et se resservir, ivresse reste.\", true},\n        {\"palindrome\", false}, // non-palindrome\n        {\"desserts\", false},   // semi-palindrome\n    }\n    for _, test := range tests {\n        if got := IsPalindrome(test.input); got != test.want {\n            t.Errorf(\"IsPalindrome(%q) = %v\", test.input, got)\n        }\n    }\n}\n```\n\n## 覆盖率\n`go test` 命令中集成了测试覆盖率工具。\n运行 `go tool cover`：\n```bash\n$ go tool cover\nUsage of 'go tool cover':\nGiven a coverage profile produced by 'go test':\n    go test -coverprofile=c.out\n\nOpen a web browser displaying annotated source code:\n    go tool cover -html=c.out\n```\n\n添加 `-coverprofile` 参数，统计覆盖率数据，并将统计日志数据写入指定文件，如 `go test -run=Coverage -coverprofile=c.out`。\n`-covermode=count` 参数将在每个代码块插入一个计数器而不是布尔标志量。在统计结果中记录了每个块的执行次数，\n这可以用于衡量哪些是被频繁执行的热点代码。\n\n## 基准测试\n**测试函数必须导入 `testing` 包，并以 `Benchmark` 为函数名前缀，后缀名必须以大写字母开头，并且唯一参数的类型必须\n是 `*testing.B` 类型的**：\n```go\nfunc BenchmarkName(b *testing.B) {\n  ...\n}\n```\n`*testing.B` 参数除了提供和 `*testing.T` 类似的方法，还有额外一些和性能测量相关的方法。\n\n### 运行基准测试\n运行基准测试需要使用 `-bench` 参数，指定要运行的基准测试函数。该参数是一个正则表达式，用于匹配要执行的基准测试函数的名字，\n默认值是空的。\n\n`.` 会匹配所有基准测试函数。\n\n### 剖析\n基准测试对于衡量特定操作的性能是有帮助的，Go 语言支持多种类型的剖析性能分析：\n1. CPU 剖析数据标识了最耗 CPU 时间的函数。\n2. 堆剖析则标识了最耗内存的语句。\n3. 阻塞剖析则记录阻塞 goroutine 最久的操作，例如系统调用、管道发送和接收，还有获取锁等。\n\n```bash\n$ go test -cpuprofile=cpu.out\n$ go test -blockprofile=block.out\n$ go test -memprofile=mem.out\n```\n\n#### go tool pprof\n`go tool pprof` 命令可以用来分析上面的命令生成的数据。\n\n## 示例函数\n并以 `Benchmark` 为函数名前缀，示例函数没有函数参数和返回值：\n```go\nfunc ExampleName() {\n  ...\n}\n```\n\n三个用处:\n1. 作为文档，如 `ExampleIsPalindrome` 示例函数将是 `IsPalindrome` 函数文档的一部分。\n2. `go test` 会运行示例函数测试。\n3. 提供 Go Playground，可以在浏览器中在线编辑和运行每个示例函数。\n\n## go test 命令执行的主要测试流程\n`go test` 命令在开始运行时，会先做一些准备工作，比如，确定内部需要用到的命令，检查我们指定的代码包或源码文件的有效性，\n以及判断我们给予的标记是否合法，等等。\n\n在准备工作顺利完成之后，go test 命令就会针对每个被测代码包，依次地进行构建、执行包中符合要求的测试函数，清理临时文件，\n打印测试结果。这就是通常情况下的主要测试流程。\n\n对于每个被测代码包，`go test` 命令会**串行地执行测试流程中的每个步骤**。\n\n但是，为了加快测试速度，它通常会并发地对多个被测代码包进行功能测试，只不过，在最后打印测试结果的时候，它会依照我们给定的\n顺序逐个进行，这会让我们感觉到它是在完全串行地执行测试流程。\n\n由于**并发的测试会让性能测试的结果存在偏差，所以性能测试一般都是串行进行的**。\n\n## 功能测试的测试结果\n```bash\n$ go test puzzlers/article20/q2\nok   puzzlers/article20/q2 (cached)\n```\n`(cached)` 表明，由于测试代码与被测代码都没有任何变动，所以 `go test` 命令直接把之前缓存测试成功的结果打印出来了。\n\ngo 命令通常会缓存程序构建的结果，以便在将来的构建中重用。我们可以通过运行 `go env GOCACHE` 命令来查看缓存目录的路径。\n\n运行 `go clean -testcache` 将会删除所有的测试结果缓存。不过，这样做肯定不会删除任何构建结果缓存。\n\n设置环境变量 `GODEBUG` 的值也可以稍稍地改变 go 命令的缓存行为。比如，设置值为 `gocacheverify=1` 将会导致 go 命令绕\n过任何的缓存数据，而真正地执行操作并重新生成所有结果，然后再去检查新的结果与现有的缓存数据是否一致。\n\n## 性能测试的测试结果\n```bash\n$ go test -bench=. -run=^$ puzzlers/article20/q3\ngoos: darwin\ngoarch: amd64\npkg: puzzlers/article20/q3\nBenchmarkGetPrimes-8      500000       2314 ns/op\nPASS\nok   puzzlers/article20/q3 1.192s\n```\n\n**第一个标记及其值为 `-bench=.`，只有有了这个标记，命令才会进行性能测试**。该标记的值`.`表明需要执行任意名称的性能测试函数。\n\n第二个标记及其值是 `-run=^$`，这个标记用于表明需要执行哪些功能测试函数，这同样也是以函数名称为依据的。该标记的值 `^$` 意味着：\n只执行名称为空的功能测试函数，换句话说，不执行任何功能测试函数。\n\n这两个标记的值都是正则表达式。实际上，它们只能以正则表达式为值。此外，如果运行 `go test` 命令的时候不加 `-run` 标记，\n那么就会使它执行被测代码包中的所有功能测试函数。\n\n测试结果，重点在倒数第三行的内容。`BenchmarkGetPrimes-8` 被称为单个性能测试的名称，它表示命令执行了性能测试\n函数 `BenchmarkGetPrimes`，并且当时所用的最大 P 数量为 8。\n\n最大 P 数量相当于可以同时运行 goroutine 的逻辑 CPU 的最大个数。这里的逻辑 CPU，也可以被称为 CPU 核心，但它并不等同\n于计算机中真正的 CPU 核心，只是 Go 语言运行时系统内部的一个概念，代表着它同时运行 goroutine 的能力。\n\n可以通过调用 `runtime.GOMAXPROCS` 函数改变最大 P 数量，也可以在运行 `go test` 命令时，加入标记 `-cpu` 来设置一个最大 P 数量\n的列表，以供命令在多次测试时使用。\n\n测试名称右边的是执行次数。**它指的是被测函数的执行次数，而不是性能测试函数的执行次数**。\n\n## `-parallel` 标记\n该标记的作用是：设置同一个被测代码包中的功能测试函数的最大并发执行数。\n该标记的默认值是测试运行时的最大 P 数量（这可以通过调用表达 式`runtime.GOMAXPROCS(0)` 获得）。\n\n对于功能测试，为了加快测试速度，命令通常会并发地测试多个被测代码包。但是，在默认情况下，**对于同一个被测代码包中的多个功\n能测试函数，命令会串行地执行它们**。除非我们在一些功能测试函数中显式地调用 `t.Parallel`方 法。\n\n这个时候，这些包含了 `t.Parallel` 方法调用的功能测试函数就会被 `go test` 命令并发地执行，而并发执行的最大数量正是\n由 `-parallel` 标记值决定的。要注意，同一个功能测试函数的多次执行之间一定是串行的。\n\n## 性能测试函数中的计时器\n`testing.B` 类型有这么几个指针方法：`StartTimer`、`StopTimer` 和 `ResetTimer`。这些方法都是用于操作当前的性能测试函数\n专属的计时器的。\n\n这些字段用于记录：当前测试函数在当次执行过程中耗费的时间、分配的堆内存的字节数以及分配次数。\n\n## 性能分析\nGo 语言为程序开发者们提供了丰富的性能分析 API，和非常好用的标准工具。这些 API 主要存在于：\n- `runtime/pprof`；\n- `net/http/pprof`；\n- `runtime/trace`；\n\n至于标准工具，主要有 `go tool pprof` 和 `go tool trace` 这两个。它们可以解析概要文件中的信息，并以人类易读的方式把这些\n信息展示出来。\n\n在 Go 语言中，用于分析程序性能的概要文件有三种，分别是：**CPU 概要文件（CPU Profile）、内存概要文件（Mem Profile）和阻塞概\n要文件（Block Profile）**。\n- CPU 概要文件，其中的每一段独立的概要信息都记录着，在进行某一次采样的那个时刻，CPU 上正在执行的 Go 代码。\n- 内存概要文件，其中的每一段概要信息都记载着，在某个采样时刻，正在执行的 Go 代码以及堆内存的使用情况，这里包含已分配和已释放的\n字节数量和对象数量。\n- 阻塞概要文件，其中的每一段概要信息，都代表着 Go 程序中的一个 goroutine 阻塞事件。\n\n### 程序对 CPU 概要信息进行采样\n这需要用到 `runtime/pprof` 包中的 API。想让程序开始对 CPU 概要信息进行采样的时候，需要调用这个代码包中\n的 `StartCPUProfile` 函数，而在停止采样的时候则需要调用该包中的`StopCPUProfile`函数。\n\n### 设定内存概要信息的采样频率\n针对内存概要信息的采样会按照一定比例收集 Go 程序在运行期间的堆内存使用情况。设定内存概要信息采样频率的方法很简单，\n只要为 `runtime.MemProfileRate` 变量赋值即可。\n\n这个变量的含义是，平均每分配多少个字节，就对堆内存的使用情况进行一次采样。如果把该变量的值设为0，那么，Go 语言运行时系统就\n会完全停止对内存概要信息的采样。该变量的缺省值是 512 KB，也就是 512 千字节。\n\n**如果你要设定这个采样频率，那么越早设定越好，并且只应该设定一次，否则就可能会对 Go 语言运行时系统的采样工作，造成不良影响**。\n比如，只在 `main` 函数的开始处设定一次。\n\n当我们想获取内存概要信息的时候，还需要调用 `runtime/pprof` 包中的 `WriteHeapProfile` 函数。该函数会把收集好的内存概要信息，\n写到我们指定的写入器中。\n\n注意，我们通过 **`WriteHeapProfile` 函数得到的内存概要信息并不是实时的，它是一个快照，是在最近一次的内存垃圾收集工作完成时产\n生的**。如果你想要实时的信息，那么可以调用 `runtime.ReadMemStats` 函数。不过要特别注意，该函数会引起 Go 语言调度器的短暂停顿。\n\n### 获取到阻塞概要信息\n调用 `runtime` 包中的 `SetBlockProfileRate` 函数，即可对阻塞概要信息的采样频率进行设定。该函数有一个名叫 `rate` 的参数，\n它是 `int` 类型的。\n\n这个参数的含义是，只要发现一个阻塞事件的持续时间达到了多少个纳秒，就可以对其进行采样。如果这个参数的值小于或等于0，那么就意\n味着 Go 语言运行时系统将会完全停止对阻塞概要信息的采样。\n\n当我们需要获取阻塞概要信息的时候，需要先调用 `runtime/pprof` 包中的 `Lookup` 函数并传入参数值 \"block\"，从而得到一\n个 `*runtime/pprof.Profile` 类型的值（以下简称Profile值）。在这之后，我们还需要调用这个 `Profile` 值的 `WriteTo` 方法，\n以驱使它把概要信息写进我们指定的写入器中。\n\n`WriteTo` 方法有两个参数，一个参数就是我们刚刚提到的写入器，它是 `io.Writer` 类型的。而另一个参数则是代表了概要信息\n详细程度的 `int` 类型参数 `debug`。\n\n`debug` 参数主要的可选值有两个，即：0 和 1。当 `debug` 的值为 0 时，通过 `WriteTo` 方法写进写入器的概要信息仅会包含\n `go tool pprof` 工具所需的内存地址，这些内存地址会以十六进制的形式展现出来。\n\n当该值为 1 时，相应的包名、函数名、源码文件路径、代码行号等信息就都会作为注释被加入进去。另外，`debug` 为 0 时的概要信息，\n会经由 protocol buffers 转换为字节流。而在 `debug` 为 1 的时候，`WriteTo` 方法输出的这些概要信息就是我们可以读懂\n的普通文本了。\n\n除此之外，`debug` 的值也可以是 2。这时，被输出的概要信息也会是普通的文本，并且通常会包含更多的细节。至于这些细节都包含了哪些\n内容，那就要看们调用 `runtime/pprof.Lookup` 函数的时候传入的是什么样的参数值了。","date":"2019-08-24T04:40:10.915Z","updated":"2019-08-24T04:40:10.864Z","path":"basic/test.html","comments":1,"layout":"page","_id":"ck1xm14l6000xfcw2nhgegts3","content":"<h1 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h1><p><code>go test</code> 命令测试代码，包目录内，所有以 <code>_test.go</code> 为后缀名的源文件在执行 <code>go build</code> 时不会被构建成包的一部分，<br>它们是 <code>go test</code> 测试的一部分。</p>\n<p>在 <code>*_test.go</code> 文件中，有三种类型的函数：</p>\n<ul>\n<li>测试函数，测试程序的一些逻辑行为是否正确。<code>go test</code> 命令会调用这些测试函数并报告测试结果是 <code>PASS</code> 或 <code>FAIL</code>。</li>\n<li>基准测试函数，衡量一些函数的性能。<code>go test</code> 命令会多次运行基准函数以计算一个平均的执行时间。</li>\n<li>示例函数，提供一个由编译器保证正确性的示例文档。</li>\n</ul>\n<p><code>go test</code> 会生成一个临时 <code>main</code> 包调用测试函数。<br><strong>参数</strong></p>\n<ul>\n<li><code>-v</code>，打印每个测试函数的名字和运行时间。</li>\n<li><code>-run</code>，指定一个正则表达式，只有匹配到的测试函数名才会被 <code>go test</code> 运行，如 <code>go test -v -run=&quot;French|Canal&quot;</code>。</li>\n<li><code>-cover</code>，测试覆盖率。</li>\n<li><code>-bench</code>，运行基准测试。例如 <code>go test -bench=.</code>（如果在 Windows Powershell 环境下使用 <code>go test -bench=&quot;.&quot;</code>）</li>\n<li><code>-c</code>，生成用于运行测试的可执行文件，但不执行它。这个可执行文件会被命名为 <code>pkg.test</code>，其中的 <code>pkg</code> 即为被测试代码包的<br>导入路径的最后一个元素的名称。</li>\n<li><code>-i</code>，安装/重新安装运行测试所需的依赖包，但不编译和运行测试代码。</li>\n<li><code>-o</code>，指定用于运行测试的可执行文件的名称。追加该标记不会影响测试代码的运行，除非同时追加了标记 <code>-c</code> 或 <code>-i</code>。</li>\n</ul>\n<h2 id=\"测试函数\"><a href=\"#测试函数\" class=\"headerlink\" title=\"测试函数\"></a>测试函数</h2><p><strong>测试函数必须导入 <code>testing</code> 包，并以 <code>Test</code> 为函数名前缀，后缀名必须以大写字母开头，并且参数列表中只应有一个 <code>*testing.T</code><br>类型的参数声明</strong>：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestName</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>t</code> 参数用于报告测试失败和附加的日志信息。<code>t.Error</code> 和 <code>t.Errorf</code> 打印错误日志。<code>t.Fatal</code> 或 <code>t.Fatalf</code> 停止当前测试函数<br><code>go test</code> 命令如果没有参数指定包那么将默认采用当前目录对应的包。</p>\n<p>表格驱动测试在我们要创建一系列相同测试方式的测试用例时很有用。例如:<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestIsPalindrome</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> tests = []<span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">        input <span class=\"keyword\">string</span></span><br><span class=\"line\">        want  <span class=\"keyword\">bool</span></span><br><span class=\"line\">    &#125;&#123;</span><br><span class=\"line\">        &#123;<span class=\"string\">\"\"</span>, <span class=\"literal\">true</span>&#125;,</span><br><span class=\"line\">        &#123;<span class=\"string\">\"a\"</span>, <span class=\"literal\">true</span>&#125;,</span><br><span class=\"line\">        &#123;<span class=\"string\">\"aa\"</span>, <span class=\"literal\">true</span>&#125;,</span><br><span class=\"line\">        &#123;<span class=\"string\">\"ab\"</span>, <span class=\"literal\">false</span>&#125;,</span><br><span class=\"line\">        &#123;<span class=\"string\">\"kayak\"</span>, <span class=\"literal\">true</span>&#125;,</span><br><span class=\"line\">        &#123;<span class=\"string\">\"detartrated\"</span>, <span class=\"literal\">true</span>&#125;,</span><br><span class=\"line\">        &#123;<span class=\"string\">\"A man, a plan, a canal: Panama\"</span>, <span class=\"literal\">true</span>&#125;,</span><br><span class=\"line\">        &#123;<span class=\"string\">\"Evil I did dwell; lewd did I live.\"</span>, <span class=\"literal\">true</span>&#125;,</span><br><span class=\"line\">        &#123;<span class=\"string\">\"Able was I ere I saw Elba\"</span>, <span class=\"literal\">true</span>&#125;,</span><br><span class=\"line\">        &#123;<span class=\"string\">\"été\"</span>, <span class=\"literal\">true</span>&#125;,</span><br><span class=\"line\">        &#123;<span class=\"string\">\"Et se resservir, ivresse reste.\"</span>, <span class=\"literal\">true</span>&#125;,</span><br><span class=\"line\">        &#123;<span class=\"string\">\"palindrome\"</span>, <span class=\"literal\">false</span>&#125;, <span class=\"comment\">// non-palindrome</span></span><br><span class=\"line\">        &#123;<span class=\"string\">\"desserts\"</span>, <span class=\"literal\">false</span>&#125;,   <span class=\"comment\">// semi-palindrome</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> _, test := <span class=\"keyword\">range</span> tests &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> got := IsPalindrome(test.input); got != test.want &#123;</span><br><span class=\"line\">            t.Errorf(<span class=\"string\">\"IsPalindrome(%q) = %v\"</span>, test.input, got)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"覆盖率\"><a href=\"#覆盖率\" class=\"headerlink\" title=\"覆盖率\"></a>覆盖率</h2><p><code>go test</code> 命令中集成了测试覆盖率工具。<br>运行 <code>go tool cover</code>：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ go tool cover</span><br><span class=\"line\">Usage of <span class=\"string\">'go tool cover'</span>:</span><br><span class=\"line\">Given a coverage profile produced by <span class=\"string\">'go test'</span>:</span><br><span class=\"line\">    go <span class=\"built_in\">test</span> -coverprofile=c.out</span><br><span class=\"line\"></span><br><span class=\"line\">Open a web browser displaying annotated <span class=\"built_in\">source</span> code:</span><br><span class=\"line\">    go tool cover -html=c.out</span><br></pre></td></tr></table></figure></p>\n<p>添加 <code>-coverprofile</code> 参数，统计覆盖率数据，并将统计日志数据写入指定文件，如 <code>go test -run=Coverage -coverprofile=c.out</code>。<br><code>-covermode=count</code> 参数将在每个代码块插入一个计数器而不是布尔标志量。在统计结果中记录了每个块的执行次数，<br>这可以用于衡量哪些是被频繁执行的热点代码。</p>\n<h2 id=\"基准测试\"><a href=\"#基准测试\" class=\"headerlink\" title=\"基准测试\"></a>基准测试</h2><p><strong>测试函数必须导入 <code>testing</code> 包，并以 <code>Benchmark</code> 为函数名前缀，后缀名必须以大写字母开头，并且唯一参数的类型必须<br>是 <code>*testing.B</code> 类型的</strong>：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">BenchmarkName</span><span class=\"params\">(b *testing.B)</span></span> &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>*testing.B</code> 参数除了提供和 <code>*testing.T</code> 类似的方法，还有额外一些和性能测量相关的方法。</p>\n<h3 id=\"运行基准测试\"><a href=\"#运行基准测试\" class=\"headerlink\" title=\"运行基准测试\"></a>运行基准测试</h3><p>运行基准测试需要使用 <code>-bench</code> 参数，指定要运行的基准测试函数。该参数是一个正则表达式，用于匹配要执行的基准测试函数的名字，<br>默认值是空的。</p>\n<p><code>.</code> 会匹配所有基准测试函数。</p>\n<h3 id=\"剖析\"><a href=\"#剖析\" class=\"headerlink\" title=\"剖析\"></a>剖析</h3><p>基准测试对于衡量特定操作的性能是有帮助的，Go 语言支持多种类型的剖析性能分析：</p>\n<ol>\n<li>CPU 剖析数据标识了最耗 CPU 时间的函数。</li>\n<li>堆剖析则标识了最耗内存的语句。</li>\n<li>阻塞剖析则记录阻塞 goroutine 最久的操作，例如系统调用、管道发送和接收，还有获取锁等。</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ go <span class=\"built_in\">test</span> -cpuprofile=cpu.out</span><br><span class=\"line\">$ go <span class=\"built_in\">test</span> -blockprofile=block.out</span><br><span class=\"line\">$ go <span class=\"built_in\">test</span> -memprofile=mem.out</span><br></pre></td></tr></table></figure>\n<h4 id=\"go-tool-pprof\"><a href=\"#go-tool-pprof\" class=\"headerlink\" title=\"go tool pprof\"></a>go tool pprof</h4><p><code>go tool pprof</code> 命令可以用来分析上面的命令生成的数据。</p>\n<h2 id=\"示例函数\"><a href=\"#示例函数\" class=\"headerlink\" title=\"示例函数\"></a>示例函数</h2><p>并以 <code>Benchmark</code> 为函数名前缀，示例函数没有函数参数和返回值：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">ExampleName</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>三个用处:</p>\n<ol>\n<li>作为文档，如 <code>ExampleIsPalindrome</code> 示例函数将是 <code>IsPalindrome</code> 函数文档的一部分。</li>\n<li><code>go test</code> 会运行示例函数测试。</li>\n<li>提供 Go Playground，可以在浏览器中在线编辑和运行每个示例函数。</li>\n</ol>\n<h2 id=\"go-test-命令执行的主要测试流程\"><a href=\"#go-test-命令执行的主要测试流程\" class=\"headerlink\" title=\"go test 命令执行的主要测试流程\"></a>go test 命令执行的主要测试流程</h2><p><code>go test</code> 命令在开始运行时，会先做一些准备工作，比如，确定内部需要用到的命令，检查我们指定的代码包或源码文件的有效性，<br>以及判断我们给予的标记是否合法，等等。</p>\n<p>在准备工作顺利完成之后，go test 命令就会针对每个被测代码包，依次地进行构建、执行包中符合要求的测试函数，清理临时文件，<br>打印测试结果。这就是通常情况下的主要测试流程。</p>\n<p>对于每个被测代码包，<code>go test</code> 命令会<strong>串行地执行测试流程中的每个步骤</strong>。</p>\n<p>但是，为了加快测试速度，它通常会并发地对多个被测代码包进行功能测试，只不过，在最后打印测试结果的时候，它会依照我们给定的<br>顺序逐个进行，这会让我们感觉到它是在完全串行地执行测试流程。</p>\n<p>由于<strong>并发的测试会让性能测试的结果存在偏差，所以性能测试一般都是串行进行的</strong>。</p>\n<h2 id=\"功能测试的测试结果\"><a href=\"#功能测试的测试结果\" class=\"headerlink\" title=\"功能测试的测试结果\"></a>功能测试的测试结果</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ go <span class=\"built_in\">test</span> puzzlers/article20/q2</span><br><span class=\"line\">ok   puzzlers/article20/q2 (cached)</span><br></pre></td></tr></table></figure>\n<p><code>(cached)</code> 表明，由于测试代码与被测代码都没有任何变动，所以 <code>go test</code> 命令直接把之前缓存测试成功的结果打印出来了。</p>\n<p>go 命令通常会缓存程序构建的结果，以便在将来的构建中重用。我们可以通过运行 <code>go env GOCACHE</code> 命令来查看缓存目录的路径。</p>\n<p>运行 <code>go clean -testcache</code> 将会删除所有的测试结果缓存。不过，这样做肯定不会删除任何构建结果缓存。</p>\n<p>设置环境变量 <code>GODEBUG</code> 的值也可以稍稍地改变 go 命令的缓存行为。比如，设置值为 <code>gocacheverify=1</code> 将会导致 go 命令绕<br>过任何的缓存数据，而真正地执行操作并重新生成所有结果，然后再去检查新的结果与现有的缓存数据是否一致。</p>\n<h2 id=\"性能测试的测试结果\"><a href=\"#性能测试的测试结果\" class=\"headerlink\" title=\"性能测试的测试结果\"></a>性能测试的测试结果</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ go <span class=\"built_in\">test</span> -bench=. -run=^$ puzzlers/article20/q3</span><br><span class=\"line\">goos: darwin</span><br><span class=\"line\">goarch: amd64</span><br><span class=\"line\">pkg: puzzlers/article20/q3</span><br><span class=\"line\">BenchmarkGetPrimes-8      500000       2314 ns/op</span><br><span class=\"line\">PASS</span><br><span class=\"line\">ok   puzzlers/article20/q3 1.192s</span><br></pre></td></tr></table></figure>\n<p><strong>第一个标记及其值为 <code>-bench=.</code>，只有有了这个标记，命令才会进行性能测试</strong>。该标记的值<code>.</code>表明需要执行任意名称的性能测试函数。</p>\n<p>第二个标记及其值是 <code>-run=^$</code>，这个标记用于表明需要执行哪些功能测试函数，这同样也是以函数名称为依据的。该标记的值 <code>^$</code> 意味着：<br>只执行名称为空的功能测试函数，换句话说，不执行任何功能测试函数。</p>\n<p>这两个标记的值都是正则表达式。实际上，它们只能以正则表达式为值。此外，如果运行 <code>go test</code> 命令的时候不加 <code>-run</code> 标记，<br>那么就会使它执行被测代码包中的所有功能测试函数。</p>\n<p>测试结果，重点在倒数第三行的内容。<code>BenchmarkGetPrimes-8</code> 被称为单个性能测试的名称，它表示命令执行了性能测试<br>函数 <code>BenchmarkGetPrimes</code>，并且当时所用的最大 P 数量为 8。</p>\n<p>最大 P 数量相当于可以同时运行 goroutine 的逻辑 CPU 的最大个数。这里的逻辑 CPU，也可以被称为 CPU 核心，但它并不等同<br>于计算机中真正的 CPU 核心，只是 Go 语言运行时系统内部的一个概念，代表着它同时运行 goroutine 的能力。</p>\n<p>可以通过调用 <code>runtime.GOMAXPROCS</code> 函数改变最大 P 数量，也可以在运行 <code>go test</code> 命令时，加入标记 <code>-cpu</code> 来设置一个最大 P 数量<br>的列表，以供命令在多次测试时使用。</p>\n<p>测试名称右边的是执行次数。<strong>它指的是被测函数的执行次数，而不是性能测试函数的执行次数</strong>。</p>\n<h2 id=\"parallel-标记\"><a href=\"#parallel-标记\" class=\"headerlink\" title=\"-parallel 标记\"></a><code>-parallel</code> 标记</h2><p>该标记的作用是：设置同一个被测代码包中的功能测试函数的最大并发执行数。<br>该标记的默认值是测试运行时的最大 P 数量（这可以通过调用表达 式<code>runtime.GOMAXPROCS(0)</code> 获得）。</p>\n<p>对于功能测试，为了加快测试速度，命令通常会并发地测试多个被测代码包。但是，在默认情况下，<strong>对于同一个被测代码包中的多个功<br>能测试函数，命令会串行地执行它们</strong>。除非我们在一些功能测试函数中显式地调用 <code>t.Parallel</code>方 法。</p>\n<p>这个时候，这些包含了 <code>t.Parallel</code> 方法调用的功能测试函数就会被 <code>go test</code> 命令并发地执行，而并发执行的最大数量正是<br>由 <code>-parallel</code> 标记值决定的。要注意，同一个功能测试函数的多次执行之间一定是串行的。</p>\n<h2 id=\"性能测试函数中的计时器\"><a href=\"#性能测试函数中的计时器\" class=\"headerlink\" title=\"性能测试函数中的计时器\"></a>性能测试函数中的计时器</h2><p><code>testing.B</code> 类型有这么几个指针方法：<code>StartTimer</code>、<code>StopTimer</code> 和 <code>ResetTimer</code>。这些方法都是用于操作当前的性能测试函数<br>专属的计时器的。</p>\n<p>这些字段用于记录：当前测试函数在当次执行过程中耗费的时间、分配的堆内存的字节数以及分配次数。</p>\n<h2 id=\"性能分析\"><a href=\"#性能分析\" class=\"headerlink\" title=\"性能分析\"></a>性能分析</h2><p>Go 语言为程序开发者们提供了丰富的性能分析 API，和非常好用的标准工具。这些 API 主要存在于：</p>\n<ul>\n<li><code>runtime/pprof</code>；</li>\n<li><code>net/http/pprof</code>；</li>\n<li><code>runtime/trace</code>；</li>\n</ul>\n<p>至于标准工具，主要有 <code>go tool pprof</code> 和 <code>go tool trace</code> 这两个。它们可以解析概要文件中的信息，并以人类易读的方式把这些<br>信息展示出来。</p>\n<p>在 Go 语言中，用于分析程序性能的概要文件有三种，分别是：<strong>CPU 概要文件（CPU Profile）、内存概要文件（Mem Profile）和阻塞概<br>要文件（Block Profile）</strong>。</p>\n<ul>\n<li>CPU 概要文件，其中的每一段独立的概要信息都记录着，在进行某一次采样的那个时刻，CPU 上正在执行的 Go 代码。</li>\n<li>内存概要文件，其中的每一段概要信息都记载着，在某个采样时刻，正在执行的 Go 代码以及堆内存的使用情况，这里包含已分配和已释放的<br>字节数量和对象数量。</li>\n<li>阻塞概要文件，其中的每一段概要信息，都代表着 Go 程序中的一个 goroutine 阻塞事件。</li>\n</ul>\n<h3 id=\"程序对-CPU-概要信息进行采样\"><a href=\"#程序对-CPU-概要信息进行采样\" class=\"headerlink\" title=\"程序对 CPU 概要信息进行采样\"></a>程序对 CPU 概要信息进行采样</h3><p>这需要用到 <code>runtime/pprof</code> 包中的 API。想让程序开始对 CPU 概要信息进行采样的时候，需要调用这个代码包中<br>的 <code>StartCPUProfile</code> 函数，而在停止采样的时候则需要调用该包中的<code>StopCPUProfile</code>函数。</p>\n<h3 id=\"设定内存概要信息的采样频率\"><a href=\"#设定内存概要信息的采样频率\" class=\"headerlink\" title=\"设定内存概要信息的采样频率\"></a>设定内存概要信息的采样频率</h3><p>针对内存概要信息的采样会按照一定比例收集 Go 程序在运行期间的堆内存使用情况。设定内存概要信息采样频率的方法很简单，<br>只要为 <code>runtime.MemProfileRate</code> 变量赋值即可。</p>\n<p>这个变量的含义是，平均每分配多少个字节，就对堆内存的使用情况进行一次采样。如果把该变量的值设为0，那么，Go 语言运行时系统就<br>会完全停止对内存概要信息的采样。该变量的缺省值是 512 KB，也就是 512 千字节。</p>\n<p><strong>如果你要设定这个采样频率，那么越早设定越好，并且只应该设定一次，否则就可能会对 Go 语言运行时系统的采样工作，造成不良影响</strong>。<br>比如，只在 <code>main</code> 函数的开始处设定一次。</p>\n<p>当我们想获取内存概要信息的时候，还需要调用 <code>runtime/pprof</code> 包中的 <code>WriteHeapProfile</code> 函数。该函数会把收集好的内存概要信息，<br>写到我们指定的写入器中。</p>\n<p>注意，我们通过 <strong><code>WriteHeapProfile</code> 函数得到的内存概要信息并不是实时的，它是一个快照，是在最近一次的内存垃圾收集工作完成时产<br>生的</strong>。如果你想要实时的信息，那么可以调用 <code>runtime.ReadMemStats</code> 函数。不过要特别注意，该函数会引起 Go 语言调度器的短暂停顿。</p>\n<h3 id=\"获取到阻塞概要信息\"><a href=\"#获取到阻塞概要信息\" class=\"headerlink\" title=\"获取到阻塞概要信息\"></a>获取到阻塞概要信息</h3><p>调用 <code>runtime</code> 包中的 <code>SetBlockProfileRate</code> 函数，即可对阻塞概要信息的采样频率进行设定。该函数有一个名叫 <code>rate</code> 的参数，<br>它是 <code>int</code> 类型的。</p>\n<p>这个参数的含义是，只要发现一个阻塞事件的持续时间达到了多少个纳秒，就可以对其进行采样。如果这个参数的值小于或等于0，那么就意<br>味着 Go 语言运行时系统将会完全停止对阻塞概要信息的采样。</p>\n<p>当我们需要获取阻塞概要信息的时候，需要先调用 <code>runtime/pprof</code> 包中的 <code>Lookup</code> 函数并传入参数值 “block”，从而得到一<br>个 <code>*runtime/pprof.Profile</code> 类型的值（以下简称Profile值）。在这之后，我们还需要调用这个 <code>Profile</code> 值的 <code>WriteTo</code> 方法，<br>以驱使它把概要信息写进我们指定的写入器中。</p>\n<p><code>WriteTo</code> 方法有两个参数，一个参数就是我们刚刚提到的写入器，它是 <code>io.Writer</code> 类型的。而另一个参数则是代表了概要信息<br>详细程度的 <code>int</code> 类型参数 <code>debug</code>。</p>\n<p><code>debug</code> 参数主要的可选值有两个，即：0 和 1。当 <code>debug</code> 的值为 0 时，通过 <code>WriteTo</code> 方法写进写入器的概要信息仅会包含<br> <code>go tool pprof</code> 工具所需的内存地址，这些内存地址会以十六进制的形式展现出来。</p>\n<p>当该值为 1 时，相应的包名、函数名、源码文件路径、代码行号等信息就都会作为注释被加入进去。另外，<code>debug</code> 为 0 时的概要信息，<br>会经由 protocol buffers 转换为字节流。而在 <code>debug</code> 为 1 的时候，<code>WriteTo</code> 方法输出的这些概要信息就是我们可以读懂<br>的普通文本了。</p>\n<p>除此之外，<code>debug</code> 的值也可以是 2。这时，被输出的概要信息也会是普通的文本，并且通常会包含更多的细节。至于这些细节都包含了哪些<br>内容，那就要看们调用 <code>runtime/pprof.Lookup</code> 函数的时候传入的是什么样的参数值了。</p>\n","site":{"data":{"navigation":{"logo":{"text":"Golang Learn","type":"link","path":"index.html"},"main":[{"text":"Golang 基础","type":"label"},{"text":"Go 环境配置","type":"link","path":"basic/env_config.html"},{"text":"包","type":"link","path":"basic/package.html"},{"text":"基础数据类型","type":"link","path":"basic/basic_data.html"},{"text":"变量","type":"link","path":"basic/var.html"},{"text":"常量","type":"link","path":"basic/constant.html"},{"text":"控制语句","type":"link","path":"basic/flow.html"},{"text":"运算符","type":"link","path":"basic/operator.html"},{"text":"作用域","type":"link","path":"basic/scope.html"},{"text":"指针","type":"link","path":"basic/pointer.html"},{"text":"数组","type":"link","path":"basic/array.html"},{"text":"切片","type":"link","path":"basic/slice.html"},{"text":"字典","type":"link","path":"basic/map.html"},{"text":"函数","type":"link","path":"basic/function.html"},{"text":"结构体","type":"link","path":"basic/struct.html"},{"text":"接口","type":"link","path":"basic/interface.html"},{"text":"面向对象","type":"link","path":"basic/oop.html"},{"text":"错误","type":"link","path":"basic/error.html"},{"text":"序列化","type":"link","path":"basic/json.html"},{"text":"反射","type":"link","path":"basic/reflect.html"},{"text":"测试","type":"link","path":"basic/test.html"},{"text":"并发编程","type":"label"},{"text":"goroutine","type":"link","path":"concurrent/goroutine.html"},{"text":"channel","type":"link","path":"concurrent/channel.html"},{"text":"同步和锁","type":"link","path":"concurrent/sync_lock.html"},{"text":"内存分配","type":"label"},{"text":"内存分配","type":"link","path":"advance/mm.html"},{"text":"垃圾回收","type":"label"},{"text":"垃圾回收","type":"link","path":"advance/gc.html"},{"text":"标准库","type":"label"},{"text":"fmt","type":"link","path":"standards/io/fmt.html"},{"text":"io","type":"link","path":"standards/io/io.html"},{"text":"ioutil","type":"link","path":"standards/io/ioutil.html"},{"text":"bufio","type":"link","path":"standards/io/bufio.html"},{"text":"os","type":"link","path":"standards/os/os.html"},{"text":"filepath","type":"link","path":"standards/os/filepath.html"},{"text":"strings","type":"link","path":"standards/text/strings.html"},{"text":"strconv","type":"link","path":"standards/text/strconv.html"},{"text":"unicode","type":"link","path":"standards/text/unicode.html"},{"text":"log","type":"link","path":"standards/log.html"},{"text":"time","type":"link","path":"standards/time.html"},{"text":"http","type":"link","path":"standards/net/http.html"},{"text":"math","type":"link","path":"standards/data/math.html"},{"text":"sort","type":"link","path":"standards/data/sort.html"},{"text":"big","type":"link","path":"standards/data/big.html"},{"text":"container","type":"link","path":"standards/data/container.html"},{"text":"sql","type":"link","path":"standards/database/sql.html"},{"text":"THEME","type":"label"},{"text":"使用文档主题","type":"link","path":"theme/theme-usage.html"},{"text":"SUPPORT AND FEEDBACK","type":"label"},{"text":"Raise an Issue on Github","type":"link","path":"https://github.com/shipengqi/golang-learn/issues/new"}]}}},"excerpt":"","more":"<h1 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h1><p><code>go test</code> 命令测试代码，包目录内，所有以 <code>_test.go</code> 为后缀名的源文件在执行 <code>go build</code> 时不会被构建成包的一部分，<br>它们是 <code>go test</code> 测试的一部分。</p>\n<p>在 <code>*_test.go</code> 文件中，有三种类型的函数：</p>\n<ul>\n<li>测试函数，测试程序的一些逻辑行为是否正确。<code>go test</code> 命令会调用这些测试函数并报告测试结果是 <code>PASS</code> 或 <code>FAIL</code>。</li>\n<li>基准测试函数，衡量一些函数的性能。<code>go test</code> 命令会多次运行基准函数以计算一个平均的执行时间。</li>\n<li>示例函数，提供一个由编译器保证正确性的示例文档。</li>\n</ul>\n<p><code>go test</code> 会生成一个临时 <code>main</code> 包调用测试函数。<br><strong>参数</strong></p>\n<ul>\n<li><code>-v</code>，打印每个测试函数的名字和运行时间。</li>\n<li><code>-run</code>，指定一个正则表达式，只有匹配到的测试函数名才会被 <code>go test</code> 运行，如 <code>go test -v -run=&quot;French|Canal&quot;</code>。</li>\n<li><code>-cover</code>，测试覆盖率。</li>\n<li><code>-bench</code>，运行基准测试。例如 <code>go test -bench=.</code>（如果在 Windows Powershell 环境下使用 <code>go test -bench=&quot;.&quot;</code>）</li>\n<li><code>-c</code>，生成用于运行测试的可执行文件，但不执行它。这个可执行文件会被命名为 <code>pkg.test</code>，其中的 <code>pkg</code> 即为被测试代码包的<br>导入路径的最后一个元素的名称。</li>\n<li><code>-i</code>，安装/重新安装运行测试所需的依赖包，但不编译和运行测试代码。</li>\n<li><code>-o</code>，指定用于运行测试的可执行文件的名称。追加该标记不会影响测试代码的运行，除非同时追加了标记 <code>-c</code> 或 <code>-i</code>。</li>\n</ul>\n<h2 id=\"测试函数\"><a href=\"#测试函数\" class=\"headerlink\" title=\"测试函数\"></a>测试函数</h2><p><strong>测试函数必须导入 <code>testing</code> 包，并以 <code>Test</code> 为函数名前缀，后缀名必须以大写字母开头，并且参数列表中只应有一个 <code>*testing.T</code><br>类型的参数声明</strong>：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestName</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>t</code> 参数用于报告测试失败和附加的日志信息。<code>t.Error</code> 和 <code>t.Errorf</code> 打印错误日志。<code>t.Fatal</code> 或 <code>t.Fatalf</code> 停止当前测试函数<br><code>go test</code> 命令如果没有参数指定包那么将默认采用当前目录对应的包。</p>\n<p>表格驱动测试在我们要创建一系列相同测试方式的测试用例时很有用。例如:<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestIsPalindrome</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> tests = []<span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">        input <span class=\"keyword\">string</span></span><br><span class=\"line\">        want  <span class=\"keyword\">bool</span></span><br><span class=\"line\">    &#125;&#123;</span><br><span class=\"line\">        &#123;<span class=\"string\">\"\"</span>, <span class=\"literal\">true</span>&#125;,</span><br><span class=\"line\">        &#123;<span class=\"string\">\"a\"</span>, <span class=\"literal\">true</span>&#125;,</span><br><span class=\"line\">        &#123;<span class=\"string\">\"aa\"</span>, <span class=\"literal\">true</span>&#125;,</span><br><span class=\"line\">        &#123;<span class=\"string\">\"ab\"</span>, <span class=\"literal\">false</span>&#125;,</span><br><span class=\"line\">        &#123;<span class=\"string\">\"kayak\"</span>, <span class=\"literal\">true</span>&#125;,</span><br><span class=\"line\">        &#123;<span class=\"string\">\"detartrated\"</span>, <span class=\"literal\">true</span>&#125;,</span><br><span class=\"line\">        &#123;<span class=\"string\">\"A man, a plan, a canal: Panama\"</span>, <span class=\"literal\">true</span>&#125;,</span><br><span class=\"line\">        &#123;<span class=\"string\">\"Evil I did dwell; lewd did I live.\"</span>, <span class=\"literal\">true</span>&#125;,</span><br><span class=\"line\">        &#123;<span class=\"string\">\"Able was I ere I saw Elba\"</span>, <span class=\"literal\">true</span>&#125;,</span><br><span class=\"line\">        &#123;<span class=\"string\">\"été\"</span>, <span class=\"literal\">true</span>&#125;,</span><br><span class=\"line\">        &#123;<span class=\"string\">\"Et se resservir, ivresse reste.\"</span>, <span class=\"literal\">true</span>&#125;,</span><br><span class=\"line\">        &#123;<span class=\"string\">\"palindrome\"</span>, <span class=\"literal\">false</span>&#125;, <span class=\"comment\">// non-palindrome</span></span><br><span class=\"line\">        &#123;<span class=\"string\">\"desserts\"</span>, <span class=\"literal\">false</span>&#125;,   <span class=\"comment\">// semi-palindrome</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> _, test := <span class=\"keyword\">range</span> tests &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> got := IsPalindrome(test.input); got != test.want &#123;</span><br><span class=\"line\">            t.Errorf(<span class=\"string\">\"IsPalindrome(%q) = %v\"</span>, test.input, got)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"覆盖率\"><a href=\"#覆盖率\" class=\"headerlink\" title=\"覆盖率\"></a>覆盖率</h2><p><code>go test</code> 命令中集成了测试覆盖率工具。<br>运行 <code>go tool cover</code>：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ go tool cover</span><br><span class=\"line\">Usage of <span class=\"string\">'go tool cover'</span>:</span><br><span class=\"line\">Given a coverage profile produced by <span class=\"string\">'go test'</span>:</span><br><span class=\"line\">    go <span class=\"built_in\">test</span> -coverprofile=c.out</span><br><span class=\"line\"></span><br><span class=\"line\">Open a web browser displaying annotated <span class=\"built_in\">source</span> code:</span><br><span class=\"line\">    go tool cover -html=c.out</span><br></pre></td></tr></table></figure></p>\n<p>添加 <code>-coverprofile</code> 参数，统计覆盖率数据，并将统计日志数据写入指定文件，如 <code>go test -run=Coverage -coverprofile=c.out</code>。<br><code>-covermode=count</code> 参数将在每个代码块插入一个计数器而不是布尔标志量。在统计结果中记录了每个块的执行次数，<br>这可以用于衡量哪些是被频繁执行的热点代码。</p>\n<h2 id=\"基准测试\"><a href=\"#基准测试\" class=\"headerlink\" title=\"基准测试\"></a>基准测试</h2><p><strong>测试函数必须导入 <code>testing</code> 包，并以 <code>Benchmark</code> 为函数名前缀，后缀名必须以大写字母开头，并且唯一参数的类型必须<br>是 <code>*testing.B</code> 类型的</strong>：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">BenchmarkName</span><span class=\"params\">(b *testing.B)</span></span> &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>*testing.B</code> 参数除了提供和 <code>*testing.T</code> 类似的方法，还有额外一些和性能测量相关的方法。</p>\n<h3 id=\"运行基准测试\"><a href=\"#运行基准测试\" class=\"headerlink\" title=\"运行基准测试\"></a>运行基准测试</h3><p>运行基准测试需要使用 <code>-bench</code> 参数，指定要运行的基准测试函数。该参数是一个正则表达式，用于匹配要执行的基准测试函数的名字，<br>默认值是空的。</p>\n<p><code>.</code> 会匹配所有基准测试函数。</p>\n<h3 id=\"剖析\"><a href=\"#剖析\" class=\"headerlink\" title=\"剖析\"></a>剖析</h3><p>基准测试对于衡量特定操作的性能是有帮助的，Go 语言支持多种类型的剖析性能分析：</p>\n<ol>\n<li>CPU 剖析数据标识了最耗 CPU 时间的函数。</li>\n<li>堆剖析则标识了最耗内存的语句。</li>\n<li>阻塞剖析则记录阻塞 goroutine 最久的操作，例如系统调用、管道发送和接收，还有获取锁等。</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ go <span class=\"built_in\">test</span> -cpuprofile=cpu.out</span><br><span class=\"line\">$ go <span class=\"built_in\">test</span> -blockprofile=block.out</span><br><span class=\"line\">$ go <span class=\"built_in\">test</span> -memprofile=mem.out</span><br></pre></td></tr></table></figure>\n<h4 id=\"go-tool-pprof\"><a href=\"#go-tool-pprof\" class=\"headerlink\" title=\"go tool pprof\"></a>go tool pprof</h4><p><code>go tool pprof</code> 命令可以用来分析上面的命令生成的数据。</p>\n<h2 id=\"示例函数\"><a href=\"#示例函数\" class=\"headerlink\" title=\"示例函数\"></a>示例函数</h2><p>并以 <code>Benchmark</code> 为函数名前缀，示例函数没有函数参数和返回值：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">ExampleName</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>三个用处:</p>\n<ol>\n<li>作为文档，如 <code>ExampleIsPalindrome</code> 示例函数将是 <code>IsPalindrome</code> 函数文档的一部分。</li>\n<li><code>go test</code> 会运行示例函数测试。</li>\n<li>提供 Go Playground，可以在浏览器中在线编辑和运行每个示例函数。</li>\n</ol>\n<h2 id=\"go-test-命令执行的主要测试流程\"><a href=\"#go-test-命令执行的主要测试流程\" class=\"headerlink\" title=\"go test 命令执行的主要测试流程\"></a>go test 命令执行的主要测试流程</h2><p><code>go test</code> 命令在开始运行时，会先做一些准备工作，比如，确定内部需要用到的命令，检查我们指定的代码包或源码文件的有效性，<br>以及判断我们给予的标记是否合法，等等。</p>\n<p>在准备工作顺利完成之后，go test 命令就会针对每个被测代码包，依次地进行构建、执行包中符合要求的测试函数，清理临时文件，<br>打印测试结果。这就是通常情况下的主要测试流程。</p>\n<p>对于每个被测代码包，<code>go test</code> 命令会<strong>串行地执行测试流程中的每个步骤</strong>。</p>\n<p>但是，为了加快测试速度，它通常会并发地对多个被测代码包进行功能测试，只不过，在最后打印测试结果的时候，它会依照我们给定的<br>顺序逐个进行，这会让我们感觉到它是在完全串行地执行测试流程。</p>\n<p>由于<strong>并发的测试会让性能测试的结果存在偏差，所以性能测试一般都是串行进行的</strong>。</p>\n<h2 id=\"功能测试的测试结果\"><a href=\"#功能测试的测试结果\" class=\"headerlink\" title=\"功能测试的测试结果\"></a>功能测试的测试结果</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ go <span class=\"built_in\">test</span> puzzlers/article20/q2</span><br><span class=\"line\">ok   puzzlers/article20/q2 (cached)</span><br></pre></td></tr></table></figure>\n<p><code>(cached)</code> 表明，由于测试代码与被测代码都没有任何变动，所以 <code>go test</code> 命令直接把之前缓存测试成功的结果打印出来了。</p>\n<p>go 命令通常会缓存程序构建的结果，以便在将来的构建中重用。我们可以通过运行 <code>go env GOCACHE</code> 命令来查看缓存目录的路径。</p>\n<p>运行 <code>go clean -testcache</code> 将会删除所有的测试结果缓存。不过，这样做肯定不会删除任何构建结果缓存。</p>\n<p>设置环境变量 <code>GODEBUG</code> 的值也可以稍稍地改变 go 命令的缓存行为。比如，设置值为 <code>gocacheverify=1</code> 将会导致 go 命令绕<br>过任何的缓存数据，而真正地执行操作并重新生成所有结果，然后再去检查新的结果与现有的缓存数据是否一致。</p>\n<h2 id=\"性能测试的测试结果\"><a href=\"#性能测试的测试结果\" class=\"headerlink\" title=\"性能测试的测试结果\"></a>性能测试的测试结果</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ go <span class=\"built_in\">test</span> -bench=. -run=^$ puzzlers/article20/q3</span><br><span class=\"line\">goos: darwin</span><br><span class=\"line\">goarch: amd64</span><br><span class=\"line\">pkg: puzzlers/article20/q3</span><br><span class=\"line\">BenchmarkGetPrimes-8      500000       2314 ns/op</span><br><span class=\"line\">PASS</span><br><span class=\"line\">ok   puzzlers/article20/q3 1.192s</span><br></pre></td></tr></table></figure>\n<p><strong>第一个标记及其值为 <code>-bench=.</code>，只有有了这个标记，命令才会进行性能测试</strong>。该标记的值<code>.</code>表明需要执行任意名称的性能测试函数。</p>\n<p>第二个标记及其值是 <code>-run=^$</code>，这个标记用于表明需要执行哪些功能测试函数，这同样也是以函数名称为依据的。该标记的值 <code>^$</code> 意味着：<br>只执行名称为空的功能测试函数，换句话说，不执行任何功能测试函数。</p>\n<p>这两个标记的值都是正则表达式。实际上，它们只能以正则表达式为值。此外，如果运行 <code>go test</code> 命令的时候不加 <code>-run</code> 标记，<br>那么就会使它执行被测代码包中的所有功能测试函数。</p>\n<p>测试结果，重点在倒数第三行的内容。<code>BenchmarkGetPrimes-8</code> 被称为单个性能测试的名称，它表示命令执行了性能测试<br>函数 <code>BenchmarkGetPrimes</code>，并且当时所用的最大 P 数量为 8。</p>\n<p>最大 P 数量相当于可以同时运行 goroutine 的逻辑 CPU 的最大个数。这里的逻辑 CPU，也可以被称为 CPU 核心，但它并不等同<br>于计算机中真正的 CPU 核心，只是 Go 语言运行时系统内部的一个概念，代表着它同时运行 goroutine 的能力。</p>\n<p>可以通过调用 <code>runtime.GOMAXPROCS</code> 函数改变最大 P 数量，也可以在运行 <code>go test</code> 命令时，加入标记 <code>-cpu</code> 来设置一个最大 P 数量<br>的列表，以供命令在多次测试时使用。</p>\n<p>测试名称右边的是执行次数。<strong>它指的是被测函数的执行次数，而不是性能测试函数的执行次数</strong>。</p>\n<h2 id=\"parallel-标记\"><a href=\"#parallel-标记\" class=\"headerlink\" title=\"-parallel 标记\"></a><code>-parallel</code> 标记</h2><p>该标记的作用是：设置同一个被测代码包中的功能测试函数的最大并发执行数。<br>该标记的默认值是测试运行时的最大 P 数量（这可以通过调用表达 式<code>runtime.GOMAXPROCS(0)</code> 获得）。</p>\n<p>对于功能测试，为了加快测试速度，命令通常会并发地测试多个被测代码包。但是，在默认情况下，<strong>对于同一个被测代码包中的多个功<br>能测试函数，命令会串行地执行它们</strong>。除非我们在一些功能测试函数中显式地调用 <code>t.Parallel</code>方 法。</p>\n<p>这个时候，这些包含了 <code>t.Parallel</code> 方法调用的功能测试函数就会被 <code>go test</code> 命令并发地执行，而并发执行的最大数量正是<br>由 <code>-parallel</code> 标记值决定的。要注意，同一个功能测试函数的多次执行之间一定是串行的。</p>\n<h2 id=\"性能测试函数中的计时器\"><a href=\"#性能测试函数中的计时器\" class=\"headerlink\" title=\"性能测试函数中的计时器\"></a>性能测试函数中的计时器</h2><p><code>testing.B</code> 类型有这么几个指针方法：<code>StartTimer</code>、<code>StopTimer</code> 和 <code>ResetTimer</code>。这些方法都是用于操作当前的性能测试函数<br>专属的计时器的。</p>\n<p>这些字段用于记录：当前测试函数在当次执行过程中耗费的时间、分配的堆内存的字节数以及分配次数。</p>\n<h2 id=\"性能分析\"><a href=\"#性能分析\" class=\"headerlink\" title=\"性能分析\"></a>性能分析</h2><p>Go 语言为程序开发者们提供了丰富的性能分析 API，和非常好用的标准工具。这些 API 主要存在于：</p>\n<ul>\n<li><code>runtime/pprof</code>；</li>\n<li><code>net/http/pprof</code>；</li>\n<li><code>runtime/trace</code>；</li>\n</ul>\n<p>至于标准工具，主要有 <code>go tool pprof</code> 和 <code>go tool trace</code> 这两个。它们可以解析概要文件中的信息，并以人类易读的方式把这些<br>信息展示出来。</p>\n<p>在 Go 语言中，用于分析程序性能的概要文件有三种，分别是：<strong>CPU 概要文件（CPU Profile）、内存概要文件（Mem Profile）和阻塞概<br>要文件（Block Profile）</strong>。</p>\n<ul>\n<li>CPU 概要文件，其中的每一段独立的概要信息都记录着，在进行某一次采样的那个时刻，CPU 上正在执行的 Go 代码。</li>\n<li>内存概要文件，其中的每一段概要信息都记载着，在某个采样时刻，正在执行的 Go 代码以及堆内存的使用情况，这里包含已分配和已释放的<br>字节数量和对象数量。</li>\n<li>阻塞概要文件，其中的每一段概要信息，都代表着 Go 程序中的一个 goroutine 阻塞事件。</li>\n</ul>\n<h3 id=\"程序对-CPU-概要信息进行采样\"><a href=\"#程序对-CPU-概要信息进行采样\" class=\"headerlink\" title=\"程序对 CPU 概要信息进行采样\"></a>程序对 CPU 概要信息进行采样</h3><p>这需要用到 <code>runtime/pprof</code> 包中的 API。想让程序开始对 CPU 概要信息进行采样的时候，需要调用这个代码包中<br>的 <code>StartCPUProfile</code> 函数，而在停止采样的时候则需要调用该包中的<code>StopCPUProfile</code>函数。</p>\n<h3 id=\"设定内存概要信息的采样频率\"><a href=\"#设定内存概要信息的采样频率\" class=\"headerlink\" title=\"设定内存概要信息的采样频率\"></a>设定内存概要信息的采样频率</h3><p>针对内存概要信息的采样会按照一定比例收集 Go 程序在运行期间的堆内存使用情况。设定内存概要信息采样频率的方法很简单，<br>只要为 <code>runtime.MemProfileRate</code> 变量赋值即可。</p>\n<p>这个变量的含义是，平均每分配多少个字节，就对堆内存的使用情况进行一次采样。如果把该变量的值设为0，那么，Go 语言运行时系统就<br>会完全停止对内存概要信息的采样。该变量的缺省值是 512 KB，也就是 512 千字节。</p>\n<p><strong>如果你要设定这个采样频率，那么越早设定越好，并且只应该设定一次，否则就可能会对 Go 语言运行时系统的采样工作，造成不良影响</strong>。<br>比如，只在 <code>main</code> 函数的开始处设定一次。</p>\n<p>当我们想获取内存概要信息的时候，还需要调用 <code>runtime/pprof</code> 包中的 <code>WriteHeapProfile</code> 函数。该函数会把收集好的内存概要信息，<br>写到我们指定的写入器中。</p>\n<p>注意，我们通过 <strong><code>WriteHeapProfile</code> 函数得到的内存概要信息并不是实时的，它是一个快照，是在最近一次的内存垃圾收集工作完成时产<br>生的</strong>。如果你想要实时的信息，那么可以调用 <code>runtime.ReadMemStats</code> 函数。不过要特别注意，该函数会引起 Go 语言调度器的短暂停顿。</p>\n<h3 id=\"获取到阻塞概要信息\"><a href=\"#获取到阻塞概要信息\" class=\"headerlink\" title=\"获取到阻塞概要信息\"></a>获取到阻塞概要信息</h3><p>调用 <code>runtime</code> 包中的 <code>SetBlockProfileRate</code> 函数，即可对阻塞概要信息的采样频率进行设定。该函数有一个名叫 <code>rate</code> 的参数，<br>它是 <code>int</code> 类型的。</p>\n<p>这个参数的含义是，只要发现一个阻塞事件的持续时间达到了多少个纳秒，就可以对其进行采样。如果这个参数的值小于或等于0，那么就意<br>味着 Go 语言运行时系统将会完全停止对阻塞概要信息的采样。</p>\n<p>当我们需要获取阻塞概要信息的时候，需要先调用 <code>runtime/pprof</code> 包中的 <code>Lookup</code> 函数并传入参数值 “block”，从而得到一<br>个 <code>*runtime/pprof.Profile</code> 类型的值（以下简称Profile值）。在这之后，我们还需要调用这个 <code>Profile</code> 值的 <code>WriteTo</code> 方法，<br>以驱使它把概要信息写进我们指定的写入器中。</p>\n<p><code>WriteTo</code> 方法有两个参数，一个参数就是我们刚刚提到的写入器，它是 <code>io.Writer</code> 类型的。而另一个参数则是代表了概要信息<br>详细程度的 <code>int</code> 类型参数 <code>debug</code>。</p>\n<p><code>debug</code> 参数主要的可选值有两个，即：0 和 1。当 <code>debug</code> 的值为 0 时，通过 <code>WriteTo</code> 方法写进写入器的概要信息仅会包含<br> <code>go tool pprof</code> 工具所需的内存地址，这些内存地址会以十六进制的形式展现出来。</p>\n<p>当该值为 1 时，相应的包名、函数名、源码文件路径、代码行号等信息就都会作为注释被加入进去。另外，<code>debug</code> 为 0 时的概要信息，<br>会经由 protocol buffers 转换为字节流。而在 <code>debug</code> 为 1 的时候，<code>WriteTo</code> 方法输出的这些概要信息就是我们可以读懂<br>的普通文本了。</p>\n<p>除此之外，<code>debug</code> 的值也可以是 2。这时，被输出的概要信息也会是普通的文本，并且通常会包含更多的细节。至于这些细节都包含了哪些<br>内容，那就要看们调用 <code>runtime/pprof.Lookup</code> 函数的时候传入的是什么样的参数值了。</p>\n"},{"title":"big","_content":"\n# big\n`big` 是 Go 语言提供的进行大数操作的标准库，实现了任意精度算术（大数）。\n\nGo 语言中的 `float64` 类型进行浮点运算，返回结果将精确到 15 位，足以满足大多数的任务。但是当对超出 `int64` 或者 `uint64` 类型这样的大\n数进行计算时，如果对精度没有要求，`float32` 或者 `float64` 可以胜任，但如果对精度有严格要求的时候，则不能使用浮点数，在内存中它们只能\n被近似的表示。\n\n对于整数的高精度计算 Go 语言中提供了 `big` 包，被包含在 `math` 包下：有用来表示大整数的 `big.Int` 和表示大有理数的 `big.Rat` 类型\n（可以表示为 `2/5` 或 `3.1416` 这样的分数，而不是无理数或 `π`）。这些类型可以实现任意位类型的数字，只要内存足够大。缺点是更大的内存\n和处理开销使它们使用起来要比内置的数字类型慢很多。\n\n大的整型数字是通过 `big.NewInt(n)` 来构造的，其中 `n` 为 `int64` 类型整数。而大有理数是通过 `big.NewRat(n, d)` 方法构造。`n`（分子）\n和 `d`（分母）都是 `int64` 型整数。因为 Go 语言不支持运算符重载，所以所有大数字类型都有像是 `Add()` 和 `Mul()` 这样的方法。它们作用\n于作为 receiver 的整数和有理数，大多数情况下它们修改 receiver 并以 receiver 作为返回结果。因为没有必要创建 `big.Int` 类型的临\n时变量来存放中间结果，所以运算可以被链式地调用，并节省内存。\n\n示例：\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"math/big\"\n)\n\nfunc main() {\n\t// Here are some calculations with bigInts:\n\tim := big.NewInt(math.MaxInt64)\n\tin := im\n\tio := big.NewInt(1956)\n\tip := big.NewInt(1)\n\tip.Mul(im, in).Add(ip, im).Div(ip, io)\n\tfmt.Printf(\"Big Int: %v\\n\", ip)\n\t// Here are some calculations with bigInts:\n\trm := big.NewRat(math.MaxInt64, 1956)\n\trn := big.NewRat(-1956, math.MaxInt64)\n\tro := big.NewRat(19, 56)\n\trp := big.NewRat(1111, 2222)\n\trq := big.NewRat(1, 1)\n\trq.Mul(rm, rn).Add(rq, ro).Mul(rq, rp)\n\tfmt.Printf(\"Big Rat: %v\\n\", rq)\n}\n\n/* Output:\nBig Int: 43492122561469640008497075573153004\nBig Rat: -37/112\n*/\n```\n","source":"standards/data/big.md","raw":"---\ntitle: big\n---\n\n# big\n`big` 是 Go 语言提供的进行大数操作的标准库，实现了任意精度算术（大数）。\n\nGo 语言中的 `float64` 类型进行浮点运算，返回结果将精确到 15 位，足以满足大多数的任务。但是当对超出 `int64` 或者 `uint64` 类型这样的大\n数进行计算时，如果对精度没有要求，`float32` 或者 `float64` 可以胜任，但如果对精度有严格要求的时候，则不能使用浮点数，在内存中它们只能\n被近似的表示。\n\n对于整数的高精度计算 Go 语言中提供了 `big` 包，被包含在 `math` 包下：有用来表示大整数的 `big.Int` 和表示大有理数的 `big.Rat` 类型\n（可以表示为 `2/5` 或 `3.1416` 这样的分数，而不是无理数或 `π`）。这些类型可以实现任意位类型的数字，只要内存足够大。缺点是更大的内存\n和处理开销使它们使用起来要比内置的数字类型慢很多。\n\n大的整型数字是通过 `big.NewInt(n)` 来构造的，其中 `n` 为 `int64` 类型整数。而大有理数是通过 `big.NewRat(n, d)` 方法构造。`n`（分子）\n和 `d`（分母）都是 `int64` 型整数。因为 Go 语言不支持运算符重载，所以所有大数字类型都有像是 `Add()` 和 `Mul()` 这样的方法。它们作用\n于作为 receiver 的整数和有理数，大多数情况下它们修改 receiver 并以 receiver 作为返回结果。因为没有必要创建 `big.Int` 类型的临\n时变量来存放中间结果，所以运算可以被链式地调用，并节省内存。\n\n示例：\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"math/big\"\n)\n\nfunc main() {\n\t// Here are some calculations with bigInts:\n\tim := big.NewInt(math.MaxInt64)\n\tin := im\n\tio := big.NewInt(1956)\n\tip := big.NewInt(1)\n\tip.Mul(im, in).Add(ip, im).Div(ip, io)\n\tfmt.Printf(\"Big Int: %v\\n\", ip)\n\t// Here are some calculations with bigInts:\n\trm := big.NewRat(math.MaxInt64, 1956)\n\trn := big.NewRat(-1956, math.MaxInt64)\n\tro := big.NewRat(19, 56)\n\trp := big.NewRat(1111, 2222)\n\trq := big.NewRat(1, 1)\n\trq.Mul(rm, rn).Add(rq, ro).Mul(rq, rp)\n\tfmt.Printf(\"Big Rat: %v\\n\", rq)\n}\n\n/* Output:\nBig Int: 43492122561469640008497075573153004\nBig Rat: -37/112\n*/\n```\n","date":"2019-10-19T13:40:15.174Z","updated":"2019-10-19T13:40:15.174Z","path":"standards/data/big.html","comments":1,"layout":"page","_id":"ck1xm14l6000yfcw2iay0duy6","content":"<h1 id=\"big\"><a href=\"#big\" class=\"headerlink\" title=\"big\"></a>big</h1><p><code>big</code> 是 Go 语言提供的进行大数操作的标准库，实现了任意精度算术（大数）。</p>\n<p>Go 语言中的 <code>float64</code> 类型进行浮点运算，返回结果将精确到 15 位，足以满足大多数的任务。但是当对超出 <code>int64</code> 或者 <code>uint64</code> 类型这样的大<br>数进行计算时，如果对精度没有要求，<code>float32</code> 或者 <code>float64</code> 可以胜任，但如果对精度有严格要求的时候，则不能使用浮点数，在内存中它们只能<br>被近似的表示。</p>\n<p>对于整数的高精度计算 Go 语言中提供了 <code>big</code> 包，被包含在 <code>math</code> 包下：有用来表示大整数的 <code>big.Int</code> 和表示大有理数的 <code>big.Rat</code> 类型<br>（可以表示为 <code>2/5</code> 或 <code>3.1416</code> 这样的分数，而不是无理数或 <code>π</code>）。这些类型可以实现任意位类型的数字，只要内存足够大。缺点是更大的内存<br>和处理开销使它们使用起来要比内置的数字类型慢很多。</p>\n<p>大的整型数字是通过 <code>big.NewInt(n)</code> 来构造的，其中 <code>n</code> 为 <code>int64</code> 类型整数。而大有理数是通过 <code>big.NewRat(n, d)</code> 方法构造。<code>n</code>（分子）<br>和 <code>d</code>（分母）都是 <code>int64</code> 型整数。因为 Go 语言不支持运算符重载，所以所有大数字类型都有像是 <code>Add()</code> 和 <code>Mul()</code> 这样的方法。它们作用<br>于作为 receiver 的整数和有理数，大多数情况下它们修改 receiver 并以 receiver 作为返回结果。因为没有必要创建 <code>big.Int</code> 类型的临<br>时变量来存放中间结果，所以运算可以被链式地调用，并节省内存。</p>\n<p>示例：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">\"fmt\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"math\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"math/big\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// Here are some calculations with bigInts:</span></span><br><span class=\"line\">\tim := big.NewInt(math.MaxInt64)</span><br><span class=\"line\">\tin := im</span><br><span class=\"line\">\tio := big.NewInt(<span class=\"number\">1956</span>)</span><br><span class=\"line\">\tip := big.NewInt(<span class=\"number\">1</span>)</span><br><span class=\"line\">\tip.Mul(im, in).Add(ip, im).Div(ip, io)</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"Big Int: %v\\n\"</span>, ip)</span><br><span class=\"line\">\t<span class=\"comment\">// Here are some calculations with bigInts:</span></span><br><span class=\"line\">\trm := big.NewRat(math.MaxInt64, <span class=\"number\">1956</span>)</span><br><span class=\"line\">\trn := big.NewRat(<span class=\"number\">-1956</span>, math.MaxInt64)</span><br><span class=\"line\">\tro := big.NewRat(<span class=\"number\">19</span>, <span class=\"number\">56</span>)</span><br><span class=\"line\">\trp := big.NewRat(<span class=\"number\">1111</span>, <span class=\"number\">2222</span>)</span><br><span class=\"line\">\trq := big.NewRat(<span class=\"number\">1</span>, <span class=\"number\">1</span>)</span><br><span class=\"line\">\trq.Mul(rm, rn).Add(rq, ro).Mul(rq, rp)</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"Big Rat: %v\\n\"</span>, rq)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* Output:</span></span><br><span class=\"line\"><span class=\"comment\">Big Int: 43492122561469640008497075573153004</span></span><br><span class=\"line\"><span class=\"comment\">Big Rat: -37/112</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{"navigation":{"logo":{"text":"Golang Learn","type":"link","path":"index.html"},"main":[{"text":"Golang 基础","type":"label"},{"text":"Go 环境配置","type":"link","path":"basic/env_config.html"},{"text":"包","type":"link","path":"basic/package.html"},{"text":"基础数据类型","type":"link","path":"basic/basic_data.html"},{"text":"变量","type":"link","path":"basic/var.html"},{"text":"常量","type":"link","path":"basic/constant.html"},{"text":"控制语句","type":"link","path":"basic/flow.html"},{"text":"运算符","type":"link","path":"basic/operator.html"},{"text":"作用域","type":"link","path":"basic/scope.html"},{"text":"指针","type":"link","path":"basic/pointer.html"},{"text":"数组","type":"link","path":"basic/array.html"},{"text":"切片","type":"link","path":"basic/slice.html"},{"text":"字典","type":"link","path":"basic/map.html"},{"text":"函数","type":"link","path":"basic/function.html"},{"text":"结构体","type":"link","path":"basic/struct.html"},{"text":"接口","type":"link","path":"basic/interface.html"},{"text":"面向对象","type":"link","path":"basic/oop.html"},{"text":"错误","type":"link","path":"basic/error.html"},{"text":"序列化","type":"link","path":"basic/json.html"},{"text":"反射","type":"link","path":"basic/reflect.html"},{"text":"测试","type":"link","path":"basic/test.html"},{"text":"并发编程","type":"label"},{"text":"goroutine","type":"link","path":"concurrent/goroutine.html"},{"text":"channel","type":"link","path":"concurrent/channel.html"},{"text":"同步和锁","type":"link","path":"concurrent/sync_lock.html"},{"text":"内存分配","type":"label"},{"text":"内存分配","type":"link","path":"advance/mm.html"},{"text":"垃圾回收","type":"label"},{"text":"垃圾回收","type":"link","path":"advance/gc.html"},{"text":"标准库","type":"label"},{"text":"fmt","type":"link","path":"standards/io/fmt.html"},{"text":"io","type":"link","path":"standards/io/io.html"},{"text":"ioutil","type":"link","path":"standards/io/ioutil.html"},{"text":"bufio","type":"link","path":"standards/io/bufio.html"},{"text":"os","type":"link","path":"standards/os/os.html"},{"text":"filepath","type":"link","path":"standards/os/filepath.html"},{"text":"strings","type":"link","path":"standards/text/strings.html"},{"text":"strconv","type":"link","path":"standards/text/strconv.html"},{"text":"unicode","type":"link","path":"standards/text/unicode.html"},{"text":"log","type":"link","path":"standards/log.html"},{"text":"time","type":"link","path":"standards/time.html"},{"text":"http","type":"link","path":"standards/net/http.html"},{"text":"math","type":"link","path":"standards/data/math.html"},{"text":"sort","type":"link","path":"standards/data/sort.html"},{"text":"big","type":"link","path":"standards/data/big.html"},{"text":"container","type":"link","path":"standards/data/container.html"},{"text":"sql","type":"link","path":"standards/database/sql.html"},{"text":"THEME","type":"label"},{"text":"使用文档主题","type":"link","path":"theme/theme-usage.html"},{"text":"SUPPORT AND FEEDBACK","type":"label"},{"text":"Raise an Issue on Github","type":"link","path":"https://github.com/shipengqi/golang-learn/issues/new"}]}}},"excerpt":"","more":"<h1 id=\"big\"><a href=\"#big\" class=\"headerlink\" title=\"big\"></a>big</h1><p><code>big</code> 是 Go 语言提供的进行大数操作的标准库，实现了任意精度算术（大数）。</p>\n<p>Go 语言中的 <code>float64</code> 类型进行浮点运算，返回结果将精确到 15 位，足以满足大多数的任务。但是当对超出 <code>int64</code> 或者 <code>uint64</code> 类型这样的大<br>数进行计算时，如果对精度没有要求，<code>float32</code> 或者 <code>float64</code> 可以胜任，但如果对精度有严格要求的时候，则不能使用浮点数，在内存中它们只能<br>被近似的表示。</p>\n<p>对于整数的高精度计算 Go 语言中提供了 <code>big</code> 包，被包含在 <code>math</code> 包下：有用来表示大整数的 <code>big.Int</code> 和表示大有理数的 <code>big.Rat</code> 类型<br>（可以表示为 <code>2/5</code> 或 <code>3.1416</code> 这样的分数，而不是无理数或 <code>π</code>）。这些类型可以实现任意位类型的数字，只要内存足够大。缺点是更大的内存<br>和处理开销使它们使用起来要比内置的数字类型慢很多。</p>\n<p>大的整型数字是通过 <code>big.NewInt(n)</code> 来构造的，其中 <code>n</code> 为 <code>int64</code> 类型整数。而大有理数是通过 <code>big.NewRat(n, d)</code> 方法构造。<code>n</code>（分子）<br>和 <code>d</code>（分母）都是 <code>int64</code> 型整数。因为 Go 语言不支持运算符重载，所以所有大数字类型都有像是 <code>Add()</code> 和 <code>Mul()</code> 这样的方法。它们作用<br>于作为 receiver 的整数和有理数，大多数情况下它们修改 receiver 并以 receiver 作为返回结果。因为没有必要创建 <code>big.Int</code> 类型的临<br>时变量来存放中间结果，所以运算可以被链式地调用，并节省内存。</p>\n<p>示例：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">\"fmt\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"math\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"math/big\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// Here are some calculations with bigInts:</span></span><br><span class=\"line\">\tim := big.NewInt(math.MaxInt64)</span><br><span class=\"line\">\tin := im</span><br><span class=\"line\">\tio := big.NewInt(<span class=\"number\">1956</span>)</span><br><span class=\"line\">\tip := big.NewInt(<span class=\"number\">1</span>)</span><br><span class=\"line\">\tip.Mul(im, in).Add(ip, im).Div(ip, io)</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"Big Int: %v\\n\"</span>, ip)</span><br><span class=\"line\">\t<span class=\"comment\">// Here are some calculations with bigInts:</span></span><br><span class=\"line\">\trm := big.NewRat(math.MaxInt64, <span class=\"number\">1956</span>)</span><br><span class=\"line\">\trn := big.NewRat(<span class=\"number\">-1956</span>, math.MaxInt64)</span><br><span class=\"line\">\tro := big.NewRat(<span class=\"number\">19</span>, <span class=\"number\">56</span>)</span><br><span class=\"line\">\trp := big.NewRat(<span class=\"number\">1111</span>, <span class=\"number\">2222</span>)</span><br><span class=\"line\">\trq := big.NewRat(<span class=\"number\">1</span>, <span class=\"number\">1</span>)</span><br><span class=\"line\">\trq.Mul(rm, rn).Add(rq, ro).Mul(rq, rp)</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"Big Rat: %v\\n\"</span>, rq)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* Output:</span></span><br><span class=\"line\"><span class=\"comment\">Big Int: 43492122561469640008497075573153004</span></span><br><span class=\"line\"><span class=\"comment\">Big Rat: -37/112</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n"},{"title":"sql","_content":"\n# sql\n`database/sql` 提供了操作 SQL/SQL-Like 数据库的通用接口，但 Go 标准库并没有提供具体数据库的实现，需要结合第三方的驱动来使用该接口。\n例如 mysql 的驱动：[github.com/go-sql-driver/mysql](https://github.com/go-sql-driver/mysql)。\n\n## 类型\n\n`database/sql` 提供了一些类型：\n- `sql.DB` 类型代表了一个数据库。它并**不代表一个到数据库的具体连接，而是一个能操作的数据库对象**，具体的连接在内部通过连接池来管理，\n对外不暴露。\n- `sql.Rows`、`sql.Row` 和 `sql.Result`，分别用于获取多个多行结果、一行结果和修改数据库影响的行数（或其返回 `last insert id`）。\n- `sql.Stmt` 代表一个语句，如：DDL、DML 等。\n- `sql.Tx` 代表带有特定属性的一个事务。\n\n## sql.DB 的使用\n`sql.DB` 是一个数据库句柄，代表一个具有零到多个底层连接的连接池，它可以安全的被多个 goroutine 同时使用。  \n\n> sql 包会自动创建和释放连接；它也会维护一个闲置连接的连接池。如果数据库具有单连接状态的概念，该状态只有在事务中被观察时才可信。\n一旦调用了 `BD.Begin`，返回的 `Tx` 会绑定到单个连接。当调用事务 `Tx` 的 `Commit` 或 `Rollback` 后，该事务使用的连接会归还到 `DB` 的闲\n置连接池中。连接池的大小可以用 `SetMaxIdleConns` 方法控制。\n\n由于 `DB` 并非一个实际的到数据库的连接，而且可以被多个 goroutine 并发使用，因此，程序中只需要拥有一个全局的实例即可：\n```go\ndb, err := sql.Open(\"mysql\", \"root:@tcp(localhost:3306)/test?charset=utf8\")\nif err != nil {\n    panic(err)\n}\ndefer db.Close()\n```\n通常情况下，`defer db.Close()` 可以不调用，因为 `DB` 句柄通常被多个 goroutine 共享，并长期活跃。当然，如果你确定 DB 只会被使用一次，\n之后不会使用了，应该调用 `Close`。\n\n所以，实际应用时，应该在一个 go 文件中的 `init` 函数中调用 `sql.Open` 初始化全局的 `sql.DB` 对象，供程序中所有需要进\n行数据库操作的地方使用。\n\n前面说过，`sql.DB` 并不是实际的数据库连接，因此，`sql.Open` 函数并没有进行数据库连接。\n\n例如：`db, err := sql.Open(\"mysql\", \"root:@tcp23(localhost233:3306)/test?charset=utf8\")`。虽然这里的 dsn 是错误的，\n但依然 `err == nil`，只有在实际操作数据库（查询、更新等）或调用 `Ping` 时才会报错。\n\n关于 `Open` 函数的参数，第一个是驱动名，为了避免混淆，一般和驱动包名一致，在驱动实现中，会有类似这样的代码：\n```go\nfunc init() {\n    sql.Register(\"mysql\", &MySQLDriver{})\n}\n```\n其中 `mysql` 即是注册的驱动名。由于注册驱动是在 `init` 函数中进行的，这也就是为什么采用 `_ \"github.com/go-sql-driver/mysql\"` \n这种方式引入驱动包。第二个参数是 DSN（数据源名称），这个是和具体驱动相关的，`database/sql` 包并没有规定，具体书写方式参见驱动文档。\n\n### 连接池的工作原理\n\n获取 `DB` 对象后，连接池是空的，第一个连接在需要的时候才会创建：\n```go\ndb, _ := sql.Open(\"mysql\", \"root:@tcp(localhost:3306)/test?charset=utf8\")\nfmt.Println(\"please exec show processlist\")\ntime.Sleep(10 * time.Second)\nfmt.Println(\"please exec show processlist again\")\ndb.Ping()\ntime.Sleep(10 * time.Second)\n```\n在 `Ping` 执行之前和之后，`show processlist` 多了一条记录，即多了一个连接，`Command` 列是 `Sleep`。\n\n连接池的工作方式：当调用一个函数，需要访问数据库时，该函数会请求从连接池中获取一个连接，如果连接池中存在一个空闲连接，它会将该空闲连接给\n该函数；否则，会打开一个新的连接。当该函数结束时，该连接要么返回给连接池，要么传递给某个需要该连接的对象，知道该对象完成时，连接才会返回给连\n接池。相关方法的处理说明（假设 `sql.DB` 的对象是 `db`）：\n\n- **db.Ping()** 会将连接立马返回给连接池。\n- **db.Exec()** 会将连接立马返回给连接池，但是它返回的 `Result` 对象会引用该连接，所以，之后可能会再次被使用。\n- **db.Query()** 会传递连接给 `sql.Rows` 对象，直到完全遍历了所有的行或 `Rows` 的 `Close` 方法被调用了，连接才会返回给连接池。\n- **db.QueryRow()** 会传递连接给 `sql.Row` 对象，当该对象的 `Scan` 方法被调用时，连接会返回给连接池。\n- **db.Begin()** 会传递连接给 `sql.Tx` 对象，当该对象的 `Commit` 或 `Rollback` 方法被调用时，该连接会返回给连接池。\n\n大部分时候，我们不需要关心连接不释放问题，它们会自动返回给连接池，只有 Query 方法有点特殊。\n\n注意：如果某个连接有问题（broken connection)，database/sql 内部会进行\n[最多 10 次](http://docs.studygolang.com/src/database/sql/sql.go?s=22080:22097#L824) 的重试，从连接池中获取\n或新开一个连接来服务，因此，你的代码中不需要重试的逻辑。\n\n### 控制连接池\n\nGo1.2.1 之前，没法控制连接池，Go1.2.1 之后，提供了两个方法来控制连接池。\n\n- **db.SetMaxOpenConns(n int)** 设置连接池中最多保存打开多少个数据库连接。注意，它包括在使用的和空闲的。如果某个方法调用需要一个连接，\n但连接池中没有空闲的可用，且打开的连接数达到了该方法设置的最大值，该方法调用将堵塞。默认限制是 0，表示最大打开数没有限制。\n- **db.SetMaxIdleConns(n int)** 设置连接池中能够保持的最大空闲连接的数量。\n[默认值是 2](http://docs.studygolang.com/src/database/sql/sql.go?s=13724:13743#L501) \n\n验证 `MaxIdleConns` 是 2：\n```go\n\tdb, _ := sql.Open(\"mysql\", \"root:@tcp(localhost:3306)/test?charset=utf8\")\n\t\n\t// 去掉注释，可以看看相应的空闲连接是不是变化了\n\t// db.SetMaxIdleConns(3)\n\t\n\tfor i := 0; i < 10; i++ {\n\t\tgo func() {\n\t\t\tdb.Ping()\n\t\t}()\n\t}\n\n\ttime.Sleep(20 * time.Second)\n```\n通过 `show processlist` 命令，可以看到有两个是 `Sleep` 的连接。\n","source":"standards/database/sql.md","raw":"---\ntitle: sql\n---\n\n# sql\n`database/sql` 提供了操作 SQL/SQL-Like 数据库的通用接口，但 Go 标准库并没有提供具体数据库的实现，需要结合第三方的驱动来使用该接口。\n例如 mysql 的驱动：[github.com/go-sql-driver/mysql](https://github.com/go-sql-driver/mysql)。\n\n## 类型\n\n`database/sql` 提供了一些类型：\n- `sql.DB` 类型代表了一个数据库。它并**不代表一个到数据库的具体连接，而是一个能操作的数据库对象**，具体的连接在内部通过连接池来管理，\n对外不暴露。\n- `sql.Rows`、`sql.Row` 和 `sql.Result`，分别用于获取多个多行结果、一行结果和修改数据库影响的行数（或其返回 `last insert id`）。\n- `sql.Stmt` 代表一个语句，如：DDL、DML 等。\n- `sql.Tx` 代表带有特定属性的一个事务。\n\n## sql.DB 的使用\n`sql.DB` 是一个数据库句柄，代表一个具有零到多个底层连接的连接池，它可以安全的被多个 goroutine 同时使用。  \n\n> sql 包会自动创建和释放连接；它也会维护一个闲置连接的连接池。如果数据库具有单连接状态的概念，该状态只有在事务中被观察时才可信。\n一旦调用了 `BD.Begin`，返回的 `Tx` 会绑定到单个连接。当调用事务 `Tx` 的 `Commit` 或 `Rollback` 后，该事务使用的连接会归还到 `DB` 的闲\n置连接池中。连接池的大小可以用 `SetMaxIdleConns` 方法控制。\n\n由于 `DB` 并非一个实际的到数据库的连接，而且可以被多个 goroutine 并发使用，因此，程序中只需要拥有一个全局的实例即可：\n```go\ndb, err := sql.Open(\"mysql\", \"root:@tcp(localhost:3306)/test?charset=utf8\")\nif err != nil {\n    panic(err)\n}\ndefer db.Close()\n```\n通常情况下，`defer db.Close()` 可以不调用，因为 `DB` 句柄通常被多个 goroutine 共享，并长期活跃。当然，如果你确定 DB 只会被使用一次，\n之后不会使用了，应该调用 `Close`。\n\n所以，实际应用时，应该在一个 go 文件中的 `init` 函数中调用 `sql.Open` 初始化全局的 `sql.DB` 对象，供程序中所有需要进\n行数据库操作的地方使用。\n\n前面说过，`sql.DB` 并不是实际的数据库连接，因此，`sql.Open` 函数并没有进行数据库连接。\n\n例如：`db, err := sql.Open(\"mysql\", \"root:@tcp23(localhost233:3306)/test?charset=utf8\")`。虽然这里的 dsn 是错误的，\n但依然 `err == nil`，只有在实际操作数据库（查询、更新等）或调用 `Ping` 时才会报错。\n\n关于 `Open` 函数的参数，第一个是驱动名，为了避免混淆，一般和驱动包名一致，在驱动实现中，会有类似这样的代码：\n```go\nfunc init() {\n    sql.Register(\"mysql\", &MySQLDriver{})\n}\n```\n其中 `mysql` 即是注册的驱动名。由于注册驱动是在 `init` 函数中进行的，这也就是为什么采用 `_ \"github.com/go-sql-driver/mysql\"` \n这种方式引入驱动包。第二个参数是 DSN（数据源名称），这个是和具体驱动相关的，`database/sql` 包并没有规定，具体书写方式参见驱动文档。\n\n### 连接池的工作原理\n\n获取 `DB` 对象后，连接池是空的，第一个连接在需要的时候才会创建：\n```go\ndb, _ := sql.Open(\"mysql\", \"root:@tcp(localhost:3306)/test?charset=utf8\")\nfmt.Println(\"please exec show processlist\")\ntime.Sleep(10 * time.Second)\nfmt.Println(\"please exec show processlist again\")\ndb.Ping()\ntime.Sleep(10 * time.Second)\n```\n在 `Ping` 执行之前和之后，`show processlist` 多了一条记录，即多了一个连接，`Command` 列是 `Sleep`。\n\n连接池的工作方式：当调用一个函数，需要访问数据库时，该函数会请求从连接池中获取一个连接，如果连接池中存在一个空闲连接，它会将该空闲连接给\n该函数；否则，会打开一个新的连接。当该函数结束时，该连接要么返回给连接池，要么传递给某个需要该连接的对象，知道该对象完成时，连接才会返回给连\n接池。相关方法的处理说明（假设 `sql.DB` 的对象是 `db`）：\n\n- **db.Ping()** 会将连接立马返回给连接池。\n- **db.Exec()** 会将连接立马返回给连接池，但是它返回的 `Result` 对象会引用该连接，所以，之后可能会再次被使用。\n- **db.Query()** 会传递连接给 `sql.Rows` 对象，直到完全遍历了所有的行或 `Rows` 的 `Close` 方法被调用了，连接才会返回给连接池。\n- **db.QueryRow()** 会传递连接给 `sql.Row` 对象，当该对象的 `Scan` 方法被调用时，连接会返回给连接池。\n- **db.Begin()** 会传递连接给 `sql.Tx` 对象，当该对象的 `Commit` 或 `Rollback` 方法被调用时，该连接会返回给连接池。\n\n大部分时候，我们不需要关心连接不释放问题，它们会自动返回给连接池，只有 Query 方法有点特殊。\n\n注意：如果某个连接有问题（broken connection)，database/sql 内部会进行\n[最多 10 次](http://docs.studygolang.com/src/database/sql/sql.go?s=22080:22097#L824) 的重试，从连接池中获取\n或新开一个连接来服务，因此，你的代码中不需要重试的逻辑。\n\n### 控制连接池\n\nGo1.2.1 之前，没法控制连接池，Go1.2.1 之后，提供了两个方法来控制连接池。\n\n- **db.SetMaxOpenConns(n int)** 设置连接池中最多保存打开多少个数据库连接。注意，它包括在使用的和空闲的。如果某个方法调用需要一个连接，\n但连接池中没有空闲的可用，且打开的连接数达到了该方法设置的最大值，该方法调用将堵塞。默认限制是 0，表示最大打开数没有限制。\n- **db.SetMaxIdleConns(n int)** 设置连接池中能够保持的最大空闲连接的数量。\n[默认值是 2](http://docs.studygolang.com/src/database/sql/sql.go?s=13724:13743#L501) \n\n验证 `MaxIdleConns` 是 2：\n```go\n\tdb, _ := sql.Open(\"mysql\", \"root:@tcp(localhost:3306)/test?charset=utf8\")\n\t\n\t// 去掉注释，可以看看相应的空闲连接是不是变化了\n\t// db.SetMaxIdleConns(3)\n\t\n\tfor i := 0; i < 10; i++ {\n\t\tgo func() {\n\t\t\tdb.Ping()\n\t\t}()\n\t}\n\n\ttime.Sleep(20 * time.Second)\n```\n通过 `show processlist` 命令，可以看到有两个是 `Sleep` 的连接。\n","date":"2019-10-19T13:40:15.176Z","updated":"2019-10-19T13:40:15.176Z","path":"standards/database/sql.html","comments":1,"layout":"page","_id":"ck1xm14l7000zfcw2cbs2gm2v","content":"<h1 id=\"sql\"><a href=\"#sql\" class=\"headerlink\" title=\"sql\"></a>sql</h1><p><code>database/sql</code> 提供了操作 SQL/SQL-Like 数据库的通用接口，但 Go 标准库并没有提供具体数据库的实现，需要结合第三方的驱动来使用该接口。<br>例如 mysql 的驱动：<a href=\"https://github.com/go-sql-driver/mysql\" target=\"_blank\" rel=\"noopener\">github.com/go-sql-driver/mysql</a>。</p>\n<h2 id=\"类型\"><a href=\"#类型\" class=\"headerlink\" title=\"类型\"></a>类型</h2><p><code>database/sql</code> 提供了一些类型：</p>\n<ul>\n<li><code>sql.DB</code> 类型代表了一个数据库。它并<strong>不代表一个到数据库的具体连接，而是一个能操作的数据库对象</strong>，具体的连接在内部通过连接池来管理，<br>对外不暴露。</li>\n<li><code>sql.Rows</code>、<code>sql.Row</code> 和 <code>sql.Result</code>，分别用于获取多个多行结果、一行结果和修改数据库影响的行数（或其返回 <code>last insert id</code>）。</li>\n<li><code>sql.Stmt</code> 代表一个语句，如：DDL、DML 等。</li>\n<li><code>sql.Tx</code> 代表带有特定属性的一个事务。</li>\n</ul>\n<h2 id=\"sql-DB-的使用\"><a href=\"#sql-DB-的使用\" class=\"headerlink\" title=\"sql.DB 的使用\"></a>sql.DB 的使用</h2><p><code>sql.DB</code> 是一个数据库句柄，代表一个具有零到多个底层连接的连接池，它可以安全的被多个 goroutine 同时使用。  </p>\n<blockquote>\n<p>sql 包会自动创建和释放连接；它也会维护一个闲置连接的连接池。如果数据库具有单连接状态的概念，该状态只有在事务中被观察时才可信。<br>一旦调用了 <code>BD.Begin</code>，返回的 <code>Tx</code> 会绑定到单个连接。当调用事务 <code>Tx</code> 的 <code>Commit</code> 或 <code>Rollback</code> 后，该事务使用的连接会归还到 <code>DB</code> 的闲<br>置连接池中。连接池的大小可以用 <code>SetMaxIdleConns</code> 方法控制。</p>\n</blockquote>\n<p>由于 <code>DB</code> 并非一个实际的到数据库的连接，而且可以被多个 goroutine 并发使用，因此，程序中只需要拥有一个全局的实例即可：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db, err := sql.Open(<span class=\"string\">\"mysql\"</span>, <span class=\"string\">\"root:@tcp(localhost:3306)/test?charset=utf8\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">panic</span>(err)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">defer</span> db.Close()</span><br></pre></td></tr></table></figure></p>\n<p>通常情况下，<code>defer db.Close()</code> 可以不调用，因为 <code>DB</code> 句柄通常被多个 goroutine 共享，并长期活跃。当然，如果你确定 DB 只会被使用一次，<br>之后不会使用了，应该调用 <code>Close</code>。</p>\n<p>所以，实际应用时，应该在一个 go 文件中的 <code>init</code> 函数中调用 <code>sql.Open</code> 初始化全局的 <code>sql.DB</code> 对象，供程序中所有需要进<br>行数据库操作的地方使用。</p>\n<p>前面说过，<code>sql.DB</code> 并不是实际的数据库连接，因此，<code>sql.Open</code> 函数并没有进行数据库连接。</p>\n<p>例如：<code>db, err := sql.Open(&quot;mysql&quot;, &quot;root:@tcp23(localhost233:3306)/test?charset=utf8&quot;)</code>。虽然这里的 dsn 是错误的，<br>但依然 <code>err == nil</code>，只有在实际操作数据库（查询、更新等）或调用 <code>Ping</code> 时才会报错。</p>\n<p>关于 <code>Open</code> 函数的参数，第一个是驱动名，为了避免混淆，一般和驱动包名一致，在驱动实现中，会有类似这样的代码：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">init</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    sql.Register(<span class=\"string\">\"mysql\"</span>, &amp;MySQLDriver&#123;&#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>其中 <code>mysql</code> 即是注册的驱动名。由于注册驱动是在 <code>init</code> 函数中进行的，这也就是为什么采用 <code>_ &quot;github.com/go-sql-driver/mysql&quot;</code><br>这种方式引入驱动包。第二个参数是 DSN（数据源名称），这个是和具体驱动相关的，<code>database/sql</code> 包并没有规定，具体书写方式参见驱动文档。</p>\n<h3 id=\"连接池的工作原理\"><a href=\"#连接池的工作原理\" class=\"headerlink\" title=\"连接池的工作原理\"></a>连接池的工作原理</h3><p>获取 <code>DB</code> 对象后，连接池是空的，第一个连接在需要的时候才会创建：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db, _ := sql.Open(<span class=\"string\">\"mysql\"</span>, <span class=\"string\">\"root:@tcp(localhost:3306)/test?charset=utf8\"</span>)</span><br><span class=\"line\">fmt.Println(<span class=\"string\">\"please exec show processlist\"</span>)</span><br><span class=\"line\">time.Sleep(<span class=\"number\">10</span> * time.Second)</span><br><span class=\"line\">fmt.Println(<span class=\"string\">\"please exec show processlist again\"</span>)</span><br><span class=\"line\">db.Ping()</span><br><span class=\"line\">time.Sleep(<span class=\"number\">10</span> * time.Second)</span><br></pre></td></tr></table></figure></p>\n<p>在 <code>Ping</code> 执行之前和之后，<code>show processlist</code> 多了一条记录，即多了一个连接，<code>Command</code> 列是 <code>Sleep</code>。</p>\n<p>连接池的工作方式：当调用一个函数，需要访问数据库时，该函数会请求从连接池中获取一个连接，如果连接池中存在一个空闲连接，它会将该空闲连接给<br>该函数；否则，会打开一个新的连接。当该函数结束时，该连接要么返回给连接池，要么传递给某个需要该连接的对象，知道该对象完成时，连接才会返回给连<br>接池。相关方法的处理说明（假设 <code>sql.DB</code> 的对象是 <code>db</code>）：</p>\n<ul>\n<li><strong>db.Ping()</strong> 会将连接立马返回给连接池。</li>\n<li><strong>db.Exec()</strong> 会将连接立马返回给连接池，但是它返回的 <code>Result</code> 对象会引用该连接，所以，之后可能会再次被使用。</li>\n<li><strong>db.Query()</strong> 会传递连接给 <code>sql.Rows</code> 对象，直到完全遍历了所有的行或 <code>Rows</code> 的 <code>Close</code> 方法被调用了，连接才会返回给连接池。</li>\n<li><strong>db.QueryRow()</strong> 会传递连接给 <code>sql.Row</code> 对象，当该对象的 <code>Scan</code> 方法被调用时，连接会返回给连接池。</li>\n<li><strong>db.Begin()</strong> 会传递连接给 <code>sql.Tx</code> 对象，当该对象的 <code>Commit</code> 或 <code>Rollback</code> 方法被调用时，该连接会返回给连接池。</li>\n</ul>\n<p>大部分时候，我们不需要关心连接不释放问题，它们会自动返回给连接池，只有 Query 方法有点特殊。</p>\n<p>注意：如果某个连接有问题（broken connection)，database/sql 内部会进行<br><a href=\"http://docs.studygolang.com/src/database/sql/sql.go?s=22080:22097#L824\" target=\"_blank\" rel=\"noopener\">最多 10 次</a> 的重试，从连接池中获取<br>或新开一个连接来服务，因此，你的代码中不需要重试的逻辑。</p>\n<h3 id=\"控制连接池\"><a href=\"#控制连接池\" class=\"headerlink\" title=\"控制连接池\"></a>控制连接池</h3><p>Go1.2.1 之前，没法控制连接池，Go1.2.1 之后，提供了两个方法来控制连接池。</p>\n<ul>\n<li><strong>db.SetMaxOpenConns(n int)</strong> 设置连接池中最多保存打开多少个数据库连接。注意，它包括在使用的和空闲的。如果某个方法调用需要一个连接，<br>但连接池中没有空闲的可用，且打开的连接数达到了该方法设置的最大值，该方法调用将堵塞。默认限制是 0，表示最大打开数没有限制。</li>\n<li><strong>db.SetMaxIdleConns(n int)</strong> 设置连接池中能够保持的最大空闲连接的数量。<br><a href=\"http://docs.studygolang.com/src/database/sql/sql.go?s=13724:13743#L501\" target=\"_blank\" rel=\"noopener\">默认值是 2</a> </li>\n</ul>\n<p>验证 <code>MaxIdleConns</code> 是 2：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db, _ := sql.Open(<span class=\"string\">\"mysql\"</span>, <span class=\"string\">\"root:@tcp(localhost:3306)/test?charset=utf8\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 去掉注释，可以看看相应的空闲连接是不是变化了</span></span><br><span class=\"line\"><span class=\"comment\">// db.SetMaxIdleConns(3)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++ &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\tdb.Ping()</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">time.Sleep(<span class=\"number\">20</span> * time.Second)</span><br></pre></td></tr></table></figure></p>\n<p>通过 <code>show processlist</code> 命令，可以看到有两个是 <code>Sleep</code> 的连接。</p>\n","site":{"data":{"navigation":{"logo":{"text":"Golang Learn","type":"link","path":"index.html"},"main":[{"text":"Golang 基础","type":"label"},{"text":"Go 环境配置","type":"link","path":"basic/env_config.html"},{"text":"包","type":"link","path":"basic/package.html"},{"text":"基础数据类型","type":"link","path":"basic/basic_data.html"},{"text":"变量","type":"link","path":"basic/var.html"},{"text":"常量","type":"link","path":"basic/constant.html"},{"text":"控制语句","type":"link","path":"basic/flow.html"},{"text":"运算符","type":"link","path":"basic/operator.html"},{"text":"作用域","type":"link","path":"basic/scope.html"},{"text":"指针","type":"link","path":"basic/pointer.html"},{"text":"数组","type":"link","path":"basic/array.html"},{"text":"切片","type":"link","path":"basic/slice.html"},{"text":"字典","type":"link","path":"basic/map.html"},{"text":"函数","type":"link","path":"basic/function.html"},{"text":"结构体","type":"link","path":"basic/struct.html"},{"text":"接口","type":"link","path":"basic/interface.html"},{"text":"面向对象","type":"link","path":"basic/oop.html"},{"text":"错误","type":"link","path":"basic/error.html"},{"text":"序列化","type":"link","path":"basic/json.html"},{"text":"反射","type":"link","path":"basic/reflect.html"},{"text":"测试","type":"link","path":"basic/test.html"},{"text":"并发编程","type":"label"},{"text":"goroutine","type":"link","path":"concurrent/goroutine.html"},{"text":"channel","type":"link","path":"concurrent/channel.html"},{"text":"同步和锁","type":"link","path":"concurrent/sync_lock.html"},{"text":"内存分配","type":"label"},{"text":"内存分配","type":"link","path":"advance/mm.html"},{"text":"垃圾回收","type":"label"},{"text":"垃圾回收","type":"link","path":"advance/gc.html"},{"text":"标准库","type":"label"},{"text":"fmt","type":"link","path":"standards/io/fmt.html"},{"text":"io","type":"link","path":"standards/io/io.html"},{"text":"ioutil","type":"link","path":"standards/io/ioutil.html"},{"text":"bufio","type":"link","path":"standards/io/bufio.html"},{"text":"os","type":"link","path":"standards/os/os.html"},{"text":"filepath","type":"link","path":"standards/os/filepath.html"},{"text":"strings","type":"link","path":"standards/text/strings.html"},{"text":"strconv","type":"link","path":"standards/text/strconv.html"},{"text":"unicode","type":"link","path":"standards/text/unicode.html"},{"text":"log","type":"link","path":"standards/log.html"},{"text":"time","type":"link","path":"standards/time.html"},{"text":"http","type":"link","path":"standards/net/http.html"},{"text":"math","type":"link","path":"standards/data/math.html"},{"text":"sort","type":"link","path":"standards/data/sort.html"},{"text":"big","type":"link","path":"standards/data/big.html"},{"text":"container","type":"link","path":"standards/data/container.html"},{"text":"sql","type":"link","path":"standards/database/sql.html"},{"text":"THEME","type":"label"},{"text":"使用文档主题","type":"link","path":"theme/theme-usage.html"},{"text":"SUPPORT AND FEEDBACK","type":"label"},{"text":"Raise an Issue on Github","type":"link","path":"https://github.com/shipengqi/golang-learn/issues/new"}]}}},"excerpt":"","more":"<h1 id=\"sql\"><a href=\"#sql\" class=\"headerlink\" title=\"sql\"></a>sql</h1><p><code>database/sql</code> 提供了操作 SQL/SQL-Like 数据库的通用接口，但 Go 标准库并没有提供具体数据库的实现，需要结合第三方的驱动来使用该接口。<br>例如 mysql 的驱动：<a href=\"https://github.com/go-sql-driver/mysql\" target=\"_blank\" rel=\"noopener\">github.com/go-sql-driver/mysql</a>。</p>\n<h2 id=\"类型\"><a href=\"#类型\" class=\"headerlink\" title=\"类型\"></a>类型</h2><p><code>database/sql</code> 提供了一些类型：</p>\n<ul>\n<li><code>sql.DB</code> 类型代表了一个数据库。它并<strong>不代表一个到数据库的具体连接，而是一个能操作的数据库对象</strong>，具体的连接在内部通过连接池来管理，<br>对外不暴露。</li>\n<li><code>sql.Rows</code>、<code>sql.Row</code> 和 <code>sql.Result</code>，分别用于获取多个多行结果、一行结果和修改数据库影响的行数（或其返回 <code>last insert id</code>）。</li>\n<li><code>sql.Stmt</code> 代表一个语句，如：DDL、DML 等。</li>\n<li><code>sql.Tx</code> 代表带有特定属性的一个事务。</li>\n</ul>\n<h2 id=\"sql-DB-的使用\"><a href=\"#sql-DB-的使用\" class=\"headerlink\" title=\"sql.DB 的使用\"></a>sql.DB 的使用</h2><p><code>sql.DB</code> 是一个数据库句柄，代表一个具有零到多个底层连接的连接池，它可以安全的被多个 goroutine 同时使用。  </p>\n<blockquote>\n<p>sql 包会自动创建和释放连接；它也会维护一个闲置连接的连接池。如果数据库具有单连接状态的概念，该状态只有在事务中被观察时才可信。<br>一旦调用了 <code>BD.Begin</code>，返回的 <code>Tx</code> 会绑定到单个连接。当调用事务 <code>Tx</code> 的 <code>Commit</code> 或 <code>Rollback</code> 后，该事务使用的连接会归还到 <code>DB</code> 的闲<br>置连接池中。连接池的大小可以用 <code>SetMaxIdleConns</code> 方法控制。</p>\n</blockquote>\n<p>由于 <code>DB</code> 并非一个实际的到数据库的连接，而且可以被多个 goroutine 并发使用，因此，程序中只需要拥有一个全局的实例即可：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db, err := sql.Open(<span class=\"string\">\"mysql\"</span>, <span class=\"string\">\"root:@tcp(localhost:3306)/test?charset=utf8\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">panic</span>(err)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">defer</span> db.Close()</span><br></pre></td></tr></table></figure></p>\n<p>通常情况下，<code>defer db.Close()</code> 可以不调用，因为 <code>DB</code> 句柄通常被多个 goroutine 共享，并长期活跃。当然，如果你确定 DB 只会被使用一次，<br>之后不会使用了，应该调用 <code>Close</code>。</p>\n<p>所以，实际应用时，应该在一个 go 文件中的 <code>init</code> 函数中调用 <code>sql.Open</code> 初始化全局的 <code>sql.DB</code> 对象，供程序中所有需要进<br>行数据库操作的地方使用。</p>\n<p>前面说过，<code>sql.DB</code> 并不是实际的数据库连接，因此，<code>sql.Open</code> 函数并没有进行数据库连接。</p>\n<p>例如：<code>db, err := sql.Open(&quot;mysql&quot;, &quot;root:@tcp23(localhost233:3306)/test?charset=utf8&quot;)</code>。虽然这里的 dsn 是错误的，<br>但依然 <code>err == nil</code>，只有在实际操作数据库（查询、更新等）或调用 <code>Ping</code> 时才会报错。</p>\n<p>关于 <code>Open</code> 函数的参数，第一个是驱动名，为了避免混淆，一般和驱动包名一致，在驱动实现中，会有类似这样的代码：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">init</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    sql.Register(<span class=\"string\">\"mysql\"</span>, &amp;MySQLDriver&#123;&#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>其中 <code>mysql</code> 即是注册的驱动名。由于注册驱动是在 <code>init</code> 函数中进行的，这也就是为什么采用 <code>_ &quot;github.com/go-sql-driver/mysql&quot;</code><br>这种方式引入驱动包。第二个参数是 DSN（数据源名称），这个是和具体驱动相关的，<code>database/sql</code> 包并没有规定，具体书写方式参见驱动文档。</p>\n<h3 id=\"连接池的工作原理\"><a href=\"#连接池的工作原理\" class=\"headerlink\" title=\"连接池的工作原理\"></a>连接池的工作原理</h3><p>获取 <code>DB</code> 对象后，连接池是空的，第一个连接在需要的时候才会创建：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db, _ := sql.Open(<span class=\"string\">\"mysql\"</span>, <span class=\"string\">\"root:@tcp(localhost:3306)/test?charset=utf8\"</span>)</span><br><span class=\"line\">fmt.Println(<span class=\"string\">\"please exec show processlist\"</span>)</span><br><span class=\"line\">time.Sleep(<span class=\"number\">10</span> * time.Second)</span><br><span class=\"line\">fmt.Println(<span class=\"string\">\"please exec show processlist again\"</span>)</span><br><span class=\"line\">db.Ping()</span><br><span class=\"line\">time.Sleep(<span class=\"number\">10</span> * time.Second)</span><br></pre></td></tr></table></figure></p>\n<p>在 <code>Ping</code> 执行之前和之后，<code>show processlist</code> 多了一条记录，即多了一个连接，<code>Command</code> 列是 <code>Sleep</code>。</p>\n<p>连接池的工作方式：当调用一个函数，需要访问数据库时，该函数会请求从连接池中获取一个连接，如果连接池中存在一个空闲连接，它会将该空闲连接给<br>该函数；否则，会打开一个新的连接。当该函数结束时，该连接要么返回给连接池，要么传递给某个需要该连接的对象，知道该对象完成时，连接才会返回给连<br>接池。相关方法的处理说明（假设 <code>sql.DB</code> 的对象是 <code>db</code>）：</p>\n<ul>\n<li><strong>db.Ping()</strong> 会将连接立马返回给连接池。</li>\n<li><strong>db.Exec()</strong> 会将连接立马返回给连接池，但是它返回的 <code>Result</code> 对象会引用该连接，所以，之后可能会再次被使用。</li>\n<li><strong>db.Query()</strong> 会传递连接给 <code>sql.Rows</code> 对象，直到完全遍历了所有的行或 <code>Rows</code> 的 <code>Close</code> 方法被调用了，连接才会返回给连接池。</li>\n<li><strong>db.QueryRow()</strong> 会传递连接给 <code>sql.Row</code> 对象，当该对象的 <code>Scan</code> 方法被调用时，连接会返回给连接池。</li>\n<li><strong>db.Begin()</strong> 会传递连接给 <code>sql.Tx</code> 对象，当该对象的 <code>Commit</code> 或 <code>Rollback</code> 方法被调用时，该连接会返回给连接池。</li>\n</ul>\n<p>大部分时候，我们不需要关心连接不释放问题，它们会自动返回给连接池，只有 Query 方法有点特殊。</p>\n<p>注意：如果某个连接有问题（broken connection)，database/sql 内部会进行<br><a href=\"http://docs.studygolang.com/src/database/sql/sql.go?s=22080:22097#L824\" target=\"_blank\" rel=\"noopener\">最多 10 次</a> 的重试，从连接池中获取<br>或新开一个连接来服务，因此，你的代码中不需要重试的逻辑。</p>\n<h3 id=\"控制连接池\"><a href=\"#控制连接池\" class=\"headerlink\" title=\"控制连接池\"></a>控制连接池</h3><p>Go1.2.1 之前，没法控制连接池，Go1.2.1 之后，提供了两个方法来控制连接池。</p>\n<ul>\n<li><strong>db.SetMaxOpenConns(n int)</strong> 设置连接池中最多保存打开多少个数据库连接。注意，它包括在使用的和空闲的。如果某个方法调用需要一个连接，<br>但连接池中没有空闲的可用，且打开的连接数达到了该方法设置的最大值，该方法调用将堵塞。默认限制是 0，表示最大打开数没有限制。</li>\n<li><strong>db.SetMaxIdleConns(n int)</strong> 设置连接池中能够保持的最大空闲连接的数量。<br><a href=\"http://docs.studygolang.com/src/database/sql/sql.go?s=13724:13743#L501\" target=\"_blank\" rel=\"noopener\">默认值是 2</a> </li>\n</ul>\n<p>验证 <code>MaxIdleConns</code> 是 2：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db, _ := sql.Open(<span class=\"string\">\"mysql\"</span>, <span class=\"string\">\"root:@tcp(localhost:3306)/test?charset=utf8\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 去掉注释，可以看看相应的空闲连接是不是变化了</span></span><br><span class=\"line\"><span class=\"comment\">// db.SetMaxIdleConns(3)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++ &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\tdb.Ping()</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">time.Sleep(<span class=\"number\">20</span> * time.Second)</span><br></pre></td></tr></table></figure></p>\n<p>通过 <code>show processlist</code> 命令，可以看到有两个是 <code>Sleep</code> 的连接。</p>\n"},{"title":"fmt 包","_content":"\n# fmt 包\n`fmt` 包实现了格式化 I/O 函数，有关格式化输入输出的方法有两大类：`Scan` 和 `Print`。\n\n`print.go` 文件中定义了如下函数：\n\n## Print\n```Go\n// 普通输出，不带换行符\nfunc Print(a ...interface{}) (n int,  err error)\nfunc Fprint(w io.Writer,  a ...interface{}) (n int,  err error)\nfunc Sprint(a ...interface{}) string\n\n// 输出内容时会加上换行符\nfunc Println(a ...interface{}) (n int,  err error)\nfunc Fprintln(w io.Writer,  a ...interface{}) (n int,  err error)\nfunc Sprintln(a ...interface{}) string\n\n// 按照指定格式化文本输出内容\nfunc Printf(format string,  a ...interface{}) (n int,  err error)\nfunc Fprintf(w io.Writer,  format string,  a ...interface{}) (n int,  err error)\nfunc Sprintf(format string,  a ...interface{}) string\n```\n\n如果前缀是 \"F\", 则指定了 `io.Writer`\n如果前缀是 \"S\", 则是输出到字符串\n```\n// 输出内容到标准输出 os.Stdout\nPrint\nPrintf\nPrintln\n// 输出内容到指定的 io.Writer\nFprint\nFprintf\nFprintln\n// 输出内容到字符串，并返回\nSprint\nSprintf\nSprintln\n```\n\n## Scan\n`scan.go` 文件中定义了如下函数：\n```go\n// 读取内容时不关注换行\nfunc Scan(a ...interface{}) (n int,  err error)\nfunc Fscan(r io.Reader,  a ...interface{}) (n int,  err error)\nfunc Sscan(str string,  a ...interface{}) (n int,  err error)\n\n// 读取到换行时停止，并要求一次提供一行所有条目\nfunc Scanln(a ...interface{}) (n int,  err error)\nfunc Fscanln(r io.Reader,  a ...interface{}) (n int,  err error)\nfunc Sscanln(str string,  a ...interface{}) (n int,  err error) \n\n// 根据格式化文本读取\nfunc Scanf(format string,  a ...interface{}) (n int,  err error)\nfunc Fscanf(r io.Reader,  format string,  a ...interface{}) (n int,  err error)\nfunc Sscanf(str string,  format string,  a ...interface{}) (n int,  err error)\n```\n\n如果前缀是 \"F\", 则指定了 `io.Reader`\n如果前缀是 \"S\", 则是从字符串读取\n```\n// 从标准输入os.Stdin读取文本\nScan\nScanf\nScanln\n// 从指定的 io.Reader 接口读取文本\nFscan\nFscanf\nFscanln\n// 从一个参数字符串读取文本\nSscan\nSscanf\nSscanln\n```\n\n## 占位符\n**普通占位符**\n\t\n\t占位符\t\t\t\t\t\t说明\t\t\t\t\t\t举例\t\t\t\t\t\t\t\t\t\t输出\n\t%v\t\t相应值的默认格式。\t\t\t\t\t\t\t\tPrintf(\"%v\", site)，Printf(\"%+v\", site)\t{studygolang}，{Name:studygolang}\n\t\t\t在打印结构体时，“加号”标记（%+v）会添加字段名\n\t%#v\t\t相应值的 Go 语法表示\t\t\t\t\t\t\tPrintf(\"#v\", site)\t\t\t\t\t\tmain.Website{Name:\"studygolang\"}\n\t%T\t\t相应值的类型的 Go 语法表示\t\t\t\t\t\tPrintf(\"%T\", site)\t\t\t\t\t\tmain.Website\n\t%%\t\t字面上的百分号，并非值的占位符\t\t\t\t\tPrintf(\"%%\")\t\t\t\t\t\t\t%\n\n**布尔占位符**\n\n\t占位符\t\t\t\t\t\t说明\t\t\t\t\t\t举例\t\t\t\t\t\t\t\t\t\t输出\n\t%t\t\t单词 true 或 false。\t\t\t\t\t\t\tPrintf(\"%t\", true)\t\t\t\t\t\ttrue\n\n**整数占位符**\n\n\t占位符\t\t\t\t\t\t说明\t\t\t\t\t\t举例\t\t\t\t\t\t\t\t\t输出\n\t%b\t\t二进制表示\t\t\t\t\t\t\t\t\tPrintf(\"%b\", 5)\t\t\t\t\t\t101\n\t%c\t\t相应Unicode码点所表示的字符\t\t\t\t\tPrintf(\"%c\", 0x4E2D)\t\t\t\t中\n\t%d\t\t十进制表示\t\t\t\t\t\t\t\t\tPrintf(\"%d\", 0x12)\t\t\t\t\t18\n\t%o\t\t八进制表示\t\t\t\t\t\t\t\t\tPrintf(\"%d\", 10)\t\t\t\t\t12\n\t%q\t\t单引号围绕的字符字面值，由 Go 语法安全地转义\t\tPrintf(\"%q\", 0x4E2D)\t\t\t\t'中'\n\t%x\t\t十六进制表示，字母形式为小写 a-f\t\t\t\t    Printf(\"%x\", 13)\t\t\t\t\td\n\t%X\t\t十六进制表示，字母形式为大写 A-F\t\t\t\t    Printf(\"%x\", 13)\t\t\t\t\tD\n\t%U\t\tUnicode格式：U+1234，等同于 \"U+%04X\"\t\t\tPrintf(\"%U\", 0x4E2D)\t\t\t\tU+4E2D\n\n**浮点数和复数的组成部分（实部和虚部）**\n\n\t占位符\t\t\t\t\t\t说明\t\t\t\t\t\t\t\t\t\t\t\t举例\t\t\t\t\t\t\t\t\t输出\n\t%b\t\t无小数部分的，指数为二的幂的科学计数法，与 strconv.FormatFloat\t\n\t\t\t的 'b' 转换格式一致。例如 -123456p-78\n\t%e\t\t科学计数法，例如 -1234.456e+78\t\t\t\t\t\t\t\t\tPrintf(\"%e\", 10.2)\t\t\t\t\t\t\t1.020000e+01\n\t%E\t\t科学计数法，例如 -1234.456E+78\t\t\t\t\t\t\t\t\tPrintf(\"%e\", 10.2)\t\t\t\t\t\t\t1.020000E+01\n\t%f\t\t有小数点而无指数，例如 123.456\t\t\t\t\t\t\t\t\tPrintf(\"%f\", 10.2)\t\t\t\t\t\t\t10.200000\n\t%g\t\t根据情况选择 %e 或 %f 以产生更紧凑的（无末尾的0）输出\t\t\t\tPrintf(\"%g\", 10.20)\t\t\t\t\t\t\t10.2\n\t%G\t\t根据情况选择 %E 或 %f 以产生更紧凑的（无末尾的0）输出\t\t\t\tPrintf(\"%G\", 10.20+2i)\t\t\t\t\t\t(10.2+2i)\n\n**字符串与字节切片**\n\n\t占位符\t\t\t\t\t\t说明\t\t\t\t\t\t\t\t\t\t\t\t举例\t\t\t\t\t\t\t\t\t输出\n\t%s\t\t输出字符串表示（string 类型或 []byte)\t\t\t\t\t\t\tPrintf(\"%s\", []byte (\"Hello world\"))\t\tHello world\n\t%q\t\t双引号围绕的字符串，由 Go 语法安全地转义\t\t\t\t\t\t\tPrintf(\"%q\", \"Hello world\")\t\t\t\t    \"Hello world\"\n\t%x\t\t十六进制，小写字母，每字节两个字符\t\t\t\t\t\t\t\tPrintf(\"%x\", \"golang\")\t\t\t\t\t\t676f6c616e67\n\t%X\t\t十六进制，大写字母，每字节两个字符\t\t\t\t\t\t\t\tPrintf(\"%X\", \"golang\")\t\t\t\t\t\t676F6C616E67\n\n**指针**\n\n\t占位符\t\t\t\t\t\t说明\t\t\t\t\t\t\t\t\t\t\t\t举例\t\t\t\t\t\t\t\t\t输出\n\t%p\t\t十六进制表示，前缀 0x\t\t\t\t\t\t\t\t\t\t\tPrintf(\"%p\", &site)\t\t\t\t\t\t\t0x4f57f0\n\t\n**其它标记**\n\n\t占位符\t\t\t\t\t\t说明\t\t\t\t\t\t\t\t\t\t\t\t举例\t\t\t\t\t\t\t\t\t输出\n\t+\t\t总打印数值的正负号；对于%q（%+q）保证只输出 ASCII 编码的字符。\t\t\tPrintf(\"%+q\", \"中文\")\t\t\t\t\t\"\\u4e2d\\u6587\"\n\t-\t\t在右侧而非左侧填充空格（左对齐该区域）\n\t#\t\t备用格式：为八进制添加前导 0（%#o），为十六进制添加前导 0x（%#x）或\tPrintf(\"%#U\", '中')\t\t\t\t\t\tU+4E2D '中'\n\t\t\t0X（%#X），为 %p（%#p）去掉前导 0x；如果可能的话，%q（%#q）会打印原始\n\t\t\t（即反引号围绕的）字符串；如果是可打印字符，%U（%#U）会写出该字符的\n\t\t\tUnicode 编码形式（如字符 x 会被打印成 U+0078 'x'）。\n\t' '\t\t（空格）为数值中省略的正负号留出空白（% d）；\n\t\t\t以十六进制（% x, % X）打印字符串或切片时，在字节之间用空格隔开\n\t0\t\t填充前导的0而非空格；对于数字，这会将填充移到正负号之后\n\t\n示例：\n```go\ntype user struct {\n\tname string\n}\n\nfunc main() {\n\tu := user{\"tang\"}\n\tfmt.Printf(\"% + v\\n\", u)     // 格式化输出结构               {name: tang}\n\tfmt.Printf(\"%#v\\n\", u)       // 输出值的 Go 语言表示方法       main.user{name: \"tang\"}\n\tfmt.Printf(\"%T\\n\", u)        // 输出值的类型的 Go 语言表示     main.user\n\tfmt.Printf(\"%t\\n\", true)     // 输出值的 true 或 false   true\n\tfmt.Printf(\"%b\\n\", 1024)     // 二进制表示               10000000000\n\tfmt.Printf(\"%c\\n\", 11111111) // 数值对应的 Unicode 编码字符\n\tfmt.Printf(\"%d\\n\", 10)       // 十进制表示                 10\n\tfmt.Printf(\"%o\\n\", 8)        // 八进制表示                 10\n\tfmt.Printf(\"%q\\n\", 22)       // 转化为十六进制并附上单引号    '\\x16'\n\tfmt.Printf(\"%x\\n\", 1223)     // 十六进制表示，用 a-f 表示      4c7\n\tfmt.Printf(\"%X\\n\", 1223)     // 十六进制表示，用 A-F 表示      4c7\n\tfmt.Printf(\"%U\\n\", 1233)     // Unicode 表示\n\tfmt.Printf(\"%b\\n\", 12.34)    // 无小数部分，两位指数的科学计数法 6946802425218990p-49\n\tfmt.Printf(\"%e\\n\", 12.345)   // 科学计数法，e 表示   1.234500e+01\n\tfmt.Printf(\"%E\\n\", 12.34455) // 科学计数法，E 表示   1.234455E+01\n\tfmt.Printf(\"%f\\n\", 12.3456)  // 有小数部分，无指数部分   12.345600\n\tfmt.Printf(\"%g\\n\", 12.3456)  // 根据实际情况采用 %e 或 %f 输出  12.3456\n\tfmt.Printf(\"%G\\n\", 12.3456)  // 根据实际情况采用 %E 或 %f 输出  12.3456\n\tfmt.Printf(\"%s\\n\", \"wqdew\")  // 直接输出字符串或者 []byte         wqdew\n\tfmt.Printf(\"%q\\n\", \"dedede\") // 双引号括起来的字符串             \"dedede\"\n\tfmt.Printf(\"%x\\n\", \"abczxc\") // 每个字节用两字节十六进制表示，a-f 表示  6162637a7863\n\tfmt.Printf(\"%X\\n\", \"asdzxc\") // 每个字节用两字节十六进制表示，A-F 表示  6173647A7863\n\tfmt.Printf(\"%p\\n\", 0x123)    // 0x 开头的十六进制数表示\n}\n```","source":"standards/io/fmt.md","raw":"---\ntitle: fmt 包\n---\n\n# fmt 包\n`fmt` 包实现了格式化 I/O 函数，有关格式化输入输出的方法有两大类：`Scan` 和 `Print`。\n\n`print.go` 文件中定义了如下函数：\n\n## Print\n```Go\n// 普通输出，不带换行符\nfunc Print(a ...interface{}) (n int,  err error)\nfunc Fprint(w io.Writer,  a ...interface{}) (n int,  err error)\nfunc Sprint(a ...interface{}) string\n\n// 输出内容时会加上换行符\nfunc Println(a ...interface{}) (n int,  err error)\nfunc Fprintln(w io.Writer,  a ...interface{}) (n int,  err error)\nfunc Sprintln(a ...interface{}) string\n\n// 按照指定格式化文本输出内容\nfunc Printf(format string,  a ...interface{}) (n int,  err error)\nfunc Fprintf(w io.Writer,  format string,  a ...interface{}) (n int,  err error)\nfunc Sprintf(format string,  a ...interface{}) string\n```\n\n如果前缀是 \"F\", 则指定了 `io.Writer`\n如果前缀是 \"S\", 则是输出到字符串\n```\n// 输出内容到标准输出 os.Stdout\nPrint\nPrintf\nPrintln\n// 输出内容到指定的 io.Writer\nFprint\nFprintf\nFprintln\n// 输出内容到字符串，并返回\nSprint\nSprintf\nSprintln\n```\n\n## Scan\n`scan.go` 文件中定义了如下函数：\n```go\n// 读取内容时不关注换行\nfunc Scan(a ...interface{}) (n int,  err error)\nfunc Fscan(r io.Reader,  a ...interface{}) (n int,  err error)\nfunc Sscan(str string,  a ...interface{}) (n int,  err error)\n\n// 读取到换行时停止，并要求一次提供一行所有条目\nfunc Scanln(a ...interface{}) (n int,  err error)\nfunc Fscanln(r io.Reader,  a ...interface{}) (n int,  err error)\nfunc Sscanln(str string,  a ...interface{}) (n int,  err error) \n\n// 根据格式化文本读取\nfunc Scanf(format string,  a ...interface{}) (n int,  err error)\nfunc Fscanf(r io.Reader,  format string,  a ...interface{}) (n int,  err error)\nfunc Sscanf(str string,  format string,  a ...interface{}) (n int,  err error)\n```\n\n如果前缀是 \"F\", 则指定了 `io.Reader`\n如果前缀是 \"S\", 则是从字符串读取\n```\n// 从标准输入os.Stdin读取文本\nScan\nScanf\nScanln\n// 从指定的 io.Reader 接口读取文本\nFscan\nFscanf\nFscanln\n// 从一个参数字符串读取文本\nSscan\nSscanf\nSscanln\n```\n\n## 占位符\n**普通占位符**\n\t\n\t占位符\t\t\t\t\t\t说明\t\t\t\t\t\t举例\t\t\t\t\t\t\t\t\t\t输出\n\t%v\t\t相应值的默认格式。\t\t\t\t\t\t\t\tPrintf(\"%v\", site)，Printf(\"%+v\", site)\t{studygolang}，{Name:studygolang}\n\t\t\t在打印结构体时，“加号”标记（%+v）会添加字段名\n\t%#v\t\t相应值的 Go 语法表示\t\t\t\t\t\t\tPrintf(\"#v\", site)\t\t\t\t\t\tmain.Website{Name:\"studygolang\"}\n\t%T\t\t相应值的类型的 Go 语法表示\t\t\t\t\t\tPrintf(\"%T\", site)\t\t\t\t\t\tmain.Website\n\t%%\t\t字面上的百分号，并非值的占位符\t\t\t\t\tPrintf(\"%%\")\t\t\t\t\t\t\t%\n\n**布尔占位符**\n\n\t占位符\t\t\t\t\t\t说明\t\t\t\t\t\t举例\t\t\t\t\t\t\t\t\t\t输出\n\t%t\t\t单词 true 或 false。\t\t\t\t\t\t\tPrintf(\"%t\", true)\t\t\t\t\t\ttrue\n\n**整数占位符**\n\n\t占位符\t\t\t\t\t\t说明\t\t\t\t\t\t举例\t\t\t\t\t\t\t\t\t输出\n\t%b\t\t二进制表示\t\t\t\t\t\t\t\t\tPrintf(\"%b\", 5)\t\t\t\t\t\t101\n\t%c\t\t相应Unicode码点所表示的字符\t\t\t\t\tPrintf(\"%c\", 0x4E2D)\t\t\t\t中\n\t%d\t\t十进制表示\t\t\t\t\t\t\t\t\tPrintf(\"%d\", 0x12)\t\t\t\t\t18\n\t%o\t\t八进制表示\t\t\t\t\t\t\t\t\tPrintf(\"%d\", 10)\t\t\t\t\t12\n\t%q\t\t单引号围绕的字符字面值，由 Go 语法安全地转义\t\tPrintf(\"%q\", 0x4E2D)\t\t\t\t'中'\n\t%x\t\t十六进制表示，字母形式为小写 a-f\t\t\t\t    Printf(\"%x\", 13)\t\t\t\t\td\n\t%X\t\t十六进制表示，字母形式为大写 A-F\t\t\t\t    Printf(\"%x\", 13)\t\t\t\t\tD\n\t%U\t\tUnicode格式：U+1234，等同于 \"U+%04X\"\t\t\tPrintf(\"%U\", 0x4E2D)\t\t\t\tU+4E2D\n\n**浮点数和复数的组成部分（实部和虚部）**\n\n\t占位符\t\t\t\t\t\t说明\t\t\t\t\t\t\t\t\t\t\t\t举例\t\t\t\t\t\t\t\t\t输出\n\t%b\t\t无小数部分的，指数为二的幂的科学计数法，与 strconv.FormatFloat\t\n\t\t\t的 'b' 转换格式一致。例如 -123456p-78\n\t%e\t\t科学计数法，例如 -1234.456e+78\t\t\t\t\t\t\t\t\tPrintf(\"%e\", 10.2)\t\t\t\t\t\t\t1.020000e+01\n\t%E\t\t科学计数法，例如 -1234.456E+78\t\t\t\t\t\t\t\t\tPrintf(\"%e\", 10.2)\t\t\t\t\t\t\t1.020000E+01\n\t%f\t\t有小数点而无指数，例如 123.456\t\t\t\t\t\t\t\t\tPrintf(\"%f\", 10.2)\t\t\t\t\t\t\t10.200000\n\t%g\t\t根据情况选择 %e 或 %f 以产生更紧凑的（无末尾的0）输出\t\t\t\tPrintf(\"%g\", 10.20)\t\t\t\t\t\t\t10.2\n\t%G\t\t根据情况选择 %E 或 %f 以产生更紧凑的（无末尾的0）输出\t\t\t\tPrintf(\"%G\", 10.20+2i)\t\t\t\t\t\t(10.2+2i)\n\n**字符串与字节切片**\n\n\t占位符\t\t\t\t\t\t说明\t\t\t\t\t\t\t\t\t\t\t\t举例\t\t\t\t\t\t\t\t\t输出\n\t%s\t\t输出字符串表示（string 类型或 []byte)\t\t\t\t\t\t\tPrintf(\"%s\", []byte (\"Hello world\"))\t\tHello world\n\t%q\t\t双引号围绕的字符串，由 Go 语法安全地转义\t\t\t\t\t\t\tPrintf(\"%q\", \"Hello world\")\t\t\t\t    \"Hello world\"\n\t%x\t\t十六进制，小写字母，每字节两个字符\t\t\t\t\t\t\t\tPrintf(\"%x\", \"golang\")\t\t\t\t\t\t676f6c616e67\n\t%X\t\t十六进制，大写字母，每字节两个字符\t\t\t\t\t\t\t\tPrintf(\"%X\", \"golang\")\t\t\t\t\t\t676F6C616E67\n\n**指针**\n\n\t占位符\t\t\t\t\t\t说明\t\t\t\t\t\t\t\t\t\t\t\t举例\t\t\t\t\t\t\t\t\t输出\n\t%p\t\t十六进制表示，前缀 0x\t\t\t\t\t\t\t\t\t\t\tPrintf(\"%p\", &site)\t\t\t\t\t\t\t0x4f57f0\n\t\n**其它标记**\n\n\t占位符\t\t\t\t\t\t说明\t\t\t\t\t\t\t\t\t\t\t\t举例\t\t\t\t\t\t\t\t\t输出\n\t+\t\t总打印数值的正负号；对于%q（%+q）保证只输出 ASCII 编码的字符。\t\t\tPrintf(\"%+q\", \"中文\")\t\t\t\t\t\"\\u4e2d\\u6587\"\n\t-\t\t在右侧而非左侧填充空格（左对齐该区域）\n\t#\t\t备用格式：为八进制添加前导 0（%#o），为十六进制添加前导 0x（%#x）或\tPrintf(\"%#U\", '中')\t\t\t\t\t\tU+4E2D '中'\n\t\t\t0X（%#X），为 %p（%#p）去掉前导 0x；如果可能的话，%q（%#q）会打印原始\n\t\t\t（即反引号围绕的）字符串；如果是可打印字符，%U（%#U）会写出该字符的\n\t\t\tUnicode 编码形式（如字符 x 会被打印成 U+0078 'x'）。\n\t' '\t\t（空格）为数值中省略的正负号留出空白（% d）；\n\t\t\t以十六进制（% x, % X）打印字符串或切片时，在字节之间用空格隔开\n\t0\t\t填充前导的0而非空格；对于数字，这会将填充移到正负号之后\n\t\n示例：\n```go\ntype user struct {\n\tname string\n}\n\nfunc main() {\n\tu := user{\"tang\"}\n\tfmt.Printf(\"% + v\\n\", u)     // 格式化输出结构               {name: tang}\n\tfmt.Printf(\"%#v\\n\", u)       // 输出值的 Go 语言表示方法       main.user{name: \"tang\"}\n\tfmt.Printf(\"%T\\n\", u)        // 输出值的类型的 Go 语言表示     main.user\n\tfmt.Printf(\"%t\\n\", true)     // 输出值的 true 或 false   true\n\tfmt.Printf(\"%b\\n\", 1024)     // 二进制表示               10000000000\n\tfmt.Printf(\"%c\\n\", 11111111) // 数值对应的 Unicode 编码字符\n\tfmt.Printf(\"%d\\n\", 10)       // 十进制表示                 10\n\tfmt.Printf(\"%o\\n\", 8)        // 八进制表示                 10\n\tfmt.Printf(\"%q\\n\", 22)       // 转化为十六进制并附上单引号    '\\x16'\n\tfmt.Printf(\"%x\\n\", 1223)     // 十六进制表示，用 a-f 表示      4c7\n\tfmt.Printf(\"%X\\n\", 1223)     // 十六进制表示，用 A-F 表示      4c7\n\tfmt.Printf(\"%U\\n\", 1233)     // Unicode 表示\n\tfmt.Printf(\"%b\\n\", 12.34)    // 无小数部分，两位指数的科学计数法 6946802425218990p-49\n\tfmt.Printf(\"%e\\n\", 12.345)   // 科学计数法，e 表示   1.234500e+01\n\tfmt.Printf(\"%E\\n\", 12.34455) // 科学计数法，E 表示   1.234455E+01\n\tfmt.Printf(\"%f\\n\", 12.3456)  // 有小数部分，无指数部分   12.345600\n\tfmt.Printf(\"%g\\n\", 12.3456)  // 根据实际情况采用 %e 或 %f 输出  12.3456\n\tfmt.Printf(\"%G\\n\", 12.3456)  // 根据实际情况采用 %E 或 %f 输出  12.3456\n\tfmt.Printf(\"%s\\n\", \"wqdew\")  // 直接输出字符串或者 []byte         wqdew\n\tfmt.Printf(\"%q\\n\", \"dedede\") // 双引号括起来的字符串             \"dedede\"\n\tfmt.Printf(\"%x\\n\", \"abczxc\") // 每个字节用两字节十六进制表示，a-f 表示  6162637a7863\n\tfmt.Printf(\"%X\\n\", \"asdzxc\") // 每个字节用两字节十六进制表示，A-F 表示  6173647A7863\n\tfmt.Printf(\"%p\\n\", 0x123)    // 0x 开头的十六进制数表示\n}\n```","date":"2019-10-19T13:40:15.178Z","updated":"2019-10-19T13:40:15.178Z","path":"standards/io/fmt.html","comments":1,"layout":"page","_id":"ck1xm14l80010fcw2x3s77f3m","content":"<h1 id=\"fmt-包\"><a href=\"#fmt-包\" class=\"headerlink\" title=\"fmt 包\"></a>fmt 包</h1><p><code>fmt</code> 包实现了格式化 I/O 函数，有关格式化输入输出的方法有两大类：<code>Scan</code> 和 <code>Print</code>。</p>\n<p><code>print.go</code> 文件中定义了如下函数：</p>\n<h2 id=\"Print\"><a href=\"#Print\" class=\"headerlink\" title=\"Print\"></a>Print</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 普通输出，不带换行符</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Print</span><span class=\"params\">(a ...<span class=\"keyword\">interface</span>&#123;&#125;)</span> <span class=\"params\">(n <span class=\"keyword\">int</span>,  err error)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">Fprint</span><span class=\"params\">(w io.Writer,  a ...<span class=\"keyword\">interface</span>&#123;&#125;)</span> <span class=\"params\">(n <span class=\"keyword\">int</span>,  err error)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">Sprint</span><span class=\"params\">(a ...<span class=\"keyword\">interface</span>&#123;&#125;)</span> <span class=\"title\">string</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// 输出内容时会加上换行符</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">Println</span><span class=\"params\">(a ...<span class=\"keyword\">interface</span>&#123;&#125;)</span> <span class=\"params\">(n <span class=\"keyword\">int</span>,  err error)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">Fprintln</span><span class=\"params\">(w io.Writer,  a ...<span class=\"keyword\">interface</span>&#123;&#125;)</span> <span class=\"params\">(n <span class=\"keyword\">int</span>,  err error)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">Sprintln</span><span class=\"params\">(a ...<span class=\"keyword\">interface</span>&#123;&#125;)</span> <span class=\"title\">string</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// 按照指定格式化文本输出内容</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">Printf</span><span class=\"params\">(format <span class=\"keyword\">string</span>,  a ...<span class=\"keyword\">interface</span>&#123;&#125;)</span> <span class=\"params\">(n <span class=\"keyword\">int</span>,  err error)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">Fprintf</span><span class=\"params\">(w io.Writer,  format <span class=\"keyword\">string</span>,  a ...<span class=\"keyword\">interface</span>&#123;&#125;)</span> <span class=\"params\">(n <span class=\"keyword\">int</span>,  err error)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">Sprintf</span><span class=\"params\">(format <span class=\"keyword\">string</span>,  a ...<span class=\"keyword\">interface</span>&#123;&#125;)</span> <span class=\"title\">string</span></span></span><br></pre></td></tr></table></figure>\n<p>如果前缀是 “F”, 则指定了 <code>io.Writer</code><br>如果前缀是 “S”, 则是输出到字符串<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 输出内容到标准输出 os.Stdout</span><br><span class=\"line\">Print</span><br><span class=\"line\">Printf</span><br><span class=\"line\">Println</span><br><span class=\"line\">// 输出内容到指定的 io.Writer</span><br><span class=\"line\">Fprint</span><br><span class=\"line\">Fprintf</span><br><span class=\"line\">Fprintln</span><br><span class=\"line\">// 输出内容到字符串，并返回</span><br><span class=\"line\">Sprint</span><br><span class=\"line\">Sprintf</span><br><span class=\"line\">Sprintln</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Scan\"><a href=\"#Scan\" class=\"headerlink\" title=\"Scan\"></a>Scan</h2><p><code>scan.go</code> 文件中定义了如下函数：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 读取内容时不关注换行</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Scan</span><span class=\"params\">(a ...<span class=\"keyword\">interface</span>&#123;&#125;)</span> <span class=\"params\">(n <span class=\"keyword\">int</span>,  err error)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">Fscan</span><span class=\"params\">(r io.Reader,  a ...<span class=\"keyword\">interface</span>&#123;&#125;)</span> <span class=\"params\">(n <span class=\"keyword\">int</span>,  err error)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">Sscan</span><span class=\"params\">(str <span class=\"keyword\">string</span>,  a ...<span class=\"keyword\">interface</span>&#123;&#125;)</span> <span class=\"params\">(n <span class=\"keyword\">int</span>,  err error)</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// 读取到换行时停止，并要求一次提供一行所有条目</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">Scanln</span><span class=\"params\">(a ...<span class=\"keyword\">interface</span>&#123;&#125;)</span> <span class=\"params\">(n <span class=\"keyword\">int</span>,  err error)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">Fscanln</span><span class=\"params\">(r io.Reader,  a ...<span class=\"keyword\">interface</span>&#123;&#125;)</span> <span class=\"params\">(n <span class=\"keyword\">int</span>,  err error)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">Sscanln</span><span class=\"params\">(str <span class=\"keyword\">string</span>,  a ...<span class=\"keyword\">interface</span>&#123;&#125;)</span> <span class=\"params\">(n <span class=\"keyword\">int</span>,  err error)</span> </span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// 根据格式化文本读取</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">Scanf</span><span class=\"params\">(format <span class=\"keyword\">string</span>,  a ...<span class=\"keyword\">interface</span>&#123;&#125;)</span> <span class=\"params\">(n <span class=\"keyword\">int</span>,  err error)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">Fscanf</span><span class=\"params\">(r io.Reader,  format <span class=\"keyword\">string</span>,  a ...<span class=\"keyword\">interface</span>&#123;&#125;)</span> <span class=\"params\">(n <span class=\"keyword\">int</span>,  err error)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">Sscanf</span><span class=\"params\">(str <span class=\"keyword\">string</span>,  format <span class=\"keyword\">string</span>,  a ...<span class=\"keyword\">interface</span>&#123;&#125;)</span> <span class=\"params\">(n <span class=\"keyword\">int</span>,  err error)</span></span></span><br></pre></td></tr></table></figure></p>\n<p>如果前缀是 “F”, 则指定了 <code>io.Reader</code><br>如果前缀是 “S”, 则是从字符串读取<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 从标准输入os.Stdin读取文本</span><br><span class=\"line\">Scan</span><br><span class=\"line\">Scanf</span><br><span class=\"line\">Scanln</span><br><span class=\"line\">// 从指定的 io.Reader 接口读取文本</span><br><span class=\"line\">Fscan</span><br><span class=\"line\">Fscanf</span><br><span class=\"line\">Fscanln</span><br><span class=\"line\">// 从一个参数字符串读取文本</span><br><span class=\"line\">Sscan</span><br><span class=\"line\">Sscanf</span><br><span class=\"line\">Sscanln</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"占位符\"><a href=\"#占位符\" class=\"headerlink\" title=\"占位符\"></a>占位符</h2><p><strong>普通占位符</strong></p>\n<pre><code>占位符                        说明                        举例                                        输出\n%v        相应值的默认格式。                                Printf(&quot;%v&quot;, site)，Printf(&quot;%+v&quot;, site)    {studygolang}，{Name:studygolang}\n        在打印结构体时，“加号”标记（%+v）会添加字段名\n%#v        相应值的 Go 语法表示                            Printf(&quot;#v&quot;, site)                        main.Website{Name:&quot;studygolang&quot;}\n%T        相应值的类型的 Go 语法表示                        Printf(&quot;%T&quot;, site)                        main.Website\n%%        字面上的百分号，并非值的占位符                    Printf(&quot;%%&quot;)                            %\n</code></pre><p><strong>布尔占位符</strong></p>\n<pre><code>占位符                        说明                        举例                                        输出\n%t        单词 true 或 false。                            Printf(&quot;%t&quot;, true)                        true\n</code></pre><p><strong>整数占位符</strong></p>\n<pre><code>占位符                        说明                        举例                                    输出\n%b        二进制表示                                    Printf(&quot;%b&quot;, 5)                        101\n%c        相应Unicode码点所表示的字符                    Printf(&quot;%c&quot;, 0x4E2D)                中\n%d        十进制表示                                    Printf(&quot;%d&quot;, 0x12)                    18\n%o        八进制表示                                    Printf(&quot;%d&quot;, 10)                    12\n%q        单引号围绕的字符字面值，由 Go 语法安全地转义        Printf(&quot;%q&quot;, 0x4E2D)                &apos;中&apos;\n%x        十六进制表示，字母形式为小写 a-f                    Printf(&quot;%x&quot;, 13)                    d\n%X        十六进制表示，字母形式为大写 A-F                    Printf(&quot;%x&quot;, 13)                    D\n%U        Unicode格式：U+1234，等同于 &quot;U+%04X&quot;            Printf(&quot;%U&quot;, 0x4E2D)                U+4E2D\n</code></pre><p><strong>浮点数和复数的组成部分（实部和虚部）</strong></p>\n<pre><code>占位符                        说明                                                举例                                    输出\n%b        无小数部分的，指数为二的幂的科学计数法，与 strconv.FormatFloat    \n        的 &apos;b&apos; 转换格式一致。例如 -123456p-78\n%e        科学计数法，例如 -1234.456e+78                                    Printf(&quot;%e&quot;, 10.2)                            1.020000e+01\n%E        科学计数法，例如 -1234.456E+78                                    Printf(&quot;%e&quot;, 10.2)                            1.020000E+01\n%f        有小数点而无指数，例如 123.456                                    Printf(&quot;%f&quot;, 10.2)                            10.200000\n%g        根据情况选择 %e 或 %f 以产生更紧凑的（无末尾的0）输出                Printf(&quot;%g&quot;, 10.20)                            10.2\n%G        根据情况选择 %E 或 %f 以产生更紧凑的（无末尾的0）输出                Printf(&quot;%G&quot;, 10.20+2i)                        (10.2+2i)\n</code></pre><p><strong>字符串与字节切片</strong></p>\n<pre><code>占位符                        说明                                                举例                                    输出\n%s        输出字符串表示（string 类型或 []byte)                            Printf(&quot;%s&quot;, []byte (&quot;Hello world&quot;))        Hello world\n%q        双引号围绕的字符串，由 Go 语法安全地转义                            Printf(&quot;%q&quot;, &quot;Hello world&quot;)                    &quot;Hello world&quot;\n%x        十六进制，小写字母，每字节两个字符                                Printf(&quot;%x&quot;, &quot;golang&quot;)                        676f6c616e67\n%X        十六进制，大写字母，每字节两个字符                                Printf(&quot;%X&quot;, &quot;golang&quot;)                        676F6C616E67\n</code></pre><p><strong>指针</strong></p>\n<pre><code>占位符                        说明                                                举例                                    输出\n%p        十六进制表示，前缀 0x                                            Printf(&quot;%p&quot;, &amp;site)                            0x4f57f0\n</code></pre><p><strong>其它标记</strong></p>\n<pre><code>占位符                        说明                                                举例                                    输出\n+        总打印数值的正负号；对于%q（%+q）保证只输出 ASCII 编码的字符。            Printf(&quot;%+q&quot;, &quot;中文&quot;)                    &quot;\\u4e2d\\u6587&quot;\n-        在右侧而非左侧填充空格（左对齐该区域）\n#        备用格式：为八进制添加前导 0（%#o），为十六进制添加前导 0x（%#x）或    Printf(&quot;%#U&quot;, &apos;中&apos;)                        U+4E2D &apos;中&apos;\n        0X（%#X），为 %p（%#p）去掉前导 0x；如果可能的话，%q（%#q）会打印原始\n        （即反引号围绕的）字符串；如果是可打印字符，%U（%#U）会写出该字符的\n        Unicode 编码形式（如字符 x 会被打印成 U+0078 &apos;x&apos;）。\n&apos; &apos;        （空格）为数值中省略的正负号留出空白（% d）；\n        以十六进制（% x, % X）打印字符串或切片时，在字节之间用空格隔开\n0        填充前导的0而非空格；对于数字，这会将填充移到正负号之后\n</code></pre><p>示例：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> user <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tname <span class=\"keyword\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tu := user&#123;<span class=\"string\">\"tang\"</span>&#125;</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"% + v\\n\"</span>, u)     <span class=\"comment\">// 格式化输出结构               &#123;name: tang&#125;</span></span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"%#v\\n\"</span>, u)       <span class=\"comment\">// 输出值的 Go 语言表示方法       main.user&#123;name: \"tang\"&#125;</span></span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"%T\\n\"</span>, u)        <span class=\"comment\">// 输出值的类型的 Go 语言表示     main.user</span></span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"%t\\n\"</span>, <span class=\"literal\">true</span>)     <span class=\"comment\">// 输出值的 true 或 false   true</span></span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"%b\\n\"</span>, <span class=\"number\">1024</span>)     <span class=\"comment\">// 二进制表示               10000000000</span></span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"%c\\n\"</span>, <span class=\"number\">11111111</span>) <span class=\"comment\">// 数值对应的 Unicode 编码字符</span></span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"%d\\n\"</span>, <span class=\"number\">10</span>)       <span class=\"comment\">// 十进制表示                 10</span></span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"%o\\n\"</span>, <span class=\"number\">8</span>)        <span class=\"comment\">// 八进制表示                 10</span></span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"%q\\n\"</span>, <span class=\"number\">22</span>)       <span class=\"comment\">// 转化为十六进制并附上单引号    '\\x16'</span></span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"%x\\n\"</span>, <span class=\"number\">1223</span>)     <span class=\"comment\">// 十六进制表示，用 a-f 表示      4c7</span></span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"%X\\n\"</span>, <span class=\"number\">1223</span>)     <span class=\"comment\">// 十六进制表示，用 A-F 表示      4c7</span></span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"%U\\n\"</span>, <span class=\"number\">1233</span>)     <span class=\"comment\">// Unicode 表示</span></span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"%b\\n\"</span>, <span class=\"number\">12.34</span>)    <span class=\"comment\">// 无小数部分，两位指数的科学计数法 6946802425218990p-49</span></span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"%e\\n\"</span>, <span class=\"number\">12.345</span>)   <span class=\"comment\">// 科学计数法，e 表示   1.234500e+01</span></span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"%E\\n\"</span>, <span class=\"number\">12.34455</span>) <span class=\"comment\">// 科学计数法，E 表示   1.234455E+01</span></span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"%f\\n\"</span>, <span class=\"number\">12.3456</span>)  <span class=\"comment\">// 有小数部分，无指数部分   12.345600</span></span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"%g\\n\"</span>, <span class=\"number\">12.3456</span>)  <span class=\"comment\">// 根据实际情况采用 %e 或 %f 输出  12.3456</span></span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"%G\\n\"</span>, <span class=\"number\">12.3456</span>)  <span class=\"comment\">// 根据实际情况采用 %E 或 %f 输出  12.3456</span></span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"%s\\n\"</span>, <span class=\"string\">\"wqdew\"</span>)  <span class=\"comment\">// 直接输出字符串或者 []byte         wqdew</span></span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"%q\\n\"</span>, <span class=\"string\">\"dedede\"</span>) <span class=\"comment\">// 双引号括起来的字符串             \"dedede\"</span></span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"%x\\n\"</span>, <span class=\"string\">\"abczxc\"</span>) <span class=\"comment\">// 每个字节用两字节十六进制表示，a-f 表示  6162637a7863</span></span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"%X\\n\"</span>, <span class=\"string\">\"asdzxc\"</span>) <span class=\"comment\">// 每个字节用两字节十六进制表示，A-F 表示  6173647A7863</span></span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"%p\\n\"</span>, <span class=\"number\">0x123</span>)    <span class=\"comment\">// 0x 开头的十六进制数表示</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{"navigation":{"logo":{"text":"Golang Learn","type":"link","path":"index.html"},"main":[{"text":"Golang 基础","type":"label"},{"text":"Go 环境配置","type":"link","path":"basic/env_config.html"},{"text":"包","type":"link","path":"basic/package.html"},{"text":"基础数据类型","type":"link","path":"basic/basic_data.html"},{"text":"变量","type":"link","path":"basic/var.html"},{"text":"常量","type":"link","path":"basic/constant.html"},{"text":"控制语句","type":"link","path":"basic/flow.html"},{"text":"运算符","type":"link","path":"basic/operator.html"},{"text":"作用域","type":"link","path":"basic/scope.html"},{"text":"指针","type":"link","path":"basic/pointer.html"},{"text":"数组","type":"link","path":"basic/array.html"},{"text":"切片","type":"link","path":"basic/slice.html"},{"text":"字典","type":"link","path":"basic/map.html"},{"text":"函数","type":"link","path":"basic/function.html"},{"text":"结构体","type":"link","path":"basic/struct.html"},{"text":"接口","type":"link","path":"basic/interface.html"},{"text":"面向对象","type":"link","path":"basic/oop.html"},{"text":"错误","type":"link","path":"basic/error.html"},{"text":"序列化","type":"link","path":"basic/json.html"},{"text":"反射","type":"link","path":"basic/reflect.html"},{"text":"测试","type":"link","path":"basic/test.html"},{"text":"并发编程","type":"label"},{"text":"goroutine","type":"link","path":"concurrent/goroutine.html"},{"text":"channel","type":"link","path":"concurrent/channel.html"},{"text":"同步和锁","type":"link","path":"concurrent/sync_lock.html"},{"text":"内存分配","type":"label"},{"text":"内存分配","type":"link","path":"advance/mm.html"},{"text":"垃圾回收","type":"label"},{"text":"垃圾回收","type":"link","path":"advance/gc.html"},{"text":"标准库","type":"label"},{"text":"fmt","type":"link","path":"standards/io/fmt.html"},{"text":"io","type":"link","path":"standards/io/io.html"},{"text":"ioutil","type":"link","path":"standards/io/ioutil.html"},{"text":"bufio","type":"link","path":"standards/io/bufio.html"},{"text":"os","type":"link","path":"standards/os/os.html"},{"text":"filepath","type":"link","path":"standards/os/filepath.html"},{"text":"strings","type":"link","path":"standards/text/strings.html"},{"text":"strconv","type":"link","path":"standards/text/strconv.html"},{"text":"unicode","type":"link","path":"standards/text/unicode.html"},{"text":"log","type":"link","path":"standards/log.html"},{"text":"time","type":"link","path":"standards/time.html"},{"text":"http","type":"link","path":"standards/net/http.html"},{"text":"math","type":"link","path":"standards/data/math.html"},{"text":"sort","type":"link","path":"standards/data/sort.html"},{"text":"big","type":"link","path":"standards/data/big.html"},{"text":"container","type":"link","path":"standards/data/container.html"},{"text":"sql","type":"link","path":"standards/database/sql.html"},{"text":"THEME","type":"label"},{"text":"使用文档主题","type":"link","path":"theme/theme-usage.html"},{"text":"SUPPORT AND FEEDBACK","type":"label"},{"text":"Raise an Issue on Github","type":"link","path":"https://github.com/shipengqi/golang-learn/issues/new"}]}}},"excerpt":"","more":"<h1 id=\"fmt-包\"><a href=\"#fmt-包\" class=\"headerlink\" title=\"fmt 包\"></a>fmt 包</h1><p><code>fmt</code> 包实现了格式化 I/O 函数，有关格式化输入输出的方法有两大类：<code>Scan</code> 和 <code>Print</code>。</p>\n<p><code>print.go</code> 文件中定义了如下函数：</p>\n<h2 id=\"Print\"><a href=\"#Print\" class=\"headerlink\" title=\"Print\"></a>Print</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 普通输出，不带换行符</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Print</span><span class=\"params\">(a ...<span class=\"keyword\">interface</span>&#123;&#125;)</span> <span class=\"params\">(n <span class=\"keyword\">int</span>,  err error)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">Fprint</span><span class=\"params\">(w io.Writer,  a ...<span class=\"keyword\">interface</span>&#123;&#125;)</span> <span class=\"params\">(n <span class=\"keyword\">int</span>,  err error)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">Sprint</span><span class=\"params\">(a ...<span class=\"keyword\">interface</span>&#123;&#125;)</span> <span class=\"title\">string</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// 输出内容时会加上换行符</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">Println</span><span class=\"params\">(a ...<span class=\"keyword\">interface</span>&#123;&#125;)</span> <span class=\"params\">(n <span class=\"keyword\">int</span>,  err error)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">Fprintln</span><span class=\"params\">(w io.Writer,  a ...<span class=\"keyword\">interface</span>&#123;&#125;)</span> <span class=\"params\">(n <span class=\"keyword\">int</span>,  err error)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">Sprintln</span><span class=\"params\">(a ...<span class=\"keyword\">interface</span>&#123;&#125;)</span> <span class=\"title\">string</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// 按照指定格式化文本输出内容</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">Printf</span><span class=\"params\">(format <span class=\"keyword\">string</span>,  a ...<span class=\"keyword\">interface</span>&#123;&#125;)</span> <span class=\"params\">(n <span class=\"keyword\">int</span>,  err error)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">Fprintf</span><span class=\"params\">(w io.Writer,  format <span class=\"keyword\">string</span>,  a ...<span class=\"keyword\">interface</span>&#123;&#125;)</span> <span class=\"params\">(n <span class=\"keyword\">int</span>,  err error)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">Sprintf</span><span class=\"params\">(format <span class=\"keyword\">string</span>,  a ...<span class=\"keyword\">interface</span>&#123;&#125;)</span> <span class=\"title\">string</span></span></span><br></pre></td></tr></table></figure>\n<p>如果前缀是 “F”, 则指定了 <code>io.Writer</code><br>如果前缀是 “S”, 则是输出到字符串<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 输出内容到标准输出 os.Stdout</span><br><span class=\"line\">Print</span><br><span class=\"line\">Printf</span><br><span class=\"line\">Println</span><br><span class=\"line\">// 输出内容到指定的 io.Writer</span><br><span class=\"line\">Fprint</span><br><span class=\"line\">Fprintf</span><br><span class=\"line\">Fprintln</span><br><span class=\"line\">// 输出内容到字符串，并返回</span><br><span class=\"line\">Sprint</span><br><span class=\"line\">Sprintf</span><br><span class=\"line\">Sprintln</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Scan\"><a href=\"#Scan\" class=\"headerlink\" title=\"Scan\"></a>Scan</h2><p><code>scan.go</code> 文件中定义了如下函数：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 读取内容时不关注换行</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Scan</span><span class=\"params\">(a ...<span class=\"keyword\">interface</span>&#123;&#125;)</span> <span class=\"params\">(n <span class=\"keyword\">int</span>,  err error)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">Fscan</span><span class=\"params\">(r io.Reader,  a ...<span class=\"keyword\">interface</span>&#123;&#125;)</span> <span class=\"params\">(n <span class=\"keyword\">int</span>,  err error)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">Sscan</span><span class=\"params\">(str <span class=\"keyword\">string</span>,  a ...<span class=\"keyword\">interface</span>&#123;&#125;)</span> <span class=\"params\">(n <span class=\"keyword\">int</span>,  err error)</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// 读取到换行时停止，并要求一次提供一行所有条目</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">Scanln</span><span class=\"params\">(a ...<span class=\"keyword\">interface</span>&#123;&#125;)</span> <span class=\"params\">(n <span class=\"keyword\">int</span>,  err error)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">Fscanln</span><span class=\"params\">(r io.Reader,  a ...<span class=\"keyword\">interface</span>&#123;&#125;)</span> <span class=\"params\">(n <span class=\"keyword\">int</span>,  err error)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">Sscanln</span><span class=\"params\">(str <span class=\"keyword\">string</span>,  a ...<span class=\"keyword\">interface</span>&#123;&#125;)</span> <span class=\"params\">(n <span class=\"keyword\">int</span>,  err error)</span> </span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// 根据格式化文本读取</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">Scanf</span><span class=\"params\">(format <span class=\"keyword\">string</span>,  a ...<span class=\"keyword\">interface</span>&#123;&#125;)</span> <span class=\"params\">(n <span class=\"keyword\">int</span>,  err error)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">Fscanf</span><span class=\"params\">(r io.Reader,  format <span class=\"keyword\">string</span>,  a ...<span class=\"keyword\">interface</span>&#123;&#125;)</span> <span class=\"params\">(n <span class=\"keyword\">int</span>,  err error)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">Sscanf</span><span class=\"params\">(str <span class=\"keyword\">string</span>,  format <span class=\"keyword\">string</span>,  a ...<span class=\"keyword\">interface</span>&#123;&#125;)</span> <span class=\"params\">(n <span class=\"keyword\">int</span>,  err error)</span></span></span><br></pre></td></tr></table></figure></p>\n<p>如果前缀是 “F”, 则指定了 <code>io.Reader</code><br>如果前缀是 “S”, 则是从字符串读取<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 从标准输入os.Stdin读取文本</span><br><span class=\"line\">Scan</span><br><span class=\"line\">Scanf</span><br><span class=\"line\">Scanln</span><br><span class=\"line\">// 从指定的 io.Reader 接口读取文本</span><br><span class=\"line\">Fscan</span><br><span class=\"line\">Fscanf</span><br><span class=\"line\">Fscanln</span><br><span class=\"line\">// 从一个参数字符串读取文本</span><br><span class=\"line\">Sscan</span><br><span class=\"line\">Sscanf</span><br><span class=\"line\">Sscanln</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"占位符\"><a href=\"#占位符\" class=\"headerlink\" title=\"占位符\"></a>占位符</h2><p><strong>普通占位符</strong></p>\n<pre><code>占位符                        说明                        举例                                        输出\n%v        相应值的默认格式。                                Printf(&quot;%v&quot;, site)，Printf(&quot;%+v&quot;, site)    {studygolang}，{Name:studygolang}\n        在打印结构体时，“加号”标记（%+v）会添加字段名\n%#v        相应值的 Go 语法表示                            Printf(&quot;#v&quot;, site)                        main.Website{Name:&quot;studygolang&quot;}\n%T        相应值的类型的 Go 语法表示                        Printf(&quot;%T&quot;, site)                        main.Website\n%%        字面上的百分号，并非值的占位符                    Printf(&quot;%%&quot;)                            %\n</code></pre><p><strong>布尔占位符</strong></p>\n<pre><code>占位符                        说明                        举例                                        输出\n%t        单词 true 或 false。                            Printf(&quot;%t&quot;, true)                        true\n</code></pre><p><strong>整数占位符</strong></p>\n<pre><code>占位符                        说明                        举例                                    输出\n%b        二进制表示                                    Printf(&quot;%b&quot;, 5)                        101\n%c        相应Unicode码点所表示的字符                    Printf(&quot;%c&quot;, 0x4E2D)                中\n%d        十进制表示                                    Printf(&quot;%d&quot;, 0x12)                    18\n%o        八进制表示                                    Printf(&quot;%d&quot;, 10)                    12\n%q        单引号围绕的字符字面值，由 Go 语法安全地转义        Printf(&quot;%q&quot;, 0x4E2D)                &apos;中&apos;\n%x        十六进制表示，字母形式为小写 a-f                    Printf(&quot;%x&quot;, 13)                    d\n%X        十六进制表示，字母形式为大写 A-F                    Printf(&quot;%x&quot;, 13)                    D\n%U        Unicode格式：U+1234，等同于 &quot;U+%04X&quot;            Printf(&quot;%U&quot;, 0x4E2D)                U+4E2D\n</code></pre><p><strong>浮点数和复数的组成部分（实部和虚部）</strong></p>\n<pre><code>占位符                        说明                                                举例                                    输出\n%b        无小数部分的，指数为二的幂的科学计数法，与 strconv.FormatFloat    \n        的 &apos;b&apos; 转换格式一致。例如 -123456p-78\n%e        科学计数法，例如 -1234.456e+78                                    Printf(&quot;%e&quot;, 10.2)                            1.020000e+01\n%E        科学计数法，例如 -1234.456E+78                                    Printf(&quot;%e&quot;, 10.2)                            1.020000E+01\n%f        有小数点而无指数，例如 123.456                                    Printf(&quot;%f&quot;, 10.2)                            10.200000\n%g        根据情况选择 %e 或 %f 以产生更紧凑的（无末尾的0）输出                Printf(&quot;%g&quot;, 10.20)                            10.2\n%G        根据情况选择 %E 或 %f 以产生更紧凑的（无末尾的0）输出                Printf(&quot;%G&quot;, 10.20+2i)                        (10.2+2i)\n</code></pre><p><strong>字符串与字节切片</strong></p>\n<pre><code>占位符                        说明                                                举例                                    输出\n%s        输出字符串表示（string 类型或 []byte)                            Printf(&quot;%s&quot;, []byte (&quot;Hello world&quot;))        Hello world\n%q        双引号围绕的字符串，由 Go 语法安全地转义                            Printf(&quot;%q&quot;, &quot;Hello world&quot;)                    &quot;Hello world&quot;\n%x        十六进制，小写字母，每字节两个字符                                Printf(&quot;%x&quot;, &quot;golang&quot;)                        676f6c616e67\n%X        十六进制，大写字母，每字节两个字符                                Printf(&quot;%X&quot;, &quot;golang&quot;)                        676F6C616E67\n</code></pre><p><strong>指针</strong></p>\n<pre><code>占位符                        说明                                                举例                                    输出\n%p        十六进制表示，前缀 0x                                            Printf(&quot;%p&quot;, &amp;site)                            0x4f57f0\n</code></pre><p><strong>其它标记</strong></p>\n<pre><code>占位符                        说明                                                举例                                    输出\n+        总打印数值的正负号；对于%q（%+q）保证只输出 ASCII 编码的字符。            Printf(&quot;%+q&quot;, &quot;中文&quot;)                    &quot;\\u4e2d\\u6587&quot;\n-        在右侧而非左侧填充空格（左对齐该区域）\n#        备用格式：为八进制添加前导 0（%#o），为十六进制添加前导 0x（%#x）或    Printf(&quot;%#U&quot;, &apos;中&apos;)                        U+4E2D &apos;中&apos;\n        0X（%#X），为 %p（%#p）去掉前导 0x；如果可能的话，%q（%#q）会打印原始\n        （即反引号围绕的）字符串；如果是可打印字符，%U（%#U）会写出该字符的\n        Unicode 编码形式（如字符 x 会被打印成 U+0078 &apos;x&apos;）。\n&apos; &apos;        （空格）为数值中省略的正负号留出空白（% d）；\n        以十六进制（% x, % X）打印字符串或切片时，在字节之间用空格隔开\n0        填充前导的0而非空格；对于数字，这会将填充移到正负号之后\n</code></pre><p>示例：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> user <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tname <span class=\"keyword\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tu := user&#123;<span class=\"string\">\"tang\"</span>&#125;</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"% + v\\n\"</span>, u)     <span class=\"comment\">// 格式化输出结构               &#123;name: tang&#125;</span></span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"%#v\\n\"</span>, u)       <span class=\"comment\">// 输出值的 Go 语言表示方法       main.user&#123;name: \"tang\"&#125;</span></span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"%T\\n\"</span>, u)        <span class=\"comment\">// 输出值的类型的 Go 语言表示     main.user</span></span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"%t\\n\"</span>, <span class=\"literal\">true</span>)     <span class=\"comment\">// 输出值的 true 或 false   true</span></span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"%b\\n\"</span>, <span class=\"number\">1024</span>)     <span class=\"comment\">// 二进制表示               10000000000</span></span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"%c\\n\"</span>, <span class=\"number\">11111111</span>) <span class=\"comment\">// 数值对应的 Unicode 编码字符</span></span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"%d\\n\"</span>, <span class=\"number\">10</span>)       <span class=\"comment\">// 十进制表示                 10</span></span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"%o\\n\"</span>, <span class=\"number\">8</span>)        <span class=\"comment\">// 八进制表示                 10</span></span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"%q\\n\"</span>, <span class=\"number\">22</span>)       <span class=\"comment\">// 转化为十六进制并附上单引号    '\\x16'</span></span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"%x\\n\"</span>, <span class=\"number\">1223</span>)     <span class=\"comment\">// 十六进制表示，用 a-f 表示      4c7</span></span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"%X\\n\"</span>, <span class=\"number\">1223</span>)     <span class=\"comment\">// 十六进制表示，用 A-F 表示      4c7</span></span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"%U\\n\"</span>, <span class=\"number\">1233</span>)     <span class=\"comment\">// Unicode 表示</span></span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"%b\\n\"</span>, <span class=\"number\">12.34</span>)    <span class=\"comment\">// 无小数部分，两位指数的科学计数法 6946802425218990p-49</span></span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"%e\\n\"</span>, <span class=\"number\">12.345</span>)   <span class=\"comment\">// 科学计数法，e 表示   1.234500e+01</span></span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"%E\\n\"</span>, <span class=\"number\">12.34455</span>) <span class=\"comment\">// 科学计数法，E 表示   1.234455E+01</span></span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"%f\\n\"</span>, <span class=\"number\">12.3456</span>)  <span class=\"comment\">// 有小数部分，无指数部分   12.345600</span></span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"%g\\n\"</span>, <span class=\"number\">12.3456</span>)  <span class=\"comment\">// 根据实际情况采用 %e 或 %f 输出  12.3456</span></span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"%G\\n\"</span>, <span class=\"number\">12.3456</span>)  <span class=\"comment\">// 根据实际情况采用 %E 或 %f 输出  12.3456</span></span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"%s\\n\"</span>, <span class=\"string\">\"wqdew\"</span>)  <span class=\"comment\">// 直接输出字符串或者 []byte         wqdew</span></span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"%q\\n\"</span>, <span class=\"string\">\"dedede\"</span>) <span class=\"comment\">// 双引号括起来的字符串             \"dedede\"</span></span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"%x\\n\"</span>, <span class=\"string\">\"abczxc\"</span>) <span class=\"comment\">// 每个字节用两字节十六进制表示，a-f 表示  6162637a7863</span></span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"%X\\n\"</span>, <span class=\"string\">\"asdzxc\"</span>) <span class=\"comment\">// 每个字节用两字节十六进制表示，A-F 表示  6173647A7863</span></span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"%p\\n\"</span>, <span class=\"number\">0x123</span>)    <span class=\"comment\">// 0x 开头的十六进制数表示</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n"},{"title":"ioutil","_content":"\n# ioutil\n\nioutil 提供了一些常用、方便的 IO 操作函数。\n\n## NopCloser 函数\n\n有时候我们需要传递一个 `io.ReadCloser` 的实例，而我们现在有一个 `io.Reader` 的实例，比如：`strings.Reader` ，这个时候 `NopCloser` \n就派上用场了。它包装一个 `io.Reader`，返回一个 `io.ReadCloser` ，而相应的 `Close` 方法啥也不做，只是返回 `nil`。\n\n比如，在标准库 `net/http` 包中的 `NewRequest`，接收一个 `io.Reader` 的 `body`，而实际上，`Request` 的 `Body `的类\n型是 `io.ReadCloser`，因此，代码内部进行了判断，如果传递的 `io.Reader` 也实现了 `io.ReadCloser` 接口，则转换，否则通\n过 `ioutil.NopCloser` 包装转换一下。相关代码如下：\n```go\nrc, ok := body.(io.ReadCloser)\nif !ok && body != nil {\n    rc = ioutil.NopCloser(body)\n}\n```\n\n## ReadAll 函数\n\n很多时候，我们需要一次性读取 `io.Reader` 中的数据，考虑到读取所有数据的需求比较多，Go 提供了 `ReadAll` 这个函数，用来从 `io.Reader` 中\n一次读取所有数据。\n```go\nfunc ReadAll(r io.Reader) ([]byte, error)\n```\n该函数成功调用后会返回 `err == nil` 而不是 `err == EOF`。\n\n## ReadDir 函数\n\n在 Go 中如何输出目录下的所有文件呢？\n\n在 `ioutil` 中提供了一个方便的函数：`ReadDir`，它读取目录并返回排好序的文件和子目录名（ `[]os.FileInfo` ）。\n\n```go\nfunc main() {\n\tdir := os.Args[1]\n\tlistAll(dir,0)\n}\n\nfunc listAll(path string, curHier int){\n\tfileInfos, err := ioutil.ReadDir(path)\n\tif err != nil{fmt.Println(err); return}\n\n\tfor _, info := range fileInfos{\n\t\tif info.IsDir(){\n\t\t\tfor tmpHier := curHier; tmpHier > 0; tmpHier--{\n\t\t\t\tfmt.Printf(\"|\\t\")\n\t\t\t}\n\t\t\tfmt.Println(info.Name(),\"\\\\\")\n\t\t\tlistAll(path + \"/\" + info.Name(),curHier + 1)\n\t\t}else{\n\t\t\tfor tmpHier := curHier; tmpHier > 0; tmpHier--{\n\t\t\t\tfmt.Printf(\"|\\t\")\n\t\t\t}\n\t\t\tfmt.Println(info.Name())\n\t\t}\n\t}\n}\n```\n\n## ReadFile 和 WriteFile 函数\n\n`ReadFile` 读取整个文件的内容，`ReadFile` 会先判断文件的大小，给 `bytes.Buffer` 一个预定义容量，避免额外分配内存。\n\n```go\nfunc ReadFile(filename string) ([]byte, error)\n```\n\n> `ReadFile` 从 `filename` 指定的文件中读取数据并返回文件的内容。成功的调用返回的 `err` 为 `nil` 而非 `EOF`。因为本函数定义为\n读取整个文件，它不会将读取返回的 `EOF` 视为应报告的错误。\n\n**WriteFile**：\n```go\nfunc WriteFile(filename string, data []byte, perm os.FileMode) error\n```\n\n\n> `WriteFile` 将 `data` 写入 `filename` 文件中，当文件不存在时会根据 `perm` 指定的权限进行创建一个,文件存在时会先清空文件内容。\n对于 `perm` 参数，我们一般可以指定为：`0666`。\n\n## TempDir 和 TempFile 函数\n\n操作系统中一般都会提供临时目录，比如 linux 下的 `/tmp` 目录（通过 `os.TempDir()` 可以获取到)。有时候，我们自己需要创建临时目录，\n比如 Go 工具链源码中（`src/cmd/go/build.go`），通过 `TempDir` 创建一个临时目录，用于存放编译过程的临时文件：\n```go\nb.work, err = ioutil.TempDir(\"\", \"go-build\")\n```\n第一个参数如果为空，表明在系统默认的临时目录（ `os.TempDir` ）中创建临时目录；第二个参数指定临时目录名的前缀，该函数返回临时目录的路径。\n\n相应的，`TempFile` 用于创建临时文件。如 `gofmt` 命令的源码中创建临时文件：\n```go\nf1, err := ioutil.TempFile(\"\", \"gofmt\")\n```\n参数和 `ioutil.TempDir` 参数含义类似。\n\n这里需要**注意**：创建者创建的临时文件和临时目录要负责删除这些临时目录和文件。如删除临时文件：\n```go\ndefer func() {\n    f.Close()\n    os.Remove(f.Name())\n}()\n```\n","source":"standards/io/ioutil.md","raw":"---\ntitle: ioutil\n---\n\n# ioutil\n\nioutil 提供了一些常用、方便的 IO 操作函数。\n\n## NopCloser 函数\n\n有时候我们需要传递一个 `io.ReadCloser` 的实例，而我们现在有一个 `io.Reader` 的实例，比如：`strings.Reader` ，这个时候 `NopCloser` \n就派上用场了。它包装一个 `io.Reader`，返回一个 `io.ReadCloser` ，而相应的 `Close` 方法啥也不做，只是返回 `nil`。\n\n比如，在标准库 `net/http` 包中的 `NewRequest`，接收一个 `io.Reader` 的 `body`，而实际上，`Request` 的 `Body `的类\n型是 `io.ReadCloser`，因此，代码内部进行了判断，如果传递的 `io.Reader` 也实现了 `io.ReadCloser` 接口，则转换，否则通\n过 `ioutil.NopCloser` 包装转换一下。相关代码如下：\n```go\nrc, ok := body.(io.ReadCloser)\nif !ok && body != nil {\n    rc = ioutil.NopCloser(body)\n}\n```\n\n## ReadAll 函数\n\n很多时候，我们需要一次性读取 `io.Reader` 中的数据，考虑到读取所有数据的需求比较多，Go 提供了 `ReadAll` 这个函数，用来从 `io.Reader` 中\n一次读取所有数据。\n```go\nfunc ReadAll(r io.Reader) ([]byte, error)\n```\n该函数成功调用后会返回 `err == nil` 而不是 `err == EOF`。\n\n## ReadDir 函数\n\n在 Go 中如何输出目录下的所有文件呢？\n\n在 `ioutil` 中提供了一个方便的函数：`ReadDir`，它读取目录并返回排好序的文件和子目录名（ `[]os.FileInfo` ）。\n\n```go\nfunc main() {\n\tdir := os.Args[1]\n\tlistAll(dir,0)\n}\n\nfunc listAll(path string, curHier int){\n\tfileInfos, err := ioutil.ReadDir(path)\n\tif err != nil{fmt.Println(err); return}\n\n\tfor _, info := range fileInfos{\n\t\tif info.IsDir(){\n\t\t\tfor tmpHier := curHier; tmpHier > 0; tmpHier--{\n\t\t\t\tfmt.Printf(\"|\\t\")\n\t\t\t}\n\t\t\tfmt.Println(info.Name(),\"\\\\\")\n\t\t\tlistAll(path + \"/\" + info.Name(),curHier + 1)\n\t\t}else{\n\t\t\tfor tmpHier := curHier; tmpHier > 0; tmpHier--{\n\t\t\t\tfmt.Printf(\"|\\t\")\n\t\t\t}\n\t\t\tfmt.Println(info.Name())\n\t\t}\n\t}\n}\n```\n\n## ReadFile 和 WriteFile 函数\n\n`ReadFile` 读取整个文件的内容，`ReadFile` 会先判断文件的大小，给 `bytes.Buffer` 一个预定义容量，避免额外分配内存。\n\n```go\nfunc ReadFile(filename string) ([]byte, error)\n```\n\n> `ReadFile` 从 `filename` 指定的文件中读取数据并返回文件的内容。成功的调用返回的 `err` 为 `nil` 而非 `EOF`。因为本函数定义为\n读取整个文件，它不会将读取返回的 `EOF` 视为应报告的错误。\n\n**WriteFile**：\n```go\nfunc WriteFile(filename string, data []byte, perm os.FileMode) error\n```\n\n\n> `WriteFile` 将 `data` 写入 `filename` 文件中，当文件不存在时会根据 `perm` 指定的权限进行创建一个,文件存在时会先清空文件内容。\n对于 `perm` 参数，我们一般可以指定为：`0666`。\n\n## TempDir 和 TempFile 函数\n\n操作系统中一般都会提供临时目录，比如 linux 下的 `/tmp` 目录（通过 `os.TempDir()` 可以获取到)。有时候，我们自己需要创建临时目录，\n比如 Go 工具链源码中（`src/cmd/go/build.go`），通过 `TempDir` 创建一个临时目录，用于存放编译过程的临时文件：\n```go\nb.work, err = ioutil.TempDir(\"\", \"go-build\")\n```\n第一个参数如果为空，表明在系统默认的临时目录（ `os.TempDir` ）中创建临时目录；第二个参数指定临时目录名的前缀，该函数返回临时目录的路径。\n\n相应的，`TempFile` 用于创建临时文件。如 `gofmt` 命令的源码中创建临时文件：\n```go\nf1, err := ioutil.TempFile(\"\", \"gofmt\")\n```\n参数和 `ioutil.TempDir` 参数含义类似。\n\n这里需要**注意**：创建者创建的临时文件和临时目录要负责删除这些临时目录和文件。如删除临时文件：\n```go\ndefer func() {\n    f.Close()\n    os.Remove(f.Name())\n}()\n```\n","date":"2019-10-19T13:40:15.179Z","updated":"2019-10-19T13:40:15.179Z","path":"standards/io/ioutil.html","comments":1,"layout":"page","_id":"ck1xm14l80011fcw2m863k5xq","content":"<h1 id=\"ioutil\"><a href=\"#ioutil\" class=\"headerlink\" title=\"ioutil\"></a>ioutil</h1><p>ioutil 提供了一些常用、方便的 IO 操作函数。</p>\n<h2 id=\"NopCloser-函数\"><a href=\"#NopCloser-函数\" class=\"headerlink\" title=\"NopCloser 函数\"></a>NopCloser 函数</h2><p>有时候我们需要传递一个 <code>io.ReadCloser</code> 的实例，而我们现在有一个 <code>io.Reader</code> 的实例，比如：<code>strings.Reader</code> ，这个时候 <code>NopCloser</code><br>就派上用场了。它包装一个 <code>io.Reader</code>，返回一个 <code>io.ReadCloser</code> ，而相应的 <code>Close</code> 方法啥也不做，只是返回 <code>nil</code>。</p>\n<p>比如，在标准库 <code>net/http</code> 包中的 <code>NewRequest</code>，接收一个 <code>io.Reader</code> 的 <code>body</code>，而实际上，<code>Request</code> 的 <code>Body</code>的类<br>型是 <code>io.ReadCloser</code>，因此，代码内部进行了判断，如果传递的 <code>io.Reader</code> 也实现了 <code>io.ReadCloser</code> 接口，则转换，否则通<br>过 <code>ioutil.NopCloser</code> 包装转换一下。相关代码如下：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rc, ok := body.(io.ReadCloser)</span><br><span class=\"line\"><span class=\"keyword\">if</span> !ok &amp;&amp; body != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    rc = ioutil.NopCloser(body)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"ReadAll-函数\"><a href=\"#ReadAll-函数\" class=\"headerlink\" title=\"ReadAll 函数\"></a>ReadAll 函数</h2><p>很多时候，我们需要一次性读取 <code>io.Reader</code> 中的数据，考虑到读取所有数据的需求比较多，Go 提供了 <code>ReadAll</code> 这个函数，用来从 <code>io.Reader</code> 中<br>一次读取所有数据。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">ReadAll</span><span class=\"params\">(r io.Reader)</span> <span class=\"params\">([]<span class=\"keyword\">byte</span>, error)</span></span></span><br></pre></td></tr></table></figure></p>\n<p>该函数成功调用后会返回 <code>err == nil</code> 而不是 <code>err == EOF</code>。</p>\n<h2 id=\"ReadDir-函数\"><a href=\"#ReadDir-函数\" class=\"headerlink\" title=\"ReadDir 函数\"></a>ReadDir 函数</h2><p>在 Go 中如何输出目录下的所有文件呢？</p>\n<p>在 <code>ioutil</code> 中提供了一个方便的函数：<code>ReadDir</code>，它读取目录并返回排好序的文件和子目录名（ <code>[]os.FileInfo</code> ）。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tdir := os.Args[<span class=\"number\">1</span>]</span><br><span class=\"line\">\tlistAll(dir,<span class=\"number\">0</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">listAll</span><span class=\"params\">(path <span class=\"keyword\">string</span>, curHier <span class=\"keyword\">int</span>)</span></span>&#123;</span><br><span class=\"line\">\tfileInfos, err := ioutil.ReadDir(path)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span>&#123;fmt.Println(err); <span class=\"keyword\">return</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> _, info := <span class=\"keyword\">range</span> fileInfos&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> info.IsDir()&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> tmpHier := curHier; tmpHier &gt; <span class=\"number\">0</span>; tmpHier--&#123;</span><br><span class=\"line\">\t\t\t\tfmt.Printf(<span class=\"string\">\"|\\t\"</span>)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tfmt.Println(info.Name(),<span class=\"string\">\"\\\\\"</span>)</span><br><span class=\"line\">\t\t\tlistAll(path + <span class=\"string\">\"/\"</span> + info.Name(),curHier + <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> tmpHier := curHier; tmpHier &gt; <span class=\"number\">0</span>; tmpHier--&#123;</span><br><span class=\"line\">\t\t\t\tfmt.Printf(<span class=\"string\">\"|\\t\"</span>)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tfmt.Println(info.Name())</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"ReadFile-和-WriteFile-函数\"><a href=\"#ReadFile-和-WriteFile-函数\" class=\"headerlink\" title=\"ReadFile 和 WriteFile 函数\"></a>ReadFile 和 WriteFile 函数</h2><p><code>ReadFile</code> 读取整个文件的内容，<code>ReadFile</code> 会先判断文件的大小，给 <code>bytes.Buffer</code> 一个预定义容量，避免额外分配内存。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">ReadFile</span><span class=\"params\">(filename <span class=\"keyword\">string</span>)</span> <span class=\"params\">([]<span class=\"keyword\">byte</span>, error)</span></span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>ReadFile</code> 从 <code>filename</code> 指定的文件中读取数据并返回文件的内容。成功的调用返回的 <code>err</code> 为 <code>nil</code> 而非 <code>EOF</code>。因为本函数定义为<br>读取整个文件，它不会将读取返回的 <code>EOF</code> 视为应报告的错误。</p>\n</blockquote>\n<p><strong>WriteFile</strong>：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">WriteFile</span><span class=\"params\">(filename <span class=\"keyword\">string</span>, data []<span class=\"keyword\">byte</span>, perm os.FileMode)</span> <span class=\"title\">error</span></span></span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p><code>WriteFile</code> 将 <code>data</code> 写入 <code>filename</code> 文件中，当文件不存在时会根据 <code>perm</code> 指定的权限进行创建一个,文件存在时会先清空文件内容。<br>对于 <code>perm</code> 参数，我们一般可以指定为：<code>0666</code>。</p>\n</blockquote>\n<h2 id=\"TempDir-和-TempFile-函数\"><a href=\"#TempDir-和-TempFile-函数\" class=\"headerlink\" title=\"TempDir 和 TempFile 函数\"></a>TempDir 和 TempFile 函数</h2><p>操作系统中一般都会提供临时目录，比如 linux 下的 <code>/tmp</code> 目录（通过 <code>os.TempDir()</code> 可以获取到)。有时候，我们自己需要创建临时目录，<br>比如 Go 工具链源码中（<code>src/cmd/go/build.go</code>），通过 <code>TempDir</code> 创建一个临时目录，用于存放编译过程的临时文件：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">b.work, err = ioutil.TempDir(<span class=\"string\">\"\"</span>, <span class=\"string\">\"go-build\"</span>)</span><br></pre></td></tr></table></figure></p>\n<p>第一个参数如果为空，表明在系统默认的临时目录（ <code>os.TempDir</code> ）中创建临时目录；第二个参数指定临时目录名的前缀，该函数返回临时目录的路径。</p>\n<p>相应的，<code>TempFile</code> 用于创建临时文件。如 <code>gofmt</code> 命令的源码中创建临时文件：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f1, err := ioutil.TempFile(<span class=\"string\">\"\"</span>, <span class=\"string\">\"gofmt\"</span>)</span><br></pre></td></tr></table></figure></p>\n<p>参数和 <code>ioutil.TempDir</code> 参数含义类似。</p>\n<p>这里需要<strong>注意</strong>：创建者创建的临时文件和临时目录要负责删除这些临时目录和文件。如删除临时文件：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">defer</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    f.Close()</span><br><span class=\"line\">    os.Remove(f.Name())</span><br><span class=\"line\">&#125;()</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{"navigation":{"logo":{"text":"Golang Learn","type":"link","path":"index.html"},"main":[{"text":"Golang 基础","type":"label"},{"text":"Go 环境配置","type":"link","path":"basic/env_config.html"},{"text":"包","type":"link","path":"basic/package.html"},{"text":"基础数据类型","type":"link","path":"basic/basic_data.html"},{"text":"变量","type":"link","path":"basic/var.html"},{"text":"常量","type":"link","path":"basic/constant.html"},{"text":"控制语句","type":"link","path":"basic/flow.html"},{"text":"运算符","type":"link","path":"basic/operator.html"},{"text":"作用域","type":"link","path":"basic/scope.html"},{"text":"指针","type":"link","path":"basic/pointer.html"},{"text":"数组","type":"link","path":"basic/array.html"},{"text":"切片","type":"link","path":"basic/slice.html"},{"text":"字典","type":"link","path":"basic/map.html"},{"text":"函数","type":"link","path":"basic/function.html"},{"text":"结构体","type":"link","path":"basic/struct.html"},{"text":"接口","type":"link","path":"basic/interface.html"},{"text":"面向对象","type":"link","path":"basic/oop.html"},{"text":"错误","type":"link","path":"basic/error.html"},{"text":"序列化","type":"link","path":"basic/json.html"},{"text":"反射","type":"link","path":"basic/reflect.html"},{"text":"测试","type":"link","path":"basic/test.html"},{"text":"并发编程","type":"label"},{"text":"goroutine","type":"link","path":"concurrent/goroutine.html"},{"text":"channel","type":"link","path":"concurrent/channel.html"},{"text":"同步和锁","type":"link","path":"concurrent/sync_lock.html"},{"text":"内存分配","type":"label"},{"text":"内存分配","type":"link","path":"advance/mm.html"},{"text":"垃圾回收","type":"label"},{"text":"垃圾回收","type":"link","path":"advance/gc.html"},{"text":"标准库","type":"label"},{"text":"fmt","type":"link","path":"standards/io/fmt.html"},{"text":"io","type":"link","path":"standards/io/io.html"},{"text":"ioutil","type":"link","path":"standards/io/ioutil.html"},{"text":"bufio","type":"link","path":"standards/io/bufio.html"},{"text":"os","type":"link","path":"standards/os/os.html"},{"text":"filepath","type":"link","path":"standards/os/filepath.html"},{"text":"strings","type":"link","path":"standards/text/strings.html"},{"text":"strconv","type":"link","path":"standards/text/strconv.html"},{"text":"unicode","type":"link","path":"standards/text/unicode.html"},{"text":"log","type":"link","path":"standards/log.html"},{"text":"time","type":"link","path":"standards/time.html"},{"text":"http","type":"link","path":"standards/net/http.html"},{"text":"math","type":"link","path":"standards/data/math.html"},{"text":"sort","type":"link","path":"standards/data/sort.html"},{"text":"big","type":"link","path":"standards/data/big.html"},{"text":"container","type":"link","path":"standards/data/container.html"},{"text":"sql","type":"link","path":"standards/database/sql.html"},{"text":"THEME","type":"label"},{"text":"使用文档主题","type":"link","path":"theme/theme-usage.html"},{"text":"SUPPORT AND FEEDBACK","type":"label"},{"text":"Raise an Issue on Github","type":"link","path":"https://github.com/shipengqi/golang-learn/issues/new"}]}}},"excerpt":"","more":"<h1 id=\"ioutil\"><a href=\"#ioutil\" class=\"headerlink\" title=\"ioutil\"></a>ioutil</h1><p>ioutil 提供了一些常用、方便的 IO 操作函数。</p>\n<h2 id=\"NopCloser-函数\"><a href=\"#NopCloser-函数\" class=\"headerlink\" title=\"NopCloser 函数\"></a>NopCloser 函数</h2><p>有时候我们需要传递一个 <code>io.ReadCloser</code> 的实例，而我们现在有一个 <code>io.Reader</code> 的实例，比如：<code>strings.Reader</code> ，这个时候 <code>NopCloser</code><br>就派上用场了。它包装一个 <code>io.Reader</code>，返回一个 <code>io.ReadCloser</code> ，而相应的 <code>Close</code> 方法啥也不做，只是返回 <code>nil</code>。</p>\n<p>比如，在标准库 <code>net/http</code> 包中的 <code>NewRequest</code>，接收一个 <code>io.Reader</code> 的 <code>body</code>，而实际上，<code>Request</code> 的 <code>Body</code>的类<br>型是 <code>io.ReadCloser</code>，因此，代码内部进行了判断，如果传递的 <code>io.Reader</code> 也实现了 <code>io.ReadCloser</code> 接口，则转换，否则通<br>过 <code>ioutil.NopCloser</code> 包装转换一下。相关代码如下：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rc, ok := body.(io.ReadCloser)</span><br><span class=\"line\"><span class=\"keyword\">if</span> !ok &amp;&amp; body != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    rc = ioutil.NopCloser(body)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"ReadAll-函数\"><a href=\"#ReadAll-函数\" class=\"headerlink\" title=\"ReadAll 函数\"></a>ReadAll 函数</h2><p>很多时候，我们需要一次性读取 <code>io.Reader</code> 中的数据，考虑到读取所有数据的需求比较多，Go 提供了 <code>ReadAll</code> 这个函数，用来从 <code>io.Reader</code> 中<br>一次读取所有数据。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">ReadAll</span><span class=\"params\">(r io.Reader)</span> <span class=\"params\">([]<span class=\"keyword\">byte</span>, error)</span></span></span><br></pre></td></tr></table></figure></p>\n<p>该函数成功调用后会返回 <code>err == nil</code> 而不是 <code>err == EOF</code>。</p>\n<h2 id=\"ReadDir-函数\"><a href=\"#ReadDir-函数\" class=\"headerlink\" title=\"ReadDir 函数\"></a>ReadDir 函数</h2><p>在 Go 中如何输出目录下的所有文件呢？</p>\n<p>在 <code>ioutil</code> 中提供了一个方便的函数：<code>ReadDir</code>，它读取目录并返回排好序的文件和子目录名（ <code>[]os.FileInfo</code> ）。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tdir := os.Args[<span class=\"number\">1</span>]</span><br><span class=\"line\">\tlistAll(dir,<span class=\"number\">0</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">listAll</span><span class=\"params\">(path <span class=\"keyword\">string</span>, curHier <span class=\"keyword\">int</span>)</span></span>&#123;</span><br><span class=\"line\">\tfileInfos, err := ioutil.ReadDir(path)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span>&#123;fmt.Println(err); <span class=\"keyword\">return</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> _, info := <span class=\"keyword\">range</span> fileInfos&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> info.IsDir()&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> tmpHier := curHier; tmpHier &gt; <span class=\"number\">0</span>; tmpHier--&#123;</span><br><span class=\"line\">\t\t\t\tfmt.Printf(<span class=\"string\">\"|\\t\"</span>)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tfmt.Println(info.Name(),<span class=\"string\">\"\\\\\"</span>)</span><br><span class=\"line\">\t\t\tlistAll(path + <span class=\"string\">\"/\"</span> + info.Name(),curHier + <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> tmpHier := curHier; tmpHier &gt; <span class=\"number\">0</span>; tmpHier--&#123;</span><br><span class=\"line\">\t\t\t\tfmt.Printf(<span class=\"string\">\"|\\t\"</span>)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tfmt.Println(info.Name())</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"ReadFile-和-WriteFile-函数\"><a href=\"#ReadFile-和-WriteFile-函数\" class=\"headerlink\" title=\"ReadFile 和 WriteFile 函数\"></a>ReadFile 和 WriteFile 函数</h2><p><code>ReadFile</code> 读取整个文件的内容，<code>ReadFile</code> 会先判断文件的大小，给 <code>bytes.Buffer</code> 一个预定义容量，避免额外分配内存。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">ReadFile</span><span class=\"params\">(filename <span class=\"keyword\">string</span>)</span> <span class=\"params\">([]<span class=\"keyword\">byte</span>, error)</span></span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>ReadFile</code> 从 <code>filename</code> 指定的文件中读取数据并返回文件的内容。成功的调用返回的 <code>err</code> 为 <code>nil</code> 而非 <code>EOF</code>。因为本函数定义为<br>读取整个文件，它不会将读取返回的 <code>EOF</code> 视为应报告的错误。</p>\n</blockquote>\n<p><strong>WriteFile</strong>：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">WriteFile</span><span class=\"params\">(filename <span class=\"keyword\">string</span>, data []<span class=\"keyword\">byte</span>, perm os.FileMode)</span> <span class=\"title\">error</span></span></span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p><code>WriteFile</code> 将 <code>data</code> 写入 <code>filename</code> 文件中，当文件不存在时会根据 <code>perm</code> 指定的权限进行创建一个,文件存在时会先清空文件内容。<br>对于 <code>perm</code> 参数，我们一般可以指定为：<code>0666</code>。</p>\n</blockquote>\n<h2 id=\"TempDir-和-TempFile-函数\"><a href=\"#TempDir-和-TempFile-函数\" class=\"headerlink\" title=\"TempDir 和 TempFile 函数\"></a>TempDir 和 TempFile 函数</h2><p>操作系统中一般都会提供临时目录，比如 linux 下的 <code>/tmp</code> 目录（通过 <code>os.TempDir()</code> 可以获取到)。有时候，我们自己需要创建临时目录，<br>比如 Go 工具链源码中（<code>src/cmd/go/build.go</code>），通过 <code>TempDir</code> 创建一个临时目录，用于存放编译过程的临时文件：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">b.work, err = ioutil.TempDir(<span class=\"string\">\"\"</span>, <span class=\"string\">\"go-build\"</span>)</span><br></pre></td></tr></table></figure></p>\n<p>第一个参数如果为空，表明在系统默认的临时目录（ <code>os.TempDir</code> ）中创建临时目录；第二个参数指定临时目录名的前缀，该函数返回临时目录的路径。</p>\n<p>相应的，<code>TempFile</code> 用于创建临时文件。如 <code>gofmt</code> 命令的源码中创建临时文件：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f1, err := ioutil.TempFile(<span class=\"string\">\"\"</span>, <span class=\"string\">\"gofmt\"</span>)</span><br></pre></td></tr></table></figure></p>\n<p>参数和 <code>ioutil.TempDir</code> 参数含义类似。</p>\n<p>这里需要<strong>注意</strong>：创建者创建的临时文件和临时目录要负责删除这些临时目录和文件。如删除临时文件：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">defer</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    f.Close()</span><br><span class=\"line\">    os.Remove(f.Name())</span><br><span class=\"line\">&#125;()</span><br></pre></td></tr></table></figure></p>\n"},{"title":"strconv","_content":"\n# strconv\n\n`strconv` 包包含了一系列字符串与相关的类型转换的函数。\n\n## 转换错误处理\n\n`strconv` 中的错误处理。\n\n由于将字符串转为其他数据类型可能会出错，*strconv* 包定义了两个 *error* 类型的变量：*ErrRange* 和 *ErrSyntax*。其中，*ErrRange* 表示\n值超过了类型能表示的最大范围，比如将 \"128\" 转为 `int8` 就会返回这个错误；*ErrSyntax* 表示语法错误，比如将 `\"\"` 转为 `int` 类型会返\n回这个错误。\n\n然而，在返回错误的时候，通过构造一个 *NumError* 类型的 *error* 对象返回。*NumError* 结构的定义如下：\n```go\n// A NumError records a failed conversion.\ntype NumError struct {\n    Func string // the failing function (ParseBool, ParseInt, ParseUint, ParseFloat)\n    Num  string // the input\n    Err  error  // the reason the conversion failed (ErrRange, ErrSyntax)\n}\n```\n\n该结构记录了转换过程中发生的错误信息。该结构不仅包含了一个 *error* 类型的成员，记录具体的错误信息，包的实现中，定义了两个便捷函数，\n用于构造 *NumError* 对象：\n```go\nfunc syntaxError(fn, str string) *NumError {\n    return &NumError{fn, str, ErrSyntax}\n}\n\nfunc rangeError(fn, str string) *NumError {\n    return &NumError{fn, str, ErrRange}\n}\n```\n\n\n## 字符串转为整型\n\n包括三个函数：`ParseInt`、`ParseUint` 和 `Atoi`，函数原型如下：\n```go\n// 转为有符号整型\nfunc ParseInt(s string, base int, bitSize int) (i int64, err error)\n// 转为无符号整型\nfunc ParseUint(s string, base int, bitSize int) (n uint64, err error)\nfunc Atoi(s string) (i int, err error)\n```\n\n**`Atoi` 内部通过调用 `ParseInt(s, 10, 0)` 来实现的**。\n\n### ParseInt\n```go\nfunc ParseInt(s string, base int, bitSize int) (i int64, err error)\n```\n参数：\n-  `base` 进制，取值为 `2~36`，如果 `base` 的值为 0，则会根据字符串的前缀来确定 `base` 的值：\n\"0x\" 表示 16 进制； \"0\" 表示 8 进制；否则就是 10 进制。\n- `bitSize` 表示的是整数取值范围，或者说整数的具体类型。取值 0、8、16、32 和 64 分别代表 `int`、`int8`、`int16`、`int32`\n和 `int64`。\n\nGo 中，`int/uint` 类型，不同系统能表示的范围是不一样的，目前的实现是，32 位系统占 4 个字节；64 位系统占 8 个字节。\n当 `bitSize==0` 时，应该表示 32 位还是 64 位呢？`strconv.IntSize` 变量用于获取程序运行的操作系统平台下 int 类型所占的位数。\n\n下面的代码 n 和 err 的值分别是什么？\n```go\nn, err := strconv.ParseInt(\"128\", 10, 8)\n```\n\t\n在 `ParseInt/ParseUint` 的实现中，如果字符串表示的整数超过了 `bitSize` 参数能够表示的范围，则会返回 `ErrRange`，同时会\n返回 `bitSize` 能够表示的最大或最小值。\n\n`int8` 占 8 位，最高位代表符号位 （1-负号；0-正号）。所以这里 n 是 127。\n\n另外，`ParseInt` 返回的是 `int64`，这是为了能够容纳所有的整型，在实际使用中，可以根据传递的 `bitSize`，然后将结果转为实\n际需要的类型。\n\n\n## 整型转为字符串\n\n遇到需要将字符串和整型连接起来，在 Go 语言中，你需要将整型转为字符串类型，然后才能进行连接。\n```go\n// 无符号整型转字符串\nfunc FormatUint(i uint64, base int) string\t\n// 有符号整型转字符串\nfunc FormatInt(i int64, base int) string\t\nfunc Itoa(i int) string\n```\n\n**`Itoa` 内部直接调用 *FormatInt(i, 10)* 实现的**。\n\n\n除了使用上述方法将整数转为字符串外，经常见到有人使用 *fmt* 包来做这件事。如：\n```go\nfmt.Sprintf(\"%d\", 127)\n```\n\n那么，这两种方式我们该怎么选择呢？我们主要来考察一下性能。\n```go\nstartTime := time.Now()\nfor i := 0; i < 10000; i++ {\n    fmt.Sprintf(\"%d\", i)\n}   \nfmt.Println(time.Now().Sub(startTime))\n\nstartTime := time.Now()\nfor i := 0; i < 10000; i++ {\n    strconv.Itoa(i)\n}   \nfmt.Println(time.Now().Sub(startTime))\n```\n`Sprintf` 的时间是 3.549761ms，而 `Itoa` 的时间是 848.208us，相差 4 倍多。\n\n`Sprintf` 性能差些可以预见，因为它接收的是 `interface`，需要进行反射等操作。建议使用 `strconv` 包中的方法进行转换。\n\n\n## 字符串和布尔值之间的转换\n\nGo 中字符串和布尔值之间的转换比较简单，主要有三个函数：\n```go\n// 接受 1, t, T, TRUE, true, True, 0, f, F, FALSE, false, False 等字符串；\n// 其他形式的字符串会返回错误\n// 返回转换后的布尔值\nfunc ParseBool(str string) (value bool, err error)\n// 直接返回 \"true\" 或 \"false\"\nfunc FormatBool(b bool) string\n```\n\n\n## 字符串和浮点数之间的转换\n\n类似的，包含三个函数：\n```go\n// 无论 bitSize 取值如何，函数返回值类型都是 float64。\nfunc ParseFloat(s string, bitSize int) (f float64, err error)\n// 第一个参数是输入浮点数\n// 第二个是浮点数的显示格式（可以是 b, e, E, f, g, G）\nfunc FormatFloat(f float64, fmt byte, prec, bitSize int) string\n```\n\n`prec` 表示有效数字（对 `fmt='b'` 无效），对于 'e', 'E' 和 'f'，有效数字用于小数点之后的位数；\n对于 'g' 和 'G'，则是所有的有效数字。例如：\n```go\nstrconv.FormatFloat(1223.13252, 'e', 3, 32)\t// 结果：1.223e+03\nstrconv.FormatFloat(1223.13252, 'g', 3, 32)\t// 结果：1.22e+03\n```\n\n\n由于浮点数有精度的问题，精度不一样，`ParseFloat` 和 `FormatFloat` 可能达不到互逆的效果。如：\n```go\ns := strconv.FormatFloat(1234.5678, 'g', 6, 64)\nstrconv.ParseFloat(s, 64)\n```\n\n另外，`fmt='b'` 时，得到的字符串是无法通过 `ParseFloat` 还原的。\n\n同样的，基于性能的考虑，应该使用 `FormatFloat` 而不是 `fmt.Sprintf`。\n","source":"standards/text/strconv.md","raw":"---\ntitle: strconv\n---\n\n# strconv\n\n`strconv` 包包含了一系列字符串与相关的类型转换的函数。\n\n## 转换错误处理\n\n`strconv` 中的错误处理。\n\n由于将字符串转为其他数据类型可能会出错，*strconv* 包定义了两个 *error* 类型的变量：*ErrRange* 和 *ErrSyntax*。其中，*ErrRange* 表示\n值超过了类型能表示的最大范围，比如将 \"128\" 转为 `int8` 就会返回这个错误；*ErrSyntax* 表示语法错误，比如将 `\"\"` 转为 `int` 类型会返\n回这个错误。\n\n然而，在返回错误的时候，通过构造一个 *NumError* 类型的 *error* 对象返回。*NumError* 结构的定义如下：\n```go\n// A NumError records a failed conversion.\ntype NumError struct {\n    Func string // the failing function (ParseBool, ParseInt, ParseUint, ParseFloat)\n    Num  string // the input\n    Err  error  // the reason the conversion failed (ErrRange, ErrSyntax)\n}\n```\n\n该结构记录了转换过程中发生的错误信息。该结构不仅包含了一个 *error* 类型的成员，记录具体的错误信息，包的实现中，定义了两个便捷函数，\n用于构造 *NumError* 对象：\n```go\nfunc syntaxError(fn, str string) *NumError {\n    return &NumError{fn, str, ErrSyntax}\n}\n\nfunc rangeError(fn, str string) *NumError {\n    return &NumError{fn, str, ErrRange}\n}\n```\n\n\n## 字符串转为整型\n\n包括三个函数：`ParseInt`、`ParseUint` 和 `Atoi`，函数原型如下：\n```go\n// 转为有符号整型\nfunc ParseInt(s string, base int, bitSize int) (i int64, err error)\n// 转为无符号整型\nfunc ParseUint(s string, base int, bitSize int) (n uint64, err error)\nfunc Atoi(s string) (i int, err error)\n```\n\n**`Atoi` 内部通过调用 `ParseInt(s, 10, 0)` 来实现的**。\n\n### ParseInt\n```go\nfunc ParseInt(s string, base int, bitSize int) (i int64, err error)\n```\n参数：\n-  `base` 进制，取值为 `2~36`，如果 `base` 的值为 0，则会根据字符串的前缀来确定 `base` 的值：\n\"0x\" 表示 16 进制； \"0\" 表示 8 进制；否则就是 10 进制。\n- `bitSize` 表示的是整数取值范围，或者说整数的具体类型。取值 0、8、16、32 和 64 分别代表 `int`、`int8`、`int16`、`int32`\n和 `int64`。\n\nGo 中，`int/uint` 类型，不同系统能表示的范围是不一样的，目前的实现是，32 位系统占 4 个字节；64 位系统占 8 个字节。\n当 `bitSize==0` 时，应该表示 32 位还是 64 位呢？`strconv.IntSize` 变量用于获取程序运行的操作系统平台下 int 类型所占的位数。\n\n下面的代码 n 和 err 的值分别是什么？\n```go\nn, err := strconv.ParseInt(\"128\", 10, 8)\n```\n\t\n在 `ParseInt/ParseUint` 的实现中，如果字符串表示的整数超过了 `bitSize` 参数能够表示的范围，则会返回 `ErrRange`，同时会\n返回 `bitSize` 能够表示的最大或最小值。\n\n`int8` 占 8 位，最高位代表符号位 （1-负号；0-正号）。所以这里 n 是 127。\n\n另外，`ParseInt` 返回的是 `int64`，这是为了能够容纳所有的整型，在实际使用中，可以根据传递的 `bitSize`，然后将结果转为实\n际需要的类型。\n\n\n## 整型转为字符串\n\n遇到需要将字符串和整型连接起来，在 Go 语言中，你需要将整型转为字符串类型，然后才能进行连接。\n```go\n// 无符号整型转字符串\nfunc FormatUint(i uint64, base int) string\t\n// 有符号整型转字符串\nfunc FormatInt(i int64, base int) string\t\nfunc Itoa(i int) string\n```\n\n**`Itoa` 内部直接调用 *FormatInt(i, 10)* 实现的**。\n\n\n除了使用上述方法将整数转为字符串外，经常见到有人使用 *fmt* 包来做这件事。如：\n```go\nfmt.Sprintf(\"%d\", 127)\n```\n\n那么，这两种方式我们该怎么选择呢？我们主要来考察一下性能。\n```go\nstartTime := time.Now()\nfor i := 0; i < 10000; i++ {\n    fmt.Sprintf(\"%d\", i)\n}   \nfmt.Println(time.Now().Sub(startTime))\n\nstartTime := time.Now()\nfor i := 0; i < 10000; i++ {\n    strconv.Itoa(i)\n}   \nfmt.Println(time.Now().Sub(startTime))\n```\n`Sprintf` 的时间是 3.549761ms，而 `Itoa` 的时间是 848.208us，相差 4 倍多。\n\n`Sprintf` 性能差些可以预见，因为它接收的是 `interface`，需要进行反射等操作。建议使用 `strconv` 包中的方法进行转换。\n\n\n## 字符串和布尔值之间的转换\n\nGo 中字符串和布尔值之间的转换比较简单，主要有三个函数：\n```go\n// 接受 1, t, T, TRUE, true, True, 0, f, F, FALSE, false, False 等字符串；\n// 其他形式的字符串会返回错误\n// 返回转换后的布尔值\nfunc ParseBool(str string) (value bool, err error)\n// 直接返回 \"true\" 或 \"false\"\nfunc FormatBool(b bool) string\n```\n\n\n## 字符串和浮点数之间的转换\n\n类似的，包含三个函数：\n```go\n// 无论 bitSize 取值如何，函数返回值类型都是 float64。\nfunc ParseFloat(s string, bitSize int) (f float64, err error)\n// 第一个参数是输入浮点数\n// 第二个是浮点数的显示格式（可以是 b, e, E, f, g, G）\nfunc FormatFloat(f float64, fmt byte, prec, bitSize int) string\n```\n\n`prec` 表示有效数字（对 `fmt='b'` 无效），对于 'e', 'E' 和 'f'，有效数字用于小数点之后的位数；\n对于 'g' 和 'G'，则是所有的有效数字。例如：\n```go\nstrconv.FormatFloat(1223.13252, 'e', 3, 32)\t// 结果：1.223e+03\nstrconv.FormatFloat(1223.13252, 'g', 3, 32)\t// 结果：1.22e+03\n```\n\n\n由于浮点数有精度的问题，精度不一样，`ParseFloat` 和 `FormatFloat` 可能达不到互逆的效果。如：\n```go\ns := strconv.FormatFloat(1234.5678, 'g', 6, 64)\nstrconv.ParseFloat(s, 64)\n```\n\n另外，`fmt='b'` 时，得到的字符串是无法通过 `ParseFloat` 还原的。\n\n同样的，基于性能的考虑，应该使用 `FormatFloat` 而不是 `fmt.Sprintf`。\n","date":"2019-09-01T00:24:56.521Z","updated":"2019-09-01T00:24:56.494Z","path":"standards/text/strconv.html","comments":1,"layout":"page","_id":"ck1xm14l90012fcw2dn94y221","content":"<h1 id=\"strconv\"><a href=\"#strconv\" class=\"headerlink\" title=\"strconv\"></a>strconv</h1><p><code>strconv</code> 包包含了一系列字符串与相关的类型转换的函数。</p>\n<h2 id=\"转换错误处理\"><a href=\"#转换错误处理\" class=\"headerlink\" title=\"转换错误处理\"></a>转换错误处理</h2><p><code>strconv</code> 中的错误处理。</p>\n<p>由于将字符串转为其他数据类型可能会出错，<em>strconv</em> 包定义了两个 <em>error</em> 类型的变量：<em>ErrRange</em> 和 <em>ErrSyntax</em>。其中，<em>ErrRange</em> 表示<br>值超过了类型能表示的最大范围，比如将 “128” 转为 <code>int8</code> 就会返回这个错误；<em>ErrSyntax</em> 表示语法错误，比如将 <code>&quot;&quot;</code> 转为 <code>int</code> 类型会返<br>回这个错误。</p>\n<p>然而，在返回错误的时候，通过构造一个 <em>NumError</em> 类型的 <em>error</em> 对象返回。<em>NumError</em> 结构的定义如下：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// A NumError records a failed conversion.</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> NumError <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    Func <span class=\"keyword\">string</span> <span class=\"comment\">// the failing function (ParseBool, ParseInt, ParseUint, ParseFloat)</span></span><br><span class=\"line\">    Num  <span class=\"keyword\">string</span> <span class=\"comment\">// the input</span></span><br><span class=\"line\">    Err  error  <span class=\"comment\">// the reason the conversion failed (ErrRange, ErrSyntax)</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>该结构记录了转换过程中发生的错误信息。该结构不仅包含了一个 <em>error</em> 类型的成员，记录具体的错误信息，包的实现中，定义了两个便捷函数，<br>用于构造 <em>NumError</em> 对象：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">syntaxError</span><span class=\"params\">(fn, str <span class=\"keyword\">string</span>)</span> *<span class=\"title\">NumError</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &amp;NumError&#123;fn, str, ErrSyntax&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">rangeError</span><span class=\"params\">(fn, str <span class=\"keyword\">string</span>)</span> *<span class=\"title\">NumError</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &amp;NumError&#123;fn, str, ErrRange&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"字符串转为整型\"><a href=\"#字符串转为整型\" class=\"headerlink\" title=\"字符串转为整型\"></a>字符串转为整型</h2><p>包括三个函数：<code>ParseInt</code>、<code>ParseUint</code> 和 <code>Atoi</code>，函数原型如下：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 转为有符号整型</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">ParseInt</span><span class=\"params\">(s <span class=\"keyword\">string</span>, base <span class=\"keyword\">int</span>, bitSize <span class=\"keyword\">int</span>)</span> <span class=\"params\">(i <span class=\"keyword\">int64</span>, err error)</span></span></span><br><span class=\"line\"><span class=\"function\">// 转为无符号整型</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">ParseUint</span><span class=\"params\">(s <span class=\"keyword\">string</span>, base <span class=\"keyword\">int</span>, bitSize <span class=\"keyword\">int</span>)</span> <span class=\"params\">(n <span class=\"keyword\">uint64</span>, err error)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">Atoi</span><span class=\"params\">(s <span class=\"keyword\">string</span>)</span> <span class=\"params\">(i <span class=\"keyword\">int</span>, err error)</span></span></span><br></pre></td></tr></table></figure></p>\n<p><strong><code>Atoi</code> 内部通过调用 <code>ParseInt(s, 10, 0)</code> 来实现的</strong>。</p>\n<h3 id=\"ParseInt\"><a href=\"#ParseInt\" class=\"headerlink\" title=\"ParseInt\"></a>ParseInt</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">ParseInt</span><span class=\"params\">(s <span class=\"keyword\">string</span>, base <span class=\"keyword\">int</span>, bitSize <span class=\"keyword\">int</span>)</span> <span class=\"params\">(i <span class=\"keyword\">int64</span>, err error)</span></span></span><br></pre></td></tr></table></figure>\n<p>参数：</p>\n<ul>\n<li><code>base</code> 进制，取值为 <code>2~36</code>，如果 <code>base</code> 的值为 0，则会根据字符串的前缀来确定 <code>base</code> 的值：<br>“0x” 表示 16 进制； “0” 表示 8 进制；否则就是 10 进制。</li>\n<li><code>bitSize</code> 表示的是整数取值范围，或者说整数的具体类型。取值 0、8、16、32 和 64 分别代表 <code>int</code>、<code>int8</code>、<code>int16</code>、<code>int32</code><br>和 <code>int64</code>。</li>\n</ul>\n<p>Go 中，<code>int/uint</code> 类型，不同系统能表示的范围是不一样的，目前的实现是，32 位系统占 4 个字节；64 位系统占 8 个字节。<br>当 <code>bitSize==0</code> 时，应该表示 32 位还是 64 位呢？<code>strconv.IntSize</code> 变量用于获取程序运行的操作系统平台下 int 类型所占的位数。</p>\n<p>下面的代码 n 和 err 的值分别是什么？<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">n, err := strconv.ParseInt(<span class=\"string\">\"128\"</span>, <span class=\"number\">10</span>, <span class=\"number\">8</span>)</span><br></pre></td></tr></table></figure></p>\n<p>在 <code>ParseInt/ParseUint</code> 的实现中，如果字符串表示的整数超过了 <code>bitSize</code> 参数能够表示的范围，则会返回 <code>ErrRange</code>，同时会<br>返回 <code>bitSize</code> 能够表示的最大或最小值。</p>\n<p><code>int8</code> 占 8 位，最高位代表符号位 （1-负号；0-正号）。所以这里 n 是 127。</p>\n<p>另外，<code>ParseInt</code> 返回的是 <code>int64</code>，这是为了能够容纳所有的整型，在实际使用中，可以根据传递的 <code>bitSize</code>，然后将结果转为实<br>际需要的类型。</p>\n<h2 id=\"整型转为字符串\"><a href=\"#整型转为字符串\" class=\"headerlink\" title=\"整型转为字符串\"></a>整型转为字符串</h2><p>遇到需要将字符串和整型连接起来，在 Go 语言中，你需要将整型转为字符串类型，然后才能进行连接。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 无符号整型转字符串</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">FormatUint</span><span class=\"params\">(i <span class=\"keyword\">uint64</span>, base <span class=\"keyword\">int</span>)</span> <span class=\"title\">string</span>\t</span></span><br><span class=\"line\"><span class=\"function\">// 有符号整型转字符串</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">FormatInt</span><span class=\"params\">(i <span class=\"keyword\">int64</span>, base <span class=\"keyword\">int</span>)</span> <span class=\"title\">string</span>\t</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">Itoa</span><span class=\"params\">(i <span class=\"keyword\">int</span>)</span> <span class=\"title\">string</span></span></span><br></pre></td></tr></table></figure></p>\n<p><strong><code>Itoa</code> 内部直接调用 <em>FormatInt(i, 10)</em> 实现的</strong>。</p>\n<p>除了使用上述方法将整数转为字符串外，经常见到有人使用 <em>fmt</em> 包来做这件事。如：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fmt.Sprintf(<span class=\"string\">\"%d\"</span>, <span class=\"number\">127</span>)</span><br></pre></td></tr></table></figure></p>\n<p>那么，这两种方式我们该怎么选择呢？我们主要来考察一下性能。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">startTime := time.Now()</span><br><span class=\"line\"><span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">10000</span>; i++ &#123;</span><br><span class=\"line\">    fmt.Sprintf(<span class=\"string\">\"%d\"</span>, i)</span><br><span class=\"line\">&#125;   </span><br><span class=\"line\">fmt.Println(time.Now().Sub(startTime))</span><br><span class=\"line\"></span><br><span class=\"line\">startTime := time.Now()</span><br><span class=\"line\"><span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">10000</span>; i++ &#123;</span><br><span class=\"line\">    strconv.Itoa(i)</span><br><span class=\"line\">&#125;   </span><br><span class=\"line\">fmt.Println(time.Now().Sub(startTime))</span><br></pre></td></tr></table></figure></p>\n<p><code>Sprintf</code> 的时间是 3.549761ms，而 <code>Itoa</code> 的时间是 848.208us，相差 4 倍多。</p>\n<p><code>Sprintf</code> 性能差些可以预见，因为它接收的是 <code>interface</code>，需要进行反射等操作。建议使用 <code>strconv</code> 包中的方法进行转换。</p>\n<h2 id=\"字符串和布尔值之间的转换\"><a href=\"#字符串和布尔值之间的转换\" class=\"headerlink\" title=\"字符串和布尔值之间的转换\"></a>字符串和布尔值之间的转换</h2><p>Go 中字符串和布尔值之间的转换比较简单，主要有三个函数：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 接受 1, t, T, TRUE, true, True, 0, f, F, FALSE, false, False 等字符串；</span></span><br><span class=\"line\"><span class=\"comment\">// 其他形式的字符串会返回错误</span></span><br><span class=\"line\"><span class=\"comment\">// 返回转换后的布尔值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">ParseBool</span><span class=\"params\">(str <span class=\"keyword\">string</span>)</span> <span class=\"params\">(value <span class=\"keyword\">bool</span>, err error)</span></span></span><br><span class=\"line\"><span class=\"function\">// 直接返回 \"<span class=\"title\">true</span>\" 或 \"<span class=\"title\">false</span>\"</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">FormatBool</span><span class=\"params\">(b <span class=\"keyword\">bool</span>)</span> <span class=\"title\">string</span></span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"字符串和浮点数之间的转换\"><a href=\"#字符串和浮点数之间的转换\" class=\"headerlink\" title=\"字符串和浮点数之间的转换\"></a>字符串和浮点数之间的转换</h2><p>类似的，包含三个函数：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 无论 bitSize 取值如何，函数返回值类型都是 float64。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">ParseFloat</span><span class=\"params\">(s <span class=\"keyword\">string</span>, bitSize <span class=\"keyword\">int</span>)</span> <span class=\"params\">(f <span class=\"keyword\">float64</span>, err error)</span></span></span><br><span class=\"line\"><span class=\"function\">// 第一个参数是输入浮点数</span></span><br><span class=\"line\"><span class=\"function\">// 第二个是浮点数的显示格式（可以是 <span class=\"title\">b</span>, <span class=\"title\">e</span>, <span class=\"title\">E</span>, <span class=\"title\">f</span>, <span class=\"title\">g</span>, <span class=\"title\">G</span>）</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">FormatFloat</span><span class=\"params\">(f <span class=\"keyword\">float64</span>, fmt <span class=\"keyword\">byte</span>, prec, bitSize <span class=\"keyword\">int</span>)</span> <span class=\"title\">string</span></span></span><br></pre></td></tr></table></figure></p>\n<p><code>prec</code> 表示有效数字（对 <code>fmt=&#39;b&#39;</code> 无效），对于 ‘e’, ‘E’ 和 ‘f’，有效数字用于小数点之后的位数；<br>对于 ‘g’ 和 ‘G’，则是所有的有效数字。例如：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">strconv.FormatFloat(<span class=\"number\">1223.13252</span>, <span class=\"string\">'e'</span>, <span class=\"number\">3</span>, <span class=\"number\">32</span>)\t<span class=\"comment\">// 结果：1.223e+03</span></span><br><span class=\"line\">strconv.FormatFloat(<span class=\"number\">1223.13252</span>, <span class=\"string\">'g'</span>, <span class=\"number\">3</span>, <span class=\"number\">32</span>)\t<span class=\"comment\">// 结果：1.22e+03</span></span><br></pre></td></tr></table></figure></p>\n<p>由于浮点数有精度的问题，精度不一样，<code>ParseFloat</code> 和 <code>FormatFloat</code> 可能达不到互逆的效果。如：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s := strconv.FormatFloat(<span class=\"number\">1234.5678</span>, <span class=\"string\">'g'</span>, <span class=\"number\">6</span>, <span class=\"number\">64</span>)</span><br><span class=\"line\">strconv.ParseFloat(s, <span class=\"number\">64</span>)</span><br></pre></td></tr></table></figure></p>\n<p>另外，<code>fmt=&#39;b&#39;</code> 时，得到的字符串是无法通过 <code>ParseFloat</code> 还原的。</p>\n<p>同样的，基于性能的考虑，应该使用 <code>FormatFloat</code> 而不是 <code>fmt.Sprintf</code>。</p>\n","site":{"data":{"navigation":{"logo":{"text":"Golang Learn","type":"link","path":"index.html"},"main":[{"text":"Golang 基础","type":"label"},{"text":"Go 环境配置","type":"link","path":"basic/env_config.html"},{"text":"包","type":"link","path":"basic/package.html"},{"text":"基础数据类型","type":"link","path":"basic/basic_data.html"},{"text":"变量","type":"link","path":"basic/var.html"},{"text":"常量","type":"link","path":"basic/constant.html"},{"text":"控制语句","type":"link","path":"basic/flow.html"},{"text":"运算符","type":"link","path":"basic/operator.html"},{"text":"作用域","type":"link","path":"basic/scope.html"},{"text":"指针","type":"link","path":"basic/pointer.html"},{"text":"数组","type":"link","path":"basic/array.html"},{"text":"切片","type":"link","path":"basic/slice.html"},{"text":"字典","type":"link","path":"basic/map.html"},{"text":"函数","type":"link","path":"basic/function.html"},{"text":"结构体","type":"link","path":"basic/struct.html"},{"text":"接口","type":"link","path":"basic/interface.html"},{"text":"面向对象","type":"link","path":"basic/oop.html"},{"text":"错误","type":"link","path":"basic/error.html"},{"text":"序列化","type":"link","path":"basic/json.html"},{"text":"反射","type":"link","path":"basic/reflect.html"},{"text":"测试","type":"link","path":"basic/test.html"},{"text":"并发编程","type":"label"},{"text":"goroutine","type":"link","path":"concurrent/goroutine.html"},{"text":"channel","type":"link","path":"concurrent/channel.html"},{"text":"同步和锁","type":"link","path":"concurrent/sync_lock.html"},{"text":"内存分配","type":"label"},{"text":"内存分配","type":"link","path":"advance/mm.html"},{"text":"垃圾回收","type":"label"},{"text":"垃圾回收","type":"link","path":"advance/gc.html"},{"text":"标准库","type":"label"},{"text":"fmt","type":"link","path":"standards/io/fmt.html"},{"text":"io","type":"link","path":"standards/io/io.html"},{"text":"ioutil","type":"link","path":"standards/io/ioutil.html"},{"text":"bufio","type":"link","path":"standards/io/bufio.html"},{"text":"os","type":"link","path":"standards/os/os.html"},{"text":"filepath","type":"link","path":"standards/os/filepath.html"},{"text":"strings","type":"link","path":"standards/text/strings.html"},{"text":"strconv","type":"link","path":"standards/text/strconv.html"},{"text":"unicode","type":"link","path":"standards/text/unicode.html"},{"text":"log","type":"link","path":"standards/log.html"},{"text":"time","type":"link","path":"standards/time.html"},{"text":"http","type":"link","path":"standards/net/http.html"},{"text":"math","type":"link","path":"standards/data/math.html"},{"text":"sort","type":"link","path":"standards/data/sort.html"},{"text":"big","type":"link","path":"standards/data/big.html"},{"text":"container","type":"link","path":"standards/data/container.html"},{"text":"sql","type":"link","path":"standards/database/sql.html"},{"text":"THEME","type":"label"},{"text":"使用文档主题","type":"link","path":"theme/theme-usage.html"},{"text":"SUPPORT AND FEEDBACK","type":"label"},{"text":"Raise an Issue on Github","type":"link","path":"https://github.com/shipengqi/golang-learn/issues/new"}]}}},"excerpt":"","more":"<h1 id=\"strconv\"><a href=\"#strconv\" class=\"headerlink\" title=\"strconv\"></a>strconv</h1><p><code>strconv</code> 包包含了一系列字符串与相关的类型转换的函数。</p>\n<h2 id=\"转换错误处理\"><a href=\"#转换错误处理\" class=\"headerlink\" title=\"转换错误处理\"></a>转换错误处理</h2><p><code>strconv</code> 中的错误处理。</p>\n<p>由于将字符串转为其他数据类型可能会出错，<em>strconv</em> 包定义了两个 <em>error</em> 类型的变量：<em>ErrRange</em> 和 <em>ErrSyntax</em>。其中，<em>ErrRange</em> 表示<br>值超过了类型能表示的最大范围，比如将 “128” 转为 <code>int8</code> 就会返回这个错误；<em>ErrSyntax</em> 表示语法错误，比如将 <code>&quot;&quot;</code> 转为 <code>int</code> 类型会返<br>回这个错误。</p>\n<p>然而，在返回错误的时候，通过构造一个 <em>NumError</em> 类型的 <em>error</em> 对象返回。<em>NumError</em> 结构的定义如下：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// A NumError records a failed conversion.</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> NumError <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    Func <span class=\"keyword\">string</span> <span class=\"comment\">// the failing function (ParseBool, ParseInt, ParseUint, ParseFloat)</span></span><br><span class=\"line\">    Num  <span class=\"keyword\">string</span> <span class=\"comment\">// the input</span></span><br><span class=\"line\">    Err  error  <span class=\"comment\">// the reason the conversion failed (ErrRange, ErrSyntax)</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>该结构记录了转换过程中发生的错误信息。该结构不仅包含了一个 <em>error</em> 类型的成员，记录具体的错误信息，包的实现中，定义了两个便捷函数，<br>用于构造 <em>NumError</em> 对象：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">syntaxError</span><span class=\"params\">(fn, str <span class=\"keyword\">string</span>)</span> *<span class=\"title\">NumError</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &amp;NumError&#123;fn, str, ErrSyntax&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">rangeError</span><span class=\"params\">(fn, str <span class=\"keyword\">string</span>)</span> *<span class=\"title\">NumError</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &amp;NumError&#123;fn, str, ErrRange&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"字符串转为整型\"><a href=\"#字符串转为整型\" class=\"headerlink\" title=\"字符串转为整型\"></a>字符串转为整型</h2><p>包括三个函数：<code>ParseInt</code>、<code>ParseUint</code> 和 <code>Atoi</code>，函数原型如下：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 转为有符号整型</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">ParseInt</span><span class=\"params\">(s <span class=\"keyword\">string</span>, base <span class=\"keyword\">int</span>, bitSize <span class=\"keyword\">int</span>)</span> <span class=\"params\">(i <span class=\"keyword\">int64</span>, err error)</span></span></span><br><span class=\"line\"><span class=\"function\">// 转为无符号整型</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">ParseUint</span><span class=\"params\">(s <span class=\"keyword\">string</span>, base <span class=\"keyword\">int</span>, bitSize <span class=\"keyword\">int</span>)</span> <span class=\"params\">(n <span class=\"keyword\">uint64</span>, err error)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">Atoi</span><span class=\"params\">(s <span class=\"keyword\">string</span>)</span> <span class=\"params\">(i <span class=\"keyword\">int</span>, err error)</span></span></span><br></pre></td></tr></table></figure></p>\n<p><strong><code>Atoi</code> 内部通过调用 <code>ParseInt(s, 10, 0)</code> 来实现的</strong>。</p>\n<h3 id=\"ParseInt\"><a href=\"#ParseInt\" class=\"headerlink\" title=\"ParseInt\"></a>ParseInt</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">ParseInt</span><span class=\"params\">(s <span class=\"keyword\">string</span>, base <span class=\"keyword\">int</span>, bitSize <span class=\"keyword\">int</span>)</span> <span class=\"params\">(i <span class=\"keyword\">int64</span>, err error)</span></span></span><br></pre></td></tr></table></figure>\n<p>参数：</p>\n<ul>\n<li><code>base</code> 进制，取值为 <code>2~36</code>，如果 <code>base</code> 的值为 0，则会根据字符串的前缀来确定 <code>base</code> 的值：<br>“0x” 表示 16 进制； “0” 表示 8 进制；否则就是 10 进制。</li>\n<li><code>bitSize</code> 表示的是整数取值范围，或者说整数的具体类型。取值 0、8、16、32 和 64 分别代表 <code>int</code>、<code>int8</code>、<code>int16</code>、<code>int32</code><br>和 <code>int64</code>。</li>\n</ul>\n<p>Go 中，<code>int/uint</code> 类型，不同系统能表示的范围是不一样的，目前的实现是，32 位系统占 4 个字节；64 位系统占 8 个字节。<br>当 <code>bitSize==0</code> 时，应该表示 32 位还是 64 位呢？<code>strconv.IntSize</code> 变量用于获取程序运行的操作系统平台下 int 类型所占的位数。</p>\n<p>下面的代码 n 和 err 的值分别是什么？<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">n, err := strconv.ParseInt(<span class=\"string\">\"128\"</span>, <span class=\"number\">10</span>, <span class=\"number\">8</span>)</span><br></pre></td></tr></table></figure></p>\n<p>在 <code>ParseInt/ParseUint</code> 的实现中，如果字符串表示的整数超过了 <code>bitSize</code> 参数能够表示的范围，则会返回 <code>ErrRange</code>，同时会<br>返回 <code>bitSize</code> 能够表示的最大或最小值。</p>\n<p><code>int8</code> 占 8 位，最高位代表符号位 （1-负号；0-正号）。所以这里 n 是 127。</p>\n<p>另外，<code>ParseInt</code> 返回的是 <code>int64</code>，这是为了能够容纳所有的整型，在实际使用中，可以根据传递的 <code>bitSize</code>，然后将结果转为实<br>际需要的类型。</p>\n<h2 id=\"整型转为字符串\"><a href=\"#整型转为字符串\" class=\"headerlink\" title=\"整型转为字符串\"></a>整型转为字符串</h2><p>遇到需要将字符串和整型连接起来，在 Go 语言中，你需要将整型转为字符串类型，然后才能进行连接。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 无符号整型转字符串</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">FormatUint</span><span class=\"params\">(i <span class=\"keyword\">uint64</span>, base <span class=\"keyword\">int</span>)</span> <span class=\"title\">string</span>\t</span></span><br><span class=\"line\"><span class=\"function\">// 有符号整型转字符串</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">FormatInt</span><span class=\"params\">(i <span class=\"keyword\">int64</span>, base <span class=\"keyword\">int</span>)</span> <span class=\"title\">string</span>\t</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">Itoa</span><span class=\"params\">(i <span class=\"keyword\">int</span>)</span> <span class=\"title\">string</span></span></span><br></pre></td></tr></table></figure></p>\n<p><strong><code>Itoa</code> 内部直接调用 <em>FormatInt(i, 10)</em> 实现的</strong>。</p>\n<p>除了使用上述方法将整数转为字符串外，经常见到有人使用 <em>fmt</em> 包来做这件事。如：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fmt.Sprintf(<span class=\"string\">\"%d\"</span>, <span class=\"number\">127</span>)</span><br></pre></td></tr></table></figure></p>\n<p>那么，这两种方式我们该怎么选择呢？我们主要来考察一下性能。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">startTime := time.Now()</span><br><span class=\"line\"><span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">10000</span>; i++ &#123;</span><br><span class=\"line\">    fmt.Sprintf(<span class=\"string\">\"%d\"</span>, i)</span><br><span class=\"line\">&#125;   </span><br><span class=\"line\">fmt.Println(time.Now().Sub(startTime))</span><br><span class=\"line\"></span><br><span class=\"line\">startTime := time.Now()</span><br><span class=\"line\"><span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">10000</span>; i++ &#123;</span><br><span class=\"line\">    strconv.Itoa(i)</span><br><span class=\"line\">&#125;   </span><br><span class=\"line\">fmt.Println(time.Now().Sub(startTime))</span><br></pre></td></tr></table></figure></p>\n<p><code>Sprintf</code> 的时间是 3.549761ms，而 <code>Itoa</code> 的时间是 848.208us，相差 4 倍多。</p>\n<p><code>Sprintf</code> 性能差些可以预见，因为它接收的是 <code>interface</code>，需要进行反射等操作。建议使用 <code>strconv</code> 包中的方法进行转换。</p>\n<h2 id=\"字符串和布尔值之间的转换\"><a href=\"#字符串和布尔值之间的转换\" class=\"headerlink\" title=\"字符串和布尔值之间的转换\"></a>字符串和布尔值之间的转换</h2><p>Go 中字符串和布尔值之间的转换比较简单，主要有三个函数：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 接受 1, t, T, TRUE, true, True, 0, f, F, FALSE, false, False 等字符串；</span></span><br><span class=\"line\"><span class=\"comment\">// 其他形式的字符串会返回错误</span></span><br><span class=\"line\"><span class=\"comment\">// 返回转换后的布尔值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">ParseBool</span><span class=\"params\">(str <span class=\"keyword\">string</span>)</span> <span class=\"params\">(value <span class=\"keyword\">bool</span>, err error)</span></span></span><br><span class=\"line\"><span class=\"function\">// 直接返回 \"<span class=\"title\">true</span>\" 或 \"<span class=\"title\">false</span>\"</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">FormatBool</span><span class=\"params\">(b <span class=\"keyword\">bool</span>)</span> <span class=\"title\">string</span></span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"字符串和浮点数之间的转换\"><a href=\"#字符串和浮点数之间的转换\" class=\"headerlink\" title=\"字符串和浮点数之间的转换\"></a>字符串和浮点数之间的转换</h2><p>类似的，包含三个函数：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 无论 bitSize 取值如何，函数返回值类型都是 float64。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">ParseFloat</span><span class=\"params\">(s <span class=\"keyword\">string</span>, bitSize <span class=\"keyword\">int</span>)</span> <span class=\"params\">(f <span class=\"keyword\">float64</span>, err error)</span></span></span><br><span class=\"line\"><span class=\"function\">// 第一个参数是输入浮点数</span></span><br><span class=\"line\"><span class=\"function\">// 第二个是浮点数的显示格式（可以是 <span class=\"title\">b</span>, <span class=\"title\">e</span>, <span class=\"title\">E</span>, <span class=\"title\">f</span>, <span class=\"title\">g</span>, <span class=\"title\">G</span>）</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">FormatFloat</span><span class=\"params\">(f <span class=\"keyword\">float64</span>, fmt <span class=\"keyword\">byte</span>, prec, bitSize <span class=\"keyword\">int</span>)</span> <span class=\"title\">string</span></span></span><br></pre></td></tr></table></figure></p>\n<p><code>prec</code> 表示有效数字（对 <code>fmt=&#39;b&#39;</code> 无效），对于 ‘e’, ‘E’ 和 ‘f’，有效数字用于小数点之后的位数；<br>对于 ‘g’ 和 ‘G’，则是所有的有效数字。例如：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">strconv.FormatFloat(<span class=\"number\">1223.13252</span>, <span class=\"string\">'e'</span>, <span class=\"number\">3</span>, <span class=\"number\">32</span>)\t<span class=\"comment\">// 结果：1.223e+03</span></span><br><span class=\"line\">strconv.FormatFloat(<span class=\"number\">1223.13252</span>, <span class=\"string\">'g'</span>, <span class=\"number\">3</span>, <span class=\"number\">32</span>)\t<span class=\"comment\">// 结果：1.22e+03</span></span><br></pre></td></tr></table></figure></p>\n<p>由于浮点数有精度的问题，精度不一样，<code>ParseFloat</code> 和 <code>FormatFloat</code> 可能达不到互逆的效果。如：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s := strconv.FormatFloat(<span class=\"number\">1234.5678</span>, <span class=\"string\">'g'</span>, <span class=\"number\">6</span>, <span class=\"number\">64</span>)</span><br><span class=\"line\">strconv.ParseFloat(s, <span class=\"number\">64</span>)</span><br></pre></td></tr></table></figure></p>\n<p>另外，<code>fmt=&#39;b&#39;</code> 时，得到的字符串是无法通过 <code>ParseFloat</code> 还原的。</p>\n<p>同样的，基于性能的考虑，应该使用 <code>FormatFloat</code> 而不是 <code>fmt.Sprintf</code>。</p>\n"},{"title":"反射","_content":"\n# 反射\n\n反射机制，能够在运行时更新变量和检查它们的值、调用它们的方法和它们支持的内在操作，而不需要在编译时就知道\n这些变量的具体类型。弥补了静态语言在动态行为上的一些不足。\n\n## reflect.TypeOf\n`reflect.TypeOf` 获取类型信息。\n`reflect.TypeOf` 接受任意的 `interface{}` 类型, 并以 `reflect.Type` 形式返回其动态类型：\n```go\nt := reflect.TypeOf(3)  // a reflect.Type\nfmt.Println(t.String()) // \"int\"\nfmt.Println(t)          // \"int\"\n\ntype X int\nfunc main() {\n\tvar a X = 20\n\tt := reflect.TypeOf(a)\n\tfmt.Println(t.Name(), t.Kind()) // X int\n}\n```\n\n上面的代码，**注意区分 Type 和 Kind，前者表示真实类型（静态类型），后者表示底层类型**。所以在判断类型时，\n要选择正确的方式。\n```go\ntype X int\ntype Y int\nfunc main() {\n\tvar a, b X = 10, 20\n\tvar c Y = 30\n\tta, tb, tc := reflect.TypeOf(a), reflect.TypeOf(b), reflect.TypeOf(c)\n\tfmt.Println(ta == tb, ta == tc) // true false\n\tfmt.Println(ta.Kind() == tc.Kind()) // true\n}\n```\n\n## reflect.ValueOf\n`reflect.ValueOf` 专注于对象实例数据读写。\n`reflect.ValueOf` 接受任意的 `interface{}` 类型, 并以 `reflect.Value` 形式返回其动态值：\n```go\nv := reflect.ValueOf(3) // a reflect.Value\nfmt.Println(v)          // \"3\"\nfmt.Printf(\"%v\\n\", v)   // \"3\"\nfmt.Println(v.String()) // NOTE: \"<int Value>\"\n\nx := struct {\n    Name string\n}{expected}\nval := reflect.ValueOf(x)\nfield := val.Field(0)\nfmt.Println(val)            // {Chris}\nfmt.Println(field)          //  Chris\nfmt.Println(field.String()) // Chris\n```\n\n在 Go 中不能对切片使用等号运算符。你可以写一个函数迭代每个元素来检查它们的值。但是一种\n比较简单的办法是使用 `reflect.DeepEqual`，它在判断两个变量是否相等时十分有用。\n\n```go\nfunc TestSumAll(t *testing.T) {\n\n    got := SumAll([]int{1,2}, []int{0,9})\n    want := []int{3, 9}\n\n    if !reflect.DeepEqual(got, want) {\n        t.Errorf(\"got %v want %v\", got, want)\n    }\n}\n```\n\n**注意**，`reflect.DeepEqual` 不是「类型安全」的，所以有时候会发生比较怪异的行为。比如：\n```go\nfunc TestSumAll(t *testing.T) {\n\n    got := SumAll([]int{1,2}, []int{0,9})\n    want := \"bob\"\n\n    if !reflect.DeepEqual(got, want) {\n        t.Errorf(\"got %v want %v\", got, want)\n    }\n}\n```\n尝试比较 `slice` 和 `string`。这显然是不合理的，但是却通过了测试。所以使用 `reflect.DeepEqual` 比较简洁但是在使用时需多加小心。","source":"basic/reflect.md","raw":"---\ntitle: 反射\n---\n\n# 反射\n\n反射机制，能够在运行时更新变量和检查它们的值、调用它们的方法和它们支持的内在操作，而不需要在编译时就知道\n这些变量的具体类型。弥补了静态语言在动态行为上的一些不足。\n\n## reflect.TypeOf\n`reflect.TypeOf` 获取类型信息。\n`reflect.TypeOf` 接受任意的 `interface{}` 类型, 并以 `reflect.Type` 形式返回其动态类型：\n```go\nt := reflect.TypeOf(3)  // a reflect.Type\nfmt.Println(t.String()) // \"int\"\nfmt.Println(t)          // \"int\"\n\ntype X int\nfunc main() {\n\tvar a X = 20\n\tt := reflect.TypeOf(a)\n\tfmt.Println(t.Name(), t.Kind()) // X int\n}\n```\n\n上面的代码，**注意区分 Type 和 Kind，前者表示真实类型（静态类型），后者表示底层类型**。所以在判断类型时，\n要选择正确的方式。\n```go\ntype X int\ntype Y int\nfunc main() {\n\tvar a, b X = 10, 20\n\tvar c Y = 30\n\tta, tb, tc := reflect.TypeOf(a), reflect.TypeOf(b), reflect.TypeOf(c)\n\tfmt.Println(ta == tb, ta == tc) // true false\n\tfmt.Println(ta.Kind() == tc.Kind()) // true\n}\n```\n\n## reflect.ValueOf\n`reflect.ValueOf` 专注于对象实例数据读写。\n`reflect.ValueOf` 接受任意的 `interface{}` 类型, 并以 `reflect.Value` 形式返回其动态值：\n```go\nv := reflect.ValueOf(3) // a reflect.Value\nfmt.Println(v)          // \"3\"\nfmt.Printf(\"%v\\n\", v)   // \"3\"\nfmt.Println(v.String()) // NOTE: \"<int Value>\"\n\nx := struct {\n    Name string\n}{expected}\nval := reflect.ValueOf(x)\nfield := val.Field(0)\nfmt.Println(val)            // {Chris}\nfmt.Println(field)          //  Chris\nfmt.Println(field.String()) // Chris\n```\n\n在 Go 中不能对切片使用等号运算符。你可以写一个函数迭代每个元素来检查它们的值。但是一种\n比较简单的办法是使用 `reflect.DeepEqual`，它在判断两个变量是否相等时十分有用。\n\n```go\nfunc TestSumAll(t *testing.T) {\n\n    got := SumAll([]int{1,2}, []int{0,9})\n    want := []int{3, 9}\n\n    if !reflect.DeepEqual(got, want) {\n        t.Errorf(\"got %v want %v\", got, want)\n    }\n}\n```\n\n**注意**，`reflect.DeepEqual` 不是「类型安全」的，所以有时候会发生比较怪异的行为。比如：\n```go\nfunc TestSumAll(t *testing.T) {\n\n    got := SumAll([]int{1,2}, []int{0,9})\n    want := \"bob\"\n\n    if !reflect.DeepEqual(got, want) {\n        t.Errorf(\"got %v want %v\", got, want)\n    }\n}\n```\n尝试比较 `slice` 和 `string`。这显然是不合理的，但是却通过了测试。所以使用 `reflect.DeepEqual` 比较简洁但是在使用时需多加小心。","date":"2019-08-24T07:52:49.307Z","updated":"2019-08-24T07:52:49.252Z","path":"basic/reflect.html","comments":1,"layout":"page","_id":"ck1xm14lc0013fcw2euvu7qsn","content":"<h1 id=\"反射\"><a href=\"#反射\" class=\"headerlink\" title=\"反射\"></a>反射</h1><p>反射机制，能够在运行时更新变量和检查它们的值、调用它们的方法和它们支持的内在操作，而不需要在编译时就知道<br>这些变量的具体类型。弥补了静态语言在动态行为上的一些不足。</p>\n<h2 id=\"reflect-TypeOf\"><a href=\"#reflect-TypeOf\" class=\"headerlink\" title=\"reflect.TypeOf\"></a>reflect.TypeOf</h2><p><code>reflect.TypeOf</code> 获取类型信息。<br><code>reflect.TypeOf</code> 接受任意的 <code>interface{}</code> 类型, 并以 <code>reflect.Type</code> 形式返回其动态类型：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">t := reflect.TypeOf(<span class=\"number\">3</span>)  <span class=\"comment\">// a reflect.Type</span></span><br><span class=\"line\">fmt.Println(t.String()) <span class=\"comment\">// \"int\"</span></span><br><span class=\"line\">fmt.Println(t)          <span class=\"comment\">// \"int\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> X <span class=\"keyword\">int</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> a X = <span class=\"number\">20</span></span><br><span class=\"line\">\tt := reflect.TypeOf(a)</span><br><span class=\"line\">\tfmt.Println(t.Name(), t.Kind()) <span class=\"comment\">// X int</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面的代码，<strong>注意区分 Type 和 Kind，前者表示真实类型（静态类型），后者表示底层类型</strong>。所以在判断类型时，<br>要选择正确的方式。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> X <span class=\"keyword\">int</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Y <span class=\"keyword\">int</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> a, b X = <span class=\"number\">10</span>, <span class=\"number\">20</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> c Y = <span class=\"number\">30</span></span><br><span class=\"line\">\tta, tb, tc := reflect.TypeOf(a), reflect.TypeOf(b), reflect.TypeOf(c)</span><br><span class=\"line\">\tfmt.Println(ta == tb, ta == tc) <span class=\"comment\">// true false</span></span><br><span class=\"line\">\tfmt.Println(ta.Kind() == tc.Kind()) <span class=\"comment\">// true</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"reflect-ValueOf\"><a href=\"#reflect-ValueOf\" class=\"headerlink\" title=\"reflect.ValueOf\"></a>reflect.ValueOf</h2><p><code>reflect.ValueOf</code> 专注于对象实例数据读写。<br><code>reflect.ValueOf</code> 接受任意的 <code>interface{}</code> 类型, 并以 <code>reflect.Value</code> 形式返回其动态值：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">v := reflect.ValueOf(<span class=\"number\">3</span>) <span class=\"comment\">// a reflect.Value</span></span><br><span class=\"line\">fmt.Println(v)          <span class=\"comment\">// \"3\"</span></span><br><span class=\"line\">fmt.Printf(<span class=\"string\">\"%v\\n\"</span>, v)   <span class=\"comment\">// \"3\"</span></span><br><span class=\"line\">fmt.Println(v.String()) <span class=\"comment\">// <span class=\"doctag\">NOTE:</span> \"&lt;int Value&gt;\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">x := <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    Name <span class=\"keyword\">string</span></span><br><span class=\"line\">&#125;&#123;expected&#125;</span><br><span class=\"line\">val := reflect.ValueOf(x)</span><br><span class=\"line\">field := val.Field(<span class=\"number\">0</span>)</span><br><span class=\"line\">fmt.Println(val)            <span class=\"comment\">// &#123;Chris&#125;</span></span><br><span class=\"line\">fmt.Println(field)          <span class=\"comment\">//  Chris</span></span><br><span class=\"line\">fmt.Println(field.String()) <span class=\"comment\">// Chris</span></span><br></pre></td></tr></table></figure></p>\n<p>在 Go 中不能对切片使用等号运算符。你可以写一个函数迭代每个元素来检查它们的值。但是一种<br>比较简单的办法是使用 <code>reflect.DeepEqual</code>，它在判断两个变量是否相等时十分有用。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestSumAll</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    got := SumAll([]<span class=\"keyword\">int</span>&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>&#125;, []<span class=\"keyword\">int</span>&#123;<span class=\"number\">0</span>,<span class=\"number\">9</span>&#125;)</span><br><span class=\"line\">    want := []<span class=\"keyword\">int</span>&#123;<span class=\"number\">3</span>, <span class=\"number\">9</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> !reflect.DeepEqual(got, want) &#123;</span><br><span class=\"line\">        t.Errorf(<span class=\"string\">\"got %v want %v\"</span>, got, want)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>注意</strong>，<code>reflect.DeepEqual</code> 不是「类型安全」的，所以有时候会发生比较怪异的行为。比如：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestSumAll</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    got := SumAll([]<span class=\"keyword\">int</span>&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>&#125;, []<span class=\"keyword\">int</span>&#123;<span class=\"number\">0</span>,<span class=\"number\">9</span>&#125;)</span><br><span class=\"line\">    want := <span class=\"string\">\"bob\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> !reflect.DeepEqual(got, want) &#123;</span><br><span class=\"line\">        t.Errorf(<span class=\"string\">\"got %v want %v\"</span>, got, want)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>尝试比较 <code>slice</code> 和 <code>string</code>。这显然是不合理的，但是却通过了测试。所以使用 <code>reflect.DeepEqual</code> 比较简洁但是在使用时需多加小心。</p>\n","site":{"data":{"navigation":{"logo":{"text":"Golang Learn","type":"link","path":"index.html"},"main":[{"text":"Golang 基础","type":"label"},{"text":"Go 环境配置","type":"link","path":"basic/env_config.html"},{"text":"包","type":"link","path":"basic/package.html"},{"text":"基础数据类型","type":"link","path":"basic/basic_data.html"},{"text":"变量","type":"link","path":"basic/var.html"},{"text":"常量","type":"link","path":"basic/constant.html"},{"text":"控制语句","type":"link","path":"basic/flow.html"},{"text":"运算符","type":"link","path":"basic/operator.html"},{"text":"作用域","type":"link","path":"basic/scope.html"},{"text":"指针","type":"link","path":"basic/pointer.html"},{"text":"数组","type":"link","path":"basic/array.html"},{"text":"切片","type":"link","path":"basic/slice.html"},{"text":"字典","type":"link","path":"basic/map.html"},{"text":"函数","type":"link","path":"basic/function.html"},{"text":"结构体","type":"link","path":"basic/struct.html"},{"text":"接口","type":"link","path":"basic/interface.html"},{"text":"面向对象","type":"link","path":"basic/oop.html"},{"text":"错误","type":"link","path":"basic/error.html"},{"text":"序列化","type":"link","path":"basic/json.html"},{"text":"反射","type":"link","path":"basic/reflect.html"},{"text":"测试","type":"link","path":"basic/test.html"},{"text":"并发编程","type":"label"},{"text":"goroutine","type":"link","path":"concurrent/goroutine.html"},{"text":"channel","type":"link","path":"concurrent/channel.html"},{"text":"同步和锁","type":"link","path":"concurrent/sync_lock.html"},{"text":"内存分配","type":"label"},{"text":"内存分配","type":"link","path":"advance/mm.html"},{"text":"垃圾回收","type":"label"},{"text":"垃圾回收","type":"link","path":"advance/gc.html"},{"text":"标准库","type":"label"},{"text":"fmt","type":"link","path":"standards/io/fmt.html"},{"text":"io","type":"link","path":"standards/io/io.html"},{"text":"ioutil","type":"link","path":"standards/io/ioutil.html"},{"text":"bufio","type":"link","path":"standards/io/bufio.html"},{"text":"os","type":"link","path":"standards/os/os.html"},{"text":"filepath","type":"link","path":"standards/os/filepath.html"},{"text":"strings","type":"link","path":"standards/text/strings.html"},{"text":"strconv","type":"link","path":"standards/text/strconv.html"},{"text":"unicode","type":"link","path":"standards/text/unicode.html"},{"text":"log","type":"link","path":"standards/log.html"},{"text":"time","type":"link","path":"standards/time.html"},{"text":"http","type":"link","path":"standards/net/http.html"},{"text":"math","type":"link","path":"standards/data/math.html"},{"text":"sort","type":"link","path":"standards/data/sort.html"},{"text":"big","type":"link","path":"standards/data/big.html"},{"text":"container","type":"link","path":"standards/data/container.html"},{"text":"sql","type":"link","path":"standards/database/sql.html"},{"text":"THEME","type":"label"},{"text":"使用文档主题","type":"link","path":"theme/theme-usage.html"},{"text":"SUPPORT AND FEEDBACK","type":"label"},{"text":"Raise an Issue on Github","type":"link","path":"https://github.com/shipengqi/golang-learn/issues/new"}]}}},"excerpt":"","more":"<h1 id=\"反射\"><a href=\"#反射\" class=\"headerlink\" title=\"反射\"></a>反射</h1><p>反射机制，能够在运行时更新变量和检查它们的值、调用它们的方法和它们支持的内在操作，而不需要在编译时就知道<br>这些变量的具体类型。弥补了静态语言在动态行为上的一些不足。</p>\n<h2 id=\"reflect-TypeOf\"><a href=\"#reflect-TypeOf\" class=\"headerlink\" title=\"reflect.TypeOf\"></a>reflect.TypeOf</h2><p><code>reflect.TypeOf</code> 获取类型信息。<br><code>reflect.TypeOf</code> 接受任意的 <code>interface{}</code> 类型, 并以 <code>reflect.Type</code> 形式返回其动态类型：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">t := reflect.TypeOf(<span class=\"number\">3</span>)  <span class=\"comment\">// a reflect.Type</span></span><br><span class=\"line\">fmt.Println(t.String()) <span class=\"comment\">// \"int\"</span></span><br><span class=\"line\">fmt.Println(t)          <span class=\"comment\">// \"int\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> X <span class=\"keyword\">int</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> a X = <span class=\"number\">20</span></span><br><span class=\"line\">\tt := reflect.TypeOf(a)</span><br><span class=\"line\">\tfmt.Println(t.Name(), t.Kind()) <span class=\"comment\">// X int</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面的代码，<strong>注意区分 Type 和 Kind，前者表示真实类型（静态类型），后者表示底层类型</strong>。所以在判断类型时，<br>要选择正确的方式。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> X <span class=\"keyword\">int</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Y <span class=\"keyword\">int</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> a, b X = <span class=\"number\">10</span>, <span class=\"number\">20</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> c Y = <span class=\"number\">30</span></span><br><span class=\"line\">\tta, tb, tc := reflect.TypeOf(a), reflect.TypeOf(b), reflect.TypeOf(c)</span><br><span class=\"line\">\tfmt.Println(ta == tb, ta == tc) <span class=\"comment\">// true false</span></span><br><span class=\"line\">\tfmt.Println(ta.Kind() == tc.Kind()) <span class=\"comment\">// true</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"reflect-ValueOf\"><a href=\"#reflect-ValueOf\" class=\"headerlink\" title=\"reflect.ValueOf\"></a>reflect.ValueOf</h2><p><code>reflect.ValueOf</code> 专注于对象实例数据读写。<br><code>reflect.ValueOf</code> 接受任意的 <code>interface{}</code> 类型, 并以 <code>reflect.Value</code> 形式返回其动态值：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">v := reflect.ValueOf(<span class=\"number\">3</span>) <span class=\"comment\">// a reflect.Value</span></span><br><span class=\"line\">fmt.Println(v)          <span class=\"comment\">// \"3\"</span></span><br><span class=\"line\">fmt.Printf(<span class=\"string\">\"%v\\n\"</span>, v)   <span class=\"comment\">// \"3\"</span></span><br><span class=\"line\">fmt.Println(v.String()) <span class=\"comment\">// <span class=\"doctag\">NOTE:</span> \"&lt;int Value&gt;\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">x := <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    Name <span class=\"keyword\">string</span></span><br><span class=\"line\">&#125;&#123;expected&#125;</span><br><span class=\"line\">val := reflect.ValueOf(x)</span><br><span class=\"line\">field := val.Field(<span class=\"number\">0</span>)</span><br><span class=\"line\">fmt.Println(val)            <span class=\"comment\">// &#123;Chris&#125;</span></span><br><span class=\"line\">fmt.Println(field)          <span class=\"comment\">//  Chris</span></span><br><span class=\"line\">fmt.Println(field.String()) <span class=\"comment\">// Chris</span></span><br></pre></td></tr></table></figure></p>\n<p>在 Go 中不能对切片使用等号运算符。你可以写一个函数迭代每个元素来检查它们的值。但是一种<br>比较简单的办法是使用 <code>reflect.DeepEqual</code>，它在判断两个变量是否相等时十分有用。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestSumAll</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    got := SumAll([]<span class=\"keyword\">int</span>&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>&#125;, []<span class=\"keyword\">int</span>&#123;<span class=\"number\">0</span>,<span class=\"number\">9</span>&#125;)</span><br><span class=\"line\">    want := []<span class=\"keyword\">int</span>&#123;<span class=\"number\">3</span>, <span class=\"number\">9</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> !reflect.DeepEqual(got, want) &#123;</span><br><span class=\"line\">        t.Errorf(<span class=\"string\">\"got %v want %v\"</span>, got, want)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>注意</strong>，<code>reflect.DeepEqual</code> 不是「类型安全」的，所以有时候会发生比较怪异的行为。比如：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestSumAll</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    got := SumAll([]<span class=\"keyword\">int</span>&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>&#125;, []<span class=\"keyword\">int</span>&#123;<span class=\"number\">0</span>,<span class=\"number\">9</span>&#125;)</span><br><span class=\"line\">    want := <span class=\"string\">\"bob\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> !reflect.DeepEqual(got, want) &#123;</span><br><span class=\"line\">        t.Errorf(<span class=\"string\">\"got %v want %v\"</span>, got, want)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>尝试比较 <code>slice</code> 和 <code>string</code>。这显然是不合理的，但是却通过了测试。所以使用 <code>reflect.DeepEqual</code> 比较简洁但是在使用时需多加小心。</p>\n"},{"title":"unicode","_content":"\n# unicode\ngo 对 unicode 的支持包含三个包 :\n\n- `unicode`\n- `unicode/utf8`\n- `unicode/utf16`\n\nunicode 包包含基本的字符判断函数。utf8 包主要负责 `rune` 和 `byte` 之间的转换。utf16 包负责 `rune` 和 `uint16` 数组之间\n的转换。\n\n## unicode 包\n\nunicode 包含了对 `rune` 的判断。这个包把所有 unicode 涉及到的编码进行了分类，使用结构\n\n```go\ntype RangeTable struct {\n\tR16         []Range16\n\tR32         []Range32\n\tLatinOffset int\n}\n```\n\n来表示这个功能的字符集。这些字符集都集中列表在 `table.go` 这个源码里面。\n\n比如控制字符集：\n\n```golang\nvar _Pc = &RangeTable{\n\tR16: []Range16{\n\t\t{0x005f, 0x203f, 8160},\n\t\t{0x2040, 0x2054, 20},\n\t\t{0xfe33, 0xfe34, 1},\n\t\t{0xfe4d, 0xfe4f, 1},\n\t\t{0xff3f, 0xff3f, 1},\n\t},\n}\n```\n\n回到包的函数，我们看到有下面这些判断函数：\n\n```\nfunc IsControl(r rune) bool  // 是否控制字符\nfunc IsDigit(r rune) bool  // 是否阿拉伯数字字符，即 0-9\nfunc IsGraphic(r rune) bool // 是否图形字符\nfunc IsLetter(r rune) bool // 是否字母\nfunc IsLower(r rune) bool // 是否小写字符\nfunc IsMark(r rune) bool // 是否符号字符\nfunc IsNumber(r rune) bool // 是否数字字符，比如罗马数字Ⅷ也是数字字符\nfunc IsOneOf(ranges []*RangeTable, r rune) bool // 是否是 RangeTable 中的一个\nfunc IsPrint(r rune) bool // 是否可打印字符\nfunc IsPunct(r rune) bool // 是否标点符号\nfunc IsSpace(r rune) bool // 是否空格\nfunc IsSymbol(r rune) bool // 是否符号字符\nfunc IsTitle(r rune) bool // 是否 title case\nfunc IsUpper(r rune) bool // 是否大写字符\n```\n\n例子：\n\n```go\nfunc main() {\n\tsingle := '\\u0015'\n\tfmt.Println(unicode.IsControl(single))  //true\n\tsingle = '\\ufe35'\n\tfmt.Println(unicode.IsControl(single)) // false\n\n\tdigit := rune('1')\n\tfmt.Println(unicode.IsDigit(digit)) //true\n\tfmt.Println(unicode.IsNumber(digit)) //true\n\tletter := rune(' Ⅷ ')\n\tfmt.Println(unicode.IsDigit(letter)) //false\n\tfmt.Println(unicode.IsNumber(letter)) //true\n}\n```\n\n## utf8 包\n\nutf8 里面的函数就有一些字节和字符的转换。\n\n判断是否符合 utf8 编码的函数：\n```go\nfunc Valid(p []byte) bool\nfunc ValidRune(r rune) bool\nfunc ValidString(s string) bool\n```\n\n\n判断 rune 的长度的函数：\n- `func RuneLen(r rune) int`\n\n判断字节串或者字符串的 rune 数\n- `func RuneCount(p []byte) int`\n- `func RuneCountInString(s string) (n int)`\n\n编码和解码 rune 到 byte\n- `func DecodeRune(p []byte) (r rune, size int)`\n- `func EncodeRune(p []byte, r rune) int`\n\n## 2.5.3 utf16 包 ##\n\nutf16 的包的函数就比较少了。\n\n将 int16 和 rune 进行转换\n- `func Decode(s []uint16) []rune`\n- `func Encode(s []rune) []uint16`","source":"standards/text/unicode.md","raw":"---\ntitle: unicode\n---\n\n# unicode\ngo 对 unicode 的支持包含三个包 :\n\n- `unicode`\n- `unicode/utf8`\n- `unicode/utf16`\n\nunicode 包包含基本的字符判断函数。utf8 包主要负责 `rune` 和 `byte` 之间的转换。utf16 包负责 `rune` 和 `uint16` 数组之间\n的转换。\n\n## unicode 包\n\nunicode 包含了对 `rune` 的判断。这个包把所有 unicode 涉及到的编码进行了分类，使用结构\n\n```go\ntype RangeTable struct {\n\tR16         []Range16\n\tR32         []Range32\n\tLatinOffset int\n}\n```\n\n来表示这个功能的字符集。这些字符集都集中列表在 `table.go` 这个源码里面。\n\n比如控制字符集：\n\n```golang\nvar _Pc = &RangeTable{\n\tR16: []Range16{\n\t\t{0x005f, 0x203f, 8160},\n\t\t{0x2040, 0x2054, 20},\n\t\t{0xfe33, 0xfe34, 1},\n\t\t{0xfe4d, 0xfe4f, 1},\n\t\t{0xff3f, 0xff3f, 1},\n\t},\n}\n```\n\n回到包的函数，我们看到有下面这些判断函数：\n\n```\nfunc IsControl(r rune) bool  // 是否控制字符\nfunc IsDigit(r rune) bool  // 是否阿拉伯数字字符，即 0-9\nfunc IsGraphic(r rune) bool // 是否图形字符\nfunc IsLetter(r rune) bool // 是否字母\nfunc IsLower(r rune) bool // 是否小写字符\nfunc IsMark(r rune) bool // 是否符号字符\nfunc IsNumber(r rune) bool // 是否数字字符，比如罗马数字Ⅷ也是数字字符\nfunc IsOneOf(ranges []*RangeTable, r rune) bool // 是否是 RangeTable 中的一个\nfunc IsPrint(r rune) bool // 是否可打印字符\nfunc IsPunct(r rune) bool // 是否标点符号\nfunc IsSpace(r rune) bool // 是否空格\nfunc IsSymbol(r rune) bool // 是否符号字符\nfunc IsTitle(r rune) bool // 是否 title case\nfunc IsUpper(r rune) bool // 是否大写字符\n```\n\n例子：\n\n```go\nfunc main() {\n\tsingle := '\\u0015'\n\tfmt.Println(unicode.IsControl(single))  //true\n\tsingle = '\\ufe35'\n\tfmt.Println(unicode.IsControl(single)) // false\n\n\tdigit := rune('1')\n\tfmt.Println(unicode.IsDigit(digit)) //true\n\tfmt.Println(unicode.IsNumber(digit)) //true\n\tletter := rune(' Ⅷ ')\n\tfmt.Println(unicode.IsDigit(letter)) //false\n\tfmt.Println(unicode.IsNumber(letter)) //true\n}\n```\n\n## utf8 包\n\nutf8 里面的函数就有一些字节和字符的转换。\n\n判断是否符合 utf8 编码的函数：\n```go\nfunc Valid(p []byte) bool\nfunc ValidRune(r rune) bool\nfunc ValidString(s string) bool\n```\n\n\n判断 rune 的长度的函数：\n- `func RuneLen(r rune) int`\n\n判断字节串或者字符串的 rune 数\n- `func RuneCount(p []byte) int`\n- `func RuneCountInString(s string) (n int)`\n\n编码和解码 rune 到 byte\n- `func DecodeRune(p []byte) (r rune, size int)`\n- `func EncodeRune(p []byte, r rune) int`\n\n## 2.5.3 utf16 包 ##\n\nutf16 的包的函数就比较少了。\n\n将 int16 和 rune 进行转换\n- `func Decode(s []uint16) []rune`\n- `func Encode(s []rune) []uint16`","date":"2019-09-01T00:24:56.490Z","updated":"2019-09-01T00:24:56.449Z","path":"standards/text/unicode.html","comments":1,"layout":"page","_id":"ck1xm14ld0014fcw2stsq9bo6","content":"<h1 id=\"unicode\"><a href=\"#unicode\" class=\"headerlink\" title=\"unicode\"></a>unicode</h1><p>go 对 unicode 的支持包含三个包 :</p>\n<ul>\n<li><code>unicode</code></li>\n<li><code>unicode/utf8</code></li>\n<li><code>unicode/utf16</code></li>\n</ul>\n<p>unicode 包包含基本的字符判断函数。utf8 包主要负责 <code>rune</code> 和 <code>byte</code> 之间的转换。utf16 包负责 <code>rune</code> 和 <code>uint16</code> 数组之间<br>的转换。</p>\n<h2 id=\"unicode-包\"><a href=\"#unicode-包\" class=\"headerlink\" title=\"unicode 包\"></a>unicode 包</h2><p>unicode 包含了对 <code>rune</code> 的判断。这个包把所有 unicode 涉及到的编码进行了分类，使用结构</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> RangeTable <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tR16         []Range16</span><br><span class=\"line\">\tR32         []Range32</span><br><span class=\"line\">\tLatinOffset <span class=\"keyword\">int</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>来表示这个功能的字符集。这些字符集都集中列表在 <code>table.go</code> 这个源码里面。</p>\n<p>比如控制字符集：</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> _Pc = &amp;RangeTable&#123;</span><br><span class=\"line\">\tR16: []Range16&#123;</span><br><span class=\"line\">\t\t&#123;<span class=\"number\">0x005f</span>, <span class=\"number\">0x203f</span>, <span class=\"number\">8160</span>&#125;,</span><br><span class=\"line\">\t\t&#123;<span class=\"number\">0x2040</span>, <span class=\"number\">0x2054</span>, <span class=\"number\">20</span>&#125;,</span><br><span class=\"line\">\t\t&#123;<span class=\"number\">0xfe33</span>, <span class=\"number\">0xfe34</span>, <span class=\"number\">1</span>&#125;,</span><br><span class=\"line\">\t\t&#123;<span class=\"number\">0xfe4d</span>, <span class=\"number\">0xfe4f</span>, <span class=\"number\">1</span>&#125;,</span><br><span class=\"line\">\t\t&#123;<span class=\"number\">0xff3f</span>, <span class=\"number\">0xff3f</span>, <span class=\"number\">1</span>&#125;,</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>回到包的函数，我们看到有下面这些判断函数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func IsControl(r rune) bool  // 是否控制字符</span><br><span class=\"line\">func IsDigit(r rune) bool  // 是否阿拉伯数字字符，即 0-9</span><br><span class=\"line\">func IsGraphic(r rune) bool // 是否图形字符</span><br><span class=\"line\">func IsLetter(r rune) bool // 是否字母</span><br><span class=\"line\">func IsLower(r rune) bool // 是否小写字符</span><br><span class=\"line\">func IsMark(r rune) bool // 是否符号字符</span><br><span class=\"line\">func IsNumber(r rune) bool // 是否数字字符，比如罗马数字Ⅷ也是数字字符</span><br><span class=\"line\">func IsOneOf(ranges []*RangeTable, r rune) bool // 是否是 RangeTable 中的一个</span><br><span class=\"line\">func IsPrint(r rune) bool // 是否可打印字符</span><br><span class=\"line\">func IsPunct(r rune) bool // 是否标点符号</span><br><span class=\"line\">func IsSpace(r rune) bool // 是否空格</span><br><span class=\"line\">func IsSymbol(r rune) bool // 是否符号字符</span><br><span class=\"line\">func IsTitle(r rune) bool // 是否 title case</span><br><span class=\"line\">func IsUpper(r rune) bool // 是否大写字符</span><br></pre></td></tr></table></figure>\n<p>例子：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tsingle := <span class=\"string\">'\\u0015'</span></span><br><span class=\"line\">\tfmt.Println(unicode.IsControl(single))  <span class=\"comment\">//true</span></span><br><span class=\"line\">\tsingle = <span class=\"string\">'\\ufe35'</span></span><br><span class=\"line\">\tfmt.Println(unicode.IsControl(single)) <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tdigit := <span class=\"keyword\">rune</span>(<span class=\"string\">'1'</span>)</span><br><span class=\"line\">\tfmt.Println(unicode.IsDigit(digit)) <span class=\"comment\">//true</span></span><br><span class=\"line\">\tfmt.Println(unicode.IsNumber(digit)) <span class=\"comment\">//true</span></span><br><span class=\"line\">\tletter := <span class=\"keyword\">rune</span>(<span class=\"string\">' Ⅷ '</span>)</span><br><span class=\"line\">\tfmt.Println(unicode.IsDigit(letter)) <span class=\"comment\">//false</span></span><br><span class=\"line\">\tfmt.Println(unicode.IsNumber(letter)) <span class=\"comment\">//true</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"utf8-包\"><a href=\"#utf8-包\" class=\"headerlink\" title=\"utf8 包\"></a>utf8 包</h2><p>utf8 里面的函数就有一些字节和字符的转换。</p>\n<p>判断是否符合 utf8 编码的函数：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Valid</span><span class=\"params\">(p []<span class=\"keyword\">byte</span>)</span> <span class=\"title\">bool</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">ValidRune</span><span class=\"params\">(r <span class=\"keyword\">rune</span>)</span> <span class=\"title\">bool</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">ValidString</span><span class=\"params\">(s <span class=\"keyword\">string</span>)</span> <span class=\"title\">bool</span></span></span><br></pre></td></tr></table></figure></p>\n<p>判断 rune 的长度的函数：</p>\n<ul>\n<li><code>func RuneLen(r rune) int</code></li>\n</ul>\n<p>判断字节串或者字符串的 rune 数</p>\n<ul>\n<li><code>func RuneCount(p []byte) int</code></li>\n<li><code>func RuneCountInString(s string) (n int)</code></li>\n</ul>\n<p>编码和解码 rune 到 byte</p>\n<ul>\n<li><code>func DecodeRune(p []byte) (r rune, size int)</code></li>\n<li><code>func EncodeRune(p []byte, r rune) int</code></li>\n</ul>\n<h2 id=\"2-5-3-utf16-包\"><a href=\"#2-5-3-utf16-包\" class=\"headerlink\" title=\"2.5.3 utf16 包\"></a>2.5.3 utf16 包</h2><p>utf16 的包的函数就比较少了。</p>\n<p>将 int16 和 rune 进行转换</p>\n<ul>\n<li><code>func Decode(s []uint16) []rune</code></li>\n<li><code>func Encode(s []rune) []uint16</code></li>\n</ul>\n","site":{"data":{"navigation":{"logo":{"text":"Golang Learn","type":"link","path":"index.html"},"main":[{"text":"Golang 基础","type":"label"},{"text":"Go 环境配置","type":"link","path":"basic/env_config.html"},{"text":"包","type":"link","path":"basic/package.html"},{"text":"基础数据类型","type":"link","path":"basic/basic_data.html"},{"text":"变量","type":"link","path":"basic/var.html"},{"text":"常量","type":"link","path":"basic/constant.html"},{"text":"控制语句","type":"link","path":"basic/flow.html"},{"text":"运算符","type":"link","path":"basic/operator.html"},{"text":"作用域","type":"link","path":"basic/scope.html"},{"text":"指针","type":"link","path":"basic/pointer.html"},{"text":"数组","type":"link","path":"basic/array.html"},{"text":"切片","type":"link","path":"basic/slice.html"},{"text":"字典","type":"link","path":"basic/map.html"},{"text":"函数","type":"link","path":"basic/function.html"},{"text":"结构体","type":"link","path":"basic/struct.html"},{"text":"接口","type":"link","path":"basic/interface.html"},{"text":"面向对象","type":"link","path":"basic/oop.html"},{"text":"错误","type":"link","path":"basic/error.html"},{"text":"序列化","type":"link","path":"basic/json.html"},{"text":"反射","type":"link","path":"basic/reflect.html"},{"text":"测试","type":"link","path":"basic/test.html"},{"text":"并发编程","type":"label"},{"text":"goroutine","type":"link","path":"concurrent/goroutine.html"},{"text":"channel","type":"link","path":"concurrent/channel.html"},{"text":"同步和锁","type":"link","path":"concurrent/sync_lock.html"},{"text":"内存分配","type":"label"},{"text":"内存分配","type":"link","path":"advance/mm.html"},{"text":"垃圾回收","type":"label"},{"text":"垃圾回收","type":"link","path":"advance/gc.html"},{"text":"标准库","type":"label"},{"text":"fmt","type":"link","path":"standards/io/fmt.html"},{"text":"io","type":"link","path":"standards/io/io.html"},{"text":"ioutil","type":"link","path":"standards/io/ioutil.html"},{"text":"bufio","type":"link","path":"standards/io/bufio.html"},{"text":"os","type":"link","path":"standards/os/os.html"},{"text":"filepath","type":"link","path":"standards/os/filepath.html"},{"text":"strings","type":"link","path":"standards/text/strings.html"},{"text":"strconv","type":"link","path":"standards/text/strconv.html"},{"text":"unicode","type":"link","path":"standards/text/unicode.html"},{"text":"log","type":"link","path":"standards/log.html"},{"text":"time","type":"link","path":"standards/time.html"},{"text":"http","type":"link","path":"standards/net/http.html"},{"text":"math","type":"link","path":"standards/data/math.html"},{"text":"sort","type":"link","path":"standards/data/sort.html"},{"text":"big","type":"link","path":"standards/data/big.html"},{"text":"container","type":"link","path":"standards/data/container.html"},{"text":"sql","type":"link","path":"standards/database/sql.html"},{"text":"THEME","type":"label"},{"text":"使用文档主题","type":"link","path":"theme/theme-usage.html"},{"text":"SUPPORT AND FEEDBACK","type":"label"},{"text":"Raise an Issue on Github","type":"link","path":"https://github.com/shipengqi/golang-learn/issues/new"}]}}},"excerpt":"","more":"<h1 id=\"unicode\"><a href=\"#unicode\" class=\"headerlink\" title=\"unicode\"></a>unicode</h1><p>go 对 unicode 的支持包含三个包 :</p>\n<ul>\n<li><code>unicode</code></li>\n<li><code>unicode/utf8</code></li>\n<li><code>unicode/utf16</code></li>\n</ul>\n<p>unicode 包包含基本的字符判断函数。utf8 包主要负责 <code>rune</code> 和 <code>byte</code> 之间的转换。utf16 包负责 <code>rune</code> 和 <code>uint16</code> 数组之间<br>的转换。</p>\n<h2 id=\"unicode-包\"><a href=\"#unicode-包\" class=\"headerlink\" title=\"unicode 包\"></a>unicode 包</h2><p>unicode 包含了对 <code>rune</code> 的判断。这个包把所有 unicode 涉及到的编码进行了分类，使用结构</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> RangeTable <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tR16         []Range16</span><br><span class=\"line\">\tR32         []Range32</span><br><span class=\"line\">\tLatinOffset <span class=\"keyword\">int</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>来表示这个功能的字符集。这些字符集都集中列表在 <code>table.go</code> 这个源码里面。</p>\n<p>比如控制字符集：</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> _Pc = &amp;RangeTable&#123;</span><br><span class=\"line\">\tR16: []Range16&#123;</span><br><span class=\"line\">\t\t&#123;<span class=\"number\">0x005f</span>, <span class=\"number\">0x203f</span>, <span class=\"number\">8160</span>&#125;,</span><br><span class=\"line\">\t\t&#123;<span class=\"number\">0x2040</span>, <span class=\"number\">0x2054</span>, <span class=\"number\">20</span>&#125;,</span><br><span class=\"line\">\t\t&#123;<span class=\"number\">0xfe33</span>, <span class=\"number\">0xfe34</span>, <span class=\"number\">1</span>&#125;,</span><br><span class=\"line\">\t\t&#123;<span class=\"number\">0xfe4d</span>, <span class=\"number\">0xfe4f</span>, <span class=\"number\">1</span>&#125;,</span><br><span class=\"line\">\t\t&#123;<span class=\"number\">0xff3f</span>, <span class=\"number\">0xff3f</span>, <span class=\"number\">1</span>&#125;,</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>回到包的函数，我们看到有下面这些判断函数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func IsControl(r rune) bool  // 是否控制字符</span><br><span class=\"line\">func IsDigit(r rune) bool  // 是否阿拉伯数字字符，即 0-9</span><br><span class=\"line\">func IsGraphic(r rune) bool // 是否图形字符</span><br><span class=\"line\">func IsLetter(r rune) bool // 是否字母</span><br><span class=\"line\">func IsLower(r rune) bool // 是否小写字符</span><br><span class=\"line\">func IsMark(r rune) bool // 是否符号字符</span><br><span class=\"line\">func IsNumber(r rune) bool // 是否数字字符，比如罗马数字Ⅷ也是数字字符</span><br><span class=\"line\">func IsOneOf(ranges []*RangeTable, r rune) bool // 是否是 RangeTable 中的一个</span><br><span class=\"line\">func IsPrint(r rune) bool // 是否可打印字符</span><br><span class=\"line\">func IsPunct(r rune) bool // 是否标点符号</span><br><span class=\"line\">func IsSpace(r rune) bool // 是否空格</span><br><span class=\"line\">func IsSymbol(r rune) bool // 是否符号字符</span><br><span class=\"line\">func IsTitle(r rune) bool // 是否 title case</span><br><span class=\"line\">func IsUpper(r rune) bool // 是否大写字符</span><br></pre></td></tr></table></figure>\n<p>例子：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tsingle := <span class=\"string\">'\\u0015'</span></span><br><span class=\"line\">\tfmt.Println(unicode.IsControl(single))  <span class=\"comment\">//true</span></span><br><span class=\"line\">\tsingle = <span class=\"string\">'\\ufe35'</span></span><br><span class=\"line\">\tfmt.Println(unicode.IsControl(single)) <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tdigit := <span class=\"keyword\">rune</span>(<span class=\"string\">'1'</span>)</span><br><span class=\"line\">\tfmt.Println(unicode.IsDigit(digit)) <span class=\"comment\">//true</span></span><br><span class=\"line\">\tfmt.Println(unicode.IsNumber(digit)) <span class=\"comment\">//true</span></span><br><span class=\"line\">\tletter := <span class=\"keyword\">rune</span>(<span class=\"string\">' Ⅷ '</span>)</span><br><span class=\"line\">\tfmt.Println(unicode.IsDigit(letter)) <span class=\"comment\">//false</span></span><br><span class=\"line\">\tfmt.Println(unicode.IsNumber(letter)) <span class=\"comment\">//true</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"utf8-包\"><a href=\"#utf8-包\" class=\"headerlink\" title=\"utf8 包\"></a>utf8 包</h2><p>utf8 里面的函数就有一些字节和字符的转换。</p>\n<p>判断是否符合 utf8 编码的函数：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Valid</span><span class=\"params\">(p []<span class=\"keyword\">byte</span>)</span> <span class=\"title\">bool</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">ValidRune</span><span class=\"params\">(r <span class=\"keyword\">rune</span>)</span> <span class=\"title\">bool</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">ValidString</span><span class=\"params\">(s <span class=\"keyword\">string</span>)</span> <span class=\"title\">bool</span></span></span><br></pre></td></tr></table></figure></p>\n<p>判断 rune 的长度的函数：</p>\n<ul>\n<li><code>func RuneLen(r rune) int</code></li>\n</ul>\n<p>判断字节串或者字符串的 rune 数</p>\n<ul>\n<li><code>func RuneCount(p []byte) int</code></li>\n<li><code>func RuneCountInString(s string) (n int)</code></li>\n</ul>\n<p>编码和解码 rune 到 byte</p>\n<ul>\n<li><code>func DecodeRune(p []byte) (r rune, size int)</code></li>\n<li><code>func EncodeRune(p []byte, r rune) int</code></li>\n</ul>\n<h2 id=\"2-5-3-utf16-包\"><a href=\"#2-5-3-utf16-包\" class=\"headerlink\" title=\"2.5.3 utf16 包\"></a>2.5.3 utf16 包</h2><p>utf16 的包的函数就比较少了。</p>\n<p>将 int16 和 rune 进行转换</p>\n<ul>\n<li><code>func Decode(s []uint16) []rune</code></li>\n<li><code>func Encode(s []rune) []uint16</code></li>\n</ul>\n"},{"title":"container","_content":"\n# container\n\n`container` 该包实现了三个复杂的数据结构：链表，环，堆。也就是说使用这三个数据结构的时候不需要再从头开始写算法了。\n\n##  链表\n\n链表就是一个有 `prev` 和 `next` 指针的数组了。\n`container` 包中有两个公开的结构—— `List` 和 `Element`，`List` 实现了一个双向链表（简称链表），\n而 `Element` 则代表了链表中元素的结构。\n\n```go\ntype Element struct {\n\tnext, prev *Element  // 上一个元素和下一个元素\n\tlist *List  // 元素所在链表\n\tValue interface{}  // 元素\n}\n\ntype List struct {\n\troot Element  // 链表的根元素\n\tlen  int      // 链表的长度\n}\n```\nList的四种方法:\n- `MoveBefore` 方法和 `MoveAfter` 方法，它们分别用于把给定的元素移动到另一个元素的前面和后面。\n- `MoveToFront` 方法和 `MoveToBack` 方法，分别用于把给定的元素移动到链表的最前端和最后端。\n\n\n```go\n// moves element \"e\" to its new position before \"mark\".\nfunc (l *List) MoveBefore(e, mark *Element)\n// moves element \"e\" to its new position after \"mark\".\nfunc (l *List) MoveAfter(e, mark *Element)\n\n// moves element \"e\" to the front of list \"l\".\nfunc (l *List) MoveToFront(e *Element)\n// moves element \"e\" to the back of list \"l\".\nfunc (l *List) MoveToBack(e *Element)\n```\n\n“给定的元素”都是 `*Element` 类型。\n\n如果我们自己生成这样的值，然后把它作为“给定的元素”传给链表的方法，那么会发生什么？链表会接受它吗？\n\n不会接受，这些方法将不会对链表做出任何改动。因为我们自己生成的 `Element` 值并不在链表中，所以也就谈不上“在链表中移动元素”。\n\n- `InsertBefore` 和 `InsertAfter` 方法分别用于在指定的元素之前和之后插入新元素。\n- `PushFront` 和 `PushBack` 方法则分别用于在链表的最前端和最后端插入新元素。\n\n示例：\n\n```go\npackage main\n\nimport (\n\t\"container/list\"\n\t\"fmt\"\n)\n\nfunc main() {\n    list := list.New()\n    list.PushBack(1)\n    list.PushBack(2)\n\n    fmt.Printf(\"len: %v\\n\", list.Len())\n    fmt.Printf(\"first: %#v\\n\", list.Front())\n    fmt.Printf(\"second: %#v\\n\", list.Front().Next())\n}\n\noutput:\nlen: 2\nfirst: &list.Element{next:(*list.Element)(0x2081be1b0), prev:(*list.Element)(0x2081be150), list:(*list.List)(0x2081be150), Value:1}\nsecond: &list.Element{next:(*list.Element)(0x2081be150), prev:(*list.Element)(0x2081be180), list:(*list.List)(0x2081be150), Value:2}\n```\n\nList 的其他方法：\n```go\ntype Element\n    func (e *Element) Next() *Element\n    func (e *Element) Prev() *Element\ntype List\n    func New() *List\n    func (l *List) Back() *Element   // 最后一个元素\n    func (l *List) Front() *Element  // 第一个元素\n    func (l *List) Init() *List  // 链表初始化\n    func (l *List) InsertAfter(v interface{}, mark *Element) *Element // 在某个元素后插入\n    func (l *List) InsertBefore(v interface{}, mark *Element) *Element  // 在某个元素前插入\n    func (l *List) Len() int // 在链表长度\n    func (l *List) PushBackList(other *List)  // 在队列最后插入接上新队列\n    func (l *List) PushFrontList(other *List) // 在队列头部插入接上新队列\n    func (l *List) Remove(e *Element) interface{} // 删除某个元素\n```\n\n## 环\n\n环的结构有点特殊，环的尾部就是头部，指向环形链表任一元素的指针都可以作为整个环形链表看待。\n它不需要像 List 一样保持 List 和 Element 两个结构，只需要保持一个结构就行。\n\n```go\ntype Ring struct {\n\tnext, prev *Ring\n\tValue      interface{}\n}\n```\n\n初始化环的时候，需要定义好环的大小，然后对环的每个元素进行赋值。环还提供一个 `Do` 方法，能遍历一遍环，对每个元素执行\n一个 `function`。\n\n示例：\n\n```go\npackage main\n\nimport (\n\t\"container/ring\"\n\t\"fmt\"\n)\n\nfunc main() {\n    ring := ring.New(3)\n\n    for i := 1; i <= 3; i++ {\n        ring.Value = i\n        ring = ring.Next()\n    }\n\n    // 计算 1+2+3\n    s := 0\n    ring.Do(func(p interface{}){\n        s += p.(int)\n    })\n    fmt.Println(\"sum is\", s)\n}\n\noutput:\nsum is 6\n```\n\nring 提供的方法有\n\n```go\ntype Ring\n    func New(n int) *Ring // 创建一个长度为 n 的环形链表\n    func (r *Ring) Do(f func(interface{})) // 遍历环形链表中的每一个元素 x 进行 f(x) 操作\n    func (r *Ring) Len() int // 获取环形链表长度\n    \n    // 如果 r 和 s 在同一环形链表中，则删除 r 和 s 之间的元素，\n    // 被删除的元素组成一个新的环形链表，返回值为该环形链表的指针（即删除前，r->Next() 表示的元素）\n    // 如果 r 和 s 不在同一个环形链表中，则将 s 插入到 r 后面，返回值为\n    // 插入 s 后，s 最后一个元素的下一个元素（即插入前，r->Next() 表示的元素）\n    func (r *Ring) Link(s *Ring) *Ring\n\n    func (r *Ring) Move(n int) *Ring // 移动 n % r.Len() 个位置，n 正负均可\n    func (r *Ring) Next() *Ring // 返回下一个元素\n    func (r *Ring) Prev() *Ring // 返回前一个元素\n    func (r *Ring) Unlink(n int) *Ring // 删除 r 后面的 n % r.Len() 个元素\n```\n\n## 堆\n### 什么是堆\n堆（Heap，也叫优先队列）是计算机科学中一类特殊的数据结构的统称。**堆通常是一个可以被看做一棵树的数组对象**。\n\n堆具有以下特性：\n- 任意节点小于（或大于）它的所有后裔，最小元（或最大元）在堆的根上（堆序性）。\n- 堆总是一棵完全树。即除了最底层，其他层的节点都被元素填满，且最底层尽可能地从左到右填入。\n\n将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。\n\n### Heap\n`heap` 使用的数据结构是最小堆，`heap` 包只是实现了一个接口：\n```go\ntype Interface interface {\n    sort.Interface\n    Push(x interface{}) // add x as element Len()\n    Pop() interface{}   // remove and return element Len() - 1.\n}\n```\n\n这个接口内嵌了 `sort.Interface`，那么要实现 `heap.Interface` 要实现下面的方法：\n- `Len() int`\n- `Less(i, j int) bool`\n- `Swap(i, j int)`\n- `Push(x interface{})`\n- `Pop() interface{}`\n\n示例：\n```go\ntype IntHeap []int\n\nfunc (h IntHeap) Len() int           { return len(h) }\nfunc (h IntHeap) Less(i, j int) bool { return h[i] < h[j] }\nfunc (h IntHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }\n\nfunc (h *IntHeap) Push(x interface{}) {\n    *h = append(*h, x.(int))\n}\n\nfunc (h *IntHeap) Pop() interface{} {\n    old := *h\n    n := len(old)\n    x := old[n-1]\n    *h = old[0 : n-1]\n    return x\n}\n```\n\n#### heap 提供的方法\n```go\nh := &IntHeap{3, 8, 6}  // 创建 IntHeap 类型的原始数据\nfunc Init(h Interface)  // 对 heap 进行初始化，生成小根堆（或大根堆）\nfunc Push(h Interface, x interface{})  // 往堆里面插入内容\nfunc Pop(h Interface) interface{}  // 从堆顶 pop 出内容\nfunc Remove(h Interface, i int) interface{}  // 从指定位置删除数据，并返回删除的数据\nfunc Fix(h Interface, i int)  // 从 i 位置数据发生改变后，对堆再平衡，优先级队列使用到了该方法\n```\n\n#### 实现优先级队列\n```go\npackage main\n\nimport (\n    \"container/heap\"\n    \"fmt\"\n)\n\ntype Item struct {\n    value    string // 优先级队列中的数据，可以是任意类型，这里使用 string\n    priority int    // 优先级队列中节点的优先级\n    index    int    // index 是该节点在堆中的位置\n}\n\n// 优先级队列需要实现 heap 的 Interface\ntype PriorityQueue []*Item\n\nfunc (pq PriorityQueue) Len() int {\n    return len(pq)\n}\n\n// 这里用的是小于号，生成的是最小堆\nfunc (pq PriorityQueue) Less(i, j int) bool {\n    return pq[i].priority < pq[j].priority\n}\n\nfunc (pq PriorityQueue) Swap(i, j int) {\n    pq[i], pq[j] = pq[j], pq[i]\n    pq[i].index, pq[j].index = i, j\n}\n\n// 将 index 置为 -1 是为了标识该数据已经出了优先级队列了\nfunc (pq *PriorityQueue) Pop() interface{} {\n    old := *pq\n    n := len(old)\n    item := old[n-1]\n    *pq = old[0 : n-1]\n    item.index = -1\n    return item\n}\n\nfunc (pq *PriorityQueue) Push(x interface{}) {\n    n := len(*pq)\n    item := x.(*Item)\n    item.index = n\n    *pq = append(*pq, item)\n}\n\n// 更新修改了优先级和值的 item 在优先级队列中的位置\nfunc (pq *PriorityQueue) update(item *Item, value string, priority int) {\n    item.value = value\n    item.priority = priority\n    heap.Fix(pq, item.index)\n}\n\nfunc main() {\n    // 创建节点并设计他们的优先级\n    items := map[string]int{\"二毛\": 5, \"张三\": 3, \"狗蛋\": 9}\n    i := 0\n    pq := make(PriorityQueue, len(items)) // 创建优先级队列，并初始化\n    for k, v := range items {             // 将节点放到优先级队列中\n        pq[i] = &Item{\n            value:    k,\n            priority: v,\n            index:    i}\n        i++\n    }\n    heap.Init(&pq) // 初始化堆\n    item := &Item{ // 创建一个 item\n        value:    \"李四\",\n        priority: 1,\n    }\n    heap.Push(&pq, item)           // 入优先级队列\n    pq.update(item, item.value, 6) // 更新 item 的优先级\n    for len(pq) > 0 {\n        item := heap.Pop(&pq).(*Item)\n        fmt.Printf(\"%.2d:%s index:%.2d\\n\", item.priority, item.value, item.index)\n    }\n}\n\n// 输出结果：\n// 03:张三 index:-01\n// 05:二毛 index:-01\n// 06:李四 index:-01\n// 09:狗蛋 index:-01\n```","source":"standards/data/container.md","raw":"---\ntitle: container\n---\n\n# container\n\n`container` 该包实现了三个复杂的数据结构：链表，环，堆。也就是说使用这三个数据结构的时候不需要再从头开始写算法了。\n\n##  链表\n\n链表就是一个有 `prev` 和 `next` 指针的数组了。\n`container` 包中有两个公开的结构—— `List` 和 `Element`，`List` 实现了一个双向链表（简称链表），\n而 `Element` 则代表了链表中元素的结构。\n\n```go\ntype Element struct {\n\tnext, prev *Element  // 上一个元素和下一个元素\n\tlist *List  // 元素所在链表\n\tValue interface{}  // 元素\n}\n\ntype List struct {\n\troot Element  // 链表的根元素\n\tlen  int      // 链表的长度\n}\n```\nList的四种方法:\n- `MoveBefore` 方法和 `MoveAfter` 方法，它们分别用于把给定的元素移动到另一个元素的前面和后面。\n- `MoveToFront` 方法和 `MoveToBack` 方法，分别用于把给定的元素移动到链表的最前端和最后端。\n\n\n```go\n// moves element \"e\" to its new position before \"mark\".\nfunc (l *List) MoveBefore(e, mark *Element)\n// moves element \"e\" to its new position after \"mark\".\nfunc (l *List) MoveAfter(e, mark *Element)\n\n// moves element \"e\" to the front of list \"l\".\nfunc (l *List) MoveToFront(e *Element)\n// moves element \"e\" to the back of list \"l\".\nfunc (l *List) MoveToBack(e *Element)\n```\n\n“给定的元素”都是 `*Element` 类型。\n\n如果我们自己生成这样的值，然后把它作为“给定的元素”传给链表的方法，那么会发生什么？链表会接受它吗？\n\n不会接受，这些方法将不会对链表做出任何改动。因为我们自己生成的 `Element` 值并不在链表中，所以也就谈不上“在链表中移动元素”。\n\n- `InsertBefore` 和 `InsertAfter` 方法分别用于在指定的元素之前和之后插入新元素。\n- `PushFront` 和 `PushBack` 方法则分别用于在链表的最前端和最后端插入新元素。\n\n示例：\n\n```go\npackage main\n\nimport (\n\t\"container/list\"\n\t\"fmt\"\n)\n\nfunc main() {\n    list := list.New()\n    list.PushBack(1)\n    list.PushBack(2)\n\n    fmt.Printf(\"len: %v\\n\", list.Len())\n    fmt.Printf(\"first: %#v\\n\", list.Front())\n    fmt.Printf(\"second: %#v\\n\", list.Front().Next())\n}\n\noutput:\nlen: 2\nfirst: &list.Element{next:(*list.Element)(0x2081be1b0), prev:(*list.Element)(0x2081be150), list:(*list.List)(0x2081be150), Value:1}\nsecond: &list.Element{next:(*list.Element)(0x2081be150), prev:(*list.Element)(0x2081be180), list:(*list.List)(0x2081be150), Value:2}\n```\n\nList 的其他方法：\n```go\ntype Element\n    func (e *Element) Next() *Element\n    func (e *Element) Prev() *Element\ntype List\n    func New() *List\n    func (l *List) Back() *Element   // 最后一个元素\n    func (l *List) Front() *Element  // 第一个元素\n    func (l *List) Init() *List  // 链表初始化\n    func (l *List) InsertAfter(v interface{}, mark *Element) *Element // 在某个元素后插入\n    func (l *List) InsertBefore(v interface{}, mark *Element) *Element  // 在某个元素前插入\n    func (l *List) Len() int // 在链表长度\n    func (l *List) PushBackList(other *List)  // 在队列最后插入接上新队列\n    func (l *List) PushFrontList(other *List) // 在队列头部插入接上新队列\n    func (l *List) Remove(e *Element) interface{} // 删除某个元素\n```\n\n## 环\n\n环的结构有点特殊，环的尾部就是头部，指向环形链表任一元素的指针都可以作为整个环形链表看待。\n它不需要像 List 一样保持 List 和 Element 两个结构，只需要保持一个结构就行。\n\n```go\ntype Ring struct {\n\tnext, prev *Ring\n\tValue      interface{}\n}\n```\n\n初始化环的时候，需要定义好环的大小，然后对环的每个元素进行赋值。环还提供一个 `Do` 方法，能遍历一遍环，对每个元素执行\n一个 `function`。\n\n示例：\n\n```go\npackage main\n\nimport (\n\t\"container/ring\"\n\t\"fmt\"\n)\n\nfunc main() {\n    ring := ring.New(3)\n\n    for i := 1; i <= 3; i++ {\n        ring.Value = i\n        ring = ring.Next()\n    }\n\n    // 计算 1+2+3\n    s := 0\n    ring.Do(func(p interface{}){\n        s += p.(int)\n    })\n    fmt.Println(\"sum is\", s)\n}\n\noutput:\nsum is 6\n```\n\nring 提供的方法有\n\n```go\ntype Ring\n    func New(n int) *Ring // 创建一个长度为 n 的环形链表\n    func (r *Ring) Do(f func(interface{})) // 遍历环形链表中的每一个元素 x 进行 f(x) 操作\n    func (r *Ring) Len() int // 获取环形链表长度\n    \n    // 如果 r 和 s 在同一环形链表中，则删除 r 和 s 之间的元素，\n    // 被删除的元素组成一个新的环形链表，返回值为该环形链表的指针（即删除前，r->Next() 表示的元素）\n    // 如果 r 和 s 不在同一个环形链表中，则将 s 插入到 r 后面，返回值为\n    // 插入 s 后，s 最后一个元素的下一个元素（即插入前，r->Next() 表示的元素）\n    func (r *Ring) Link(s *Ring) *Ring\n\n    func (r *Ring) Move(n int) *Ring // 移动 n % r.Len() 个位置，n 正负均可\n    func (r *Ring) Next() *Ring // 返回下一个元素\n    func (r *Ring) Prev() *Ring // 返回前一个元素\n    func (r *Ring) Unlink(n int) *Ring // 删除 r 后面的 n % r.Len() 个元素\n```\n\n## 堆\n### 什么是堆\n堆（Heap，也叫优先队列）是计算机科学中一类特殊的数据结构的统称。**堆通常是一个可以被看做一棵树的数组对象**。\n\n堆具有以下特性：\n- 任意节点小于（或大于）它的所有后裔，最小元（或最大元）在堆的根上（堆序性）。\n- 堆总是一棵完全树。即除了最底层，其他层的节点都被元素填满，且最底层尽可能地从左到右填入。\n\n将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。\n\n### Heap\n`heap` 使用的数据结构是最小堆，`heap` 包只是实现了一个接口：\n```go\ntype Interface interface {\n    sort.Interface\n    Push(x interface{}) // add x as element Len()\n    Pop() interface{}   // remove and return element Len() - 1.\n}\n```\n\n这个接口内嵌了 `sort.Interface`，那么要实现 `heap.Interface` 要实现下面的方法：\n- `Len() int`\n- `Less(i, j int) bool`\n- `Swap(i, j int)`\n- `Push(x interface{})`\n- `Pop() interface{}`\n\n示例：\n```go\ntype IntHeap []int\n\nfunc (h IntHeap) Len() int           { return len(h) }\nfunc (h IntHeap) Less(i, j int) bool { return h[i] < h[j] }\nfunc (h IntHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }\n\nfunc (h *IntHeap) Push(x interface{}) {\n    *h = append(*h, x.(int))\n}\n\nfunc (h *IntHeap) Pop() interface{} {\n    old := *h\n    n := len(old)\n    x := old[n-1]\n    *h = old[0 : n-1]\n    return x\n}\n```\n\n#### heap 提供的方法\n```go\nh := &IntHeap{3, 8, 6}  // 创建 IntHeap 类型的原始数据\nfunc Init(h Interface)  // 对 heap 进行初始化，生成小根堆（或大根堆）\nfunc Push(h Interface, x interface{})  // 往堆里面插入内容\nfunc Pop(h Interface) interface{}  // 从堆顶 pop 出内容\nfunc Remove(h Interface, i int) interface{}  // 从指定位置删除数据，并返回删除的数据\nfunc Fix(h Interface, i int)  // 从 i 位置数据发生改变后，对堆再平衡，优先级队列使用到了该方法\n```\n\n#### 实现优先级队列\n```go\npackage main\n\nimport (\n    \"container/heap\"\n    \"fmt\"\n)\n\ntype Item struct {\n    value    string // 优先级队列中的数据，可以是任意类型，这里使用 string\n    priority int    // 优先级队列中节点的优先级\n    index    int    // index 是该节点在堆中的位置\n}\n\n// 优先级队列需要实现 heap 的 Interface\ntype PriorityQueue []*Item\n\nfunc (pq PriorityQueue) Len() int {\n    return len(pq)\n}\n\n// 这里用的是小于号，生成的是最小堆\nfunc (pq PriorityQueue) Less(i, j int) bool {\n    return pq[i].priority < pq[j].priority\n}\n\nfunc (pq PriorityQueue) Swap(i, j int) {\n    pq[i], pq[j] = pq[j], pq[i]\n    pq[i].index, pq[j].index = i, j\n}\n\n// 将 index 置为 -1 是为了标识该数据已经出了优先级队列了\nfunc (pq *PriorityQueue) Pop() interface{} {\n    old := *pq\n    n := len(old)\n    item := old[n-1]\n    *pq = old[0 : n-1]\n    item.index = -1\n    return item\n}\n\nfunc (pq *PriorityQueue) Push(x interface{}) {\n    n := len(*pq)\n    item := x.(*Item)\n    item.index = n\n    *pq = append(*pq, item)\n}\n\n// 更新修改了优先级和值的 item 在优先级队列中的位置\nfunc (pq *PriorityQueue) update(item *Item, value string, priority int) {\n    item.value = value\n    item.priority = priority\n    heap.Fix(pq, item.index)\n}\n\nfunc main() {\n    // 创建节点并设计他们的优先级\n    items := map[string]int{\"二毛\": 5, \"张三\": 3, \"狗蛋\": 9}\n    i := 0\n    pq := make(PriorityQueue, len(items)) // 创建优先级队列，并初始化\n    for k, v := range items {             // 将节点放到优先级队列中\n        pq[i] = &Item{\n            value:    k,\n            priority: v,\n            index:    i}\n        i++\n    }\n    heap.Init(&pq) // 初始化堆\n    item := &Item{ // 创建一个 item\n        value:    \"李四\",\n        priority: 1,\n    }\n    heap.Push(&pq, item)           // 入优先级队列\n    pq.update(item, item.value, 6) // 更新 item 的优先级\n    for len(pq) > 0 {\n        item := heap.Pop(&pq).(*Item)\n        fmt.Printf(\"%.2d:%s index:%.2d\\n\", item.priority, item.value, item.index)\n    }\n}\n\n// 输出结果：\n// 03:张三 index:-01\n// 05:二毛 index:-01\n// 06:李四 index:-01\n// 09:狗蛋 index:-01\n```","date":"2019-10-19T13:40:15.175Z","updated":"2019-10-19T13:40:15.175Z","path":"standards/data/container.html","comments":1,"layout":"page","_id":"ck1xm14ld0015fcw2acd2cau4","content":"<h1 id=\"container\"><a href=\"#container\" class=\"headerlink\" title=\"container\"></a>container</h1><p><code>container</code> 该包实现了三个复杂的数据结构：链表，环，堆。也就是说使用这三个数据结构的时候不需要再从头开始写算法了。</p>\n<h2 id=\"链表\"><a href=\"#链表\" class=\"headerlink\" title=\"链表\"></a>链表</h2><p>链表就是一个有 <code>prev</code> 和 <code>next</code> 指针的数组了。<br><code>container</code> 包中有两个公开的结构—— <code>List</code> 和 <code>Element</code>，<code>List</code> 实现了一个双向链表（简称链表），<br>而 <code>Element</code> 则代表了链表中元素的结构。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Element <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tnext, prev *Element  <span class=\"comment\">// 上一个元素和下一个元素</span></span><br><span class=\"line\">\tlist *List  <span class=\"comment\">// 元素所在链表</span></span><br><span class=\"line\">\tValue <span class=\"keyword\">interface</span>&#123;&#125;  <span class=\"comment\">// 元素</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> List <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\troot Element  <span class=\"comment\">// 链表的根元素</span></span><br><span class=\"line\">\t<span class=\"built_in\">len</span>  <span class=\"keyword\">int</span>      <span class=\"comment\">// 链表的长度</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>List的四种方法:</p>\n<ul>\n<li><code>MoveBefore</code> 方法和 <code>MoveAfter</code> 方法，它们分别用于把给定的元素移动到另一个元素的前面和后面。</li>\n<li><code>MoveToFront</code> 方法和 <code>MoveToBack</code> 方法，分别用于把给定的元素移动到链表的最前端和最后端。</li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// moves element \"e\" to its new position before \"mark\".</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(l *List)</span> <span class=\"title\">MoveBefore</span><span class=\"params\">(e, mark *Element)</span></span></span><br><span class=\"line\"><span class=\"function\">// <span class=\"title\">moves</span> <span class=\"title\">element</span> \"<span class=\"title\">e</span>\" <span class=\"title\">to</span> <span class=\"title\">its</span> <span class=\"title\">new</span> <span class=\"title\">position</span> <span class=\"title\">after</span> \"<span class=\"title\">mark</span>\".</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"params\">(l *List)</span> <span class=\"title\">MoveAfter</span><span class=\"params\">(e, mark *Element)</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// <span class=\"title\">moves</span> <span class=\"title\">element</span> \"<span class=\"title\">e</span>\" <span class=\"title\">to</span> <span class=\"title\">the</span> <span class=\"title\">front</span> <span class=\"title\">of</span> <span class=\"title\">list</span> \"<span class=\"title\">l</span>\".</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"params\">(l *List)</span> <span class=\"title\">MoveToFront</span><span class=\"params\">(e *Element)</span></span></span><br><span class=\"line\"><span class=\"function\">// <span class=\"title\">moves</span> <span class=\"title\">element</span> \"<span class=\"title\">e</span>\" <span class=\"title\">to</span> <span class=\"title\">the</span> <span class=\"title\">back</span> <span class=\"title\">of</span> <span class=\"title\">list</span> \"<span class=\"title\">l</span>\".</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"params\">(l *List)</span> <span class=\"title\">MoveToBack</span><span class=\"params\">(e *Element)</span></span></span><br></pre></td></tr></table></figure>\n<p>“给定的元素”都是 <code>*Element</code> 类型。</p>\n<p>如果我们自己生成这样的值，然后把它作为“给定的元素”传给链表的方法，那么会发生什么？链表会接受它吗？</p>\n<p>不会接受，这些方法将不会对链表做出任何改动。因为我们自己生成的 <code>Element</code> 值并不在链表中，所以也就谈不上“在链表中移动元素”。</p>\n<ul>\n<li><code>InsertBefore</code> 和 <code>InsertAfter</code> 方法分别用于在指定的元素之前和之后插入新元素。</li>\n<li><code>PushFront</code> 和 <code>PushBack</code> 方法则分别用于在链表的最前端和最后端插入新元素。</li>\n</ul>\n<p>示例：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">\"container/list\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"fmt\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    list := list.New()</span><br><span class=\"line\">    list.PushBack(<span class=\"number\">1</span>)</span><br><span class=\"line\">    list.PushBack(<span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">\"len: %v\\n\"</span>, list.Len())</span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">\"first: %#v\\n\"</span>, list.Front())</span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">\"second: %#v\\n\"</span>, list.Front().Next())</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">output:</span><br><span class=\"line\"><span class=\"built_in\">len</span>: <span class=\"number\">2</span></span><br><span class=\"line\">first: &amp;list.Element&#123;next:(*list.Element)(<span class=\"number\">0x2081be1b0</span>), prev:(*list.Element)(<span class=\"number\">0x2081be150</span>), list:(*list.List)(<span class=\"number\">0x2081be150</span>), Value:<span class=\"number\">1</span>&#125;</span><br><span class=\"line\">second: &amp;list.Element&#123;next:(*list.Element)(<span class=\"number\">0x2081be150</span>), prev:(*list.Element)(<span class=\"number\">0x2081be180</span>), list:(*list.List)(<span class=\"number\">0x2081be150</span>), Value:<span class=\"number\">2</span>&#125;</span><br></pre></td></tr></table></figure>\n<p>List 的其他方法：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Element</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(e *Element)</span> <span class=\"title\">Next</span><span class=\"params\">()</span> *<span class=\"title\">Element</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">func</span> <span class=\"params\">(e *Element)</span> <span class=\"title\">Prev</span><span class=\"params\">()</span> *<span class=\"title\">Element</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">type</span> <span class=\"title\">List</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">func</span> <span class=\"title\">New</span><span class=\"params\">()</span> *<span class=\"title\">List</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">func</span> <span class=\"params\">(l *List)</span> <span class=\"title\">Back</span><span class=\"params\">()</span> *<span class=\"title\">Element</span>   // 最后一个元素</span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">func</span> <span class=\"params\">(l *List)</span> <span class=\"title\">Front</span><span class=\"params\">()</span> *<span class=\"title\">Element</span>  // 第一个元素</span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">func</span> <span class=\"params\">(l *List)</span> <span class=\"title\">Init</span><span class=\"params\">()</span> *<span class=\"title\">List</span>  // 链表初始化</span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">func</span> <span class=\"params\">(l *List)</span> <span class=\"title\">InsertAfter</span><span class=\"params\">(v <span class=\"keyword\">interface</span>&#123;&#125;, mark *Element)</span> *<span class=\"title\">Element</span> // 在某个元素后插入</span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">func</span> <span class=\"params\">(l *List)</span> <span class=\"title\">InsertBefore</span><span class=\"params\">(v <span class=\"keyword\">interface</span>&#123;&#125;, mark *Element)</span> *<span class=\"title\">Element</span>  // 在某个元素前插入</span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">func</span> <span class=\"params\">(l *List)</span> <span class=\"title\">Len</span><span class=\"params\">()</span> <span class=\"title\">int</span> // 在链表长度</span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">func</span> <span class=\"params\">(l *List)</span> <span class=\"title\">PushBackList</span><span class=\"params\">(other *List)</span>  // 在队列最后插入接上新队列</span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">func</span> <span class=\"params\">(l *List)</span> <span class=\"title\">PushFrontList</span><span class=\"params\">(other *List)</span> // 在队列头部插入接上新队列</span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">func</span> <span class=\"params\">(l *List)</span> <span class=\"title\">Remove</span><span class=\"params\">(e *Element)</span> <span class=\"title\">interface</span></span>&#123;&#125; <span class=\"comment\">// 删除某个元素</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"环\"><a href=\"#环\" class=\"headerlink\" title=\"环\"></a>环</h2><p>环的结构有点特殊，环的尾部就是头部，指向环形链表任一元素的指针都可以作为整个环形链表看待。<br>它不需要像 List 一样保持 List 和 Element 两个结构，只需要保持一个结构就行。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Ring <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tnext, prev *Ring</span><br><span class=\"line\">\tValue      <span class=\"keyword\">interface</span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>初始化环的时候，需要定义好环的大小，然后对环的每个元素进行赋值。环还提供一个 <code>Do</code> 方法，能遍历一遍环，对每个元素执行<br>一个 <code>function</code>。</p>\n<p>示例：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">\"container/ring\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"fmt\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    ring := ring.New(<span class=\"number\">3</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">1</span>; i &lt;= <span class=\"number\">3</span>; i++ &#123;</span><br><span class=\"line\">        ring.Value = i</span><br><span class=\"line\">        ring = ring.Next()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 计算 1+2+3</span></span><br><span class=\"line\">    s := <span class=\"number\">0</span></span><br><span class=\"line\">    ring.Do(<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(p <span class=\"keyword\">interface</span>&#123;&#125;)</span></span>&#123;</span><br><span class=\"line\">        s += p.(<span class=\"keyword\">int</span>)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    fmt.Println(<span class=\"string\">\"sum is\"</span>, s)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">output:</span><br><span class=\"line\">sum is <span class=\"number\">6</span></span><br></pre></td></tr></table></figure>\n<p>ring 提供的方法有</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Ring</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">New</span><span class=\"params\">(n <span class=\"keyword\">int</span>)</span> *<span class=\"title\">Ring</span> // 创建一个长度为 <span class=\"title\">n</span> 的环形链表</span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">func</span> <span class=\"params\">(r *Ring)</span> <span class=\"title\">Do</span><span class=\"params\">(f <span class=\"keyword\">func</span>(<span class=\"keyword\">interface</span>&#123;&#125;)</span>) // 遍历环形链表中的每一个元素 <span class=\"title\">x</span> 进行 <span class=\"title\">f</span><span class=\"params\">(x)</span> 操作</span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">func</span> <span class=\"params\">(r *Ring)</span> <span class=\"title\">Len</span><span class=\"params\">()</span> <span class=\"title\">int</span> // 获取环形链表长度</span></span><br><span class=\"line\"><span class=\"function\">    </span></span><br><span class=\"line\"><span class=\"function\">    // 如果 <span class=\"title\">r</span> 和 <span class=\"title\">s</span> 在同一环形链表中，则删除 <span class=\"title\">r</span> 和 <span class=\"title\">s</span> 之间的元素，</span></span><br><span class=\"line\"><span class=\"function\">    // 被删除的元素组成一个新的环形链表，返回值为该环形链表的指针（即删除前，<span class=\"title\">r</span>-&gt;<span class=\"title\">Next</span><span class=\"params\">()</span> 表示的元素）</span></span><br><span class=\"line\"><span class=\"function\">    // 如果 <span class=\"title\">r</span> 和 <span class=\"title\">s</span> 不在同一个环形链表中，则将 <span class=\"title\">s</span> 插入到 <span class=\"title\">r</span> 后面，返回值为</span></span><br><span class=\"line\"><span class=\"function\">    // 插入 <span class=\"title\">s</span> 后，<span class=\"title\">s</span> 最后一个元素的下一个元素（即插入前，<span class=\"title\">r</span>-&gt;<span class=\"title\">Next</span><span class=\"params\">()</span> 表示的元素）</span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">func</span> <span class=\"params\">(r *Ring)</span> <span class=\"title\">Link</span><span class=\"params\">(s *Ring)</span> *<span class=\"title\">Ring</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">func</span> <span class=\"params\">(r *Ring)</span> <span class=\"title\">Move</span><span class=\"params\">(n <span class=\"keyword\">int</span>)</span> *<span class=\"title\">Ring</span> // 移动 <span class=\"title\">n</span> % <span class=\"title\">r</span>.<span class=\"title\">Len</span><span class=\"params\">()</span> 个位置，<span class=\"title\">n</span> 正负均可</span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">func</span> <span class=\"params\">(r *Ring)</span> <span class=\"title\">Next</span><span class=\"params\">()</span> *<span class=\"title\">Ring</span> // 返回下一个元素</span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">func</span> <span class=\"params\">(r *Ring)</span> <span class=\"title\">Prev</span><span class=\"params\">()</span> *<span class=\"title\">Ring</span> // 返回前一个元素</span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">func</span> <span class=\"params\">(r *Ring)</span> <span class=\"title\">Unlink</span><span class=\"params\">(n <span class=\"keyword\">int</span>)</span> *<span class=\"title\">Ring</span> // 删除 <span class=\"title\">r</span> 后面的 <span class=\"title\">n</span> % <span class=\"title\">r</span>.<span class=\"title\">Len</span><span class=\"params\">()</span> 个元素</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"堆\"><a href=\"#堆\" class=\"headerlink\" title=\"堆\"></a>堆</h2><h3 id=\"什么是堆\"><a href=\"#什么是堆\" class=\"headerlink\" title=\"什么是堆\"></a>什么是堆</h3><p>堆（Heap，也叫优先队列）是计算机科学中一类特殊的数据结构的统称。<strong>堆通常是一个可以被看做一棵树的数组对象</strong>。</p>\n<p>堆具有以下特性：</p>\n<ul>\n<li>任意节点小于（或大于）它的所有后裔，最小元（或最大元）在堆的根上（堆序性）。</li>\n<li>堆总是一棵完全树。即除了最底层，其他层的节点都被元素填满，且最底层尽可能地从左到右填入。</li>\n</ul>\n<p>将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。</p>\n<h3 id=\"Heap\"><a href=\"#Heap\" class=\"headerlink\" title=\"Heap\"></a>Heap</h3><p><code>heap</code> 使用的数据结构是最小堆，<code>heap</code> 包只是实现了一个接口：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Interface <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">    sort.Interface</span><br><span class=\"line\">    Push(x <span class=\"keyword\">interface</span>&#123;&#125;) <span class=\"comment\">// add x as element Len()</span></span><br><span class=\"line\">    Pop() <span class=\"keyword\">interface</span>&#123;&#125;   <span class=\"comment\">// remove and return element Len() - 1.</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这个接口内嵌了 <code>sort.Interface</code>，那么要实现 <code>heap.Interface</code> 要实现下面的方法：</p>\n<ul>\n<li><code>Len() int</code></li>\n<li><code>Less(i, j int) bool</code></li>\n<li><code>Swap(i, j int)</code></li>\n<li><code>Push(x interface{})</code></li>\n<li><code>Pop() interface{}</code></li>\n</ul>\n<p>示例：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> IntHeap []<span class=\"keyword\">int</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(h IntHeap)</span> <span class=\"title\">Len</span><span class=\"params\">()</span> <span class=\"title\">int</span></span>           &#123; <span class=\"keyword\">return</span> <span class=\"built_in\">len</span>(h) &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(h IntHeap)</span> <span class=\"title\">Less</span><span class=\"params\">(i, j <span class=\"keyword\">int</span>)</span> <span class=\"title\">bool</span></span> &#123; <span class=\"keyword\">return</span> h[i] &lt; h[j] &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(h IntHeap)</span> <span class=\"title\">Swap</span><span class=\"params\">(i, j <span class=\"keyword\">int</span>)</span></span>      &#123; h[i], h[j] = h[j], h[i] &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(h *IntHeap)</span> <span class=\"title\">Push</span><span class=\"params\">(x <span class=\"keyword\">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class=\"line\">    *h = <span class=\"built_in\">append</span>(*h, x.(<span class=\"keyword\">int</span>))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(h *IntHeap)</span> <span class=\"title\">Pop</span><span class=\"params\">()</span> <span class=\"title\">interface</span></span>&#123;&#125; &#123;</span><br><span class=\"line\">    old := *h</span><br><span class=\"line\">    n := <span class=\"built_in\">len</span>(old)</span><br><span class=\"line\">    x := old[n<span class=\"number\">-1</span>]</span><br><span class=\"line\">    *h = old[<span class=\"number\">0</span> : n<span class=\"number\">-1</span>]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"heap-提供的方法\"><a href=\"#heap-提供的方法\" class=\"headerlink\" title=\"heap 提供的方法\"></a>heap 提供的方法</h4><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">h := &amp;IntHeap&#123;<span class=\"number\">3</span>, <span class=\"number\">8</span>, <span class=\"number\">6</span>&#125;  <span class=\"comment\">// 创建 IntHeap 类型的原始数据</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Init</span><span class=\"params\">(h Interface)</span>  // 对 <span class=\"title\">heap</span> 进行初始化，生成小根堆（或大根堆）</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">Push</span><span class=\"params\">(h Interface, x <span class=\"keyword\">interface</span>&#123;&#125;)</span>  // 往堆里面插入内容</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">Pop</span><span class=\"params\">(h Interface)</span> <span class=\"title\">interface</span></span>&#123;&#125;  <span class=\"comment\">// 从堆顶 pop 出内容</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Remove</span><span class=\"params\">(h Interface, i <span class=\"keyword\">int</span>)</span> <span class=\"title\">interface</span></span>&#123;&#125;  <span class=\"comment\">// 从指定位置删除数据，并返回删除的数据</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Fix</span><span class=\"params\">(h Interface, i <span class=\"keyword\">int</span>)</span>  // 从 <span class=\"title\">i</span> 位置数据发生改变后，对堆再平衡，优先级队列使用到了该方法</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"实现优先级队列\"><a href=\"#实现优先级队列\" class=\"headerlink\" title=\"实现优先级队列\"></a>实现优先级队列</h4><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">\"container/heap\"</span></span><br><span class=\"line\">    <span class=\"string\">\"fmt\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Item <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    value    <span class=\"keyword\">string</span> <span class=\"comment\">// 优先级队列中的数据，可以是任意类型，这里使用 string</span></span><br><span class=\"line\">    priority <span class=\"keyword\">int</span>    <span class=\"comment\">// 优先级队列中节点的优先级</span></span><br><span class=\"line\">    index    <span class=\"keyword\">int</span>    <span class=\"comment\">// index 是该节点在堆中的位置</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 优先级队列需要实现 heap 的 Interface</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> PriorityQueue []*Item</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(pq PriorityQueue)</span> <span class=\"title\">Len</span><span class=\"params\">()</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">len</span>(pq)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这里用的是小于号，生成的是最小堆</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(pq PriorityQueue)</span> <span class=\"title\">Less</span><span class=\"params\">(i, j <span class=\"keyword\">int</span>)</span> <span class=\"title\">bool</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pq[i].priority &lt; pq[j].priority</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(pq PriorityQueue)</span> <span class=\"title\">Swap</span><span class=\"params\">(i, j <span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">    pq[i], pq[j] = pq[j], pq[i]</span><br><span class=\"line\">    pq[i].index, pq[j].index = i, j</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将 index 置为 -1 是为了标识该数据已经出了优先级队列了</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(pq *PriorityQueue)</span> <span class=\"title\">Pop</span><span class=\"params\">()</span> <span class=\"title\">interface</span></span>&#123;&#125; &#123;</span><br><span class=\"line\">    old := *pq</span><br><span class=\"line\">    n := <span class=\"built_in\">len</span>(old)</span><br><span class=\"line\">    item := old[n<span class=\"number\">-1</span>]</span><br><span class=\"line\">    *pq = old[<span class=\"number\">0</span> : n<span class=\"number\">-1</span>]</span><br><span class=\"line\">    item.index = <span class=\"number\">-1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> item</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(pq *PriorityQueue)</span> <span class=\"title\">Push</span><span class=\"params\">(x <span class=\"keyword\">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class=\"line\">    n := <span class=\"built_in\">len</span>(*pq)</span><br><span class=\"line\">    item := x.(*Item)</span><br><span class=\"line\">    item.index = n</span><br><span class=\"line\">    *pq = <span class=\"built_in\">append</span>(*pq, item)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 更新修改了优先级和值的 item 在优先级队列中的位置</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(pq *PriorityQueue)</span> <span class=\"title\">update</span><span class=\"params\">(item *Item, value <span class=\"keyword\">string</span>, priority <span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">    item.value = value</span><br><span class=\"line\">    item.priority = priority</span><br><span class=\"line\">    heap.Fix(pq, item.index)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 创建节点并设计他们的优先级</span></span><br><span class=\"line\">    items := <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">int</span>&#123;<span class=\"string\">\"二毛\"</span>: <span class=\"number\">5</span>, <span class=\"string\">\"张三\"</span>: <span class=\"number\">3</span>, <span class=\"string\">\"狗蛋\"</span>: <span class=\"number\">9</span>&#125;</span><br><span class=\"line\">    i := <span class=\"number\">0</span></span><br><span class=\"line\">    pq := <span class=\"built_in\">make</span>(PriorityQueue, <span class=\"built_in\">len</span>(items)) <span class=\"comment\">// 创建优先级队列，并初始化</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> k, v := <span class=\"keyword\">range</span> items &#123;             <span class=\"comment\">// 将节点放到优先级队列中</span></span><br><span class=\"line\">        pq[i] = &amp;Item&#123;</span><br><span class=\"line\">            value:    k,</span><br><span class=\"line\">            priority: v,</span><br><span class=\"line\">            index:    i&#125;</span><br><span class=\"line\">        i++</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    heap.Init(&amp;pq) <span class=\"comment\">// 初始化堆</span></span><br><span class=\"line\">    item := &amp;Item&#123; <span class=\"comment\">// 创建一个 item</span></span><br><span class=\"line\">        value:    <span class=\"string\">\"李四\"</span>,</span><br><span class=\"line\">        priority: <span class=\"number\">1</span>,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    heap.Push(&amp;pq, item)           <span class=\"comment\">// 入优先级队列</span></span><br><span class=\"line\">    pq.update(item, item.value, <span class=\"number\">6</span>) <span class=\"comment\">// 更新 item 的优先级</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> <span class=\"built_in\">len</span>(pq) &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        item := heap.Pop(&amp;pq).(*Item)</span><br><span class=\"line\">        fmt.Printf(<span class=\"string\">\"%.2d:%s index:%.2d\\n\"</span>, item.priority, item.value, item.index)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 输出结果：</span></span><br><span class=\"line\"><span class=\"comment\">// 03:张三 index:-01</span></span><br><span class=\"line\"><span class=\"comment\">// 05:二毛 index:-01</span></span><br><span class=\"line\"><span class=\"comment\">// 06:李四 index:-01</span></span><br><span class=\"line\"><span class=\"comment\">// 09:狗蛋 index:-01</span></span><br></pre></td></tr></table></figure>","site":{"data":{"navigation":{"logo":{"text":"Golang Learn","type":"link","path":"index.html"},"main":[{"text":"Golang 基础","type":"label"},{"text":"Go 环境配置","type":"link","path":"basic/env_config.html"},{"text":"包","type":"link","path":"basic/package.html"},{"text":"基础数据类型","type":"link","path":"basic/basic_data.html"},{"text":"变量","type":"link","path":"basic/var.html"},{"text":"常量","type":"link","path":"basic/constant.html"},{"text":"控制语句","type":"link","path":"basic/flow.html"},{"text":"运算符","type":"link","path":"basic/operator.html"},{"text":"作用域","type":"link","path":"basic/scope.html"},{"text":"指针","type":"link","path":"basic/pointer.html"},{"text":"数组","type":"link","path":"basic/array.html"},{"text":"切片","type":"link","path":"basic/slice.html"},{"text":"字典","type":"link","path":"basic/map.html"},{"text":"函数","type":"link","path":"basic/function.html"},{"text":"结构体","type":"link","path":"basic/struct.html"},{"text":"接口","type":"link","path":"basic/interface.html"},{"text":"面向对象","type":"link","path":"basic/oop.html"},{"text":"错误","type":"link","path":"basic/error.html"},{"text":"序列化","type":"link","path":"basic/json.html"},{"text":"反射","type":"link","path":"basic/reflect.html"},{"text":"测试","type":"link","path":"basic/test.html"},{"text":"并发编程","type":"label"},{"text":"goroutine","type":"link","path":"concurrent/goroutine.html"},{"text":"channel","type":"link","path":"concurrent/channel.html"},{"text":"同步和锁","type":"link","path":"concurrent/sync_lock.html"},{"text":"内存分配","type":"label"},{"text":"内存分配","type":"link","path":"advance/mm.html"},{"text":"垃圾回收","type":"label"},{"text":"垃圾回收","type":"link","path":"advance/gc.html"},{"text":"标准库","type":"label"},{"text":"fmt","type":"link","path":"standards/io/fmt.html"},{"text":"io","type":"link","path":"standards/io/io.html"},{"text":"ioutil","type":"link","path":"standards/io/ioutil.html"},{"text":"bufio","type":"link","path":"standards/io/bufio.html"},{"text":"os","type":"link","path":"standards/os/os.html"},{"text":"filepath","type":"link","path":"standards/os/filepath.html"},{"text":"strings","type":"link","path":"standards/text/strings.html"},{"text":"strconv","type":"link","path":"standards/text/strconv.html"},{"text":"unicode","type":"link","path":"standards/text/unicode.html"},{"text":"log","type":"link","path":"standards/log.html"},{"text":"time","type":"link","path":"standards/time.html"},{"text":"http","type":"link","path":"standards/net/http.html"},{"text":"math","type":"link","path":"standards/data/math.html"},{"text":"sort","type":"link","path":"standards/data/sort.html"},{"text":"big","type":"link","path":"standards/data/big.html"},{"text":"container","type":"link","path":"standards/data/container.html"},{"text":"sql","type":"link","path":"standards/database/sql.html"},{"text":"THEME","type":"label"},{"text":"使用文档主题","type":"link","path":"theme/theme-usage.html"},{"text":"SUPPORT AND FEEDBACK","type":"label"},{"text":"Raise an Issue on Github","type":"link","path":"https://github.com/shipengqi/golang-learn/issues/new"}]}}},"excerpt":"","more":"<h1 id=\"container\"><a href=\"#container\" class=\"headerlink\" title=\"container\"></a>container</h1><p><code>container</code> 该包实现了三个复杂的数据结构：链表，环，堆。也就是说使用这三个数据结构的时候不需要再从头开始写算法了。</p>\n<h2 id=\"链表\"><a href=\"#链表\" class=\"headerlink\" title=\"链表\"></a>链表</h2><p>链表就是一个有 <code>prev</code> 和 <code>next</code> 指针的数组了。<br><code>container</code> 包中有两个公开的结构—— <code>List</code> 和 <code>Element</code>，<code>List</code> 实现了一个双向链表（简称链表），<br>而 <code>Element</code> 则代表了链表中元素的结构。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Element <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tnext, prev *Element  <span class=\"comment\">// 上一个元素和下一个元素</span></span><br><span class=\"line\">\tlist *List  <span class=\"comment\">// 元素所在链表</span></span><br><span class=\"line\">\tValue <span class=\"keyword\">interface</span>&#123;&#125;  <span class=\"comment\">// 元素</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> List <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\troot Element  <span class=\"comment\">// 链表的根元素</span></span><br><span class=\"line\">\t<span class=\"built_in\">len</span>  <span class=\"keyword\">int</span>      <span class=\"comment\">// 链表的长度</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>List的四种方法:</p>\n<ul>\n<li><code>MoveBefore</code> 方法和 <code>MoveAfter</code> 方法，它们分别用于把给定的元素移动到另一个元素的前面和后面。</li>\n<li><code>MoveToFront</code> 方法和 <code>MoveToBack</code> 方法，分别用于把给定的元素移动到链表的最前端和最后端。</li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// moves element \"e\" to its new position before \"mark\".</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(l *List)</span> <span class=\"title\">MoveBefore</span><span class=\"params\">(e, mark *Element)</span></span></span><br><span class=\"line\"><span class=\"function\">// <span class=\"title\">moves</span> <span class=\"title\">element</span> \"<span class=\"title\">e</span>\" <span class=\"title\">to</span> <span class=\"title\">its</span> <span class=\"title\">new</span> <span class=\"title\">position</span> <span class=\"title\">after</span> \"<span class=\"title\">mark</span>\".</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"params\">(l *List)</span> <span class=\"title\">MoveAfter</span><span class=\"params\">(e, mark *Element)</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// <span class=\"title\">moves</span> <span class=\"title\">element</span> \"<span class=\"title\">e</span>\" <span class=\"title\">to</span> <span class=\"title\">the</span> <span class=\"title\">front</span> <span class=\"title\">of</span> <span class=\"title\">list</span> \"<span class=\"title\">l</span>\".</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"params\">(l *List)</span> <span class=\"title\">MoveToFront</span><span class=\"params\">(e *Element)</span></span></span><br><span class=\"line\"><span class=\"function\">// <span class=\"title\">moves</span> <span class=\"title\">element</span> \"<span class=\"title\">e</span>\" <span class=\"title\">to</span> <span class=\"title\">the</span> <span class=\"title\">back</span> <span class=\"title\">of</span> <span class=\"title\">list</span> \"<span class=\"title\">l</span>\".</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"params\">(l *List)</span> <span class=\"title\">MoveToBack</span><span class=\"params\">(e *Element)</span></span></span><br></pre></td></tr></table></figure>\n<p>“给定的元素”都是 <code>*Element</code> 类型。</p>\n<p>如果我们自己生成这样的值，然后把它作为“给定的元素”传给链表的方法，那么会发生什么？链表会接受它吗？</p>\n<p>不会接受，这些方法将不会对链表做出任何改动。因为我们自己生成的 <code>Element</code> 值并不在链表中，所以也就谈不上“在链表中移动元素”。</p>\n<ul>\n<li><code>InsertBefore</code> 和 <code>InsertAfter</code> 方法分别用于在指定的元素之前和之后插入新元素。</li>\n<li><code>PushFront</code> 和 <code>PushBack</code> 方法则分别用于在链表的最前端和最后端插入新元素。</li>\n</ul>\n<p>示例：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">\"container/list\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"fmt\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    list := list.New()</span><br><span class=\"line\">    list.PushBack(<span class=\"number\">1</span>)</span><br><span class=\"line\">    list.PushBack(<span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">\"len: %v\\n\"</span>, list.Len())</span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">\"first: %#v\\n\"</span>, list.Front())</span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">\"second: %#v\\n\"</span>, list.Front().Next())</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">output:</span><br><span class=\"line\"><span class=\"built_in\">len</span>: <span class=\"number\">2</span></span><br><span class=\"line\">first: &amp;list.Element&#123;next:(*list.Element)(<span class=\"number\">0x2081be1b0</span>), prev:(*list.Element)(<span class=\"number\">0x2081be150</span>), list:(*list.List)(<span class=\"number\">0x2081be150</span>), Value:<span class=\"number\">1</span>&#125;</span><br><span class=\"line\">second: &amp;list.Element&#123;next:(*list.Element)(<span class=\"number\">0x2081be150</span>), prev:(*list.Element)(<span class=\"number\">0x2081be180</span>), list:(*list.List)(<span class=\"number\">0x2081be150</span>), Value:<span class=\"number\">2</span>&#125;</span><br></pre></td></tr></table></figure>\n<p>List 的其他方法：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Element</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(e *Element)</span> <span class=\"title\">Next</span><span class=\"params\">()</span> *<span class=\"title\">Element</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">func</span> <span class=\"params\">(e *Element)</span> <span class=\"title\">Prev</span><span class=\"params\">()</span> *<span class=\"title\">Element</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">type</span> <span class=\"title\">List</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">func</span> <span class=\"title\">New</span><span class=\"params\">()</span> *<span class=\"title\">List</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">func</span> <span class=\"params\">(l *List)</span> <span class=\"title\">Back</span><span class=\"params\">()</span> *<span class=\"title\">Element</span>   // 最后一个元素</span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">func</span> <span class=\"params\">(l *List)</span> <span class=\"title\">Front</span><span class=\"params\">()</span> *<span class=\"title\">Element</span>  // 第一个元素</span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">func</span> <span class=\"params\">(l *List)</span> <span class=\"title\">Init</span><span class=\"params\">()</span> *<span class=\"title\">List</span>  // 链表初始化</span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">func</span> <span class=\"params\">(l *List)</span> <span class=\"title\">InsertAfter</span><span class=\"params\">(v <span class=\"keyword\">interface</span>&#123;&#125;, mark *Element)</span> *<span class=\"title\">Element</span> // 在某个元素后插入</span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">func</span> <span class=\"params\">(l *List)</span> <span class=\"title\">InsertBefore</span><span class=\"params\">(v <span class=\"keyword\">interface</span>&#123;&#125;, mark *Element)</span> *<span class=\"title\">Element</span>  // 在某个元素前插入</span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">func</span> <span class=\"params\">(l *List)</span> <span class=\"title\">Len</span><span class=\"params\">()</span> <span class=\"title\">int</span> // 在链表长度</span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">func</span> <span class=\"params\">(l *List)</span> <span class=\"title\">PushBackList</span><span class=\"params\">(other *List)</span>  // 在队列最后插入接上新队列</span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">func</span> <span class=\"params\">(l *List)</span> <span class=\"title\">PushFrontList</span><span class=\"params\">(other *List)</span> // 在队列头部插入接上新队列</span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">func</span> <span class=\"params\">(l *List)</span> <span class=\"title\">Remove</span><span class=\"params\">(e *Element)</span> <span class=\"title\">interface</span></span>&#123;&#125; <span class=\"comment\">// 删除某个元素</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"环\"><a href=\"#环\" class=\"headerlink\" title=\"环\"></a>环</h2><p>环的结构有点特殊，环的尾部就是头部，指向环形链表任一元素的指针都可以作为整个环形链表看待。<br>它不需要像 List 一样保持 List 和 Element 两个结构，只需要保持一个结构就行。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Ring <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tnext, prev *Ring</span><br><span class=\"line\">\tValue      <span class=\"keyword\">interface</span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>初始化环的时候，需要定义好环的大小，然后对环的每个元素进行赋值。环还提供一个 <code>Do</code> 方法，能遍历一遍环，对每个元素执行<br>一个 <code>function</code>。</p>\n<p>示例：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">\"container/ring\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"fmt\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    ring := ring.New(<span class=\"number\">3</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">1</span>; i &lt;= <span class=\"number\">3</span>; i++ &#123;</span><br><span class=\"line\">        ring.Value = i</span><br><span class=\"line\">        ring = ring.Next()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 计算 1+2+3</span></span><br><span class=\"line\">    s := <span class=\"number\">0</span></span><br><span class=\"line\">    ring.Do(<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(p <span class=\"keyword\">interface</span>&#123;&#125;)</span></span>&#123;</span><br><span class=\"line\">        s += p.(<span class=\"keyword\">int</span>)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    fmt.Println(<span class=\"string\">\"sum is\"</span>, s)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">output:</span><br><span class=\"line\">sum is <span class=\"number\">6</span></span><br></pre></td></tr></table></figure>\n<p>ring 提供的方法有</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Ring</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">New</span><span class=\"params\">(n <span class=\"keyword\">int</span>)</span> *<span class=\"title\">Ring</span> // 创建一个长度为 <span class=\"title\">n</span> 的环形链表</span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">func</span> <span class=\"params\">(r *Ring)</span> <span class=\"title\">Do</span><span class=\"params\">(f <span class=\"keyword\">func</span>(<span class=\"keyword\">interface</span>&#123;&#125;)</span>) // 遍历环形链表中的每一个元素 <span class=\"title\">x</span> 进行 <span class=\"title\">f</span><span class=\"params\">(x)</span> 操作</span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">func</span> <span class=\"params\">(r *Ring)</span> <span class=\"title\">Len</span><span class=\"params\">()</span> <span class=\"title\">int</span> // 获取环形链表长度</span></span><br><span class=\"line\"><span class=\"function\">    </span></span><br><span class=\"line\"><span class=\"function\">    // 如果 <span class=\"title\">r</span> 和 <span class=\"title\">s</span> 在同一环形链表中，则删除 <span class=\"title\">r</span> 和 <span class=\"title\">s</span> 之间的元素，</span></span><br><span class=\"line\"><span class=\"function\">    // 被删除的元素组成一个新的环形链表，返回值为该环形链表的指针（即删除前，<span class=\"title\">r</span>-&gt;<span class=\"title\">Next</span><span class=\"params\">()</span> 表示的元素）</span></span><br><span class=\"line\"><span class=\"function\">    // 如果 <span class=\"title\">r</span> 和 <span class=\"title\">s</span> 不在同一个环形链表中，则将 <span class=\"title\">s</span> 插入到 <span class=\"title\">r</span> 后面，返回值为</span></span><br><span class=\"line\"><span class=\"function\">    // 插入 <span class=\"title\">s</span> 后，<span class=\"title\">s</span> 最后一个元素的下一个元素（即插入前，<span class=\"title\">r</span>-&gt;<span class=\"title\">Next</span><span class=\"params\">()</span> 表示的元素）</span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">func</span> <span class=\"params\">(r *Ring)</span> <span class=\"title\">Link</span><span class=\"params\">(s *Ring)</span> *<span class=\"title\">Ring</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">func</span> <span class=\"params\">(r *Ring)</span> <span class=\"title\">Move</span><span class=\"params\">(n <span class=\"keyword\">int</span>)</span> *<span class=\"title\">Ring</span> // 移动 <span class=\"title\">n</span> % <span class=\"title\">r</span>.<span class=\"title\">Len</span><span class=\"params\">()</span> 个位置，<span class=\"title\">n</span> 正负均可</span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">func</span> <span class=\"params\">(r *Ring)</span> <span class=\"title\">Next</span><span class=\"params\">()</span> *<span class=\"title\">Ring</span> // 返回下一个元素</span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">func</span> <span class=\"params\">(r *Ring)</span> <span class=\"title\">Prev</span><span class=\"params\">()</span> *<span class=\"title\">Ring</span> // 返回前一个元素</span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">func</span> <span class=\"params\">(r *Ring)</span> <span class=\"title\">Unlink</span><span class=\"params\">(n <span class=\"keyword\">int</span>)</span> *<span class=\"title\">Ring</span> // 删除 <span class=\"title\">r</span> 后面的 <span class=\"title\">n</span> % <span class=\"title\">r</span>.<span class=\"title\">Len</span><span class=\"params\">()</span> 个元素</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"堆\"><a href=\"#堆\" class=\"headerlink\" title=\"堆\"></a>堆</h2><h3 id=\"什么是堆\"><a href=\"#什么是堆\" class=\"headerlink\" title=\"什么是堆\"></a>什么是堆</h3><p>堆（Heap，也叫优先队列）是计算机科学中一类特殊的数据结构的统称。<strong>堆通常是一个可以被看做一棵树的数组对象</strong>。</p>\n<p>堆具有以下特性：</p>\n<ul>\n<li>任意节点小于（或大于）它的所有后裔，最小元（或最大元）在堆的根上（堆序性）。</li>\n<li>堆总是一棵完全树。即除了最底层，其他层的节点都被元素填满，且最底层尽可能地从左到右填入。</li>\n</ul>\n<p>将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。</p>\n<h3 id=\"Heap\"><a href=\"#Heap\" class=\"headerlink\" title=\"Heap\"></a>Heap</h3><p><code>heap</code> 使用的数据结构是最小堆，<code>heap</code> 包只是实现了一个接口：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Interface <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">    sort.Interface</span><br><span class=\"line\">    Push(x <span class=\"keyword\">interface</span>&#123;&#125;) <span class=\"comment\">// add x as element Len()</span></span><br><span class=\"line\">    Pop() <span class=\"keyword\">interface</span>&#123;&#125;   <span class=\"comment\">// remove and return element Len() - 1.</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这个接口内嵌了 <code>sort.Interface</code>，那么要实现 <code>heap.Interface</code> 要实现下面的方法：</p>\n<ul>\n<li><code>Len() int</code></li>\n<li><code>Less(i, j int) bool</code></li>\n<li><code>Swap(i, j int)</code></li>\n<li><code>Push(x interface{})</code></li>\n<li><code>Pop() interface{}</code></li>\n</ul>\n<p>示例：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> IntHeap []<span class=\"keyword\">int</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(h IntHeap)</span> <span class=\"title\">Len</span><span class=\"params\">()</span> <span class=\"title\">int</span></span>           &#123; <span class=\"keyword\">return</span> <span class=\"built_in\">len</span>(h) &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(h IntHeap)</span> <span class=\"title\">Less</span><span class=\"params\">(i, j <span class=\"keyword\">int</span>)</span> <span class=\"title\">bool</span></span> &#123; <span class=\"keyword\">return</span> h[i] &lt; h[j] &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(h IntHeap)</span> <span class=\"title\">Swap</span><span class=\"params\">(i, j <span class=\"keyword\">int</span>)</span></span>      &#123; h[i], h[j] = h[j], h[i] &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(h *IntHeap)</span> <span class=\"title\">Push</span><span class=\"params\">(x <span class=\"keyword\">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class=\"line\">    *h = <span class=\"built_in\">append</span>(*h, x.(<span class=\"keyword\">int</span>))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(h *IntHeap)</span> <span class=\"title\">Pop</span><span class=\"params\">()</span> <span class=\"title\">interface</span></span>&#123;&#125; &#123;</span><br><span class=\"line\">    old := *h</span><br><span class=\"line\">    n := <span class=\"built_in\">len</span>(old)</span><br><span class=\"line\">    x := old[n<span class=\"number\">-1</span>]</span><br><span class=\"line\">    *h = old[<span class=\"number\">0</span> : n<span class=\"number\">-1</span>]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"heap-提供的方法\"><a href=\"#heap-提供的方法\" class=\"headerlink\" title=\"heap 提供的方法\"></a>heap 提供的方法</h4><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">h := &amp;IntHeap&#123;<span class=\"number\">3</span>, <span class=\"number\">8</span>, <span class=\"number\">6</span>&#125;  <span class=\"comment\">// 创建 IntHeap 类型的原始数据</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Init</span><span class=\"params\">(h Interface)</span>  // 对 <span class=\"title\">heap</span> 进行初始化，生成小根堆（或大根堆）</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">Push</span><span class=\"params\">(h Interface, x <span class=\"keyword\">interface</span>&#123;&#125;)</span>  // 往堆里面插入内容</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">Pop</span><span class=\"params\">(h Interface)</span> <span class=\"title\">interface</span></span>&#123;&#125;  <span class=\"comment\">// 从堆顶 pop 出内容</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Remove</span><span class=\"params\">(h Interface, i <span class=\"keyword\">int</span>)</span> <span class=\"title\">interface</span></span>&#123;&#125;  <span class=\"comment\">// 从指定位置删除数据，并返回删除的数据</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Fix</span><span class=\"params\">(h Interface, i <span class=\"keyword\">int</span>)</span>  // 从 <span class=\"title\">i</span> 位置数据发生改变后，对堆再平衡，优先级队列使用到了该方法</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"实现优先级队列\"><a href=\"#实现优先级队列\" class=\"headerlink\" title=\"实现优先级队列\"></a>实现优先级队列</h4><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">\"container/heap\"</span></span><br><span class=\"line\">    <span class=\"string\">\"fmt\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Item <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    value    <span class=\"keyword\">string</span> <span class=\"comment\">// 优先级队列中的数据，可以是任意类型，这里使用 string</span></span><br><span class=\"line\">    priority <span class=\"keyword\">int</span>    <span class=\"comment\">// 优先级队列中节点的优先级</span></span><br><span class=\"line\">    index    <span class=\"keyword\">int</span>    <span class=\"comment\">// index 是该节点在堆中的位置</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 优先级队列需要实现 heap 的 Interface</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> PriorityQueue []*Item</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(pq PriorityQueue)</span> <span class=\"title\">Len</span><span class=\"params\">()</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">len</span>(pq)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这里用的是小于号，生成的是最小堆</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(pq PriorityQueue)</span> <span class=\"title\">Less</span><span class=\"params\">(i, j <span class=\"keyword\">int</span>)</span> <span class=\"title\">bool</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pq[i].priority &lt; pq[j].priority</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(pq PriorityQueue)</span> <span class=\"title\">Swap</span><span class=\"params\">(i, j <span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">    pq[i], pq[j] = pq[j], pq[i]</span><br><span class=\"line\">    pq[i].index, pq[j].index = i, j</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将 index 置为 -1 是为了标识该数据已经出了优先级队列了</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(pq *PriorityQueue)</span> <span class=\"title\">Pop</span><span class=\"params\">()</span> <span class=\"title\">interface</span></span>&#123;&#125; &#123;</span><br><span class=\"line\">    old := *pq</span><br><span class=\"line\">    n := <span class=\"built_in\">len</span>(old)</span><br><span class=\"line\">    item := old[n<span class=\"number\">-1</span>]</span><br><span class=\"line\">    *pq = old[<span class=\"number\">0</span> : n<span class=\"number\">-1</span>]</span><br><span class=\"line\">    item.index = <span class=\"number\">-1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> item</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(pq *PriorityQueue)</span> <span class=\"title\">Push</span><span class=\"params\">(x <span class=\"keyword\">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class=\"line\">    n := <span class=\"built_in\">len</span>(*pq)</span><br><span class=\"line\">    item := x.(*Item)</span><br><span class=\"line\">    item.index = n</span><br><span class=\"line\">    *pq = <span class=\"built_in\">append</span>(*pq, item)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 更新修改了优先级和值的 item 在优先级队列中的位置</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(pq *PriorityQueue)</span> <span class=\"title\">update</span><span class=\"params\">(item *Item, value <span class=\"keyword\">string</span>, priority <span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">    item.value = value</span><br><span class=\"line\">    item.priority = priority</span><br><span class=\"line\">    heap.Fix(pq, item.index)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 创建节点并设计他们的优先级</span></span><br><span class=\"line\">    items := <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">int</span>&#123;<span class=\"string\">\"二毛\"</span>: <span class=\"number\">5</span>, <span class=\"string\">\"张三\"</span>: <span class=\"number\">3</span>, <span class=\"string\">\"狗蛋\"</span>: <span class=\"number\">9</span>&#125;</span><br><span class=\"line\">    i := <span class=\"number\">0</span></span><br><span class=\"line\">    pq := <span class=\"built_in\">make</span>(PriorityQueue, <span class=\"built_in\">len</span>(items)) <span class=\"comment\">// 创建优先级队列，并初始化</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> k, v := <span class=\"keyword\">range</span> items &#123;             <span class=\"comment\">// 将节点放到优先级队列中</span></span><br><span class=\"line\">        pq[i] = &amp;Item&#123;</span><br><span class=\"line\">            value:    k,</span><br><span class=\"line\">            priority: v,</span><br><span class=\"line\">            index:    i&#125;</span><br><span class=\"line\">        i++</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    heap.Init(&amp;pq) <span class=\"comment\">// 初始化堆</span></span><br><span class=\"line\">    item := &amp;Item&#123; <span class=\"comment\">// 创建一个 item</span></span><br><span class=\"line\">        value:    <span class=\"string\">\"李四\"</span>,</span><br><span class=\"line\">        priority: <span class=\"number\">1</span>,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    heap.Push(&amp;pq, item)           <span class=\"comment\">// 入优先级队列</span></span><br><span class=\"line\">    pq.update(item, item.value, <span class=\"number\">6</span>) <span class=\"comment\">// 更新 item 的优先级</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> <span class=\"built_in\">len</span>(pq) &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        item := heap.Pop(&amp;pq).(*Item)</span><br><span class=\"line\">        fmt.Printf(<span class=\"string\">\"%.2d:%s index:%.2d\\n\"</span>, item.priority, item.value, item.index)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 输出结果：</span></span><br><span class=\"line\"><span class=\"comment\">// 03:张三 index:-01</span></span><br><span class=\"line\"><span class=\"comment\">// 05:二毛 index:-01</span></span><br><span class=\"line\"><span class=\"comment\">// 06:李四 index:-01</span></span><br><span class=\"line\"><span class=\"comment\">// 09:狗蛋 index:-01</span></span><br></pre></td></tr></table></figure>"},{"title":"bufio","_content":"\n# bufio\n\nbufio 包实现了缓存 IO。提供了数据缓冲功能，能够一定程度减少大块数据读写带来的开销。封装了 `io.Reader` 和 `io.Writer` 对象。\n\n\n## bufio包中的数据类型\nbufio包中的数据类型主要有：\n- `Reader`；\n- `Scanner`；\n- `Writer` 和 `ReadWriter`。\n\n## bufio.Reader\n两个用于初始化 `bufio.Reader` 的函数：\n\n- `NewReader` 函数初始化的 `Reader` 值会拥有一个默认尺寸的缓冲区。这个默认尺寸是 `4096` 个字节，即：`4 KB`。\n- `NewReaderSize` 函数则将缓冲区尺寸的决定权抛给了使用方。\n\n```go\nfunc NewReader(rd io.Reader) *Reader\n\nfunc NewReaderSize(rd io.Reader, size int) *Reader // 可以配置缓冲区的大小\n```\n### bufio.Reader 类型值中的缓冲区的作用\n缓冲区其实就是一个**数据存储中介，它介于底层读取器与读取方法及其调用方之间**。所谓的底层读取器是指 `io.Reader`。\n\n`Reader` 值的读取方法一般都会先从其所属值的缓冲区中读取数据。同时，在必要的时候，它们还会预先从底层读取器那里读出一部分数据，并暂\n存于缓冲区之中以备后用。\n\n缓冲区的好处是，可以在大多数的时候降低读取方法的执行时间。\n\n```go\ntype Reader struct {\n    buf          []byte\n    rd           io.Reader\n    r, w         int\n    err          error\n    lastByte     int\n    lastRuneSize int\n}\n```\n\n`bufio.Reader` 字段：\n- `buf`：`[]byte` 类型的字段，即字节切片，代表缓冲区。虽然它是切片类型的，但是其长度却会在初始化的时候指定，并在之后保持不变。\n- `rd`：`io.Reader` 类型的字段，代表底层读取器。缓冲区中的数据就是从这里拷贝来的。\n- `r`：`int` 类型的字段，代表对缓冲区进行下一次读取时的开始索引。我们可以称它为已读计数。\n- `w`：`int` 类型的字段，代表对缓冲区进行下一次写入时的开始索引。我们可以称之为已写计数。\n- `err`：`error` 类型的字段。它的值用于表示在从底层读取器获得数据时发生的错误。这里的值在被读取或忽略之后，该字段会被置为 `nil`。\n- `lastByte`：`int` 类型的字段，用于记录缓冲区中最后一个被读取的字节。读回退时会用到它的值。\n- `lastRuneSize`：`int` 类型的字段，用于记录缓冲区中最后一个被读取的 Unicode 字符所占用的字节数。读回退的时候会用到它的值。这个字\n段只会在其所属值的 `ReadRune` 方法中才会被赋予有意义的值。在其他情况下，它都会被置为 `-1`。\n\n### bufio.Reader 类型读取方法\n\n#### ReadSlice、ReadBytes、ReadString 和 ReadLine\n\n后三个方法最终都是调用 `ReadSlice` 来实现的。所以，我们先来看看 `ReadSlice` 方法。\n\n**ReadSlice方法**：\n```go\nfunc (b *Reader) ReadSlice(delim byte) (line []byte, err error)\n```\n`ReadSlice` 从输入中读取，直到遇到第一个界定符（delim）为止，返回一个指向缓存中字节的 `slice`，在下次调用读操作（`read`）时，这些字节会\n无效：\n```go\nreader := bufio.NewReader(strings.NewReader(\"Hello \\nworld\"))\nline, _ := reader.ReadSlice('\\n')\nfmt.Printf(\"the line:%s\\n\", line) // the line:Hello\nn, _ := reader.ReadSlice('\\n')\nfmt.Printf(\"the line:%s\\n\", line) // the line:world\nfmt.Println(string(n)) // world\n```\n\n从结果可以看出，第一次 `ReadSlice` 的结果 **line**，在第二次调用读操作后，内容发生了变化。也就是说，`ReadSlice` 返回的 `[]byte` 是指\n向 `Reader` 中的 `buffer` ，而不是 `copy` 一份返回。正因为 `ReadSlice` 返回的数据会被下次的 I/O 操作重写，因此许多的客户端会选择\n使用 `ReadBytes` 或者 `ReadString` 来代替。\n\n注意，这里的界定符可以是任意的字符。同时，返回的结果是包含界定符本身的。\n\n如果 `ReadSlice` 在找到界定符之前遇到了 `error`，它就会返回缓存中所有的数据和错误本身（经常是 `io.EOF`）。如果在找到界定符之前缓存已经\n满了，`ReadSlice` 会返回 `bufio.ErrBufferFull` 错误。当且仅当返回的结果（`line`）没有以界定符结束的时候，`ReadSlice` 返\n回 `err != nil`，也就是说，如果 `ReadSlice` 返回的结果 `line` 不是以界定符 `delim` 结尾，那么返回的 `err` 也一定不等于 `nil`。\n\n**ReadBytes 方法**：\n```go\nfunc (b *Reader) ReadBytes(delim byte) (line []byte, err error)\n```\n该方法的参数和返回值类型与 `ReadSlice` 都一样。 `ReadBytes` 从输入中读取直到遇到界定符（delim）为止，返回的 `slice` 包含了从当前到\n界定符的内容 **（包括界定符）**。\n\n`ReadBytes` 源码：\n```go\nfunc (b *Reader) ReadBytes(delim byte) ([]byte, error) {\n\t// Use ReadSlice to look for array,\n\t// accumulating full buffers.\n\tvar frag []byte\n\tvar full [][]byte\n\tvar err error\n\tfor {\n\t\tvar e error\n\t\tfrag, e = b.ReadSlice(delim)\n\t\tif e == nil { // got final fragment\n\t\t\tbreak\n\t\t}\n\t\tif e != ErrBufferFull { // unexpected error\n\t\t\terr = e\n\t\t\tbreak\n\t\t}\n\n\t\t// Make a copy of the buffer.\n\t\tbuf := make([]byte, len(frag)) // 这里把 ReadSlice 的返回值 copy 了一份，不再是指向 Reader 中的 buffer\n\t\tcopy(buf, frag)\n\t\tfull = append(full, buf)\n\t}\n\n\t// Allocate new buffer to hold the full pieces and the fragment.\n\tn := 0\n\tfor i := range full {\n\t\tn += len(full[i])\n\t}\n\tn += len(frag)\n\n\t// Copy full pieces and fragment in.\n\tbuf := make([]byte, n)\n\tn = 0\n\tfor i := range full {\n\t\tn += copy(buf[n:], full[i])\n\t}\n\tcopy(buf[n:], frag)\n\treturn buf, err\n}\n```\n**ReadString 方法**\n\n`ReadString` 源码：\n```go\nfunc (b *Reader) ReadString(delim byte) (line string, err error) {\n    bytes, err := b.ReadBytes(delim)\n    return string(bytes), err\n}\n```\n调用了 `ReadBytes` 方法，并将结果的 `[]byte` 转为 `string` 类型。\n\n**ReadLine 方法**\n```go\nfunc (b *Reader) ReadLine() (line []byte, isPrefix bool, err error)\n```\n`ReadLine` 是一个底层的原始行读取命令。可以使用 `ReadBytes('\\n')` 或者 `ReadString('\\n')` 来代替这个方法。\n\n**`ReadLine` 尝试返回单独的行，不包括行尾的换行符**。如果一行大于缓存，`isPrefix` 会被设置为 `true`，同时返回该行的开始部分\n（等于缓存大小的部分）。该行剩余的部分就会在下次调用的时候返回。当下次调用返回该行剩余部分时，`isPrefix` 将会是 `false` 。\n跟 `ReadSlice` 一样，**返回的 `line` 是 `buffer` 的引用**，在下次执行 IO 操作时，`line` 会无效。\n\n建议读取一行使用下面的方式：\n```go\nline, err := reader.ReadBytes('\\n')\nline = bytes.TrimRight(line, \"\\r\\n\")\n```\n\n### Peek 方法\n\n`Peek` 是 \"窥视\" 的意思，`Peek` 一个鲜明的特点，就是：即使它读取了缓冲区中的数据，也不会更改已读计数的值。\n\n```go\nfunc (b *Reader) Peek(n int) ([]byte, error)\n```\n**返回的 `[]byte` 是 `buffer` 中的引用**，该切片引用缓存中前 `n` 字节数据。\n\n**`Peek` 方法、`ReadSlice` 方法和 `ReadLine` 方法都有可能会造成内容泄露。这主要是因为它们在正常的情况下都会返回直接基于缓冲区的字节切片，\n也因为为这个原因对多 goroutine 是不安全的，也就是在多并发环境下，不能依赖其结果。**。\n\n另外，Reader 的 Peek 方法如果返回的 []byte 长度小于 n，这时返回的 `err != nil` ，用于解释为啥会小于 n。如果 n 大于 reader 的 buffer 长度，err 会是 ErrBufferFull。\n\n### 其他方法\n```go\nfunc (b *Reader) Read(p []byte) (n int, err error)\nfunc (b *Reader) ReadByte() (c byte, err error)\nfunc (b *Reader) ReadRune() (r rune, size int, err error)\nfunc (b *Reader) UnreadByte() error\nfunc (b *Reader) UnreadRune() error\nfunc (b *Reader) WriteTo(w io.Writer) (n int64, err error)\n```\n\n## bufio.Writer\n`bufio.Writer` 结构封装了一个 `io.Writer` 对象。同时实现了 `io.Writer` 接口。\n```go\ntype Writer struct {\n    err error\t\t// 写过程中遇到的错误\n    buf []byte\t\t// 缓存\n    n   int\t\t\t// 当前缓存中的字节数\n    wr  io.Writer\t// 底层的 io.Writer 对象\n}\n```\n\n`bufio.Writer` 类型的字段:\n- `err`：`error` 类型的字段。它的值用于表示在向底层写入器写数据时发生的错误。\n- `buf`：`[]byte` 类型的字段，代表缓冲区。在初始化之后，它的长度会保持不变。\n- `n`：`int` 类型的字段，代表对缓冲区进行下一次写入时的开始索引。我们可以称之为已写计数。\n- `wr`：`io.Writer` 类型的字段，代表底层写入器。\n\n两个用于初始化 `bufio.Writer` 的函数：\n\n- `NewWriter` 函数初始化的 `Writer` 值会拥有一个默认尺寸的缓冲区。这个默认尺寸是 `4096` 个字节，即：`4 KB`。\n- `NewWriterSize` 函数则将缓冲区尺寸的决定权抛给了使用方。\n\n```go\nfunc NewWriter(wr io.Writer) *Writer\n\nfunc NewWriterSize(wr io.Writer, size int) *Writer // 可以配置缓冲区的大小\n```\n\n### 方法\n- `Available` 方法获取缓存中还未使用的字节数（缓存大小 - 字段 n 的值）\n- `Buffered` 方法获取写入当前缓存中的字节数（字段 n 的值）\n- `Flush` 方法将缓存中的所有数据写入底层的 io.Writer 对象中。\n\n其他实现了 `io` 包的接口方法：\n```go\n// 实现了 io.ReaderFrom 接口\nfunc (b *Writer) ReadFrom(r io.Reader) (n int64, err error)\n\n// 实现了 io.Writer 接口\nfunc (b *Writer) Write(p []byte) (nn int, err error)\n\n// 实现了 io.ByteWriter 接口\nfunc (b *Writer) WriteByte(c byte) error\n\n// io 中没有该方法的接口，它用于写入单个 Unicode 码点，返回写入的字节数（码点占用的字节），内部实现会根据当前 rune 的范围调用 WriteByte 或 WriteString\nfunc (b *Writer) WriteRune(r rune) (size int, err error)\n\n// 写入字符串，如果返回写入的字节数比 len(s) 小，返回的error会解释原因\nfunc (b *Writer) WriteString(s string) (int, error)\n```\n\n### bufio.Writer 类型值中缓冲的数据什么时候会被写到它的底层写入器\n\n`bufio.Writer` 类型有一个名为 `Flush` 的方法，它的主要功能是把相应缓冲区中暂存的所有数据，都写到底层写入器中。数据一旦被写进底层写入器，\n该方法就会把它们从缓冲区中删除掉。\n\n`bufio.Writer` 类型值（以下简称 `Writer` 值）拥有的所有数据写入方法都会在必要的时候调用它的 `Flush` 方法。\n\n比如，`Write` 方法有时候会在把数据写进缓冲区之后，调用 `Flush` 方法，以便为后续的新数据腾出空间。`WriteString` 方法的行为与之类似。\n\n`WriteByte` 方法和 `WriteRune` 方法，都会在发现缓冲区中的可写空间不足以容纳新的字节，或 Unicode 字符的时候，调用 `Flush` 方法。\n\n在**通常情况下，只要缓冲区中的可写空间无法容纳需要写入的新数据，`Flush` 方法就一定会被调用**。\n\n## ReadWriter\n```go\ntype ReadWriter struct {\n    *Reader\n    *Writer\n}\n```\n\n通过调用 `bufio.NewReadWriter` 函数来初始化：\n```go\nfunc NewReadWriter(r *Reader, w *Writer) *ReadWriter\n```","source":"standards/io/bufio.md","raw":"---\ntitle: bufio\n---\n\n# bufio\n\nbufio 包实现了缓存 IO。提供了数据缓冲功能，能够一定程度减少大块数据读写带来的开销。封装了 `io.Reader` 和 `io.Writer` 对象。\n\n\n## bufio包中的数据类型\nbufio包中的数据类型主要有：\n- `Reader`；\n- `Scanner`；\n- `Writer` 和 `ReadWriter`。\n\n## bufio.Reader\n两个用于初始化 `bufio.Reader` 的函数：\n\n- `NewReader` 函数初始化的 `Reader` 值会拥有一个默认尺寸的缓冲区。这个默认尺寸是 `4096` 个字节，即：`4 KB`。\n- `NewReaderSize` 函数则将缓冲区尺寸的决定权抛给了使用方。\n\n```go\nfunc NewReader(rd io.Reader) *Reader\n\nfunc NewReaderSize(rd io.Reader, size int) *Reader // 可以配置缓冲区的大小\n```\n### bufio.Reader 类型值中的缓冲区的作用\n缓冲区其实就是一个**数据存储中介，它介于底层读取器与读取方法及其调用方之间**。所谓的底层读取器是指 `io.Reader`。\n\n`Reader` 值的读取方法一般都会先从其所属值的缓冲区中读取数据。同时，在必要的时候，它们还会预先从底层读取器那里读出一部分数据，并暂\n存于缓冲区之中以备后用。\n\n缓冲区的好处是，可以在大多数的时候降低读取方法的执行时间。\n\n```go\ntype Reader struct {\n    buf          []byte\n    rd           io.Reader\n    r, w         int\n    err          error\n    lastByte     int\n    lastRuneSize int\n}\n```\n\n`bufio.Reader` 字段：\n- `buf`：`[]byte` 类型的字段，即字节切片，代表缓冲区。虽然它是切片类型的，但是其长度却会在初始化的时候指定，并在之后保持不变。\n- `rd`：`io.Reader` 类型的字段，代表底层读取器。缓冲区中的数据就是从这里拷贝来的。\n- `r`：`int` 类型的字段，代表对缓冲区进行下一次读取时的开始索引。我们可以称它为已读计数。\n- `w`：`int` 类型的字段，代表对缓冲区进行下一次写入时的开始索引。我们可以称之为已写计数。\n- `err`：`error` 类型的字段。它的值用于表示在从底层读取器获得数据时发生的错误。这里的值在被读取或忽略之后，该字段会被置为 `nil`。\n- `lastByte`：`int` 类型的字段，用于记录缓冲区中最后一个被读取的字节。读回退时会用到它的值。\n- `lastRuneSize`：`int` 类型的字段，用于记录缓冲区中最后一个被读取的 Unicode 字符所占用的字节数。读回退的时候会用到它的值。这个字\n段只会在其所属值的 `ReadRune` 方法中才会被赋予有意义的值。在其他情况下，它都会被置为 `-1`。\n\n### bufio.Reader 类型读取方法\n\n#### ReadSlice、ReadBytes、ReadString 和 ReadLine\n\n后三个方法最终都是调用 `ReadSlice` 来实现的。所以，我们先来看看 `ReadSlice` 方法。\n\n**ReadSlice方法**：\n```go\nfunc (b *Reader) ReadSlice(delim byte) (line []byte, err error)\n```\n`ReadSlice` 从输入中读取，直到遇到第一个界定符（delim）为止，返回一个指向缓存中字节的 `slice`，在下次调用读操作（`read`）时，这些字节会\n无效：\n```go\nreader := bufio.NewReader(strings.NewReader(\"Hello \\nworld\"))\nline, _ := reader.ReadSlice('\\n')\nfmt.Printf(\"the line:%s\\n\", line) // the line:Hello\nn, _ := reader.ReadSlice('\\n')\nfmt.Printf(\"the line:%s\\n\", line) // the line:world\nfmt.Println(string(n)) // world\n```\n\n从结果可以看出，第一次 `ReadSlice` 的结果 **line**，在第二次调用读操作后，内容发生了变化。也就是说，`ReadSlice` 返回的 `[]byte` 是指\n向 `Reader` 中的 `buffer` ，而不是 `copy` 一份返回。正因为 `ReadSlice` 返回的数据会被下次的 I/O 操作重写，因此许多的客户端会选择\n使用 `ReadBytes` 或者 `ReadString` 来代替。\n\n注意，这里的界定符可以是任意的字符。同时，返回的结果是包含界定符本身的。\n\n如果 `ReadSlice` 在找到界定符之前遇到了 `error`，它就会返回缓存中所有的数据和错误本身（经常是 `io.EOF`）。如果在找到界定符之前缓存已经\n满了，`ReadSlice` 会返回 `bufio.ErrBufferFull` 错误。当且仅当返回的结果（`line`）没有以界定符结束的时候，`ReadSlice` 返\n回 `err != nil`，也就是说，如果 `ReadSlice` 返回的结果 `line` 不是以界定符 `delim` 结尾，那么返回的 `err` 也一定不等于 `nil`。\n\n**ReadBytes 方法**：\n```go\nfunc (b *Reader) ReadBytes(delim byte) (line []byte, err error)\n```\n该方法的参数和返回值类型与 `ReadSlice` 都一样。 `ReadBytes` 从输入中读取直到遇到界定符（delim）为止，返回的 `slice` 包含了从当前到\n界定符的内容 **（包括界定符）**。\n\n`ReadBytes` 源码：\n```go\nfunc (b *Reader) ReadBytes(delim byte) ([]byte, error) {\n\t// Use ReadSlice to look for array,\n\t// accumulating full buffers.\n\tvar frag []byte\n\tvar full [][]byte\n\tvar err error\n\tfor {\n\t\tvar e error\n\t\tfrag, e = b.ReadSlice(delim)\n\t\tif e == nil { // got final fragment\n\t\t\tbreak\n\t\t}\n\t\tif e != ErrBufferFull { // unexpected error\n\t\t\terr = e\n\t\t\tbreak\n\t\t}\n\n\t\t// Make a copy of the buffer.\n\t\tbuf := make([]byte, len(frag)) // 这里把 ReadSlice 的返回值 copy 了一份，不再是指向 Reader 中的 buffer\n\t\tcopy(buf, frag)\n\t\tfull = append(full, buf)\n\t}\n\n\t// Allocate new buffer to hold the full pieces and the fragment.\n\tn := 0\n\tfor i := range full {\n\t\tn += len(full[i])\n\t}\n\tn += len(frag)\n\n\t// Copy full pieces and fragment in.\n\tbuf := make([]byte, n)\n\tn = 0\n\tfor i := range full {\n\t\tn += copy(buf[n:], full[i])\n\t}\n\tcopy(buf[n:], frag)\n\treturn buf, err\n}\n```\n**ReadString 方法**\n\n`ReadString` 源码：\n```go\nfunc (b *Reader) ReadString(delim byte) (line string, err error) {\n    bytes, err := b.ReadBytes(delim)\n    return string(bytes), err\n}\n```\n调用了 `ReadBytes` 方法，并将结果的 `[]byte` 转为 `string` 类型。\n\n**ReadLine 方法**\n```go\nfunc (b *Reader) ReadLine() (line []byte, isPrefix bool, err error)\n```\n`ReadLine` 是一个底层的原始行读取命令。可以使用 `ReadBytes('\\n')` 或者 `ReadString('\\n')` 来代替这个方法。\n\n**`ReadLine` 尝试返回单独的行，不包括行尾的换行符**。如果一行大于缓存，`isPrefix` 会被设置为 `true`，同时返回该行的开始部分\n（等于缓存大小的部分）。该行剩余的部分就会在下次调用的时候返回。当下次调用返回该行剩余部分时，`isPrefix` 将会是 `false` 。\n跟 `ReadSlice` 一样，**返回的 `line` 是 `buffer` 的引用**，在下次执行 IO 操作时，`line` 会无效。\n\n建议读取一行使用下面的方式：\n```go\nline, err := reader.ReadBytes('\\n')\nline = bytes.TrimRight(line, \"\\r\\n\")\n```\n\n### Peek 方法\n\n`Peek` 是 \"窥视\" 的意思，`Peek` 一个鲜明的特点，就是：即使它读取了缓冲区中的数据，也不会更改已读计数的值。\n\n```go\nfunc (b *Reader) Peek(n int) ([]byte, error)\n```\n**返回的 `[]byte` 是 `buffer` 中的引用**，该切片引用缓存中前 `n` 字节数据。\n\n**`Peek` 方法、`ReadSlice` 方法和 `ReadLine` 方法都有可能会造成内容泄露。这主要是因为它们在正常的情况下都会返回直接基于缓冲区的字节切片，\n也因为为这个原因对多 goroutine 是不安全的，也就是在多并发环境下，不能依赖其结果。**。\n\n另外，Reader 的 Peek 方法如果返回的 []byte 长度小于 n，这时返回的 `err != nil` ，用于解释为啥会小于 n。如果 n 大于 reader 的 buffer 长度，err 会是 ErrBufferFull。\n\n### 其他方法\n```go\nfunc (b *Reader) Read(p []byte) (n int, err error)\nfunc (b *Reader) ReadByte() (c byte, err error)\nfunc (b *Reader) ReadRune() (r rune, size int, err error)\nfunc (b *Reader) UnreadByte() error\nfunc (b *Reader) UnreadRune() error\nfunc (b *Reader) WriteTo(w io.Writer) (n int64, err error)\n```\n\n## bufio.Writer\n`bufio.Writer` 结构封装了一个 `io.Writer` 对象。同时实现了 `io.Writer` 接口。\n```go\ntype Writer struct {\n    err error\t\t// 写过程中遇到的错误\n    buf []byte\t\t// 缓存\n    n   int\t\t\t// 当前缓存中的字节数\n    wr  io.Writer\t// 底层的 io.Writer 对象\n}\n```\n\n`bufio.Writer` 类型的字段:\n- `err`：`error` 类型的字段。它的值用于表示在向底层写入器写数据时发生的错误。\n- `buf`：`[]byte` 类型的字段，代表缓冲区。在初始化之后，它的长度会保持不变。\n- `n`：`int` 类型的字段，代表对缓冲区进行下一次写入时的开始索引。我们可以称之为已写计数。\n- `wr`：`io.Writer` 类型的字段，代表底层写入器。\n\n两个用于初始化 `bufio.Writer` 的函数：\n\n- `NewWriter` 函数初始化的 `Writer` 值会拥有一个默认尺寸的缓冲区。这个默认尺寸是 `4096` 个字节，即：`4 KB`。\n- `NewWriterSize` 函数则将缓冲区尺寸的决定权抛给了使用方。\n\n```go\nfunc NewWriter(wr io.Writer) *Writer\n\nfunc NewWriterSize(wr io.Writer, size int) *Writer // 可以配置缓冲区的大小\n```\n\n### 方法\n- `Available` 方法获取缓存中还未使用的字节数（缓存大小 - 字段 n 的值）\n- `Buffered` 方法获取写入当前缓存中的字节数（字段 n 的值）\n- `Flush` 方法将缓存中的所有数据写入底层的 io.Writer 对象中。\n\n其他实现了 `io` 包的接口方法：\n```go\n// 实现了 io.ReaderFrom 接口\nfunc (b *Writer) ReadFrom(r io.Reader) (n int64, err error)\n\n// 实现了 io.Writer 接口\nfunc (b *Writer) Write(p []byte) (nn int, err error)\n\n// 实现了 io.ByteWriter 接口\nfunc (b *Writer) WriteByte(c byte) error\n\n// io 中没有该方法的接口，它用于写入单个 Unicode 码点，返回写入的字节数（码点占用的字节），内部实现会根据当前 rune 的范围调用 WriteByte 或 WriteString\nfunc (b *Writer) WriteRune(r rune) (size int, err error)\n\n// 写入字符串，如果返回写入的字节数比 len(s) 小，返回的error会解释原因\nfunc (b *Writer) WriteString(s string) (int, error)\n```\n\n### bufio.Writer 类型值中缓冲的数据什么时候会被写到它的底层写入器\n\n`bufio.Writer` 类型有一个名为 `Flush` 的方法，它的主要功能是把相应缓冲区中暂存的所有数据，都写到底层写入器中。数据一旦被写进底层写入器，\n该方法就会把它们从缓冲区中删除掉。\n\n`bufio.Writer` 类型值（以下简称 `Writer` 值）拥有的所有数据写入方法都会在必要的时候调用它的 `Flush` 方法。\n\n比如，`Write` 方法有时候会在把数据写进缓冲区之后，调用 `Flush` 方法，以便为后续的新数据腾出空间。`WriteString` 方法的行为与之类似。\n\n`WriteByte` 方法和 `WriteRune` 方法，都会在发现缓冲区中的可写空间不足以容纳新的字节，或 Unicode 字符的时候，调用 `Flush` 方法。\n\n在**通常情况下，只要缓冲区中的可写空间无法容纳需要写入的新数据，`Flush` 方法就一定会被调用**。\n\n## ReadWriter\n```go\ntype ReadWriter struct {\n    *Reader\n    *Writer\n}\n```\n\n通过调用 `bufio.NewReadWriter` 函数来初始化：\n```go\nfunc NewReadWriter(r *Reader, w *Writer) *ReadWriter\n```","date":"2019-10-19T13:40:15.177Z","updated":"2019-10-19T13:40:15.177Z","path":"standards/io/bufio.html","comments":1,"layout":"page","_id":"ck1xm14le0016fcw2kankbicg","content":"<h1 id=\"bufio\"><a href=\"#bufio\" class=\"headerlink\" title=\"bufio\"></a>bufio</h1><p>bufio 包实现了缓存 IO。提供了数据缓冲功能，能够一定程度减少大块数据读写带来的开销。封装了 <code>io.Reader</code> 和 <code>io.Writer</code> 对象。</p>\n<h2 id=\"bufio包中的数据类型\"><a href=\"#bufio包中的数据类型\" class=\"headerlink\" title=\"bufio包中的数据类型\"></a>bufio包中的数据类型</h2><p>bufio包中的数据类型主要有：</p>\n<ul>\n<li><code>Reader</code>；</li>\n<li><code>Scanner</code>；</li>\n<li><code>Writer</code> 和 <code>ReadWriter</code>。</li>\n</ul>\n<h2 id=\"bufio-Reader\"><a href=\"#bufio-Reader\" class=\"headerlink\" title=\"bufio.Reader\"></a>bufio.Reader</h2><p>两个用于初始化 <code>bufio.Reader</code> 的函数：</p>\n<ul>\n<li><code>NewReader</code> 函数初始化的 <code>Reader</code> 值会拥有一个默认尺寸的缓冲区。这个默认尺寸是 <code>4096</code> 个字节，即：<code>4 KB</code>。</li>\n<li><code>NewReaderSize</code> 函数则将缓冲区尺寸的决定权抛给了使用方。</li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewReader</span><span class=\"params\">(rd io.Reader)</span> *<span class=\"title\">Reader</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">NewReaderSize</span><span class=\"params\">(rd io.Reader, size <span class=\"keyword\">int</span>)</span> *<span class=\"title\">Reader</span> // 可以配置缓冲区的大小</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"bufio-Reader-类型值中的缓冲区的作用\"><a href=\"#bufio-Reader-类型值中的缓冲区的作用\" class=\"headerlink\" title=\"bufio.Reader 类型值中的缓冲区的作用\"></a>bufio.Reader 类型值中的缓冲区的作用</h3><p>缓冲区其实就是一个<strong>数据存储中介，它介于底层读取器与读取方法及其调用方之间</strong>。所谓的底层读取器是指 <code>io.Reader</code>。</p>\n<p><code>Reader</code> 值的读取方法一般都会先从其所属值的缓冲区中读取数据。同时，在必要的时候，它们还会预先从底层读取器那里读出一部分数据，并暂<br>存于缓冲区之中以备后用。</p>\n<p>缓冲区的好处是，可以在大多数的时候降低读取方法的执行时间。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Reader <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    buf          []<span class=\"keyword\">byte</span></span><br><span class=\"line\">    rd           io.Reader</span><br><span class=\"line\">    r, w         <span class=\"keyword\">int</span></span><br><span class=\"line\">    err          error</span><br><span class=\"line\">    lastByte     <span class=\"keyword\">int</span></span><br><span class=\"line\">    lastRuneSize <span class=\"keyword\">int</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>bufio.Reader</code> 字段：</p>\n<ul>\n<li><code>buf</code>：<code>[]byte</code> 类型的字段，即字节切片，代表缓冲区。虽然它是切片类型的，但是其长度却会在初始化的时候指定，并在之后保持不变。</li>\n<li><code>rd</code>：<code>io.Reader</code> 类型的字段，代表底层读取器。缓冲区中的数据就是从这里拷贝来的。</li>\n<li><code>r</code>：<code>int</code> 类型的字段，代表对缓冲区进行下一次读取时的开始索引。我们可以称它为已读计数。</li>\n<li><code>w</code>：<code>int</code> 类型的字段，代表对缓冲区进行下一次写入时的开始索引。我们可以称之为已写计数。</li>\n<li><code>err</code>：<code>error</code> 类型的字段。它的值用于表示在从底层读取器获得数据时发生的错误。这里的值在被读取或忽略之后，该字段会被置为 <code>nil</code>。</li>\n<li><code>lastByte</code>：<code>int</code> 类型的字段，用于记录缓冲区中最后一个被读取的字节。读回退时会用到它的值。</li>\n<li><code>lastRuneSize</code>：<code>int</code> 类型的字段，用于记录缓冲区中最后一个被读取的 Unicode 字符所占用的字节数。读回退的时候会用到它的值。这个字<br>段只会在其所属值的 <code>ReadRune</code> 方法中才会被赋予有意义的值。在其他情况下，它都会被置为 <code>-1</code>。</li>\n</ul>\n<h3 id=\"bufio-Reader-类型读取方法\"><a href=\"#bufio-Reader-类型读取方法\" class=\"headerlink\" title=\"bufio.Reader 类型读取方法\"></a>bufio.Reader 类型读取方法</h3><h4 id=\"ReadSlice、ReadBytes、ReadString-和-ReadLine\"><a href=\"#ReadSlice、ReadBytes、ReadString-和-ReadLine\" class=\"headerlink\" title=\"ReadSlice、ReadBytes、ReadString 和 ReadLine\"></a>ReadSlice、ReadBytes、ReadString 和 ReadLine</h4><p>后三个方法最终都是调用 <code>ReadSlice</code> 来实现的。所以，我们先来看看 <code>ReadSlice</code> 方法。</p>\n<p><strong>ReadSlice方法</strong>：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">ReadSlice</span><span class=\"params\">(delim <span class=\"keyword\">byte</span>)</span> <span class=\"params\">(line []<span class=\"keyword\">byte</span>, err error)</span></span></span><br></pre></td></tr></table></figure></p>\n<p><code>ReadSlice</code> 从输入中读取，直到遇到第一个界定符（delim）为止，返回一个指向缓存中字节的 <code>slice</code>，在下次调用读操作（<code>read</code>）时，这些字节会<br>无效：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">reader := bufio.NewReader(strings.NewReader(<span class=\"string\">\"Hello \\nworld\"</span>))</span><br><span class=\"line\">line, _ := reader.ReadSlice(<span class=\"string\">'\\n'</span>)</span><br><span class=\"line\">fmt.Printf(<span class=\"string\">\"the line:%s\\n\"</span>, line) <span class=\"comment\">// the line:Hello</span></span><br><span class=\"line\">n, _ := reader.ReadSlice(<span class=\"string\">'\\n'</span>)</span><br><span class=\"line\">fmt.Printf(<span class=\"string\">\"the line:%s\\n\"</span>, line) <span class=\"comment\">// the line:world</span></span><br><span class=\"line\">fmt.Println(<span class=\"keyword\">string</span>(n)) <span class=\"comment\">// world</span></span><br></pre></td></tr></table></figure></p>\n<p>从结果可以看出，第一次 <code>ReadSlice</code> 的结果 <strong>line</strong>，在第二次调用读操作后，内容发生了变化。也就是说，<code>ReadSlice</code> 返回的 <code>[]byte</code> 是指<br>向 <code>Reader</code> 中的 <code>buffer</code> ，而不是 <code>copy</code> 一份返回。正因为 <code>ReadSlice</code> 返回的数据会被下次的 I/O 操作重写，因此许多的客户端会选择<br>使用 <code>ReadBytes</code> 或者 <code>ReadString</code> 来代替。</p>\n<p>注意，这里的界定符可以是任意的字符。同时，返回的结果是包含界定符本身的。</p>\n<p>如果 <code>ReadSlice</code> 在找到界定符之前遇到了 <code>error</code>，它就会返回缓存中所有的数据和错误本身（经常是 <code>io.EOF</code>）。如果在找到界定符之前缓存已经<br>满了，<code>ReadSlice</code> 会返回 <code>bufio.ErrBufferFull</code> 错误。当且仅当返回的结果（<code>line</code>）没有以界定符结束的时候，<code>ReadSlice</code> 返<br>回 <code>err != nil</code>，也就是说，如果 <code>ReadSlice</code> 返回的结果 <code>line</code> 不是以界定符 <code>delim</code> 结尾，那么返回的 <code>err</code> 也一定不等于 <code>nil</code>。</p>\n<p><strong>ReadBytes 方法</strong>：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">ReadBytes</span><span class=\"params\">(delim <span class=\"keyword\">byte</span>)</span> <span class=\"params\">(line []<span class=\"keyword\">byte</span>, err error)</span></span></span><br></pre></td></tr></table></figure></p>\n<p>该方法的参数和返回值类型与 <code>ReadSlice</code> 都一样。 <code>ReadBytes</code> 从输入中读取直到遇到界定符（delim）为止，返回的 <code>slice</code> 包含了从当前到<br>界定符的内容 <strong>（包括界定符）</strong>。</p>\n<p><code>ReadBytes</code> 源码：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">ReadBytes</span><span class=\"params\">(delim <span class=\"keyword\">byte</span>)</span> <span class=\"params\">([]<span class=\"keyword\">byte</span>, error)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// Use ReadSlice to look for array,</span></span><br><span class=\"line\">\t<span class=\"comment\">// accumulating full buffers.</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> frag []<span class=\"keyword\">byte</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> full [][]<span class=\"keyword\">byte</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> err error</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> e error</span><br><span class=\"line\">\t\tfrag, e = b.ReadSlice(delim)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> e == <span class=\"literal\">nil</span> &#123; <span class=\"comment\">// got final fragment</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> e != ErrBufferFull &#123; <span class=\"comment\">// unexpected error</span></span><br><span class=\"line\">\t\t\terr = e</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// Make a copy of the buffer.</span></span><br><span class=\"line\">\t\tbuf := <span class=\"built_in\">make</span>([]<span class=\"keyword\">byte</span>, <span class=\"built_in\">len</span>(frag)) <span class=\"comment\">// 这里把 ReadSlice 的返回值 copy 了一份，不再是指向 Reader 中的 buffer</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">copy</span>(buf, frag)</span><br><span class=\"line\">\t\tfull = <span class=\"built_in\">append</span>(full, buf)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// Allocate new buffer to hold the full pieces and the fragment.</span></span><br><span class=\"line\">\tn := <span class=\"number\">0</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> full &#123;</span><br><span class=\"line\">\t\tn += <span class=\"built_in\">len</span>(full[i])</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tn += <span class=\"built_in\">len</span>(frag)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// Copy full pieces and fragment in.</span></span><br><span class=\"line\">\tbuf := <span class=\"built_in\">make</span>([]<span class=\"keyword\">byte</span>, n)</span><br><span class=\"line\">\tn = <span class=\"number\">0</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> full &#123;</span><br><span class=\"line\">\t\tn += <span class=\"built_in\">copy</span>(buf[n:], full[i])</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">copy</span>(buf[n:], frag)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> buf, err</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>ReadString 方法</strong></p>\n<p><code>ReadString</code> 源码：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">ReadString</span><span class=\"params\">(delim <span class=\"keyword\">byte</span>)</span> <span class=\"params\">(line <span class=\"keyword\">string</span>, err error)</span></span> &#123;</span><br><span class=\"line\">    bytes, err := b.ReadBytes(delim)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">string</span>(bytes), err</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>调用了 <code>ReadBytes</code> 方法，并将结果的 <code>[]byte</code> 转为 <code>string</code> 类型。</p>\n<p><strong>ReadLine 方法</strong><br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">ReadLine</span><span class=\"params\">()</span> <span class=\"params\">(line []<span class=\"keyword\">byte</span>, isPrefix <span class=\"keyword\">bool</span>, err error)</span></span></span><br></pre></td></tr></table></figure></p>\n<p><code>ReadLine</code> 是一个底层的原始行读取命令。可以使用 <code>ReadBytes(&#39;\\n&#39;)</code> 或者 <code>ReadString(&#39;\\n&#39;)</code> 来代替这个方法。</p>\n<p><strong><code>ReadLine</code> 尝试返回单独的行，不包括行尾的换行符</strong>。如果一行大于缓存，<code>isPrefix</code> 会被设置为 <code>true</code>，同时返回该行的开始部分<br>（等于缓存大小的部分）。该行剩余的部分就会在下次调用的时候返回。当下次调用返回该行剩余部分时，<code>isPrefix</code> 将会是 <code>false</code> 。<br>跟 <code>ReadSlice</code> 一样，<strong>返回的 <code>line</code> 是 <code>buffer</code> 的引用</strong>，在下次执行 IO 操作时，<code>line</code> 会无效。</p>\n<p>建议读取一行使用下面的方式：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">line, err := reader.ReadBytes(<span class=\"string\">'\\n'</span>)</span><br><span class=\"line\">line = bytes.TrimRight(line, <span class=\"string\">\"\\r\\n\"</span>)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Peek-方法\"><a href=\"#Peek-方法\" class=\"headerlink\" title=\"Peek 方法\"></a>Peek 方法</h3><p><code>Peek</code> 是 “窥视” 的意思，<code>Peek</code> 一个鲜明的特点，就是：即使它读取了缓冲区中的数据，也不会更改已读计数的值。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">Peek</span><span class=\"params\">(n <span class=\"keyword\">int</span>)</span> <span class=\"params\">([]<span class=\"keyword\">byte</span>, error)</span></span></span><br></pre></td></tr></table></figure>\n<p><strong>返回的 <code>[]byte</code> 是 <code>buffer</code> 中的引用</strong>，该切片引用缓存中前 <code>n</code> 字节数据。</p>\n<p><strong><code>Peek</code> 方法、<code>ReadSlice</code> 方法和 <code>ReadLine</code> 方法都有可能会造成内容泄露。这主要是因为它们在正常的情况下都会返回直接基于缓冲区的字节切片，<br>也因为为这个原因对多 goroutine 是不安全的，也就是在多并发环境下，不能依赖其结果。</strong>。</p>\n<p>另外，Reader 的 Peek 方法如果返回的 []byte 长度小于 n，这时返回的 <code>err != nil</code> ，用于解释为啥会小于 n。如果 n 大于 reader 的 buffer 长度，err 会是 ErrBufferFull。</p>\n<h3 id=\"其他方法\"><a href=\"#其他方法\" class=\"headerlink\" title=\"其他方法\"></a>其他方法</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">Read</span><span class=\"params\">(p []<span class=\"keyword\">byte</span>)</span> <span class=\"params\">(n <span class=\"keyword\">int</span>, err error)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">ReadByte</span><span class=\"params\">()</span> <span class=\"params\">(c <span class=\"keyword\">byte</span>, err error)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">ReadRune</span><span class=\"params\">()</span> <span class=\"params\">(r <span class=\"keyword\">rune</span>, size <span class=\"keyword\">int</span>, err error)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">UnreadByte</span><span class=\"params\">()</span> <span class=\"title\">error</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">UnreadRune</span><span class=\"params\">()</span> <span class=\"title\">error</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">WriteTo</span><span class=\"params\">(w io.Writer)</span> <span class=\"params\">(n <span class=\"keyword\">int64</span>, err error)</span></span></span><br></pre></td></tr></table></figure>\n<h2 id=\"bufio-Writer\"><a href=\"#bufio-Writer\" class=\"headerlink\" title=\"bufio.Writer\"></a>bufio.Writer</h2><p><code>bufio.Writer</code> 结构封装了一个 <code>io.Writer</code> 对象。同时实现了 <code>io.Writer</code> 接口。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Writer <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    err error\t\t<span class=\"comment\">// 写过程中遇到的错误</span></span><br><span class=\"line\">    buf []<span class=\"keyword\">byte</span>\t\t<span class=\"comment\">// 缓存</span></span><br><span class=\"line\">    n   <span class=\"keyword\">int</span>\t\t\t<span class=\"comment\">// 当前缓存中的字节数</span></span><br><span class=\"line\">    wr  io.Writer\t<span class=\"comment\">// 底层的 io.Writer 对象</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>bufio.Writer</code> 类型的字段:</p>\n<ul>\n<li><code>err</code>：<code>error</code> 类型的字段。它的值用于表示在向底层写入器写数据时发生的错误。</li>\n<li><code>buf</code>：<code>[]byte</code> 类型的字段，代表缓冲区。在初始化之后，它的长度会保持不变。</li>\n<li><code>n</code>：<code>int</code> 类型的字段，代表对缓冲区进行下一次写入时的开始索引。我们可以称之为已写计数。</li>\n<li><code>wr</code>：<code>io.Writer</code> 类型的字段，代表底层写入器。</li>\n</ul>\n<p>两个用于初始化 <code>bufio.Writer</code> 的函数：</p>\n<ul>\n<li><code>NewWriter</code> 函数初始化的 <code>Writer</code> 值会拥有一个默认尺寸的缓冲区。这个默认尺寸是 <code>4096</code> 个字节，即：<code>4 KB</code>。</li>\n<li><code>NewWriterSize</code> 函数则将缓冲区尺寸的决定权抛给了使用方。</li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewWriter</span><span class=\"params\">(wr io.Writer)</span> *<span class=\"title\">Writer</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">NewWriterSize</span><span class=\"params\">(wr io.Writer, size <span class=\"keyword\">int</span>)</span> *<span class=\"title\">Writer</span> // 可以配置缓冲区的大小</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h3><ul>\n<li><code>Available</code> 方法获取缓存中还未使用的字节数（缓存大小 - 字段 n 的值）</li>\n<li><code>Buffered</code> 方法获取写入当前缓存中的字节数（字段 n 的值）</li>\n<li><code>Flush</code> 方法将缓存中的所有数据写入底层的 io.Writer 对象中。</li>\n</ul>\n<p>其他实现了 <code>io</code> 包的接口方法：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 实现了 io.ReaderFrom 接口</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Writer)</span> <span class=\"title\">ReadFrom</span><span class=\"params\">(r io.Reader)</span> <span class=\"params\">(n <span class=\"keyword\">int64</span>, err error)</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// 实现了 <span class=\"title\">io</span>.<span class=\"title\">Writer</span> 接口</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"params\">(b *Writer)</span> <span class=\"title\">Write</span><span class=\"params\">(p []<span class=\"keyword\">byte</span>)</span> <span class=\"params\">(nn <span class=\"keyword\">int</span>, err error)</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// 实现了 <span class=\"title\">io</span>.<span class=\"title\">ByteWriter</span> 接口</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"params\">(b *Writer)</span> <span class=\"title\">WriteByte</span><span class=\"params\">(c <span class=\"keyword\">byte</span>)</span> <span class=\"title\">error</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// <span class=\"title\">io</span> 中没有该方法的接口，它用于写入单个 <span class=\"title\">Unicode</span> 码点，返回写入的字节数（码点占用的字节），内部实现会根据当前 <span class=\"title\">rune</span> 的范围调用 <span class=\"title\">WriteByte</span> 或 <span class=\"title\">WriteString</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"params\">(b *Writer)</span> <span class=\"title\">WriteRune</span><span class=\"params\">(r <span class=\"keyword\">rune</span>)</span> <span class=\"params\">(size <span class=\"keyword\">int</span>, err error)</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// 写入字符串，如果返回写入的字节数比 <span class=\"title\">len</span><span class=\"params\">(s)</span> 小，返回的<span class=\"title\">error</span>会解释原因</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"params\">(b *Writer)</span> <span class=\"title\">WriteString</span><span class=\"params\">(s <span class=\"keyword\">string</span>)</span> <span class=\"params\">(<span class=\"keyword\">int</span>, error)</span></span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"bufio-Writer-类型值中缓冲的数据什么时候会被写到它的底层写入器\"><a href=\"#bufio-Writer-类型值中缓冲的数据什么时候会被写到它的底层写入器\" class=\"headerlink\" title=\"bufio.Writer 类型值中缓冲的数据什么时候会被写到它的底层写入器\"></a>bufio.Writer 类型值中缓冲的数据什么时候会被写到它的底层写入器</h3><p><code>bufio.Writer</code> 类型有一个名为 <code>Flush</code> 的方法，它的主要功能是把相应缓冲区中暂存的所有数据，都写到底层写入器中。数据一旦被写进底层写入器，<br>该方法就会把它们从缓冲区中删除掉。</p>\n<p><code>bufio.Writer</code> 类型值（以下简称 <code>Writer</code> 值）拥有的所有数据写入方法都会在必要的时候调用它的 <code>Flush</code> 方法。</p>\n<p>比如，<code>Write</code> 方法有时候会在把数据写进缓冲区之后，调用 <code>Flush</code> 方法，以便为后续的新数据腾出空间。<code>WriteString</code> 方法的行为与之类似。</p>\n<p><code>WriteByte</code> 方法和 <code>WriteRune</code> 方法，都会在发现缓冲区中的可写空间不足以容纳新的字节，或 Unicode 字符的时候，调用 <code>Flush</code> 方法。</p>\n<p>在<strong>通常情况下，只要缓冲区中的可写空间无法容纳需要写入的新数据，<code>Flush</code> 方法就一定会被调用</strong>。</p>\n<h2 id=\"ReadWriter\"><a href=\"#ReadWriter\" class=\"headerlink\" title=\"ReadWriter\"></a>ReadWriter</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> ReadWriter <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    *Reader</span><br><span class=\"line\">    *Writer</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过调用 <code>bufio.NewReadWriter</code> 函数来初始化：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewReadWriter</span><span class=\"params\">(r *Reader, w *Writer)</span> *<span class=\"title\">ReadWriter</span></span></span><br></pre></td></tr></table></figure></p>\n","site":{"data":{"navigation":{"logo":{"text":"Golang Learn","type":"link","path":"index.html"},"main":[{"text":"Golang 基础","type":"label"},{"text":"Go 环境配置","type":"link","path":"basic/env_config.html"},{"text":"包","type":"link","path":"basic/package.html"},{"text":"基础数据类型","type":"link","path":"basic/basic_data.html"},{"text":"变量","type":"link","path":"basic/var.html"},{"text":"常量","type":"link","path":"basic/constant.html"},{"text":"控制语句","type":"link","path":"basic/flow.html"},{"text":"运算符","type":"link","path":"basic/operator.html"},{"text":"作用域","type":"link","path":"basic/scope.html"},{"text":"指针","type":"link","path":"basic/pointer.html"},{"text":"数组","type":"link","path":"basic/array.html"},{"text":"切片","type":"link","path":"basic/slice.html"},{"text":"字典","type":"link","path":"basic/map.html"},{"text":"函数","type":"link","path":"basic/function.html"},{"text":"结构体","type":"link","path":"basic/struct.html"},{"text":"接口","type":"link","path":"basic/interface.html"},{"text":"面向对象","type":"link","path":"basic/oop.html"},{"text":"错误","type":"link","path":"basic/error.html"},{"text":"序列化","type":"link","path":"basic/json.html"},{"text":"反射","type":"link","path":"basic/reflect.html"},{"text":"测试","type":"link","path":"basic/test.html"},{"text":"并发编程","type":"label"},{"text":"goroutine","type":"link","path":"concurrent/goroutine.html"},{"text":"channel","type":"link","path":"concurrent/channel.html"},{"text":"同步和锁","type":"link","path":"concurrent/sync_lock.html"},{"text":"内存分配","type":"label"},{"text":"内存分配","type":"link","path":"advance/mm.html"},{"text":"垃圾回收","type":"label"},{"text":"垃圾回收","type":"link","path":"advance/gc.html"},{"text":"标准库","type":"label"},{"text":"fmt","type":"link","path":"standards/io/fmt.html"},{"text":"io","type":"link","path":"standards/io/io.html"},{"text":"ioutil","type":"link","path":"standards/io/ioutil.html"},{"text":"bufio","type":"link","path":"standards/io/bufio.html"},{"text":"os","type":"link","path":"standards/os/os.html"},{"text":"filepath","type":"link","path":"standards/os/filepath.html"},{"text":"strings","type":"link","path":"standards/text/strings.html"},{"text":"strconv","type":"link","path":"standards/text/strconv.html"},{"text":"unicode","type":"link","path":"standards/text/unicode.html"},{"text":"log","type":"link","path":"standards/log.html"},{"text":"time","type":"link","path":"standards/time.html"},{"text":"http","type":"link","path":"standards/net/http.html"},{"text":"math","type":"link","path":"standards/data/math.html"},{"text":"sort","type":"link","path":"standards/data/sort.html"},{"text":"big","type":"link","path":"standards/data/big.html"},{"text":"container","type":"link","path":"standards/data/container.html"},{"text":"sql","type":"link","path":"standards/database/sql.html"},{"text":"THEME","type":"label"},{"text":"使用文档主题","type":"link","path":"theme/theme-usage.html"},{"text":"SUPPORT AND FEEDBACK","type":"label"},{"text":"Raise an Issue on Github","type":"link","path":"https://github.com/shipengqi/golang-learn/issues/new"}]}}},"excerpt":"","more":"<h1 id=\"bufio\"><a href=\"#bufio\" class=\"headerlink\" title=\"bufio\"></a>bufio</h1><p>bufio 包实现了缓存 IO。提供了数据缓冲功能，能够一定程度减少大块数据读写带来的开销。封装了 <code>io.Reader</code> 和 <code>io.Writer</code> 对象。</p>\n<h2 id=\"bufio包中的数据类型\"><a href=\"#bufio包中的数据类型\" class=\"headerlink\" title=\"bufio包中的数据类型\"></a>bufio包中的数据类型</h2><p>bufio包中的数据类型主要有：</p>\n<ul>\n<li><code>Reader</code>；</li>\n<li><code>Scanner</code>；</li>\n<li><code>Writer</code> 和 <code>ReadWriter</code>。</li>\n</ul>\n<h2 id=\"bufio-Reader\"><a href=\"#bufio-Reader\" class=\"headerlink\" title=\"bufio.Reader\"></a>bufio.Reader</h2><p>两个用于初始化 <code>bufio.Reader</code> 的函数：</p>\n<ul>\n<li><code>NewReader</code> 函数初始化的 <code>Reader</code> 值会拥有一个默认尺寸的缓冲区。这个默认尺寸是 <code>4096</code> 个字节，即：<code>4 KB</code>。</li>\n<li><code>NewReaderSize</code> 函数则将缓冲区尺寸的决定权抛给了使用方。</li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewReader</span><span class=\"params\">(rd io.Reader)</span> *<span class=\"title\">Reader</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">NewReaderSize</span><span class=\"params\">(rd io.Reader, size <span class=\"keyword\">int</span>)</span> *<span class=\"title\">Reader</span> // 可以配置缓冲区的大小</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"bufio-Reader-类型值中的缓冲区的作用\"><a href=\"#bufio-Reader-类型值中的缓冲区的作用\" class=\"headerlink\" title=\"bufio.Reader 类型值中的缓冲区的作用\"></a>bufio.Reader 类型值中的缓冲区的作用</h3><p>缓冲区其实就是一个<strong>数据存储中介，它介于底层读取器与读取方法及其调用方之间</strong>。所谓的底层读取器是指 <code>io.Reader</code>。</p>\n<p><code>Reader</code> 值的读取方法一般都会先从其所属值的缓冲区中读取数据。同时，在必要的时候，它们还会预先从底层读取器那里读出一部分数据，并暂<br>存于缓冲区之中以备后用。</p>\n<p>缓冲区的好处是，可以在大多数的时候降低读取方法的执行时间。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Reader <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    buf          []<span class=\"keyword\">byte</span></span><br><span class=\"line\">    rd           io.Reader</span><br><span class=\"line\">    r, w         <span class=\"keyword\">int</span></span><br><span class=\"line\">    err          error</span><br><span class=\"line\">    lastByte     <span class=\"keyword\">int</span></span><br><span class=\"line\">    lastRuneSize <span class=\"keyword\">int</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>bufio.Reader</code> 字段：</p>\n<ul>\n<li><code>buf</code>：<code>[]byte</code> 类型的字段，即字节切片，代表缓冲区。虽然它是切片类型的，但是其长度却会在初始化的时候指定，并在之后保持不变。</li>\n<li><code>rd</code>：<code>io.Reader</code> 类型的字段，代表底层读取器。缓冲区中的数据就是从这里拷贝来的。</li>\n<li><code>r</code>：<code>int</code> 类型的字段，代表对缓冲区进行下一次读取时的开始索引。我们可以称它为已读计数。</li>\n<li><code>w</code>：<code>int</code> 类型的字段，代表对缓冲区进行下一次写入时的开始索引。我们可以称之为已写计数。</li>\n<li><code>err</code>：<code>error</code> 类型的字段。它的值用于表示在从底层读取器获得数据时发生的错误。这里的值在被读取或忽略之后，该字段会被置为 <code>nil</code>。</li>\n<li><code>lastByte</code>：<code>int</code> 类型的字段，用于记录缓冲区中最后一个被读取的字节。读回退时会用到它的值。</li>\n<li><code>lastRuneSize</code>：<code>int</code> 类型的字段，用于记录缓冲区中最后一个被读取的 Unicode 字符所占用的字节数。读回退的时候会用到它的值。这个字<br>段只会在其所属值的 <code>ReadRune</code> 方法中才会被赋予有意义的值。在其他情况下，它都会被置为 <code>-1</code>。</li>\n</ul>\n<h3 id=\"bufio-Reader-类型读取方法\"><a href=\"#bufio-Reader-类型读取方法\" class=\"headerlink\" title=\"bufio.Reader 类型读取方法\"></a>bufio.Reader 类型读取方法</h3><h4 id=\"ReadSlice、ReadBytes、ReadString-和-ReadLine\"><a href=\"#ReadSlice、ReadBytes、ReadString-和-ReadLine\" class=\"headerlink\" title=\"ReadSlice、ReadBytes、ReadString 和 ReadLine\"></a>ReadSlice、ReadBytes、ReadString 和 ReadLine</h4><p>后三个方法最终都是调用 <code>ReadSlice</code> 来实现的。所以，我们先来看看 <code>ReadSlice</code> 方法。</p>\n<p><strong>ReadSlice方法</strong>：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">ReadSlice</span><span class=\"params\">(delim <span class=\"keyword\">byte</span>)</span> <span class=\"params\">(line []<span class=\"keyword\">byte</span>, err error)</span></span></span><br></pre></td></tr></table></figure></p>\n<p><code>ReadSlice</code> 从输入中读取，直到遇到第一个界定符（delim）为止，返回一个指向缓存中字节的 <code>slice</code>，在下次调用读操作（<code>read</code>）时，这些字节会<br>无效：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">reader := bufio.NewReader(strings.NewReader(<span class=\"string\">\"Hello \\nworld\"</span>))</span><br><span class=\"line\">line, _ := reader.ReadSlice(<span class=\"string\">'\\n'</span>)</span><br><span class=\"line\">fmt.Printf(<span class=\"string\">\"the line:%s\\n\"</span>, line) <span class=\"comment\">// the line:Hello</span></span><br><span class=\"line\">n, _ := reader.ReadSlice(<span class=\"string\">'\\n'</span>)</span><br><span class=\"line\">fmt.Printf(<span class=\"string\">\"the line:%s\\n\"</span>, line) <span class=\"comment\">// the line:world</span></span><br><span class=\"line\">fmt.Println(<span class=\"keyword\">string</span>(n)) <span class=\"comment\">// world</span></span><br></pre></td></tr></table></figure></p>\n<p>从结果可以看出，第一次 <code>ReadSlice</code> 的结果 <strong>line</strong>，在第二次调用读操作后，内容发生了变化。也就是说，<code>ReadSlice</code> 返回的 <code>[]byte</code> 是指<br>向 <code>Reader</code> 中的 <code>buffer</code> ，而不是 <code>copy</code> 一份返回。正因为 <code>ReadSlice</code> 返回的数据会被下次的 I/O 操作重写，因此许多的客户端会选择<br>使用 <code>ReadBytes</code> 或者 <code>ReadString</code> 来代替。</p>\n<p>注意，这里的界定符可以是任意的字符。同时，返回的结果是包含界定符本身的。</p>\n<p>如果 <code>ReadSlice</code> 在找到界定符之前遇到了 <code>error</code>，它就会返回缓存中所有的数据和错误本身（经常是 <code>io.EOF</code>）。如果在找到界定符之前缓存已经<br>满了，<code>ReadSlice</code> 会返回 <code>bufio.ErrBufferFull</code> 错误。当且仅当返回的结果（<code>line</code>）没有以界定符结束的时候，<code>ReadSlice</code> 返<br>回 <code>err != nil</code>，也就是说，如果 <code>ReadSlice</code> 返回的结果 <code>line</code> 不是以界定符 <code>delim</code> 结尾，那么返回的 <code>err</code> 也一定不等于 <code>nil</code>。</p>\n<p><strong>ReadBytes 方法</strong>：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">ReadBytes</span><span class=\"params\">(delim <span class=\"keyword\">byte</span>)</span> <span class=\"params\">(line []<span class=\"keyword\">byte</span>, err error)</span></span></span><br></pre></td></tr></table></figure></p>\n<p>该方法的参数和返回值类型与 <code>ReadSlice</code> 都一样。 <code>ReadBytes</code> 从输入中读取直到遇到界定符（delim）为止，返回的 <code>slice</code> 包含了从当前到<br>界定符的内容 <strong>（包括界定符）</strong>。</p>\n<p><code>ReadBytes</code> 源码：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">ReadBytes</span><span class=\"params\">(delim <span class=\"keyword\">byte</span>)</span> <span class=\"params\">([]<span class=\"keyword\">byte</span>, error)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// Use ReadSlice to look for array,</span></span><br><span class=\"line\">\t<span class=\"comment\">// accumulating full buffers.</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> frag []<span class=\"keyword\">byte</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> full [][]<span class=\"keyword\">byte</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> err error</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> e error</span><br><span class=\"line\">\t\tfrag, e = b.ReadSlice(delim)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> e == <span class=\"literal\">nil</span> &#123; <span class=\"comment\">// got final fragment</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> e != ErrBufferFull &#123; <span class=\"comment\">// unexpected error</span></span><br><span class=\"line\">\t\t\terr = e</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// Make a copy of the buffer.</span></span><br><span class=\"line\">\t\tbuf := <span class=\"built_in\">make</span>([]<span class=\"keyword\">byte</span>, <span class=\"built_in\">len</span>(frag)) <span class=\"comment\">// 这里把 ReadSlice 的返回值 copy 了一份，不再是指向 Reader 中的 buffer</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">copy</span>(buf, frag)</span><br><span class=\"line\">\t\tfull = <span class=\"built_in\">append</span>(full, buf)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// Allocate new buffer to hold the full pieces and the fragment.</span></span><br><span class=\"line\">\tn := <span class=\"number\">0</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> full &#123;</span><br><span class=\"line\">\t\tn += <span class=\"built_in\">len</span>(full[i])</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tn += <span class=\"built_in\">len</span>(frag)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// Copy full pieces and fragment in.</span></span><br><span class=\"line\">\tbuf := <span class=\"built_in\">make</span>([]<span class=\"keyword\">byte</span>, n)</span><br><span class=\"line\">\tn = <span class=\"number\">0</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> full &#123;</span><br><span class=\"line\">\t\tn += <span class=\"built_in\">copy</span>(buf[n:], full[i])</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">copy</span>(buf[n:], frag)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> buf, err</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>ReadString 方法</strong></p>\n<p><code>ReadString</code> 源码：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">ReadString</span><span class=\"params\">(delim <span class=\"keyword\">byte</span>)</span> <span class=\"params\">(line <span class=\"keyword\">string</span>, err error)</span></span> &#123;</span><br><span class=\"line\">    bytes, err := b.ReadBytes(delim)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">string</span>(bytes), err</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>调用了 <code>ReadBytes</code> 方法，并将结果的 <code>[]byte</code> 转为 <code>string</code> 类型。</p>\n<p><strong>ReadLine 方法</strong><br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">ReadLine</span><span class=\"params\">()</span> <span class=\"params\">(line []<span class=\"keyword\">byte</span>, isPrefix <span class=\"keyword\">bool</span>, err error)</span></span></span><br></pre></td></tr></table></figure></p>\n<p><code>ReadLine</code> 是一个底层的原始行读取命令。可以使用 <code>ReadBytes(&#39;\\n&#39;)</code> 或者 <code>ReadString(&#39;\\n&#39;)</code> 来代替这个方法。</p>\n<p><strong><code>ReadLine</code> 尝试返回单独的行，不包括行尾的换行符</strong>。如果一行大于缓存，<code>isPrefix</code> 会被设置为 <code>true</code>，同时返回该行的开始部分<br>（等于缓存大小的部分）。该行剩余的部分就会在下次调用的时候返回。当下次调用返回该行剩余部分时，<code>isPrefix</code> 将会是 <code>false</code> 。<br>跟 <code>ReadSlice</code> 一样，<strong>返回的 <code>line</code> 是 <code>buffer</code> 的引用</strong>，在下次执行 IO 操作时，<code>line</code> 会无效。</p>\n<p>建议读取一行使用下面的方式：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">line, err := reader.ReadBytes(<span class=\"string\">'\\n'</span>)</span><br><span class=\"line\">line = bytes.TrimRight(line, <span class=\"string\">\"\\r\\n\"</span>)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Peek-方法\"><a href=\"#Peek-方法\" class=\"headerlink\" title=\"Peek 方法\"></a>Peek 方法</h3><p><code>Peek</code> 是 “窥视” 的意思，<code>Peek</code> 一个鲜明的特点，就是：即使它读取了缓冲区中的数据，也不会更改已读计数的值。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">Peek</span><span class=\"params\">(n <span class=\"keyword\">int</span>)</span> <span class=\"params\">([]<span class=\"keyword\">byte</span>, error)</span></span></span><br></pre></td></tr></table></figure>\n<p><strong>返回的 <code>[]byte</code> 是 <code>buffer</code> 中的引用</strong>，该切片引用缓存中前 <code>n</code> 字节数据。</p>\n<p><strong><code>Peek</code> 方法、<code>ReadSlice</code> 方法和 <code>ReadLine</code> 方法都有可能会造成内容泄露。这主要是因为它们在正常的情况下都会返回直接基于缓冲区的字节切片，<br>也因为为这个原因对多 goroutine 是不安全的，也就是在多并发环境下，不能依赖其结果。</strong>。</p>\n<p>另外，Reader 的 Peek 方法如果返回的 []byte 长度小于 n，这时返回的 <code>err != nil</code> ，用于解释为啥会小于 n。如果 n 大于 reader 的 buffer 长度，err 会是 ErrBufferFull。</p>\n<h3 id=\"其他方法\"><a href=\"#其他方法\" class=\"headerlink\" title=\"其他方法\"></a>其他方法</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">Read</span><span class=\"params\">(p []<span class=\"keyword\">byte</span>)</span> <span class=\"params\">(n <span class=\"keyword\">int</span>, err error)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">ReadByte</span><span class=\"params\">()</span> <span class=\"params\">(c <span class=\"keyword\">byte</span>, err error)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">ReadRune</span><span class=\"params\">()</span> <span class=\"params\">(r <span class=\"keyword\">rune</span>, size <span class=\"keyword\">int</span>, err error)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">UnreadByte</span><span class=\"params\">()</span> <span class=\"title\">error</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">UnreadRune</span><span class=\"params\">()</span> <span class=\"title\">error</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"params\">(b *Reader)</span> <span class=\"title\">WriteTo</span><span class=\"params\">(w io.Writer)</span> <span class=\"params\">(n <span class=\"keyword\">int64</span>, err error)</span></span></span><br></pre></td></tr></table></figure>\n<h2 id=\"bufio-Writer\"><a href=\"#bufio-Writer\" class=\"headerlink\" title=\"bufio.Writer\"></a>bufio.Writer</h2><p><code>bufio.Writer</code> 结构封装了一个 <code>io.Writer</code> 对象。同时实现了 <code>io.Writer</code> 接口。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Writer <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    err error\t\t<span class=\"comment\">// 写过程中遇到的错误</span></span><br><span class=\"line\">    buf []<span class=\"keyword\">byte</span>\t\t<span class=\"comment\">// 缓存</span></span><br><span class=\"line\">    n   <span class=\"keyword\">int</span>\t\t\t<span class=\"comment\">// 当前缓存中的字节数</span></span><br><span class=\"line\">    wr  io.Writer\t<span class=\"comment\">// 底层的 io.Writer 对象</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>bufio.Writer</code> 类型的字段:</p>\n<ul>\n<li><code>err</code>：<code>error</code> 类型的字段。它的值用于表示在向底层写入器写数据时发生的错误。</li>\n<li><code>buf</code>：<code>[]byte</code> 类型的字段，代表缓冲区。在初始化之后，它的长度会保持不变。</li>\n<li><code>n</code>：<code>int</code> 类型的字段，代表对缓冲区进行下一次写入时的开始索引。我们可以称之为已写计数。</li>\n<li><code>wr</code>：<code>io.Writer</code> 类型的字段，代表底层写入器。</li>\n</ul>\n<p>两个用于初始化 <code>bufio.Writer</code> 的函数：</p>\n<ul>\n<li><code>NewWriter</code> 函数初始化的 <code>Writer</code> 值会拥有一个默认尺寸的缓冲区。这个默认尺寸是 <code>4096</code> 个字节，即：<code>4 KB</code>。</li>\n<li><code>NewWriterSize</code> 函数则将缓冲区尺寸的决定权抛给了使用方。</li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewWriter</span><span class=\"params\">(wr io.Writer)</span> *<span class=\"title\">Writer</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">NewWriterSize</span><span class=\"params\">(wr io.Writer, size <span class=\"keyword\">int</span>)</span> *<span class=\"title\">Writer</span> // 可以配置缓冲区的大小</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h3><ul>\n<li><code>Available</code> 方法获取缓存中还未使用的字节数（缓存大小 - 字段 n 的值）</li>\n<li><code>Buffered</code> 方法获取写入当前缓存中的字节数（字段 n 的值）</li>\n<li><code>Flush</code> 方法将缓存中的所有数据写入底层的 io.Writer 对象中。</li>\n</ul>\n<p>其他实现了 <code>io</code> 包的接口方法：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 实现了 io.ReaderFrom 接口</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *Writer)</span> <span class=\"title\">ReadFrom</span><span class=\"params\">(r io.Reader)</span> <span class=\"params\">(n <span class=\"keyword\">int64</span>, err error)</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// 实现了 <span class=\"title\">io</span>.<span class=\"title\">Writer</span> 接口</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"params\">(b *Writer)</span> <span class=\"title\">Write</span><span class=\"params\">(p []<span class=\"keyword\">byte</span>)</span> <span class=\"params\">(nn <span class=\"keyword\">int</span>, err error)</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// 实现了 <span class=\"title\">io</span>.<span class=\"title\">ByteWriter</span> 接口</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"params\">(b *Writer)</span> <span class=\"title\">WriteByte</span><span class=\"params\">(c <span class=\"keyword\">byte</span>)</span> <span class=\"title\">error</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// <span class=\"title\">io</span> 中没有该方法的接口，它用于写入单个 <span class=\"title\">Unicode</span> 码点，返回写入的字节数（码点占用的字节），内部实现会根据当前 <span class=\"title\">rune</span> 的范围调用 <span class=\"title\">WriteByte</span> 或 <span class=\"title\">WriteString</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"params\">(b *Writer)</span> <span class=\"title\">WriteRune</span><span class=\"params\">(r <span class=\"keyword\">rune</span>)</span> <span class=\"params\">(size <span class=\"keyword\">int</span>, err error)</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// 写入字符串，如果返回写入的字节数比 <span class=\"title\">len</span><span class=\"params\">(s)</span> 小，返回的<span class=\"title\">error</span>会解释原因</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"params\">(b *Writer)</span> <span class=\"title\">WriteString</span><span class=\"params\">(s <span class=\"keyword\">string</span>)</span> <span class=\"params\">(<span class=\"keyword\">int</span>, error)</span></span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"bufio-Writer-类型值中缓冲的数据什么时候会被写到它的底层写入器\"><a href=\"#bufio-Writer-类型值中缓冲的数据什么时候会被写到它的底层写入器\" class=\"headerlink\" title=\"bufio.Writer 类型值中缓冲的数据什么时候会被写到它的底层写入器\"></a>bufio.Writer 类型值中缓冲的数据什么时候会被写到它的底层写入器</h3><p><code>bufio.Writer</code> 类型有一个名为 <code>Flush</code> 的方法，它的主要功能是把相应缓冲区中暂存的所有数据，都写到底层写入器中。数据一旦被写进底层写入器，<br>该方法就会把它们从缓冲区中删除掉。</p>\n<p><code>bufio.Writer</code> 类型值（以下简称 <code>Writer</code> 值）拥有的所有数据写入方法都会在必要的时候调用它的 <code>Flush</code> 方法。</p>\n<p>比如，<code>Write</code> 方法有时候会在把数据写进缓冲区之后，调用 <code>Flush</code> 方法，以便为后续的新数据腾出空间。<code>WriteString</code> 方法的行为与之类似。</p>\n<p><code>WriteByte</code> 方法和 <code>WriteRune</code> 方法，都会在发现缓冲区中的可写空间不足以容纳新的字节，或 Unicode 字符的时候，调用 <code>Flush</code> 方法。</p>\n<p>在<strong>通常情况下，只要缓冲区中的可写空间无法容纳需要写入的新数据，<code>Flush</code> 方法就一定会被调用</strong>。</p>\n<h2 id=\"ReadWriter\"><a href=\"#ReadWriter\" class=\"headerlink\" title=\"ReadWriter\"></a>ReadWriter</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> ReadWriter <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    *Reader</span><br><span class=\"line\">    *Writer</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过调用 <code>bufio.NewReadWriter</code> 函数来初始化：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewReadWriter</span><span class=\"params\">(r *Reader, w *Writer)</span> *<span class=\"title\">ReadWriter</span></span></span><br></pre></td></tr></table></figure></p>\n"},{"title":"filepath","_content":"\n# filepath\n\n`filepath` 的功能和 `path` 包类似，但是对于不同操作系统提供了更好的支持。`filepath` 包能够自动的根据不同的操作系统文件路径进行转换，\n通常情况下应该总是使用 `filepath` 包，而不是 `path` 包。\n\n`path/filepath` 包涉及到路径操作时，路径分隔符使用 `os.PathSeparator`。不同系统，路径表示方式有所不同，比如 Unix 和 Windows 差别很大。\n\n例如，在 Unix 中，路径的分隔符是 `/`，但 Windows 是 `\\`。\n\n`path/filepath` 能够处理所有的文件路径，不管是什么系统。注意，路径操作函数并不会校验路径是否真实存在。\n\n## 解析路径名字符串\n\n`Dir()` 和 `Base()` 函数将一个路径名字符串分解成目录和文件名两部分。（一般情况，这些函数与 Unix 中 dirname 和 basename 命令类似，但如果\n路径以 `/` 结尾，`Dir` 的行为和 `dirname` 不太一致。）\n\n```go\nfunc Dir(path string) string\nfunc Base(path string) string\n```\n`Dir` 返回路径中除去最后一个路径元素的部分，即该路径最后一个元素所在的目录。在使用 `Split` 去掉最后一个元素后，会简化路径并去掉末尾的斜杠。\n如果路径是空字符串，会返回 `.`；如果路径由 1 到多个斜杠后跟 0 到多个非斜杠字符组成，会返回 `/`；其他任何情况下都不会返回以斜杠结尾的路径。\n\n`Base` 函数返回路径的最后一个元素。在提取元素前会去掉末尾的斜杠。如果路径是 \"\"，会返回 `.`；如果路径是只有一个斜杆构成的，会返回 `/`。\n\n比如，给定路径名 `/home/polaris/learngo.go`，`Dir` 返回 `/home/polaris`，而 `Base` 返回 `learngo.go`。\n\n如果给定路径名 `/home/polaris/learngo/`，`Dir` 返回 `/home/polaris/learngo`\n（这与 Unix 中的 `dirname` 不一致，`dirname` 会返回 `/home/polaris`），而 `Base` 返回 `learngo`。\n\n如果需要和 `dirname` 一样的功能，应该自己处理，比如在调用 `Dir` 之前，先将末尾的 `/` 去掉。\n\n此外，`Ext` 可以获得路径中文件名的扩展名。\n\n```go\nfunc Ext(path string) string\n```\n\n`Ext` 函数返回 `path` 文件扩展名。扩展名是路径中最后一个从 `.` 开始的部分，包括 `.`。如果该元素没有 `.` 会返回空字符串。\n\n## 相对路径和绝对路径\n\n某个进程都会有当前工作目录，一般的相对路径，就是针对进程**当前工作目录**而言的。当然，可以针对某个目录指定相对路径。\n\n绝对路径，在 Unix 中，以 `/` 开始；在 Windows 下以某个盘符开始，比如 `C:\\Program Files`。\n```go\nfunc IsAbs(path string) bool\n```\n\n`IsAbs` 返回路径是否是一个绝对路径。而\n```go\nfunc Abs(path string) (string, error)\n```\n\n`Abs` 函数返回 `path` 代表的绝对路径，如果 `path` 不是绝对路径，会加入当前工作目录以使之成为绝对路径。因为硬链接的存在，不能保证返\n回的绝对路径是唯一指向该地址的绝对路径。在 `os.Getwd` 出错时，`Abs` 会返回该错误，一般不会出错，如果路径名长度超过系统限制，则会报错。\n\n```go\nfunc Rel(basepath, targpath string) (string, error)\n```\n\n`Rel` 函数返回一个相对路径，返回值是 `targpath` 相对于 `basepath` 的相对路径，\n即使 `basepath` 和 `targpath` 没有共享的路径元素。如果两个参数一个是相对路径而另一个是绝对路径，或者 `targpath` 无法表示为相对\n于 `basepath` 的路径，将返回错误。\n\n```go\nfmt.Println(filepath.Rel(\"/home/polaris/learngo\", \"/home/polaris/learngo/src/logic/topic.go\"))\nfmt.Println(filepath.Rel(\"/home/polaris/learngo\", \"/data/learngo\"))\n\n// Output:\n// src/logic/topic.go <nil>\n// ../../../data/learngo <nil>\n```\n\n## 路径的切分和拼接\n\n对于一个常规文件路径，我们可以通过 `Split` 函数得到它的目录路径和文件名：\n```go\nfunc Split(path string) (dir, file string)\n```\n\n`Split` 函数根据最后一个路径分隔符将路径 `path` 分隔为目录和文件名两部分（`dir` 和 `file`）。如果路径中没有路径分隔符，函数返回\n值 `dir` 为空字符串，`file` 等于 `path`；反之，如果路径中最后一个字符是 `/`，则 `dir` 等于 `path`，`file` 为空字符串。\n返回值满足 `path == dir+file`。`dir` 非空时，最后一个字符总是 `/`。\n\n```go\n// dir == /home/polaris/，file == learngo\nfilepath.Split(\"/home/polaris/learngo\")\n\n// dir == /home/polaris/learngo/，file == \"\"\nfilepath.Split(\"/home/polaris/learngo/\")\n\n// dir == \"\"，file == learngo\nfilepath.Split(\"learngo\")\n```\n相对路径到绝对路径的转变，需要经过路径的拼接。`Join` 用于将多个路径拼接起来，会根据情况添加路径分隔符。\n```go\nfunc Join(elem ...string) string\n```\n\n`Join` 函数可以将任意数量的路径元素放入一个单一路径里，会根据需要添加路径分隔符。结果是经过 `Clean` 的，所有的空字符串元素会被忽略。\n对于拼接路径的需求，我们应该总是使用 `Join` 函数来处理。\n\n有时，我们需要分割 `PATH` 或 `GOPATH` 之类的环境变量（这些路径被特定于 `OS` 的列表分隔符连接起来），`filepath.SplitList` 就是这个用途：\n```go\nfunc SplitList(path string) []string\n```\n\n注意，与 `strings.Split` 函数的不同之处是：对 \"\"，`SplitList` 返回 `[]string{}`，而 `strings.Split` 返回 `[]string{\"\"}`。\n`SplitList` 内部调用的是 `strings.Split`。\n\n## 规整化路径\n```go\nfunc Clean(path string) string\n```\n\n`Clean` 函数通过单纯的词法操作返回和 `path` 代表同一地址的最短路径。\n\n它会不断的依次应用如下的规则，直到不能再进行任何处理：\n\n1. 将连续的多个路径分隔符替换为单个路径分隔符\n2. 剔除每一个 `.` 路径名元素（代表当前目录）\n3. 剔除每一个路径内的 `..` 路径名元素（代表父目录）和它前面的非 `..` 路径名元素\n4. 剔除开始于根路径的 `..` 路径名元素，即将路径开始处的 `/..` 替换为 `/`（假设路径分隔符是 `/`）\n\n返回的路径只有其代表一个根地址时才以路径分隔符结尾，如 Unix 的 `/` 或 Windows 的 `C:\\`。\n\n如果处理的结果是空字符串，Clean 会返回 `.`，代表当前路径。\n\n## 符号链接指向的路径名\n\n`filepath.EvalSymlinks` 会将所有路径的符号链接都解析出来。除此之外，它返回的路径，是直接可访问的。\n```go\nfunc EvalSymlinks(path string) (string, error)\n```\n\n如果 `path` 或返回值是相对路径，则是相对于进程当前工作目录。\n\n`os.Readlink` 和 `filepath.EvalSymlinks` 区别示例：\n\n```go\n// 在当前目录下创建一个 learngo.txt 文件和一个 symlink 目录，在 symlink 目录下对 learngo.txt 建一个符号链接 learngo.txt.2\nfmt.Println(filepath.EvalSymlinks(\"symlink/learngo.txt.2\"))\nfmt.Println(os.Readlink(\"symlink/learngo.txt.2\"))\n\n// Ouput:\n// learngo.txt <nil>\n// ../learngo.txt <nil>\n```\n\n## 文件路径匹配\n```go\nfunc Match(pattern, name string) (matched bool, err error)\n```\n\n`Match` 指示 `name` 是否和 shell 的文件模式匹配。模式语法如下：\n\n```go\npattern:\n\t{ term }\nterm:\n\t'*'         匹配 0 或多个非路径分隔符的字符\n\t'?'         匹配 1 个非路径分隔符的字符\n\t'[' [ '^' ] { character-range } ']'  \n\t\t\t\t  字符组（必须非空）\n\tc           匹配字符 c（c != '*', '?', '\\\\', '['）\n\t'\\\\' c      匹配字符 c\ncharacter-range:\n\tc           匹配字符 c（c != '\\\\', '-', ']'）\n\t'\\\\' c      匹配字符 c\n\tlo '-' hi   匹配区间[lo, hi]内的字符\n```\n匹配要求 `pattern` 必须和 `name` 全匹配上，不只是子串。在 Windows 下转义字符被禁用。\n\n`Match` 函数很少使用，搜索了一遍，标准库没有用到这个函数。而 `Glob` 函数在模板标准库中被用到了。\n```go\nfunc Glob(pattern string) (matches []string, err error)\n```\n\n`Glob` 函数返回所有匹配了 模式字符串 `pattern` 的文件列表或者 nil（如果没有匹配的文件）。`pattern` 的语法和 `Match` 函数相同。\n`pattern` 可以描述多层的名字，如 `/usr/*/bin/ed`（假设路径分隔符是 `/`）。\n\n注意，`Glob` 会忽略任何文件系统相关的错误，如读目录引发的 I/O 错误。唯一的错误和 `Match` 一样，在 `pattern` 不合法时，\n返回 `filepath.ErrBadPattern`。返回的结果是根据文件名字典顺序进行了排序的。\n\n`Glob` 的常见用法，是读取某个目录下所有的文件，比如写单元测试时，读取 `testdata` 目录下所有测试数据：\n```go\nfilepath.Glob(\"testdata/*.input\")\n```\n\n## 遍历目录\n\n在 `filepath` 中，提供了 `Walk` 函数，用于遍历目录树。\n```go\nfunc Walk(root string, walkFn WalkFunc) error\n```\n\n`Walk` 函数会遍历 `root` 指定的目录下的文件树，对每一个该文件树中的目录和文件都会调用 `walkFn`，包括 `root` 自身。所有访问文件 `/` 目录\n时遇到的错误都会传递给 `walkFn` 过滤。文件是按字典顺序遍历的，这让输出更漂亮，但也导致处理非常大的目录时效率会降低。`Walk` 函数不会遍历\n文件树中的符号链接（快捷方式）文件包含的路径。\n\n`walkFn` 的类型 `WalkFunc` 的定义如下：\n```go\ntype WalkFunc func(path string, info os.FileInfo, err error) error\n```\n\n`Walk` 函数对每一个文件 `/` 目录都会调用 `WalkFunc` 函数类型值。调用时 `path` 参数会包含 `Walk` 的 `root` 参数作为前缀；就是说，\n如果 `Walk` 函数的 `root` 为 \"dir\"，该目录下有文件 \"a\"，将会使用 \"dir/a\" 作为调用 `walkFn` 的参数。`walkFn` 参数被调用时的 `info` \n参数是 `path` 指定的地址（文件 / 目录）的文件信息，类型为 `os.FileInfo`。\n\n如果遍历 `path` 指定的文件或目录时出现了问题，传入的参数 `err` 会描述该问题，`WalkFunc` 类型函数可以决定如何去处理该错误\n（`Walk` 函数将不会深入该目录）；如果该函数返回一个错误，`Walk` 函数的执行会中止；只有一个例外，如果 `Walk` 的 `walkFn` 返回\n值是 `SkipDir`，将会跳过该目录的内容而 `Walk` 函数照常执行处理下一个文件。\n\n## Windows 起作用的函数\n\n`filepath` 中有三个函数：`VolumeName`、`FromSlash` 和 `ToSlash`，针对非 Unix 平台的。","source":"standards/os/filepath.md","raw":"---\ntitle: filepath\n---\n\n# filepath\n\n`filepath` 的功能和 `path` 包类似，但是对于不同操作系统提供了更好的支持。`filepath` 包能够自动的根据不同的操作系统文件路径进行转换，\n通常情况下应该总是使用 `filepath` 包，而不是 `path` 包。\n\n`path/filepath` 包涉及到路径操作时，路径分隔符使用 `os.PathSeparator`。不同系统，路径表示方式有所不同，比如 Unix 和 Windows 差别很大。\n\n例如，在 Unix 中，路径的分隔符是 `/`，但 Windows 是 `\\`。\n\n`path/filepath` 能够处理所有的文件路径，不管是什么系统。注意，路径操作函数并不会校验路径是否真实存在。\n\n## 解析路径名字符串\n\n`Dir()` 和 `Base()` 函数将一个路径名字符串分解成目录和文件名两部分。（一般情况，这些函数与 Unix 中 dirname 和 basename 命令类似，但如果\n路径以 `/` 结尾，`Dir` 的行为和 `dirname` 不太一致。）\n\n```go\nfunc Dir(path string) string\nfunc Base(path string) string\n```\n`Dir` 返回路径中除去最后一个路径元素的部分，即该路径最后一个元素所在的目录。在使用 `Split` 去掉最后一个元素后，会简化路径并去掉末尾的斜杠。\n如果路径是空字符串，会返回 `.`；如果路径由 1 到多个斜杠后跟 0 到多个非斜杠字符组成，会返回 `/`；其他任何情况下都不会返回以斜杠结尾的路径。\n\n`Base` 函数返回路径的最后一个元素。在提取元素前会去掉末尾的斜杠。如果路径是 \"\"，会返回 `.`；如果路径是只有一个斜杆构成的，会返回 `/`。\n\n比如，给定路径名 `/home/polaris/learngo.go`，`Dir` 返回 `/home/polaris`，而 `Base` 返回 `learngo.go`。\n\n如果给定路径名 `/home/polaris/learngo/`，`Dir` 返回 `/home/polaris/learngo`\n（这与 Unix 中的 `dirname` 不一致，`dirname` 会返回 `/home/polaris`），而 `Base` 返回 `learngo`。\n\n如果需要和 `dirname` 一样的功能，应该自己处理，比如在调用 `Dir` 之前，先将末尾的 `/` 去掉。\n\n此外，`Ext` 可以获得路径中文件名的扩展名。\n\n```go\nfunc Ext(path string) string\n```\n\n`Ext` 函数返回 `path` 文件扩展名。扩展名是路径中最后一个从 `.` 开始的部分，包括 `.`。如果该元素没有 `.` 会返回空字符串。\n\n## 相对路径和绝对路径\n\n某个进程都会有当前工作目录，一般的相对路径，就是针对进程**当前工作目录**而言的。当然，可以针对某个目录指定相对路径。\n\n绝对路径，在 Unix 中，以 `/` 开始；在 Windows 下以某个盘符开始，比如 `C:\\Program Files`。\n```go\nfunc IsAbs(path string) bool\n```\n\n`IsAbs` 返回路径是否是一个绝对路径。而\n```go\nfunc Abs(path string) (string, error)\n```\n\n`Abs` 函数返回 `path` 代表的绝对路径，如果 `path` 不是绝对路径，会加入当前工作目录以使之成为绝对路径。因为硬链接的存在，不能保证返\n回的绝对路径是唯一指向该地址的绝对路径。在 `os.Getwd` 出错时，`Abs` 会返回该错误，一般不会出错，如果路径名长度超过系统限制，则会报错。\n\n```go\nfunc Rel(basepath, targpath string) (string, error)\n```\n\n`Rel` 函数返回一个相对路径，返回值是 `targpath` 相对于 `basepath` 的相对路径，\n即使 `basepath` 和 `targpath` 没有共享的路径元素。如果两个参数一个是相对路径而另一个是绝对路径，或者 `targpath` 无法表示为相对\n于 `basepath` 的路径，将返回错误。\n\n```go\nfmt.Println(filepath.Rel(\"/home/polaris/learngo\", \"/home/polaris/learngo/src/logic/topic.go\"))\nfmt.Println(filepath.Rel(\"/home/polaris/learngo\", \"/data/learngo\"))\n\n// Output:\n// src/logic/topic.go <nil>\n// ../../../data/learngo <nil>\n```\n\n## 路径的切分和拼接\n\n对于一个常规文件路径，我们可以通过 `Split` 函数得到它的目录路径和文件名：\n```go\nfunc Split(path string) (dir, file string)\n```\n\n`Split` 函数根据最后一个路径分隔符将路径 `path` 分隔为目录和文件名两部分（`dir` 和 `file`）。如果路径中没有路径分隔符，函数返回\n值 `dir` 为空字符串，`file` 等于 `path`；反之，如果路径中最后一个字符是 `/`，则 `dir` 等于 `path`，`file` 为空字符串。\n返回值满足 `path == dir+file`。`dir` 非空时，最后一个字符总是 `/`。\n\n```go\n// dir == /home/polaris/，file == learngo\nfilepath.Split(\"/home/polaris/learngo\")\n\n// dir == /home/polaris/learngo/，file == \"\"\nfilepath.Split(\"/home/polaris/learngo/\")\n\n// dir == \"\"，file == learngo\nfilepath.Split(\"learngo\")\n```\n相对路径到绝对路径的转变，需要经过路径的拼接。`Join` 用于将多个路径拼接起来，会根据情况添加路径分隔符。\n```go\nfunc Join(elem ...string) string\n```\n\n`Join` 函数可以将任意数量的路径元素放入一个单一路径里，会根据需要添加路径分隔符。结果是经过 `Clean` 的，所有的空字符串元素会被忽略。\n对于拼接路径的需求，我们应该总是使用 `Join` 函数来处理。\n\n有时，我们需要分割 `PATH` 或 `GOPATH` 之类的环境变量（这些路径被特定于 `OS` 的列表分隔符连接起来），`filepath.SplitList` 就是这个用途：\n```go\nfunc SplitList(path string) []string\n```\n\n注意，与 `strings.Split` 函数的不同之处是：对 \"\"，`SplitList` 返回 `[]string{}`，而 `strings.Split` 返回 `[]string{\"\"}`。\n`SplitList` 内部调用的是 `strings.Split`。\n\n## 规整化路径\n```go\nfunc Clean(path string) string\n```\n\n`Clean` 函数通过单纯的词法操作返回和 `path` 代表同一地址的最短路径。\n\n它会不断的依次应用如下的规则，直到不能再进行任何处理：\n\n1. 将连续的多个路径分隔符替换为单个路径分隔符\n2. 剔除每一个 `.` 路径名元素（代表当前目录）\n3. 剔除每一个路径内的 `..` 路径名元素（代表父目录）和它前面的非 `..` 路径名元素\n4. 剔除开始于根路径的 `..` 路径名元素，即将路径开始处的 `/..` 替换为 `/`（假设路径分隔符是 `/`）\n\n返回的路径只有其代表一个根地址时才以路径分隔符结尾，如 Unix 的 `/` 或 Windows 的 `C:\\`。\n\n如果处理的结果是空字符串，Clean 会返回 `.`，代表当前路径。\n\n## 符号链接指向的路径名\n\n`filepath.EvalSymlinks` 会将所有路径的符号链接都解析出来。除此之外，它返回的路径，是直接可访问的。\n```go\nfunc EvalSymlinks(path string) (string, error)\n```\n\n如果 `path` 或返回值是相对路径，则是相对于进程当前工作目录。\n\n`os.Readlink` 和 `filepath.EvalSymlinks` 区别示例：\n\n```go\n// 在当前目录下创建一个 learngo.txt 文件和一个 symlink 目录，在 symlink 目录下对 learngo.txt 建一个符号链接 learngo.txt.2\nfmt.Println(filepath.EvalSymlinks(\"symlink/learngo.txt.2\"))\nfmt.Println(os.Readlink(\"symlink/learngo.txt.2\"))\n\n// Ouput:\n// learngo.txt <nil>\n// ../learngo.txt <nil>\n```\n\n## 文件路径匹配\n```go\nfunc Match(pattern, name string) (matched bool, err error)\n```\n\n`Match` 指示 `name` 是否和 shell 的文件模式匹配。模式语法如下：\n\n```go\npattern:\n\t{ term }\nterm:\n\t'*'         匹配 0 或多个非路径分隔符的字符\n\t'?'         匹配 1 个非路径分隔符的字符\n\t'[' [ '^' ] { character-range } ']'  \n\t\t\t\t  字符组（必须非空）\n\tc           匹配字符 c（c != '*', '?', '\\\\', '['）\n\t'\\\\' c      匹配字符 c\ncharacter-range:\n\tc           匹配字符 c（c != '\\\\', '-', ']'）\n\t'\\\\' c      匹配字符 c\n\tlo '-' hi   匹配区间[lo, hi]内的字符\n```\n匹配要求 `pattern` 必须和 `name` 全匹配上，不只是子串。在 Windows 下转义字符被禁用。\n\n`Match` 函数很少使用，搜索了一遍，标准库没有用到这个函数。而 `Glob` 函数在模板标准库中被用到了。\n```go\nfunc Glob(pattern string) (matches []string, err error)\n```\n\n`Glob` 函数返回所有匹配了 模式字符串 `pattern` 的文件列表或者 nil（如果没有匹配的文件）。`pattern` 的语法和 `Match` 函数相同。\n`pattern` 可以描述多层的名字，如 `/usr/*/bin/ed`（假设路径分隔符是 `/`）。\n\n注意，`Glob` 会忽略任何文件系统相关的错误，如读目录引发的 I/O 错误。唯一的错误和 `Match` 一样，在 `pattern` 不合法时，\n返回 `filepath.ErrBadPattern`。返回的结果是根据文件名字典顺序进行了排序的。\n\n`Glob` 的常见用法，是读取某个目录下所有的文件，比如写单元测试时，读取 `testdata` 目录下所有测试数据：\n```go\nfilepath.Glob(\"testdata/*.input\")\n```\n\n## 遍历目录\n\n在 `filepath` 中，提供了 `Walk` 函数，用于遍历目录树。\n```go\nfunc Walk(root string, walkFn WalkFunc) error\n```\n\n`Walk` 函数会遍历 `root` 指定的目录下的文件树，对每一个该文件树中的目录和文件都会调用 `walkFn`，包括 `root` 自身。所有访问文件 `/` 目录\n时遇到的错误都会传递给 `walkFn` 过滤。文件是按字典顺序遍历的，这让输出更漂亮，但也导致处理非常大的目录时效率会降低。`Walk` 函数不会遍历\n文件树中的符号链接（快捷方式）文件包含的路径。\n\n`walkFn` 的类型 `WalkFunc` 的定义如下：\n```go\ntype WalkFunc func(path string, info os.FileInfo, err error) error\n```\n\n`Walk` 函数对每一个文件 `/` 目录都会调用 `WalkFunc` 函数类型值。调用时 `path` 参数会包含 `Walk` 的 `root` 参数作为前缀；就是说，\n如果 `Walk` 函数的 `root` 为 \"dir\"，该目录下有文件 \"a\"，将会使用 \"dir/a\" 作为调用 `walkFn` 的参数。`walkFn` 参数被调用时的 `info` \n参数是 `path` 指定的地址（文件 / 目录）的文件信息，类型为 `os.FileInfo`。\n\n如果遍历 `path` 指定的文件或目录时出现了问题，传入的参数 `err` 会描述该问题，`WalkFunc` 类型函数可以决定如何去处理该错误\n（`Walk` 函数将不会深入该目录）；如果该函数返回一个错误，`Walk` 函数的执行会中止；只有一个例外，如果 `Walk` 的 `walkFn` 返回\n值是 `SkipDir`，将会跳过该目录的内容而 `Walk` 函数照常执行处理下一个文件。\n\n## Windows 起作用的函数\n\n`filepath` 中有三个函数：`VolumeName`、`FromSlash` 和 `ToSlash`，针对非 Unix 平台的。","date":"2019-10-19T13:40:15.182Z","updated":"2019-10-19T13:40:15.182Z","path":"standards/os/filepath.html","comments":1,"layout":"page","_id":"ck1xm14lf0017fcw2mnvobtsb","content":"<h1 id=\"filepath\"><a href=\"#filepath\" class=\"headerlink\" title=\"filepath\"></a>filepath</h1><p><code>filepath</code> 的功能和 <code>path</code> 包类似，但是对于不同操作系统提供了更好的支持。<code>filepath</code> 包能够自动的根据不同的操作系统文件路径进行转换，<br>通常情况下应该总是使用 <code>filepath</code> 包，而不是 <code>path</code> 包。</p>\n<p><code>path/filepath</code> 包涉及到路径操作时，路径分隔符使用 <code>os.PathSeparator</code>。不同系统，路径表示方式有所不同，比如 Unix 和 Windows 差别很大。</p>\n<p>例如，在 Unix 中，路径的分隔符是 <code>/</code>，但 Windows 是 <code>\\</code>。</p>\n<p><code>path/filepath</code> 能够处理所有的文件路径，不管是什么系统。注意，路径操作函数并不会校验路径是否真实存在。</p>\n<h2 id=\"解析路径名字符串\"><a href=\"#解析路径名字符串\" class=\"headerlink\" title=\"解析路径名字符串\"></a>解析路径名字符串</h2><p><code>Dir()</code> 和 <code>Base()</code> 函数将一个路径名字符串分解成目录和文件名两部分。（一般情况，这些函数与 Unix 中 dirname 和 basename 命令类似，但如果<br>路径以 <code>/</code> 结尾，<code>Dir</code> 的行为和 <code>dirname</code> 不太一致。）</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Dir</span><span class=\"params\">(path <span class=\"keyword\">string</span>)</span> <span class=\"title\">string</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">Base</span><span class=\"params\">(path <span class=\"keyword\">string</span>)</span> <span class=\"title\">string</span></span></span><br></pre></td></tr></table></figure>\n<p><code>Dir</code> 返回路径中除去最后一个路径元素的部分，即该路径最后一个元素所在的目录。在使用 <code>Split</code> 去掉最后一个元素后，会简化路径并去掉末尾的斜杠。<br>如果路径是空字符串，会返回 <code>.</code>；如果路径由 1 到多个斜杠后跟 0 到多个非斜杠字符组成，会返回 <code>/</code>；其他任何情况下都不会返回以斜杠结尾的路径。</p>\n<p><code>Base</code> 函数返回路径的最后一个元素。在提取元素前会去掉末尾的斜杠。如果路径是 “”，会返回 <code>.</code>；如果路径是只有一个斜杆构成的，会返回 <code>/</code>。</p>\n<p>比如，给定路径名 <code>/home/polaris/learngo.go</code>，<code>Dir</code> 返回 <code>/home/polaris</code>，而 <code>Base</code> 返回 <code>learngo.go</code>。</p>\n<p>如果给定路径名 <code>/home/polaris/learngo/</code>，<code>Dir</code> 返回 <code>/home/polaris/learngo</code><br>（这与 Unix 中的 <code>dirname</code> 不一致，<code>dirname</code> 会返回 <code>/home/polaris</code>），而 <code>Base</code> 返回 <code>learngo</code>。</p>\n<p>如果需要和 <code>dirname</code> 一样的功能，应该自己处理，比如在调用 <code>Dir</code> 之前，先将末尾的 <code>/</code> 去掉。</p>\n<p>此外，<code>Ext</code> 可以获得路径中文件名的扩展名。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Ext</span><span class=\"params\">(path <span class=\"keyword\">string</span>)</span> <span class=\"title\">string</span></span></span><br></pre></td></tr></table></figure>\n<p><code>Ext</code> 函数返回 <code>path</code> 文件扩展名。扩展名是路径中最后一个从 <code>.</code> 开始的部分，包括 <code>.</code>。如果该元素没有 <code>.</code> 会返回空字符串。</p>\n<h2 id=\"相对路径和绝对路径\"><a href=\"#相对路径和绝对路径\" class=\"headerlink\" title=\"相对路径和绝对路径\"></a>相对路径和绝对路径</h2><p>某个进程都会有当前工作目录，一般的相对路径，就是针对进程<strong>当前工作目录</strong>而言的。当然，可以针对某个目录指定相对路径。</p>\n<p>绝对路径，在 Unix 中，以 <code>/</code> 开始；在 Windows 下以某个盘符开始，比如 <code>C:\\Program Files</code>。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">IsAbs</span><span class=\"params\">(path <span class=\"keyword\">string</span>)</span> <span class=\"title\">bool</span></span></span><br></pre></td></tr></table></figure></p>\n<p><code>IsAbs</code> 返回路径是否是一个绝对路径。而<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Abs</span><span class=\"params\">(path <span class=\"keyword\">string</span>)</span> <span class=\"params\">(<span class=\"keyword\">string</span>, error)</span></span></span><br></pre></td></tr></table></figure></p>\n<p><code>Abs</code> 函数返回 <code>path</code> 代表的绝对路径，如果 <code>path</code> 不是绝对路径，会加入当前工作目录以使之成为绝对路径。因为硬链接的存在，不能保证返<br>回的绝对路径是唯一指向该地址的绝对路径。在 <code>os.Getwd</code> 出错时，<code>Abs</code> 会返回该错误，一般不会出错，如果路径名长度超过系统限制，则会报错。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Rel</span><span class=\"params\">(basepath, targpath <span class=\"keyword\">string</span>)</span> <span class=\"params\">(<span class=\"keyword\">string</span>, error)</span></span></span><br></pre></td></tr></table></figure>\n<p><code>Rel</code> 函数返回一个相对路径，返回值是 <code>targpath</code> 相对于 <code>basepath</code> 的相对路径，<br>即使 <code>basepath</code> 和 <code>targpath</code> 没有共享的路径元素。如果两个参数一个是相对路径而另一个是绝对路径，或者 <code>targpath</code> 无法表示为相对<br>于 <code>basepath</code> 的路径，将返回错误。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fmt.Println(filepath.Rel(<span class=\"string\">\"/home/polaris/learngo\"</span>, <span class=\"string\">\"/home/polaris/learngo/src/logic/topic.go\"</span>))</span><br><span class=\"line\">fmt.Println(filepath.Rel(<span class=\"string\">\"/home/polaris/learngo\"</span>, <span class=\"string\">\"/data/learngo\"</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Output:</span></span><br><span class=\"line\"><span class=\"comment\">// src/logic/topic.go &lt;nil&gt;</span></span><br><span class=\"line\"><span class=\"comment\">// ../../../data/learngo &lt;nil&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"路径的切分和拼接\"><a href=\"#路径的切分和拼接\" class=\"headerlink\" title=\"路径的切分和拼接\"></a>路径的切分和拼接</h2><p>对于一个常规文件路径，我们可以通过 <code>Split</code> 函数得到它的目录路径和文件名：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Split</span><span class=\"params\">(path <span class=\"keyword\">string</span>)</span> <span class=\"params\">(dir, file <span class=\"keyword\">string</span>)</span></span></span><br></pre></td></tr></table></figure></p>\n<p><code>Split</code> 函数根据最后一个路径分隔符将路径 <code>path</code> 分隔为目录和文件名两部分（<code>dir</code> 和 <code>file</code>）。如果路径中没有路径分隔符，函数返回<br>值 <code>dir</code> 为空字符串，<code>file</code> 等于 <code>path</code>；反之，如果路径中最后一个字符是 <code>/</code>，则 <code>dir</code> 等于 <code>path</code>，<code>file</code> 为空字符串。<br>返回值满足 <code>path == dir+file</code>。<code>dir</code> 非空时，最后一个字符总是 <code>/</code>。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// dir == /home/polaris/，file == learngo</span></span><br><span class=\"line\">filepath.Split(<span class=\"string\">\"/home/polaris/learngo\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// dir == /home/polaris/learngo/，file == \"\"</span></span><br><span class=\"line\">filepath.Split(<span class=\"string\">\"/home/polaris/learngo/\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// dir == \"\"，file == learngo</span></span><br><span class=\"line\">filepath.Split(<span class=\"string\">\"learngo\"</span>)</span><br></pre></td></tr></table></figure>\n<p>相对路径到绝对路径的转变，需要经过路径的拼接。<code>Join</code> 用于将多个路径拼接起来，会根据情况添加路径分隔符。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Join</span><span class=\"params\">(elem ...<span class=\"keyword\">string</span>)</span> <span class=\"title\">string</span></span></span><br></pre></td></tr></table></figure></p>\n<p><code>Join</code> 函数可以将任意数量的路径元素放入一个单一路径里，会根据需要添加路径分隔符。结果是经过 <code>Clean</code> 的，所有的空字符串元素会被忽略。<br>对于拼接路径的需求，我们应该总是使用 <code>Join</code> 函数来处理。</p>\n<p>有时，我们需要分割 <code>PATH</code> 或 <code>GOPATH</code> 之类的环境变量（这些路径被特定于 <code>OS</code> 的列表分隔符连接起来），<code>filepath.SplitList</code> 就是这个用途：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">SplitList</span><span class=\"params\">(path <span class=\"keyword\">string</span>)</span> []<span class=\"title\">string</span></span></span><br></pre></td></tr></table></figure></p>\n<p>注意，与 <code>strings.Split</code> 函数的不同之处是：对 “”，<code>SplitList</code> 返回 <code>[]string{}</code>，而 <code>strings.Split</code> 返回 <code>[]string{&quot;&quot;}</code>。<br><code>SplitList</code> 内部调用的是 <code>strings.Split</code>。</p>\n<h2 id=\"规整化路径\"><a href=\"#规整化路径\" class=\"headerlink\" title=\"规整化路径\"></a>规整化路径</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Clean</span><span class=\"params\">(path <span class=\"keyword\">string</span>)</span> <span class=\"title\">string</span></span></span><br></pre></td></tr></table></figure>\n<p><code>Clean</code> 函数通过单纯的词法操作返回和 <code>path</code> 代表同一地址的最短路径。</p>\n<p>它会不断的依次应用如下的规则，直到不能再进行任何处理：</p>\n<ol>\n<li>将连续的多个路径分隔符替换为单个路径分隔符</li>\n<li>剔除每一个 <code>.</code> 路径名元素（代表当前目录）</li>\n<li>剔除每一个路径内的 <code>..</code> 路径名元素（代表父目录）和它前面的非 <code>..</code> 路径名元素</li>\n<li>剔除开始于根路径的 <code>..</code> 路径名元素，即将路径开始处的 <code>/..</code> 替换为 <code>/</code>（假设路径分隔符是 <code>/</code>）</li>\n</ol>\n<p>返回的路径只有其代表一个根地址时才以路径分隔符结尾，如 Unix 的 <code>/</code> 或 Windows 的 <code>C:\\</code>。</p>\n<p>如果处理的结果是空字符串，Clean 会返回 <code>.</code>，代表当前路径。</p>\n<h2 id=\"符号链接指向的路径名\"><a href=\"#符号链接指向的路径名\" class=\"headerlink\" title=\"符号链接指向的路径名\"></a>符号链接指向的路径名</h2><p><code>filepath.EvalSymlinks</code> 会将所有路径的符号链接都解析出来。除此之外，它返回的路径，是直接可访问的。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">EvalSymlinks</span><span class=\"params\">(path <span class=\"keyword\">string</span>)</span> <span class=\"params\">(<span class=\"keyword\">string</span>, error)</span></span></span><br></pre></td></tr></table></figure></p>\n<p>如果 <code>path</code> 或返回值是相对路径，则是相对于进程当前工作目录。</p>\n<p><code>os.Readlink</code> 和 <code>filepath.EvalSymlinks</code> 区别示例：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在当前目录下创建一个 learngo.txt 文件和一个 symlink 目录，在 symlink 目录下对 learngo.txt 建一个符号链接 learngo.txt.2</span></span><br><span class=\"line\">fmt.Println(filepath.EvalSymlinks(<span class=\"string\">\"symlink/learngo.txt.2\"</span>))</span><br><span class=\"line\">fmt.Println(os.Readlink(<span class=\"string\">\"symlink/learngo.txt.2\"</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Ouput:</span></span><br><span class=\"line\"><span class=\"comment\">// learngo.txt &lt;nil&gt;</span></span><br><span class=\"line\"><span class=\"comment\">// ../learngo.txt &lt;nil&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"文件路径匹配\"><a href=\"#文件路径匹配\" class=\"headerlink\" title=\"文件路径匹配\"></a>文件路径匹配</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Match</span><span class=\"params\">(pattern, name <span class=\"keyword\">string</span>)</span> <span class=\"params\">(matched <span class=\"keyword\">bool</span>, err error)</span></span></span><br></pre></td></tr></table></figure>\n<p><code>Match</code> 指示 <code>name</code> 是否和 shell 的文件模式匹配。模式语法如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pattern:</span><br><span class=\"line\">\t&#123; term &#125;</span><br><span class=\"line\">term:</span><br><span class=\"line\">\t<span class=\"string\">'*'</span>         匹配 <span class=\"number\">0</span> 或多个非路径分隔符的字符</span><br><span class=\"line\">\t<span class=\"string\">'?'</span>         匹配 <span class=\"number\">1</span> 个非路径分隔符的字符</span><br><span class=\"line\">\t<span class=\"string\">'['</span> [ <span class=\"string\">'^'</span> ] &#123; character-<span class=\"keyword\">range</span> &#125; <span class=\"string\">']'</span>  </span><br><span class=\"line\">\t\t\t\t  字符组（必须非空）</span><br><span class=\"line\">\tc           匹配字符 c（c != <span class=\"string\">'*'</span>, <span class=\"string\">'?'</span>, <span class=\"string\">'\\\\', '</span>[<span class=\"string\">'）</span></span><br><span class=\"line\"><span class=\"string\">\t'</span>\\\\<span class=\"string\">' c      匹配字符 c</span></span><br><span class=\"line\"><span class=\"string\">character-range:</span></span><br><span class=\"line\"><span class=\"string\">\tc           匹配字符 c（c != '</span>\\\\<span class=\"string\">', '</span>-<span class=\"string\">', '</span>]<span class=\"string\">'）</span></span><br><span class=\"line\"><span class=\"string\">\t'</span>\\\\<span class=\"string\">' c      匹配字符 c</span></span><br><span class=\"line\"><span class=\"string\">\tlo '</span>-<span class=\"string\">' hi   匹配区间[lo, hi]内的字符</span></span><br></pre></td></tr></table></figure>\n<p>匹配要求 <code>pattern</code> 必须和 <code>name</code> 全匹配上，不只是子串。在 Windows 下转义字符被禁用。</p>\n<p><code>Match</code> 函数很少使用，搜索了一遍，标准库没有用到这个函数。而 <code>Glob</code> 函数在模板标准库中被用到了。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Glob</span><span class=\"params\">(pattern <span class=\"keyword\">string</span>)</span> <span class=\"params\">(matches []<span class=\"keyword\">string</span>, err error)</span></span></span><br></pre></td></tr></table></figure></p>\n<p><code>Glob</code> 函数返回所有匹配了 模式字符串 <code>pattern</code> 的文件列表或者 nil（如果没有匹配的文件）。<code>pattern</code> 的语法和 <code>Match</code> 函数相同。<br><code>pattern</code> 可以描述多层的名字，如 <code>/usr/*/bin/ed</code>（假设路径分隔符是 <code>/</code>）。</p>\n<p>注意，<code>Glob</code> 会忽略任何文件系统相关的错误，如读目录引发的 I/O 错误。唯一的错误和 <code>Match</code> 一样，在 <code>pattern</code> 不合法时，<br>返回 <code>filepath.ErrBadPattern</code>。返回的结果是根据文件名字典顺序进行了排序的。</p>\n<p><code>Glob</code> 的常见用法，是读取某个目录下所有的文件，比如写单元测试时，读取 <code>testdata</code> 目录下所有测试数据：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">filepath.Glob(<span class=\"string\">\"testdata/*.input\"</span>)</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"遍历目录\"><a href=\"#遍历目录\" class=\"headerlink\" title=\"遍历目录\"></a>遍历目录</h2><p>在 <code>filepath</code> 中，提供了 <code>Walk</code> 函数，用于遍历目录树。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Walk</span><span class=\"params\">(root <span class=\"keyword\">string</span>, walkFn WalkFunc)</span> <span class=\"title\">error</span></span></span><br></pre></td></tr></table></figure></p>\n<p><code>Walk</code> 函数会遍历 <code>root</code> 指定的目录下的文件树，对每一个该文件树中的目录和文件都会调用 <code>walkFn</code>，包括 <code>root</code> 自身。所有访问文件 <code>/</code> 目录<br>时遇到的错误都会传递给 <code>walkFn</code> 过滤。文件是按字典顺序遍历的，这让输出更漂亮，但也导致处理非常大的目录时效率会降低。<code>Walk</code> 函数不会遍历<br>文件树中的符号链接（快捷方式）文件包含的路径。</p>\n<p><code>walkFn</code> 的类型 <code>WalkFunc</code> 的定义如下：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> WalkFunc <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(path <span class=\"keyword\">string</span>, info os.FileInfo, err error)</span> <span class=\"title\">error</span></span></span><br></pre></td></tr></table></figure></p>\n<p><code>Walk</code> 函数对每一个文件 <code>/</code> 目录都会调用 <code>WalkFunc</code> 函数类型值。调用时 <code>path</code> 参数会包含 <code>Walk</code> 的 <code>root</code> 参数作为前缀；就是说，<br>如果 <code>Walk</code> 函数的 <code>root</code> 为 “dir”，该目录下有文件 “a”，将会使用 “dir/a” 作为调用 <code>walkFn</code> 的参数。<code>walkFn</code> 参数被调用时的 <code>info</code><br>参数是 <code>path</code> 指定的地址（文件 / 目录）的文件信息，类型为 <code>os.FileInfo</code>。</p>\n<p>如果遍历 <code>path</code> 指定的文件或目录时出现了问题，传入的参数 <code>err</code> 会描述该问题，<code>WalkFunc</code> 类型函数可以决定如何去处理该错误<br>（<code>Walk</code> 函数将不会深入该目录）；如果该函数返回一个错误，<code>Walk</code> 函数的执行会中止；只有一个例外，如果 <code>Walk</code> 的 <code>walkFn</code> 返回<br>值是 <code>SkipDir</code>，将会跳过该目录的内容而 <code>Walk</code> 函数照常执行处理下一个文件。</p>\n<h2 id=\"Windows-起作用的函数\"><a href=\"#Windows-起作用的函数\" class=\"headerlink\" title=\"Windows 起作用的函数\"></a>Windows 起作用的函数</h2><p><code>filepath</code> 中有三个函数：<code>VolumeName</code>、<code>FromSlash</code> 和 <code>ToSlash</code>，针对非 Unix 平台的。</p>\n","site":{"data":{"navigation":{"logo":{"text":"Golang Learn","type":"link","path":"index.html"},"main":[{"text":"Golang 基础","type":"label"},{"text":"Go 环境配置","type":"link","path":"basic/env_config.html"},{"text":"包","type":"link","path":"basic/package.html"},{"text":"基础数据类型","type":"link","path":"basic/basic_data.html"},{"text":"变量","type":"link","path":"basic/var.html"},{"text":"常量","type":"link","path":"basic/constant.html"},{"text":"控制语句","type":"link","path":"basic/flow.html"},{"text":"运算符","type":"link","path":"basic/operator.html"},{"text":"作用域","type":"link","path":"basic/scope.html"},{"text":"指针","type":"link","path":"basic/pointer.html"},{"text":"数组","type":"link","path":"basic/array.html"},{"text":"切片","type":"link","path":"basic/slice.html"},{"text":"字典","type":"link","path":"basic/map.html"},{"text":"函数","type":"link","path":"basic/function.html"},{"text":"结构体","type":"link","path":"basic/struct.html"},{"text":"接口","type":"link","path":"basic/interface.html"},{"text":"面向对象","type":"link","path":"basic/oop.html"},{"text":"错误","type":"link","path":"basic/error.html"},{"text":"序列化","type":"link","path":"basic/json.html"},{"text":"反射","type":"link","path":"basic/reflect.html"},{"text":"测试","type":"link","path":"basic/test.html"},{"text":"并发编程","type":"label"},{"text":"goroutine","type":"link","path":"concurrent/goroutine.html"},{"text":"channel","type":"link","path":"concurrent/channel.html"},{"text":"同步和锁","type":"link","path":"concurrent/sync_lock.html"},{"text":"内存分配","type":"label"},{"text":"内存分配","type":"link","path":"advance/mm.html"},{"text":"垃圾回收","type":"label"},{"text":"垃圾回收","type":"link","path":"advance/gc.html"},{"text":"标准库","type":"label"},{"text":"fmt","type":"link","path":"standards/io/fmt.html"},{"text":"io","type":"link","path":"standards/io/io.html"},{"text":"ioutil","type":"link","path":"standards/io/ioutil.html"},{"text":"bufio","type":"link","path":"standards/io/bufio.html"},{"text":"os","type":"link","path":"standards/os/os.html"},{"text":"filepath","type":"link","path":"standards/os/filepath.html"},{"text":"strings","type":"link","path":"standards/text/strings.html"},{"text":"strconv","type":"link","path":"standards/text/strconv.html"},{"text":"unicode","type":"link","path":"standards/text/unicode.html"},{"text":"log","type":"link","path":"standards/log.html"},{"text":"time","type":"link","path":"standards/time.html"},{"text":"http","type":"link","path":"standards/net/http.html"},{"text":"math","type":"link","path":"standards/data/math.html"},{"text":"sort","type":"link","path":"standards/data/sort.html"},{"text":"big","type":"link","path":"standards/data/big.html"},{"text":"container","type":"link","path":"standards/data/container.html"},{"text":"sql","type":"link","path":"standards/database/sql.html"},{"text":"THEME","type":"label"},{"text":"使用文档主题","type":"link","path":"theme/theme-usage.html"},{"text":"SUPPORT AND FEEDBACK","type":"label"},{"text":"Raise an Issue on Github","type":"link","path":"https://github.com/shipengqi/golang-learn/issues/new"}]}}},"excerpt":"","more":"<h1 id=\"filepath\"><a href=\"#filepath\" class=\"headerlink\" title=\"filepath\"></a>filepath</h1><p><code>filepath</code> 的功能和 <code>path</code> 包类似，但是对于不同操作系统提供了更好的支持。<code>filepath</code> 包能够自动的根据不同的操作系统文件路径进行转换，<br>通常情况下应该总是使用 <code>filepath</code> 包，而不是 <code>path</code> 包。</p>\n<p><code>path/filepath</code> 包涉及到路径操作时，路径分隔符使用 <code>os.PathSeparator</code>。不同系统，路径表示方式有所不同，比如 Unix 和 Windows 差别很大。</p>\n<p>例如，在 Unix 中，路径的分隔符是 <code>/</code>，但 Windows 是 <code>\\</code>。</p>\n<p><code>path/filepath</code> 能够处理所有的文件路径，不管是什么系统。注意，路径操作函数并不会校验路径是否真实存在。</p>\n<h2 id=\"解析路径名字符串\"><a href=\"#解析路径名字符串\" class=\"headerlink\" title=\"解析路径名字符串\"></a>解析路径名字符串</h2><p><code>Dir()</code> 和 <code>Base()</code> 函数将一个路径名字符串分解成目录和文件名两部分。（一般情况，这些函数与 Unix 中 dirname 和 basename 命令类似，但如果<br>路径以 <code>/</code> 结尾，<code>Dir</code> 的行为和 <code>dirname</code> 不太一致。）</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Dir</span><span class=\"params\">(path <span class=\"keyword\">string</span>)</span> <span class=\"title\">string</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">Base</span><span class=\"params\">(path <span class=\"keyword\">string</span>)</span> <span class=\"title\">string</span></span></span><br></pre></td></tr></table></figure>\n<p><code>Dir</code> 返回路径中除去最后一个路径元素的部分，即该路径最后一个元素所在的目录。在使用 <code>Split</code> 去掉最后一个元素后，会简化路径并去掉末尾的斜杠。<br>如果路径是空字符串，会返回 <code>.</code>；如果路径由 1 到多个斜杠后跟 0 到多个非斜杠字符组成，会返回 <code>/</code>；其他任何情况下都不会返回以斜杠结尾的路径。</p>\n<p><code>Base</code> 函数返回路径的最后一个元素。在提取元素前会去掉末尾的斜杠。如果路径是 “”，会返回 <code>.</code>；如果路径是只有一个斜杆构成的，会返回 <code>/</code>。</p>\n<p>比如，给定路径名 <code>/home/polaris/learngo.go</code>，<code>Dir</code> 返回 <code>/home/polaris</code>，而 <code>Base</code> 返回 <code>learngo.go</code>。</p>\n<p>如果给定路径名 <code>/home/polaris/learngo/</code>，<code>Dir</code> 返回 <code>/home/polaris/learngo</code><br>（这与 Unix 中的 <code>dirname</code> 不一致，<code>dirname</code> 会返回 <code>/home/polaris</code>），而 <code>Base</code> 返回 <code>learngo</code>。</p>\n<p>如果需要和 <code>dirname</code> 一样的功能，应该自己处理，比如在调用 <code>Dir</code> 之前，先将末尾的 <code>/</code> 去掉。</p>\n<p>此外，<code>Ext</code> 可以获得路径中文件名的扩展名。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Ext</span><span class=\"params\">(path <span class=\"keyword\">string</span>)</span> <span class=\"title\">string</span></span></span><br></pre></td></tr></table></figure>\n<p><code>Ext</code> 函数返回 <code>path</code> 文件扩展名。扩展名是路径中最后一个从 <code>.</code> 开始的部分，包括 <code>.</code>。如果该元素没有 <code>.</code> 会返回空字符串。</p>\n<h2 id=\"相对路径和绝对路径\"><a href=\"#相对路径和绝对路径\" class=\"headerlink\" title=\"相对路径和绝对路径\"></a>相对路径和绝对路径</h2><p>某个进程都会有当前工作目录，一般的相对路径，就是针对进程<strong>当前工作目录</strong>而言的。当然，可以针对某个目录指定相对路径。</p>\n<p>绝对路径，在 Unix 中，以 <code>/</code> 开始；在 Windows 下以某个盘符开始，比如 <code>C:\\Program Files</code>。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">IsAbs</span><span class=\"params\">(path <span class=\"keyword\">string</span>)</span> <span class=\"title\">bool</span></span></span><br></pre></td></tr></table></figure></p>\n<p><code>IsAbs</code> 返回路径是否是一个绝对路径。而<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Abs</span><span class=\"params\">(path <span class=\"keyword\">string</span>)</span> <span class=\"params\">(<span class=\"keyword\">string</span>, error)</span></span></span><br></pre></td></tr></table></figure></p>\n<p><code>Abs</code> 函数返回 <code>path</code> 代表的绝对路径，如果 <code>path</code> 不是绝对路径，会加入当前工作目录以使之成为绝对路径。因为硬链接的存在，不能保证返<br>回的绝对路径是唯一指向该地址的绝对路径。在 <code>os.Getwd</code> 出错时，<code>Abs</code> 会返回该错误，一般不会出错，如果路径名长度超过系统限制，则会报错。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Rel</span><span class=\"params\">(basepath, targpath <span class=\"keyword\">string</span>)</span> <span class=\"params\">(<span class=\"keyword\">string</span>, error)</span></span></span><br></pre></td></tr></table></figure>\n<p><code>Rel</code> 函数返回一个相对路径，返回值是 <code>targpath</code> 相对于 <code>basepath</code> 的相对路径，<br>即使 <code>basepath</code> 和 <code>targpath</code> 没有共享的路径元素。如果两个参数一个是相对路径而另一个是绝对路径，或者 <code>targpath</code> 无法表示为相对<br>于 <code>basepath</code> 的路径，将返回错误。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fmt.Println(filepath.Rel(<span class=\"string\">\"/home/polaris/learngo\"</span>, <span class=\"string\">\"/home/polaris/learngo/src/logic/topic.go\"</span>))</span><br><span class=\"line\">fmt.Println(filepath.Rel(<span class=\"string\">\"/home/polaris/learngo\"</span>, <span class=\"string\">\"/data/learngo\"</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Output:</span></span><br><span class=\"line\"><span class=\"comment\">// src/logic/topic.go &lt;nil&gt;</span></span><br><span class=\"line\"><span class=\"comment\">// ../../../data/learngo &lt;nil&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"路径的切分和拼接\"><a href=\"#路径的切分和拼接\" class=\"headerlink\" title=\"路径的切分和拼接\"></a>路径的切分和拼接</h2><p>对于一个常规文件路径，我们可以通过 <code>Split</code> 函数得到它的目录路径和文件名：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Split</span><span class=\"params\">(path <span class=\"keyword\">string</span>)</span> <span class=\"params\">(dir, file <span class=\"keyword\">string</span>)</span></span></span><br></pre></td></tr></table></figure></p>\n<p><code>Split</code> 函数根据最后一个路径分隔符将路径 <code>path</code> 分隔为目录和文件名两部分（<code>dir</code> 和 <code>file</code>）。如果路径中没有路径分隔符，函数返回<br>值 <code>dir</code> 为空字符串，<code>file</code> 等于 <code>path</code>；反之，如果路径中最后一个字符是 <code>/</code>，则 <code>dir</code> 等于 <code>path</code>，<code>file</code> 为空字符串。<br>返回值满足 <code>path == dir+file</code>。<code>dir</code> 非空时，最后一个字符总是 <code>/</code>。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// dir == /home/polaris/，file == learngo</span></span><br><span class=\"line\">filepath.Split(<span class=\"string\">\"/home/polaris/learngo\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// dir == /home/polaris/learngo/，file == \"\"</span></span><br><span class=\"line\">filepath.Split(<span class=\"string\">\"/home/polaris/learngo/\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// dir == \"\"，file == learngo</span></span><br><span class=\"line\">filepath.Split(<span class=\"string\">\"learngo\"</span>)</span><br></pre></td></tr></table></figure>\n<p>相对路径到绝对路径的转变，需要经过路径的拼接。<code>Join</code> 用于将多个路径拼接起来，会根据情况添加路径分隔符。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Join</span><span class=\"params\">(elem ...<span class=\"keyword\">string</span>)</span> <span class=\"title\">string</span></span></span><br></pre></td></tr></table></figure></p>\n<p><code>Join</code> 函数可以将任意数量的路径元素放入一个单一路径里，会根据需要添加路径分隔符。结果是经过 <code>Clean</code> 的，所有的空字符串元素会被忽略。<br>对于拼接路径的需求，我们应该总是使用 <code>Join</code> 函数来处理。</p>\n<p>有时，我们需要分割 <code>PATH</code> 或 <code>GOPATH</code> 之类的环境变量（这些路径被特定于 <code>OS</code> 的列表分隔符连接起来），<code>filepath.SplitList</code> 就是这个用途：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">SplitList</span><span class=\"params\">(path <span class=\"keyword\">string</span>)</span> []<span class=\"title\">string</span></span></span><br></pre></td></tr></table></figure></p>\n<p>注意，与 <code>strings.Split</code> 函数的不同之处是：对 “”，<code>SplitList</code> 返回 <code>[]string{}</code>，而 <code>strings.Split</code> 返回 <code>[]string{&quot;&quot;}</code>。<br><code>SplitList</code> 内部调用的是 <code>strings.Split</code>。</p>\n<h2 id=\"规整化路径\"><a href=\"#规整化路径\" class=\"headerlink\" title=\"规整化路径\"></a>规整化路径</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Clean</span><span class=\"params\">(path <span class=\"keyword\">string</span>)</span> <span class=\"title\">string</span></span></span><br></pre></td></tr></table></figure>\n<p><code>Clean</code> 函数通过单纯的词法操作返回和 <code>path</code> 代表同一地址的最短路径。</p>\n<p>它会不断的依次应用如下的规则，直到不能再进行任何处理：</p>\n<ol>\n<li>将连续的多个路径分隔符替换为单个路径分隔符</li>\n<li>剔除每一个 <code>.</code> 路径名元素（代表当前目录）</li>\n<li>剔除每一个路径内的 <code>..</code> 路径名元素（代表父目录）和它前面的非 <code>..</code> 路径名元素</li>\n<li>剔除开始于根路径的 <code>..</code> 路径名元素，即将路径开始处的 <code>/..</code> 替换为 <code>/</code>（假设路径分隔符是 <code>/</code>）</li>\n</ol>\n<p>返回的路径只有其代表一个根地址时才以路径分隔符结尾，如 Unix 的 <code>/</code> 或 Windows 的 <code>C:\\</code>。</p>\n<p>如果处理的结果是空字符串，Clean 会返回 <code>.</code>，代表当前路径。</p>\n<h2 id=\"符号链接指向的路径名\"><a href=\"#符号链接指向的路径名\" class=\"headerlink\" title=\"符号链接指向的路径名\"></a>符号链接指向的路径名</h2><p><code>filepath.EvalSymlinks</code> 会将所有路径的符号链接都解析出来。除此之外，它返回的路径，是直接可访问的。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">EvalSymlinks</span><span class=\"params\">(path <span class=\"keyword\">string</span>)</span> <span class=\"params\">(<span class=\"keyword\">string</span>, error)</span></span></span><br></pre></td></tr></table></figure></p>\n<p>如果 <code>path</code> 或返回值是相对路径，则是相对于进程当前工作目录。</p>\n<p><code>os.Readlink</code> 和 <code>filepath.EvalSymlinks</code> 区别示例：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在当前目录下创建一个 learngo.txt 文件和一个 symlink 目录，在 symlink 目录下对 learngo.txt 建一个符号链接 learngo.txt.2</span></span><br><span class=\"line\">fmt.Println(filepath.EvalSymlinks(<span class=\"string\">\"symlink/learngo.txt.2\"</span>))</span><br><span class=\"line\">fmt.Println(os.Readlink(<span class=\"string\">\"symlink/learngo.txt.2\"</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Ouput:</span></span><br><span class=\"line\"><span class=\"comment\">// learngo.txt &lt;nil&gt;</span></span><br><span class=\"line\"><span class=\"comment\">// ../learngo.txt &lt;nil&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"文件路径匹配\"><a href=\"#文件路径匹配\" class=\"headerlink\" title=\"文件路径匹配\"></a>文件路径匹配</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Match</span><span class=\"params\">(pattern, name <span class=\"keyword\">string</span>)</span> <span class=\"params\">(matched <span class=\"keyword\">bool</span>, err error)</span></span></span><br></pre></td></tr></table></figure>\n<p><code>Match</code> 指示 <code>name</code> 是否和 shell 的文件模式匹配。模式语法如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pattern:</span><br><span class=\"line\">\t&#123; term &#125;</span><br><span class=\"line\">term:</span><br><span class=\"line\">\t<span class=\"string\">'*'</span>         匹配 <span class=\"number\">0</span> 或多个非路径分隔符的字符</span><br><span class=\"line\">\t<span class=\"string\">'?'</span>         匹配 <span class=\"number\">1</span> 个非路径分隔符的字符</span><br><span class=\"line\">\t<span class=\"string\">'['</span> [ <span class=\"string\">'^'</span> ] &#123; character-<span class=\"keyword\">range</span> &#125; <span class=\"string\">']'</span>  </span><br><span class=\"line\">\t\t\t\t  字符组（必须非空）</span><br><span class=\"line\">\tc           匹配字符 c（c != <span class=\"string\">'*'</span>, <span class=\"string\">'?'</span>, <span class=\"string\">'\\\\', '</span>[<span class=\"string\">'）</span></span><br><span class=\"line\"><span class=\"string\">\t'</span>\\\\<span class=\"string\">' c      匹配字符 c</span></span><br><span class=\"line\"><span class=\"string\">character-range:</span></span><br><span class=\"line\"><span class=\"string\">\tc           匹配字符 c（c != '</span>\\\\<span class=\"string\">', '</span>-<span class=\"string\">', '</span>]<span class=\"string\">'）</span></span><br><span class=\"line\"><span class=\"string\">\t'</span>\\\\<span class=\"string\">' c      匹配字符 c</span></span><br><span class=\"line\"><span class=\"string\">\tlo '</span>-<span class=\"string\">' hi   匹配区间[lo, hi]内的字符</span></span><br></pre></td></tr></table></figure>\n<p>匹配要求 <code>pattern</code> 必须和 <code>name</code> 全匹配上，不只是子串。在 Windows 下转义字符被禁用。</p>\n<p><code>Match</code> 函数很少使用，搜索了一遍，标准库没有用到这个函数。而 <code>Glob</code> 函数在模板标准库中被用到了。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Glob</span><span class=\"params\">(pattern <span class=\"keyword\">string</span>)</span> <span class=\"params\">(matches []<span class=\"keyword\">string</span>, err error)</span></span></span><br></pre></td></tr></table></figure></p>\n<p><code>Glob</code> 函数返回所有匹配了 模式字符串 <code>pattern</code> 的文件列表或者 nil（如果没有匹配的文件）。<code>pattern</code> 的语法和 <code>Match</code> 函数相同。<br><code>pattern</code> 可以描述多层的名字，如 <code>/usr/*/bin/ed</code>（假设路径分隔符是 <code>/</code>）。</p>\n<p>注意，<code>Glob</code> 会忽略任何文件系统相关的错误，如读目录引发的 I/O 错误。唯一的错误和 <code>Match</code> 一样，在 <code>pattern</code> 不合法时，<br>返回 <code>filepath.ErrBadPattern</code>。返回的结果是根据文件名字典顺序进行了排序的。</p>\n<p><code>Glob</code> 的常见用法，是读取某个目录下所有的文件，比如写单元测试时，读取 <code>testdata</code> 目录下所有测试数据：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">filepath.Glob(<span class=\"string\">\"testdata/*.input\"</span>)</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"遍历目录\"><a href=\"#遍历目录\" class=\"headerlink\" title=\"遍历目录\"></a>遍历目录</h2><p>在 <code>filepath</code> 中，提供了 <code>Walk</code> 函数，用于遍历目录树。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Walk</span><span class=\"params\">(root <span class=\"keyword\">string</span>, walkFn WalkFunc)</span> <span class=\"title\">error</span></span></span><br></pre></td></tr></table></figure></p>\n<p><code>Walk</code> 函数会遍历 <code>root</code> 指定的目录下的文件树，对每一个该文件树中的目录和文件都会调用 <code>walkFn</code>，包括 <code>root</code> 自身。所有访问文件 <code>/</code> 目录<br>时遇到的错误都会传递给 <code>walkFn</code> 过滤。文件是按字典顺序遍历的，这让输出更漂亮，但也导致处理非常大的目录时效率会降低。<code>Walk</code> 函数不会遍历<br>文件树中的符号链接（快捷方式）文件包含的路径。</p>\n<p><code>walkFn</code> 的类型 <code>WalkFunc</code> 的定义如下：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> WalkFunc <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(path <span class=\"keyword\">string</span>, info os.FileInfo, err error)</span> <span class=\"title\">error</span></span></span><br></pre></td></tr></table></figure></p>\n<p><code>Walk</code> 函数对每一个文件 <code>/</code> 目录都会调用 <code>WalkFunc</code> 函数类型值。调用时 <code>path</code> 参数会包含 <code>Walk</code> 的 <code>root</code> 参数作为前缀；就是说，<br>如果 <code>Walk</code> 函数的 <code>root</code> 为 “dir”，该目录下有文件 “a”，将会使用 “dir/a” 作为调用 <code>walkFn</code> 的参数。<code>walkFn</code> 参数被调用时的 <code>info</code><br>参数是 <code>path</code> 指定的地址（文件 / 目录）的文件信息，类型为 <code>os.FileInfo</code>。</p>\n<p>如果遍历 <code>path</code> 指定的文件或目录时出现了问题，传入的参数 <code>err</code> 会描述该问题，<code>WalkFunc</code> 类型函数可以决定如何去处理该错误<br>（<code>Walk</code> 函数将不会深入该目录）；如果该函数返回一个错误，<code>Walk</code> 函数的执行会中止；只有一个例外，如果 <code>Walk</code> 的 <code>walkFn</code> 返回<br>值是 <code>SkipDir</code>，将会跳过该目录的内容而 <code>Walk</code> 函数照常执行处理下一个文件。</p>\n<h2 id=\"Windows-起作用的函数\"><a href=\"#Windows-起作用的函数\" class=\"headerlink\" title=\"Windows 起作用的函数\"></a>Windows 起作用的函数</h2><p><code>filepath</code> 中有三个函数：<code>VolumeName</code>、<code>FromSlash</code> 和 <code>ToSlash</code>，针对非 Unix 平台的。</p>\n"},{"title":"strings","_content":"\n# strings\n\n字符串常见操作有：\n\n- 字符串长度；\n- 求子串；\n- 是否存在某个字符或子串；\n- 子串出现的次数（字符串匹配）；\n- 字符串分割（切分）为 `[]string`；\n- 字符串是否有某个前缀或后缀；\n- 字符或子串在字符串中首次出现的位置或最后一次出现的位置；\n- 通过某个字符串将 `[]string` 连接起来；\n- 字符串重复几次；\n- 字符串中子串替换；\n- 大小写转换；\n- `Trim` 操作；\n- ...\n\n## 前缀和后缀\n\n`HasPrefix` 判断字符串 `s` 是否以 `prefix` 开头：\n\n```go\nstrings.HasPrefix(s, prefix string) bool\n```\n\n`HasSuffix` 判断字符串 `s` 是否以 `suffix` 结尾：\n\n```go\nstrings.HasSuffix(s, suffix string) bool\n```\n示例：\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\nfunc main() {\n\tvar str string = \"This is an example of a string\"\n\tfmt.Printf(\"T/F? Does the string \\\"%s\\\" have prefix %s? \", str, \"Th\")\n\tfmt.Printf(\"%t\\n\", strings.HasPrefix(str, \"Th\"))\n}\n```\n\n输出：\n```\nT/F? Does the string \"This is an example of a string\" have prefix Th? true\n```\n\t\n\n\n## 判断是否包含字符串\n`Contains` 判断字符串 `s` 是否包含 `substr`：\n\n```go\nstrings.Contains(s, substr string) bool\n```\n\n## 获取某个子字串在字符串中的位置（索引）\n\n`Index` 返回字符串 `str` 在字符串 `s` 中的索引（`str` 的第一个字符的索引），`-1` 表示字符串 `s` 不包含字符串 `str`：\n\n```go\nstrings.Index(s, str string) int\n```\n\n`LastIndex` 返回字符串 `str` 在字符串 `s` 中最后出现位置的索引（`str` 的第一个字符的索引），`-1` 表示字符串 `s` 不包含字符\n串 `str`：\n\n```go\nstrings.LastIndex(s, str string) int\n```\n\n示例：\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\nfunc main() {\n\tvar str string = \"Hi, I'm Marc, Hi.\"\n\n\tfmt.Printf(\"The position of \\\"Marc\\\" is: \")\n\tfmt.Printf(\"%d\\n\", strings.Index(str, \"Marc\"))\n\n\tfmt.Printf(\"The position of the first instance of \\\"Hi\\\" is: \")\n\tfmt.Printf(\"%d\\n\", strings.Index(str, \"Hi\"))\n\tfmt.Printf(\"The position of the last instance of \\\"Hi\\\" is: \")\n\tfmt.Printf(\"%d\\n\", strings.LastIndex(str, \"Hi\"))\n\n\tfmt.Printf(\"The position of \\\"Burger\\\" is: \")\n\tfmt.Printf(\"%d\\n\", strings.Index(str, \"Burger\"))\n}\n```\n\n输出：\n```\nThe position of \"Marc\" is: 8\nThe position of the first instance of \"Hi\" is: 0\nThe position of the last instance of \"Hi\" is: 14\nThe position of \"Burger\" is: -1\n```\n\n## 计算字符串出现次数\n\n`Count` 用于计算字符串 `str` 在字符串 `s` 中出现的非重叠次数：\n\n```go\nstrings.Count(s, str string) int\n```\n\n示例：\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\nfunc main() {\n\tvar str string = \"Hello, how is it going, Hugo?\"\n\tvar manyG = \"gggggggggg\"\n\n\tfmt.Printf(\"Number of H's in %s is: \", str)\n\tfmt.Printf(\"%d\\n\", strings.Count(str, \"H\"))\n\n\tfmt.Printf(\"Number of double g's in %s is: \", manyG)\n\tfmt.Printf(\"%d\\n\", strings.Count(manyG, \"gg\"))\n}\n```\n\n输出：\n```\nNumber of H's in Hello, how is it going, Hugo? is: 2\nNumber of double g’s in gggggggggg is: 5\n```\n\n## 字符串替换\n尽量不使用正则，否则会影响性能。\n\n`Replace` 用于将字符串 `str` 中的前 `n` 个字符串 `old` 替换为字符串 `new`，并返回一个新的字符串，如果 `n = -1` 则替换所\n有字符串 `old` 为字符串 `new`：\n\n```go\nstrings.Replace(str, old, new, n) string\n```\n示例：\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\nfunc main() {\n    fmt.Println(strings.Replace(\"oink oink oink\", \"k\", \"ky\", 2))\n    fmt.Println(strings.Replace(\"oink oink oink\", \"oink\", \"moo\", -1))\n}\n```\n\n输出：\n```\noinky oinky oink\nmoo moo moo\n```\n\n\n## 重复字符串\n\n`Repeat` 用于重复 `count` 次字符串 `s` 并返回一个新的字符串：\n\n```go\nstrings.Repeat(s, count int) string\n```\n\n示例：\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\nfunc main() {\n    fmt.Println(\"ba\" + strings.Repeat(\"na\", 2))\n}\n```\n\n输出：\n```\nbanana\n```\n\n## 大小写转换\n\n`ToLower` 将字符串中的 Unicode 字符全部转换为小写字符：\n\n```go\nstrings.ToLower(s) string\n```\n\n`ToUpper` 将字符串中的 Unicode 字符全部转换为大写字符：\n\n```go\nstrings.ToUpper(s) string\n```\n\n示例：\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\nfunc main() {\n\tvar orig string = \"Hey, how are you George?\"\n\tvar lower string\n\tvar upper string\n\n\tfmt.Printf(\"The original string is: %s\\n\", orig)\n\tlower = strings.ToLower(orig)\n\tfmt.Printf(\"The lowercase string is: %s\\n\", lower)\n\tupper = strings.ToUpper(orig)\n\tfmt.Printf(\"The uppercase string is: %s\\n\", upper)\n}\n```\n\n输出：\n```\nThe original string is: Hey, how are you George?\nThe lowercase string is: hey, how are you george?\nThe uppercase string is: HEY, HOW ARE YOU GEORGE?\n```\n\n\n## 修改字符串\n`Trim` 系列函数可以删除字符串首尾的连续多余字符，包括：\n\n```go\n// 删除字符串首尾的字符\nfunc Trim(s string, cutset string) string\n\n// 删除字符串首的字符\nfunc TrimLeft(s string, cutset string) string\n\n// 删除字符串尾部的字符\nfunc TrimRight(s string, cutset string) string\n\n// 删除字符串首尾的空格\nfunc TrimSpace(s string) string\n```\n示例：\n\n```go\ns := \"cutjjjcut\"\n// 将字符串 s 首尾的 `cut` 去除掉\nnewStr := strings.Trim(s, \"cut\")\n\nfmt.Println(newStr)\n```\n\n输出：\n```\njjj\n```\n\n## JOIN\n`Join` 函数将字符串数组（或 `slice`）连接起来：\n```go\nfunc Join(a []string, sep string) string\n```\n\n示例：\n\n```go\nfmt.Println(strings.Join([]string{\"name=xxx\", \"age=xx\"}, \"&\"))\n```\n\n输出：\n```\nname=xxx&age=xx\n```\n\n## 分割字符串\n\n### Fields\n```go\n// 用一个或多个连续的空格分隔字符串 s，返回子字符串的数组（slice）\nfunc Fields(s string) []string\n```\n\n示例：\n```go\nfmt.Printf(\"Fields are: %q\", strings.Fields(\"  foo bar  baz   \")) // Fields are: [\"foo\" \"bar\" \"baz\"]\n```\n\n`Fields` 使用一个或多个空格分隔，也就是说返回的字符串中不会包含空格字符串。\n\n> 如果字符串 s 只包含空格，则返回空列表 (`[]string` 的长度为 `0`）\n\n### Split 和 SplitAfter、 SplitN 和 SplitAfterN\n```go\nfunc Split(s, sep string) []string { return genSplit(s, sep, 0, -1) }\nfunc SplitAfter(s, sep string) []string { return genSplit(s, sep, len(sep), -1) }\nfunc SplitN(s, sep string, n int) []string { return genSplit(s, sep, 0, n) }\nfunc SplitAfterN(s, sep string, n int) []string { return genSplit(s, sep, len(sep), n) }\n```\n\n它们都调用了 `genSplit` 函数。这四个函数都是通过 `sep` 进行分割，返回 `[]string`。\n\n- 如果 `sep` 为空，相当于分成一个个的 UTF-8 字符，如 `Split(\"abc\",\"\")`，得到的是 `[a b c]`。\n- `Split(s, sep)` 和 `SplitN(s, sep, -1)` 等价。\n- `SplitAfter(s, sep)` 和 `SplitAfterN(s, sep, -1)` 等价。\n\n#### Split 和 SplitAfter 的区别\n```go\nfmt.Printf(\"%q\\n\", strings.Split(\"foo,bar,baz\", \",\"))  // [\"foo\" \"bar\" \"baz\"]\nfmt.Printf(\"%q\\n\", strings.SplitAfter(\"foo,bar,baz\", \",\")) // [\"foo,\" \"bar,\" \"baz\"]\n```\n从输出可以看出，`SplitAfter` 会保留 `sep`。\n\n#### SplitN 和 SplitAfterN\n这两个函数通过最后一个参数 `n` 控制返回的结果中的 `slice` 中的元素个数：\n- 当 `n < 0` 时，返回所有的子字符串\n- 当 `n == 0` 时，返回的结果是 `nil`\n- 当 `n > 0` 时，表示返回的 `slice` 中最多只有 `n` 个元素，其中，最后一个元素不会分割\n\n```go\nfmt.Printf(\"%q\\n\", strings.SplitN(\"foo,bar,baz\", \",\", 2))                // [\"foo\" \"bar,baz\"]\nfmt.Printf(\"%q\\n\", strings.Split(\"a,b,c\", \",\"))                          // [\"a\" \"b\" \"c\"]\nfmt.Printf(\"%q\\n\", strings.Split(\"a man a plan a canal panama\", \"a \"))   // [\"\" \"man \" \"plan \" \"canal panama\"]\nfmt.Printf(\"%q\\n\", strings.Split(\" xyz \", \"\"))                           // [\" \" \"x\" \"y\" \"z\" \" \"]\nfmt.Printf(\"%q\\n\", strings.Split(\"\", \"Bernardo O'Higgins\"))              // [\"\"]\n```\n## 从字符串中读取内容\n\n函数 `strings.NewReader(str)` 用于生成一个 `Reader` 并读取字符串中的内容，然后返回指向该 `Reader` 的指针，从其它类型读取\n内容的函数还有：\n\n- `Read()` 从 []byte 中读取内容。\n- `ReadByte()` 和 `ReadRune()` 从字符串中读取下一个 byte 或者 rune。\n","source":"standards/text/strings.md","raw":"---\ntitle: strings\n---\n\n# strings\n\n字符串常见操作有：\n\n- 字符串长度；\n- 求子串；\n- 是否存在某个字符或子串；\n- 子串出现的次数（字符串匹配）；\n- 字符串分割（切分）为 `[]string`；\n- 字符串是否有某个前缀或后缀；\n- 字符或子串在字符串中首次出现的位置或最后一次出现的位置；\n- 通过某个字符串将 `[]string` 连接起来；\n- 字符串重复几次；\n- 字符串中子串替换；\n- 大小写转换；\n- `Trim` 操作；\n- ...\n\n## 前缀和后缀\n\n`HasPrefix` 判断字符串 `s` 是否以 `prefix` 开头：\n\n```go\nstrings.HasPrefix(s, prefix string) bool\n```\n\n`HasSuffix` 判断字符串 `s` 是否以 `suffix` 结尾：\n\n```go\nstrings.HasSuffix(s, suffix string) bool\n```\n示例：\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\nfunc main() {\n\tvar str string = \"This is an example of a string\"\n\tfmt.Printf(\"T/F? Does the string \\\"%s\\\" have prefix %s? \", str, \"Th\")\n\tfmt.Printf(\"%t\\n\", strings.HasPrefix(str, \"Th\"))\n}\n```\n\n输出：\n```\nT/F? Does the string \"This is an example of a string\" have prefix Th? true\n```\n\t\n\n\n## 判断是否包含字符串\n`Contains` 判断字符串 `s` 是否包含 `substr`：\n\n```go\nstrings.Contains(s, substr string) bool\n```\n\n## 获取某个子字串在字符串中的位置（索引）\n\n`Index` 返回字符串 `str` 在字符串 `s` 中的索引（`str` 的第一个字符的索引），`-1` 表示字符串 `s` 不包含字符串 `str`：\n\n```go\nstrings.Index(s, str string) int\n```\n\n`LastIndex` 返回字符串 `str` 在字符串 `s` 中最后出现位置的索引（`str` 的第一个字符的索引），`-1` 表示字符串 `s` 不包含字符\n串 `str`：\n\n```go\nstrings.LastIndex(s, str string) int\n```\n\n示例：\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\nfunc main() {\n\tvar str string = \"Hi, I'm Marc, Hi.\"\n\n\tfmt.Printf(\"The position of \\\"Marc\\\" is: \")\n\tfmt.Printf(\"%d\\n\", strings.Index(str, \"Marc\"))\n\n\tfmt.Printf(\"The position of the first instance of \\\"Hi\\\" is: \")\n\tfmt.Printf(\"%d\\n\", strings.Index(str, \"Hi\"))\n\tfmt.Printf(\"The position of the last instance of \\\"Hi\\\" is: \")\n\tfmt.Printf(\"%d\\n\", strings.LastIndex(str, \"Hi\"))\n\n\tfmt.Printf(\"The position of \\\"Burger\\\" is: \")\n\tfmt.Printf(\"%d\\n\", strings.Index(str, \"Burger\"))\n}\n```\n\n输出：\n```\nThe position of \"Marc\" is: 8\nThe position of the first instance of \"Hi\" is: 0\nThe position of the last instance of \"Hi\" is: 14\nThe position of \"Burger\" is: -1\n```\n\n## 计算字符串出现次数\n\n`Count` 用于计算字符串 `str` 在字符串 `s` 中出现的非重叠次数：\n\n```go\nstrings.Count(s, str string) int\n```\n\n示例：\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\nfunc main() {\n\tvar str string = \"Hello, how is it going, Hugo?\"\n\tvar manyG = \"gggggggggg\"\n\n\tfmt.Printf(\"Number of H's in %s is: \", str)\n\tfmt.Printf(\"%d\\n\", strings.Count(str, \"H\"))\n\n\tfmt.Printf(\"Number of double g's in %s is: \", manyG)\n\tfmt.Printf(\"%d\\n\", strings.Count(manyG, \"gg\"))\n}\n```\n\n输出：\n```\nNumber of H's in Hello, how is it going, Hugo? is: 2\nNumber of double g’s in gggggggggg is: 5\n```\n\n## 字符串替换\n尽量不使用正则，否则会影响性能。\n\n`Replace` 用于将字符串 `str` 中的前 `n` 个字符串 `old` 替换为字符串 `new`，并返回一个新的字符串，如果 `n = -1` 则替换所\n有字符串 `old` 为字符串 `new`：\n\n```go\nstrings.Replace(str, old, new, n) string\n```\n示例：\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\nfunc main() {\n    fmt.Println(strings.Replace(\"oink oink oink\", \"k\", \"ky\", 2))\n    fmt.Println(strings.Replace(\"oink oink oink\", \"oink\", \"moo\", -1))\n}\n```\n\n输出：\n```\noinky oinky oink\nmoo moo moo\n```\n\n\n## 重复字符串\n\n`Repeat` 用于重复 `count` 次字符串 `s` 并返回一个新的字符串：\n\n```go\nstrings.Repeat(s, count int) string\n```\n\n示例：\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\nfunc main() {\n    fmt.Println(\"ba\" + strings.Repeat(\"na\", 2))\n}\n```\n\n输出：\n```\nbanana\n```\n\n## 大小写转换\n\n`ToLower` 将字符串中的 Unicode 字符全部转换为小写字符：\n\n```go\nstrings.ToLower(s) string\n```\n\n`ToUpper` 将字符串中的 Unicode 字符全部转换为大写字符：\n\n```go\nstrings.ToUpper(s) string\n```\n\n示例：\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\nfunc main() {\n\tvar orig string = \"Hey, how are you George?\"\n\tvar lower string\n\tvar upper string\n\n\tfmt.Printf(\"The original string is: %s\\n\", orig)\n\tlower = strings.ToLower(orig)\n\tfmt.Printf(\"The lowercase string is: %s\\n\", lower)\n\tupper = strings.ToUpper(orig)\n\tfmt.Printf(\"The uppercase string is: %s\\n\", upper)\n}\n```\n\n输出：\n```\nThe original string is: Hey, how are you George?\nThe lowercase string is: hey, how are you george?\nThe uppercase string is: HEY, HOW ARE YOU GEORGE?\n```\n\n\n## 修改字符串\n`Trim` 系列函数可以删除字符串首尾的连续多余字符，包括：\n\n```go\n// 删除字符串首尾的字符\nfunc Trim(s string, cutset string) string\n\n// 删除字符串首的字符\nfunc TrimLeft(s string, cutset string) string\n\n// 删除字符串尾部的字符\nfunc TrimRight(s string, cutset string) string\n\n// 删除字符串首尾的空格\nfunc TrimSpace(s string) string\n```\n示例：\n\n```go\ns := \"cutjjjcut\"\n// 将字符串 s 首尾的 `cut` 去除掉\nnewStr := strings.Trim(s, \"cut\")\n\nfmt.Println(newStr)\n```\n\n输出：\n```\njjj\n```\n\n## JOIN\n`Join` 函数将字符串数组（或 `slice`）连接起来：\n```go\nfunc Join(a []string, sep string) string\n```\n\n示例：\n\n```go\nfmt.Println(strings.Join([]string{\"name=xxx\", \"age=xx\"}, \"&\"))\n```\n\n输出：\n```\nname=xxx&age=xx\n```\n\n## 分割字符串\n\n### Fields\n```go\n// 用一个或多个连续的空格分隔字符串 s，返回子字符串的数组（slice）\nfunc Fields(s string) []string\n```\n\n示例：\n```go\nfmt.Printf(\"Fields are: %q\", strings.Fields(\"  foo bar  baz   \")) // Fields are: [\"foo\" \"bar\" \"baz\"]\n```\n\n`Fields` 使用一个或多个空格分隔，也就是说返回的字符串中不会包含空格字符串。\n\n> 如果字符串 s 只包含空格，则返回空列表 (`[]string` 的长度为 `0`）\n\n### Split 和 SplitAfter、 SplitN 和 SplitAfterN\n```go\nfunc Split(s, sep string) []string { return genSplit(s, sep, 0, -1) }\nfunc SplitAfter(s, sep string) []string { return genSplit(s, sep, len(sep), -1) }\nfunc SplitN(s, sep string, n int) []string { return genSplit(s, sep, 0, n) }\nfunc SplitAfterN(s, sep string, n int) []string { return genSplit(s, sep, len(sep), n) }\n```\n\n它们都调用了 `genSplit` 函数。这四个函数都是通过 `sep` 进行分割，返回 `[]string`。\n\n- 如果 `sep` 为空，相当于分成一个个的 UTF-8 字符，如 `Split(\"abc\",\"\")`，得到的是 `[a b c]`。\n- `Split(s, sep)` 和 `SplitN(s, sep, -1)` 等价。\n- `SplitAfter(s, sep)` 和 `SplitAfterN(s, sep, -1)` 等价。\n\n#### Split 和 SplitAfter 的区别\n```go\nfmt.Printf(\"%q\\n\", strings.Split(\"foo,bar,baz\", \",\"))  // [\"foo\" \"bar\" \"baz\"]\nfmt.Printf(\"%q\\n\", strings.SplitAfter(\"foo,bar,baz\", \",\")) // [\"foo,\" \"bar,\" \"baz\"]\n```\n从输出可以看出，`SplitAfter` 会保留 `sep`。\n\n#### SplitN 和 SplitAfterN\n这两个函数通过最后一个参数 `n` 控制返回的结果中的 `slice` 中的元素个数：\n- 当 `n < 0` 时，返回所有的子字符串\n- 当 `n == 0` 时，返回的结果是 `nil`\n- 当 `n > 0` 时，表示返回的 `slice` 中最多只有 `n` 个元素，其中，最后一个元素不会分割\n\n```go\nfmt.Printf(\"%q\\n\", strings.SplitN(\"foo,bar,baz\", \",\", 2))                // [\"foo\" \"bar,baz\"]\nfmt.Printf(\"%q\\n\", strings.Split(\"a,b,c\", \",\"))                          // [\"a\" \"b\" \"c\"]\nfmt.Printf(\"%q\\n\", strings.Split(\"a man a plan a canal panama\", \"a \"))   // [\"\" \"man \" \"plan \" \"canal panama\"]\nfmt.Printf(\"%q\\n\", strings.Split(\" xyz \", \"\"))                           // [\" \" \"x\" \"y\" \"z\" \" \"]\nfmt.Printf(\"%q\\n\", strings.Split(\"\", \"Bernardo O'Higgins\"))              // [\"\"]\n```\n## 从字符串中读取内容\n\n函数 `strings.NewReader(str)` 用于生成一个 `Reader` 并读取字符串中的内容，然后返回指向该 `Reader` 的指针，从其它类型读取\n内容的函数还有：\n\n- `Read()` 从 []byte 中读取内容。\n- `ReadByte()` 和 `ReadRune()` 从字符串中读取下一个 byte 或者 rune。\n","date":"2019-09-01T00:24:56.549Z","updated":"2019-09-01T00:24:56.524Z","path":"standards/text/strings.html","comments":1,"layout":"page","_id":"ck1xm14lf0018fcw2zrkdobxm","content":"<h1 id=\"strings\"><a href=\"#strings\" class=\"headerlink\" title=\"strings\"></a>strings</h1><p>字符串常见操作有：</p>\n<ul>\n<li>字符串长度；</li>\n<li>求子串；</li>\n<li>是否存在某个字符或子串；</li>\n<li>子串出现的次数（字符串匹配）；</li>\n<li>字符串分割（切分）为 <code>[]string</code>；</li>\n<li>字符串是否有某个前缀或后缀；</li>\n<li>字符或子串在字符串中首次出现的位置或最后一次出现的位置；</li>\n<li>通过某个字符串将 <code>[]string</code> 连接起来；</li>\n<li>字符串重复几次；</li>\n<li>字符串中子串替换；</li>\n<li>大小写转换；</li>\n<li><code>Trim</code> 操作；</li>\n<li>…</li>\n</ul>\n<h2 id=\"前缀和后缀\"><a href=\"#前缀和后缀\" class=\"headerlink\" title=\"前缀和后缀\"></a>前缀和后缀</h2><p><code>HasPrefix</code> 判断字符串 <code>s</code> 是否以 <code>prefix</code> 开头：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">strings.HasPrefix(s, prefix <span class=\"keyword\">string</span>) <span class=\"keyword\">bool</span></span><br></pre></td></tr></table></figure>\n<p><code>HasSuffix</code> 判断字符串 <code>s</code> 是否以 <code>suffix</code> 结尾：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">strings.HasSuffix(s, suffix <span class=\"keyword\">string</span>) <span class=\"keyword\">bool</span></span><br></pre></td></tr></table></figure>\n<p>示例：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">\"fmt\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"strings\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> str <span class=\"keyword\">string</span> = <span class=\"string\">\"This is an example of a string\"</span></span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"T/F? Does the string \\\"%s\\\" have prefix %s? \"</span>, str, <span class=\"string\">\"Th\"</span>)</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"%t\\n\"</span>, strings.HasPrefix(str, <span class=\"string\">\"Th\"</span>))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">T/F? Does the string &quot;This is an example of a string&quot; have prefix Th? true</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"判断是否包含字符串\"><a href=\"#判断是否包含字符串\" class=\"headerlink\" title=\"判断是否包含字符串\"></a>判断是否包含字符串</h2><p><code>Contains</code> 判断字符串 <code>s</code> 是否包含 <code>substr</code>：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">strings.Contains(s, substr <span class=\"keyword\">string</span>) <span class=\"keyword\">bool</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"获取某个子字串在字符串中的位置（索引）\"><a href=\"#获取某个子字串在字符串中的位置（索引）\" class=\"headerlink\" title=\"获取某个子字串在字符串中的位置（索引）\"></a>获取某个子字串在字符串中的位置（索引）</h2><p><code>Index</code> 返回字符串 <code>str</code> 在字符串 <code>s</code> 中的索引（<code>str</code> 的第一个字符的索引），<code>-1</code> 表示字符串 <code>s</code> 不包含字符串 <code>str</code>：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">strings.Index(s, str <span class=\"keyword\">string</span>) <span class=\"keyword\">int</span></span><br></pre></td></tr></table></figure>\n<p><code>LastIndex</code> 返回字符串 <code>str</code> 在字符串 <code>s</code> 中最后出现位置的索引（<code>str</code> 的第一个字符的索引），<code>-1</code> 表示字符串 <code>s</code> 不包含字符<br>串 <code>str</code>：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">strings.LastIndex(s, str <span class=\"keyword\">string</span>) <span class=\"keyword\">int</span></span><br></pre></td></tr></table></figure>\n<p>示例：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">\"fmt\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"strings\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> str <span class=\"keyword\">string</span> = <span class=\"string\">\"Hi, I'm Marc, Hi.\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"The position of \\\"Marc\\\" is: \"</span>)</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"%d\\n\"</span>, strings.Index(str, <span class=\"string\">\"Marc\"</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"The position of the first instance of \\\"Hi\\\" is: \"</span>)</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"%d\\n\"</span>, strings.Index(str, <span class=\"string\">\"Hi\"</span>))</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"The position of the last instance of \\\"Hi\\\" is: \"</span>)</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"%d\\n\"</span>, strings.LastIndex(str, <span class=\"string\">\"Hi\"</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"The position of \\\"Burger\\\" is: \"</span>)</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"%d\\n\"</span>, strings.Index(str, <span class=\"string\">\"Burger\"</span>))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">The position of &quot;Marc&quot; is: 8</span><br><span class=\"line\">The position of the first instance of &quot;Hi&quot; is: 0</span><br><span class=\"line\">The position of the last instance of &quot;Hi&quot; is: 14</span><br><span class=\"line\">The position of &quot;Burger&quot; is: -1</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"计算字符串出现次数\"><a href=\"#计算字符串出现次数\" class=\"headerlink\" title=\"计算字符串出现次数\"></a>计算字符串出现次数</h2><p><code>Count</code> 用于计算字符串 <code>str</code> 在字符串 <code>s</code> 中出现的非重叠次数：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">strings.Count(s, str <span class=\"keyword\">string</span>) <span class=\"keyword\">int</span></span><br></pre></td></tr></table></figure>\n<p>示例：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">\"fmt\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"strings\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> str <span class=\"keyword\">string</span> = <span class=\"string\">\"Hello, how is it going, Hugo?\"</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> manyG = <span class=\"string\">\"gggggggggg\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"Number of H's in %s is: \"</span>, str)</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"%d\\n\"</span>, strings.Count(str, <span class=\"string\">\"H\"</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"Number of double g's in %s is: \"</span>, manyG)</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"%d\\n\"</span>, strings.Count(manyG, <span class=\"string\">\"gg\"</span>))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Number of H&apos;s in Hello, how is it going, Hugo? is: 2</span><br><span class=\"line\">Number of double g’s in gggggggggg is: 5</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"字符串替换\"><a href=\"#字符串替换\" class=\"headerlink\" title=\"字符串替换\"></a>字符串替换</h2><p>尽量不使用正则，否则会影响性能。</p>\n<p><code>Replace</code> 用于将字符串 <code>str</code> 中的前 <code>n</code> 个字符串 <code>old</code> 替换为字符串 <code>new</code>，并返回一个新的字符串，如果 <code>n = -1</code> 则替换所<br>有字符串 <code>old</code> 为字符串 <code>new</code>：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">strings.Replace(str, old, <span class=\"built_in\">new</span>, n) <span class=\"keyword\">string</span></span><br></pre></td></tr></table></figure>\n<p>示例：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">\"fmt\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"strings\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    fmt.Println(strings.Replace(<span class=\"string\">\"oink oink oink\"</span>, <span class=\"string\">\"k\"</span>, <span class=\"string\">\"ky\"</span>, <span class=\"number\">2</span>))</span><br><span class=\"line\">    fmt.Println(strings.Replace(<span class=\"string\">\"oink oink oink\"</span>, <span class=\"string\">\"oink\"</span>, <span class=\"string\">\"moo\"</span>, <span class=\"number\">-1</span>))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">oinky oinky oink</span><br><span class=\"line\">moo moo moo</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"重复字符串\"><a href=\"#重复字符串\" class=\"headerlink\" title=\"重复字符串\"></a>重复字符串</h2><p><code>Repeat</code> 用于重复 <code>count</code> 次字符串 <code>s</code> 并返回一个新的字符串：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">strings.Repeat(s, count <span class=\"keyword\">int</span>) <span class=\"keyword\">string</span></span><br></pre></td></tr></table></figure>\n<p>示例：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">\"fmt\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"strings\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    fmt.Println(<span class=\"string\">\"ba\"</span> + strings.Repeat(<span class=\"string\">\"na\"</span>, <span class=\"number\">2</span>))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">banana</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"大小写转换\"><a href=\"#大小写转换\" class=\"headerlink\" title=\"大小写转换\"></a>大小写转换</h2><p><code>ToLower</code> 将字符串中的 Unicode 字符全部转换为小写字符：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">strings.ToLower(s) <span class=\"keyword\">string</span></span><br></pre></td></tr></table></figure>\n<p><code>ToUpper</code> 将字符串中的 Unicode 字符全部转换为大写字符：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">strings.ToUpper(s) <span class=\"keyword\">string</span></span><br></pre></td></tr></table></figure>\n<p>示例：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">\"fmt\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"strings\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> orig <span class=\"keyword\">string</span> = <span class=\"string\">\"Hey, how are you George?\"</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> lower <span class=\"keyword\">string</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> upper <span class=\"keyword\">string</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"The original string is: %s\\n\"</span>, orig)</span><br><span class=\"line\">\tlower = strings.ToLower(orig)</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"The lowercase string is: %s\\n\"</span>, lower)</span><br><span class=\"line\">\tupper = strings.ToUpper(orig)</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"The uppercase string is: %s\\n\"</span>, upper)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">The original string is: Hey, how are you George?</span><br><span class=\"line\">The lowercase string is: hey, how are you george?</span><br><span class=\"line\">The uppercase string is: HEY, HOW ARE YOU GEORGE?</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"修改字符串\"><a href=\"#修改字符串\" class=\"headerlink\" title=\"修改字符串\"></a>修改字符串</h2><p><code>Trim</code> 系列函数可以删除字符串首尾的连续多余字符，包括：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 删除字符串首尾的字符</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Trim</span><span class=\"params\">(s <span class=\"keyword\">string</span>, cutset <span class=\"keyword\">string</span>)</span> <span class=\"title\">string</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// 删除字符串首的字符</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">TrimLeft</span><span class=\"params\">(s <span class=\"keyword\">string</span>, cutset <span class=\"keyword\">string</span>)</span> <span class=\"title\">string</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// 删除字符串尾部的字符</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">TrimRight</span><span class=\"params\">(s <span class=\"keyword\">string</span>, cutset <span class=\"keyword\">string</span>)</span> <span class=\"title\">string</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// 删除字符串首尾的空格</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">TrimSpace</span><span class=\"params\">(s <span class=\"keyword\">string</span>)</span> <span class=\"title\">string</span></span></span><br></pre></td></tr></table></figure>\n<p>示例：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s := <span class=\"string\">\"cutjjjcut\"</span></span><br><span class=\"line\"><span class=\"comment\">// 将字符串 s 首尾的 `cut` 去除掉</span></span><br><span class=\"line\">newStr := strings.Trim(s, <span class=\"string\">\"cut\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">fmt.Println(newStr)</span><br></pre></td></tr></table></figure>\n<p>输出：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jjj</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"JOIN\"><a href=\"#JOIN\" class=\"headerlink\" title=\"JOIN\"></a>JOIN</h2><p><code>Join</code> 函数将字符串数组（或 <code>slice</code>）连接起来：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Join</span><span class=\"params\">(a []<span class=\"keyword\">string</span>, sep <span class=\"keyword\">string</span>)</span> <span class=\"title\">string</span></span></span><br></pre></td></tr></table></figure></p>\n<p>示例：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fmt.Println(strings.Join([]<span class=\"keyword\">string</span>&#123;<span class=\"string\">\"name=xxx\"</span>, <span class=\"string\">\"age=xx\"</span>&#125;, <span class=\"string\">\"&amp;\"</span>))</span><br></pre></td></tr></table></figure>\n<p>输出：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">name=xxx&amp;age=xx</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"分割字符串\"><a href=\"#分割字符串\" class=\"headerlink\" title=\"分割字符串\"></a>分割字符串</h2><h3 id=\"Fields\"><a href=\"#Fields\" class=\"headerlink\" title=\"Fields\"></a>Fields</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 用一个或多个连续的空格分隔字符串 s，返回子字符串的数组（slice）</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Fields</span><span class=\"params\">(s <span class=\"keyword\">string</span>)</span> []<span class=\"title\">string</span></span></span><br></pre></td></tr></table></figure>\n<p>示例：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fmt.Printf(<span class=\"string\">\"Fields are: %q\"</span>, strings.Fields(<span class=\"string\">\"  foo bar  baz   \"</span>)) <span class=\"comment\">// Fields are: [\"foo\" \"bar\" \"baz\"]</span></span><br></pre></td></tr></table></figure></p>\n<p><code>Fields</code> 使用一个或多个空格分隔，也就是说返回的字符串中不会包含空格字符串。</p>\n<blockquote>\n<p>如果字符串 s 只包含空格，则返回空列表 (<code>[]string</code> 的长度为 <code>0</code>）</p>\n</blockquote>\n<h3 id=\"Split-和-SplitAfter、-SplitN-和-SplitAfterN\"><a href=\"#Split-和-SplitAfter、-SplitN-和-SplitAfterN\" class=\"headerlink\" title=\"Split 和 SplitAfter、 SplitN 和 SplitAfterN\"></a>Split 和 SplitAfter、 SplitN 和 SplitAfterN</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Split</span><span class=\"params\">(s, sep <span class=\"keyword\">string</span>)</span> []<span class=\"title\">string</span></span> &#123; <span class=\"keyword\">return</span> genSplit(s, sep, <span class=\"number\">0</span>, <span class=\"number\">-1</span>) &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">SplitAfter</span><span class=\"params\">(s, sep <span class=\"keyword\">string</span>)</span> []<span class=\"title\">string</span></span> &#123; <span class=\"keyword\">return</span> genSplit(s, sep, <span class=\"built_in\">len</span>(sep), <span class=\"number\">-1</span>) &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">SplitN</span><span class=\"params\">(s, sep <span class=\"keyword\">string</span>, n <span class=\"keyword\">int</span>)</span> []<span class=\"title\">string</span></span> &#123; <span class=\"keyword\">return</span> genSplit(s, sep, <span class=\"number\">0</span>, n) &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">SplitAfterN</span><span class=\"params\">(s, sep <span class=\"keyword\">string</span>, n <span class=\"keyword\">int</span>)</span> []<span class=\"title\">string</span></span> &#123; <span class=\"keyword\">return</span> genSplit(s, sep, <span class=\"built_in\">len</span>(sep), n) &#125;</span><br></pre></td></tr></table></figure>\n<p>它们都调用了 <code>genSplit</code> 函数。这四个函数都是通过 <code>sep</code> 进行分割，返回 <code>[]string</code>。</p>\n<ul>\n<li>如果 <code>sep</code> 为空，相当于分成一个个的 UTF-8 字符，如 <code>Split(&quot;abc&quot;,&quot;&quot;)</code>，得到的是 <code>[a b c]</code>。</li>\n<li><code>Split(s, sep)</code> 和 <code>SplitN(s, sep, -1)</code> 等价。</li>\n<li><code>SplitAfter(s, sep)</code> 和 <code>SplitAfterN(s, sep, -1)</code> 等价。</li>\n</ul>\n<h4 id=\"Split-和-SplitAfter-的区别\"><a href=\"#Split-和-SplitAfter-的区别\" class=\"headerlink\" title=\"Split 和 SplitAfter 的区别\"></a>Split 和 SplitAfter 的区别</h4><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fmt.Printf(<span class=\"string\">\"%q\\n\"</span>, strings.Split(<span class=\"string\">\"foo,bar,baz\"</span>, <span class=\"string\">\",\"</span>))  <span class=\"comment\">// [\"foo\" \"bar\" \"baz\"]</span></span><br><span class=\"line\">fmt.Printf(<span class=\"string\">\"%q\\n\"</span>, strings.SplitAfter(<span class=\"string\">\"foo,bar,baz\"</span>, <span class=\"string\">\",\"</span>)) <span class=\"comment\">// [\"foo,\" \"bar,\" \"baz\"]</span></span><br></pre></td></tr></table></figure>\n<p>从输出可以看出，<code>SplitAfter</code> 会保留 <code>sep</code>。</p>\n<h4 id=\"SplitN-和-SplitAfterN\"><a href=\"#SplitN-和-SplitAfterN\" class=\"headerlink\" title=\"SplitN 和 SplitAfterN\"></a>SplitN 和 SplitAfterN</h4><p>这两个函数通过最后一个参数 <code>n</code> 控制返回的结果中的 <code>slice</code> 中的元素个数：</p>\n<ul>\n<li>当 <code>n &lt; 0</code> 时，返回所有的子字符串</li>\n<li>当 <code>n == 0</code> 时，返回的结果是 <code>nil</code></li>\n<li>当 <code>n &gt; 0</code> 时，表示返回的 <code>slice</code> 中最多只有 <code>n</code> 个元素，其中，最后一个元素不会分割</li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fmt.Printf(<span class=\"string\">\"%q\\n\"</span>, strings.SplitN(<span class=\"string\">\"foo,bar,baz\"</span>, <span class=\"string\">\",\"</span>, <span class=\"number\">2</span>))                <span class=\"comment\">// [\"foo\" \"bar,baz\"]</span></span><br><span class=\"line\">fmt.Printf(<span class=\"string\">\"%q\\n\"</span>, strings.Split(<span class=\"string\">\"a,b,c\"</span>, <span class=\"string\">\",\"</span>))                          <span class=\"comment\">// [\"a\" \"b\" \"c\"]</span></span><br><span class=\"line\">fmt.Printf(<span class=\"string\">\"%q\\n\"</span>, strings.Split(<span class=\"string\">\"a man a plan a canal panama\"</span>, <span class=\"string\">\"a \"</span>))   <span class=\"comment\">// [\"\" \"man \" \"plan \" \"canal panama\"]</span></span><br><span class=\"line\">fmt.Printf(<span class=\"string\">\"%q\\n\"</span>, strings.Split(<span class=\"string\">\" xyz \"</span>, <span class=\"string\">\"\"</span>))                           <span class=\"comment\">// [\" \" \"x\" \"y\" \"z\" \" \"]</span></span><br><span class=\"line\">fmt.Printf(<span class=\"string\">\"%q\\n\"</span>, strings.Split(<span class=\"string\">\"\"</span>, <span class=\"string\">\"Bernardo O'Higgins\"</span>))              <span class=\"comment\">// [\"\"]</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"从字符串中读取内容\"><a href=\"#从字符串中读取内容\" class=\"headerlink\" title=\"从字符串中读取内容\"></a>从字符串中读取内容</h2><p>函数 <code>strings.NewReader(str)</code> 用于生成一个 <code>Reader</code> 并读取字符串中的内容，然后返回指向该 <code>Reader</code> 的指针，从其它类型读取<br>内容的函数还有：</p>\n<ul>\n<li><code>Read()</code> 从 []byte 中读取内容。</li>\n<li><code>ReadByte()</code> 和 <code>ReadRune()</code> 从字符串中读取下一个 byte 或者 rune。</li>\n</ul>\n","site":{"data":{"navigation":{"logo":{"text":"Golang Learn","type":"link","path":"index.html"},"main":[{"text":"Golang 基础","type":"label"},{"text":"Go 环境配置","type":"link","path":"basic/env_config.html"},{"text":"包","type":"link","path":"basic/package.html"},{"text":"基础数据类型","type":"link","path":"basic/basic_data.html"},{"text":"变量","type":"link","path":"basic/var.html"},{"text":"常量","type":"link","path":"basic/constant.html"},{"text":"控制语句","type":"link","path":"basic/flow.html"},{"text":"运算符","type":"link","path":"basic/operator.html"},{"text":"作用域","type":"link","path":"basic/scope.html"},{"text":"指针","type":"link","path":"basic/pointer.html"},{"text":"数组","type":"link","path":"basic/array.html"},{"text":"切片","type":"link","path":"basic/slice.html"},{"text":"字典","type":"link","path":"basic/map.html"},{"text":"函数","type":"link","path":"basic/function.html"},{"text":"结构体","type":"link","path":"basic/struct.html"},{"text":"接口","type":"link","path":"basic/interface.html"},{"text":"面向对象","type":"link","path":"basic/oop.html"},{"text":"错误","type":"link","path":"basic/error.html"},{"text":"序列化","type":"link","path":"basic/json.html"},{"text":"反射","type":"link","path":"basic/reflect.html"},{"text":"测试","type":"link","path":"basic/test.html"},{"text":"并发编程","type":"label"},{"text":"goroutine","type":"link","path":"concurrent/goroutine.html"},{"text":"channel","type":"link","path":"concurrent/channel.html"},{"text":"同步和锁","type":"link","path":"concurrent/sync_lock.html"},{"text":"内存分配","type":"label"},{"text":"内存分配","type":"link","path":"advance/mm.html"},{"text":"垃圾回收","type":"label"},{"text":"垃圾回收","type":"link","path":"advance/gc.html"},{"text":"标准库","type":"label"},{"text":"fmt","type":"link","path":"standards/io/fmt.html"},{"text":"io","type":"link","path":"standards/io/io.html"},{"text":"ioutil","type":"link","path":"standards/io/ioutil.html"},{"text":"bufio","type":"link","path":"standards/io/bufio.html"},{"text":"os","type":"link","path":"standards/os/os.html"},{"text":"filepath","type":"link","path":"standards/os/filepath.html"},{"text":"strings","type":"link","path":"standards/text/strings.html"},{"text":"strconv","type":"link","path":"standards/text/strconv.html"},{"text":"unicode","type":"link","path":"standards/text/unicode.html"},{"text":"log","type":"link","path":"standards/log.html"},{"text":"time","type":"link","path":"standards/time.html"},{"text":"http","type":"link","path":"standards/net/http.html"},{"text":"math","type":"link","path":"standards/data/math.html"},{"text":"sort","type":"link","path":"standards/data/sort.html"},{"text":"big","type":"link","path":"standards/data/big.html"},{"text":"container","type":"link","path":"standards/data/container.html"},{"text":"sql","type":"link","path":"standards/database/sql.html"},{"text":"THEME","type":"label"},{"text":"使用文档主题","type":"link","path":"theme/theme-usage.html"},{"text":"SUPPORT AND FEEDBACK","type":"label"},{"text":"Raise an Issue on Github","type":"link","path":"https://github.com/shipengqi/golang-learn/issues/new"}]}}},"excerpt":"","more":"<h1 id=\"strings\"><a href=\"#strings\" class=\"headerlink\" title=\"strings\"></a>strings</h1><p>字符串常见操作有：</p>\n<ul>\n<li>字符串长度；</li>\n<li>求子串；</li>\n<li>是否存在某个字符或子串；</li>\n<li>子串出现的次数（字符串匹配）；</li>\n<li>字符串分割（切分）为 <code>[]string</code>；</li>\n<li>字符串是否有某个前缀或后缀；</li>\n<li>字符或子串在字符串中首次出现的位置或最后一次出现的位置；</li>\n<li>通过某个字符串将 <code>[]string</code> 连接起来；</li>\n<li>字符串重复几次；</li>\n<li>字符串中子串替换；</li>\n<li>大小写转换；</li>\n<li><code>Trim</code> 操作；</li>\n<li>…</li>\n</ul>\n<h2 id=\"前缀和后缀\"><a href=\"#前缀和后缀\" class=\"headerlink\" title=\"前缀和后缀\"></a>前缀和后缀</h2><p><code>HasPrefix</code> 判断字符串 <code>s</code> 是否以 <code>prefix</code> 开头：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">strings.HasPrefix(s, prefix <span class=\"keyword\">string</span>) <span class=\"keyword\">bool</span></span><br></pre></td></tr></table></figure>\n<p><code>HasSuffix</code> 判断字符串 <code>s</code> 是否以 <code>suffix</code> 结尾：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">strings.HasSuffix(s, suffix <span class=\"keyword\">string</span>) <span class=\"keyword\">bool</span></span><br></pre></td></tr></table></figure>\n<p>示例：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">\"fmt\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"strings\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> str <span class=\"keyword\">string</span> = <span class=\"string\">\"This is an example of a string\"</span></span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"T/F? Does the string \\\"%s\\\" have prefix %s? \"</span>, str, <span class=\"string\">\"Th\"</span>)</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"%t\\n\"</span>, strings.HasPrefix(str, <span class=\"string\">\"Th\"</span>))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">T/F? Does the string &quot;This is an example of a string&quot; have prefix Th? true</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"判断是否包含字符串\"><a href=\"#判断是否包含字符串\" class=\"headerlink\" title=\"判断是否包含字符串\"></a>判断是否包含字符串</h2><p><code>Contains</code> 判断字符串 <code>s</code> 是否包含 <code>substr</code>：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">strings.Contains(s, substr <span class=\"keyword\">string</span>) <span class=\"keyword\">bool</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"获取某个子字串在字符串中的位置（索引）\"><a href=\"#获取某个子字串在字符串中的位置（索引）\" class=\"headerlink\" title=\"获取某个子字串在字符串中的位置（索引）\"></a>获取某个子字串在字符串中的位置（索引）</h2><p><code>Index</code> 返回字符串 <code>str</code> 在字符串 <code>s</code> 中的索引（<code>str</code> 的第一个字符的索引），<code>-1</code> 表示字符串 <code>s</code> 不包含字符串 <code>str</code>：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">strings.Index(s, str <span class=\"keyword\">string</span>) <span class=\"keyword\">int</span></span><br></pre></td></tr></table></figure>\n<p><code>LastIndex</code> 返回字符串 <code>str</code> 在字符串 <code>s</code> 中最后出现位置的索引（<code>str</code> 的第一个字符的索引），<code>-1</code> 表示字符串 <code>s</code> 不包含字符<br>串 <code>str</code>：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">strings.LastIndex(s, str <span class=\"keyword\">string</span>) <span class=\"keyword\">int</span></span><br></pre></td></tr></table></figure>\n<p>示例：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">\"fmt\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"strings\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> str <span class=\"keyword\">string</span> = <span class=\"string\">\"Hi, I'm Marc, Hi.\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"The position of \\\"Marc\\\" is: \"</span>)</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"%d\\n\"</span>, strings.Index(str, <span class=\"string\">\"Marc\"</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"The position of the first instance of \\\"Hi\\\" is: \"</span>)</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"%d\\n\"</span>, strings.Index(str, <span class=\"string\">\"Hi\"</span>))</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"The position of the last instance of \\\"Hi\\\" is: \"</span>)</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"%d\\n\"</span>, strings.LastIndex(str, <span class=\"string\">\"Hi\"</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"The position of \\\"Burger\\\" is: \"</span>)</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"%d\\n\"</span>, strings.Index(str, <span class=\"string\">\"Burger\"</span>))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">The position of &quot;Marc&quot; is: 8</span><br><span class=\"line\">The position of the first instance of &quot;Hi&quot; is: 0</span><br><span class=\"line\">The position of the last instance of &quot;Hi&quot; is: 14</span><br><span class=\"line\">The position of &quot;Burger&quot; is: -1</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"计算字符串出现次数\"><a href=\"#计算字符串出现次数\" class=\"headerlink\" title=\"计算字符串出现次数\"></a>计算字符串出现次数</h2><p><code>Count</code> 用于计算字符串 <code>str</code> 在字符串 <code>s</code> 中出现的非重叠次数：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">strings.Count(s, str <span class=\"keyword\">string</span>) <span class=\"keyword\">int</span></span><br></pre></td></tr></table></figure>\n<p>示例：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">\"fmt\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"strings\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> str <span class=\"keyword\">string</span> = <span class=\"string\">\"Hello, how is it going, Hugo?\"</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> manyG = <span class=\"string\">\"gggggggggg\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"Number of H's in %s is: \"</span>, str)</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"%d\\n\"</span>, strings.Count(str, <span class=\"string\">\"H\"</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"Number of double g's in %s is: \"</span>, manyG)</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"%d\\n\"</span>, strings.Count(manyG, <span class=\"string\">\"gg\"</span>))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Number of H&apos;s in Hello, how is it going, Hugo? is: 2</span><br><span class=\"line\">Number of double g’s in gggggggggg is: 5</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"字符串替换\"><a href=\"#字符串替换\" class=\"headerlink\" title=\"字符串替换\"></a>字符串替换</h2><p>尽量不使用正则，否则会影响性能。</p>\n<p><code>Replace</code> 用于将字符串 <code>str</code> 中的前 <code>n</code> 个字符串 <code>old</code> 替换为字符串 <code>new</code>，并返回一个新的字符串，如果 <code>n = -1</code> 则替换所<br>有字符串 <code>old</code> 为字符串 <code>new</code>：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">strings.Replace(str, old, <span class=\"built_in\">new</span>, n) <span class=\"keyword\">string</span></span><br></pre></td></tr></table></figure>\n<p>示例：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">\"fmt\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"strings\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    fmt.Println(strings.Replace(<span class=\"string\">\"oink oink oink\"</span>, <span class=\"string\">\"k\"</span>, <span class=\"string\">\"ky\"</span>, <span class=\"number\">2</span>))</span><br><span class=\"line\">    fmt.Println(strings.Replace(<span class=\"string\">\"oink oink oink\"</span>, <span class=\"string\">\"oink\"</span>, <span class=\"string\">\"moo\"</span>, <span class=\"number\">-1</span>))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">oinky oinky oink</span><br><span class=\"line\">moo moo moo</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"重复字符串\"><a href=\"#重复字符串\" class=\"headerlink\" title=\"重复字符串\"></a>重复字符串</h2><p><code>Repeat</code> 用于重复 <code>count</code> 次字符串 <code>s</code> 并返回一个新的字符串：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">strings.Repeat(s, count <span class=\"keyword\">int</span>) <span class=\"keyword\">string</span></span><br></pre></td></tr></table></figure>\n<p>示例：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">\"fmt\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"strings\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    fmt.Println(<span class=\"string\">\"ba\"</span> + strings.Repeat(<span class=\"string\">\"na\"</span>, <span class=\"number\">2</span>))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">banana</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"大小写转换\"><a href=\"#大小写转换\" class=\"headerlink\" title=\"大小写转换\"></a>大小写转换</h2><p><code>ToLower</code> 将字符串中的 Unicode 字符全部转换为小写字符：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">strings.ToLower(s) <span class=\"keyword\">string</span></span><br></pre></td></tr></table></figure>\n<p><code>ToUpper</code> 将字符串中的 Unicode 字符全部转换为大写字符：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">strings.ToUpper(s) <span class=\"keyword\">string</span></span><br></pre></td></tr></table></figure>\n<p>示例：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">\"fmt\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"strings\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> orig <span class=\"keyword\">string</span> = <span class=\"string\">\"Hey, how are you George?\"</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> lower <span class=\"keyword\">string</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> upper <span class=\"keyword\">string</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"The original string is: %s\\n\"</span>, orig)</span><br><span class=\"line\">\tlower = strings.ToLower(orig)</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"The lowercase string is: %s\\n\"</span>, lower)</span><br><span class=\"line\">\tupper = strings.ToUpper(orig)</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"The uppercase string is: %s\\n\"</span>, upper)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">The original string is: Hey, how are you George?</span><br><span class=\"line\">The lowercase string is: hey, how are you george?</span><br><span class=\"line\">The uppercase string is: HEY, HOW ARE YOU GEORGE?</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"修改字符串\"><a href=\"#修改字符串\" class=\"headerlink\" title=\"修改字符串\"></a>修改字符串</h2><p><code>Trim</code> 系列函数可以删除字符串首尾的连续多余字符，包括：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 删除字符串首尾的字符</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Trim</span><span class=\"params\">(s <span class=\"keyword\">string</span>, cutset <span class=\"keyword\">string</span>)</span> <span class=\"title\">string</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// 删除字符串首的字符</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">TrimLeft</span><span class=\"params\">(s <span class=\"keyword\">string</span>, cutset <span class=\"keyword\">string</span>)</span> <span class=\"title\">string</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// 删除字符串尾部的字符</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">TrimRight</span><span class=\"params\">(s <span class=\"keyword\">string</span>, cutset <span class=\"keyword\">string</span>)</span> <span class=\"title\">string</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// 删除字符串首尾的空格</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">TrimSpace</span><span class=\"params\">(s <span class=\"keyword\">string</span>)</span> <span class=\"title\">string</span></span></span><br></pre></td></tr></table></figure>\n<p>示例：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s := <span class=\"string\">\"cutjjjcut\"</span></span><br><span class=\"line\"><span class=\"comment\">// 将字符串 s 首尾的 `cut` 去除掉</span></span><br><span class=\"line\">newStr := strings.Trim(s, <span class=\"string\">\"cut\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">fmt.Println(newStr)</span><br></pre></td></tr></table></figure>\n<p>输出：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jjj</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"JOIN\"><a href=\"#JOIN\" class=\"headerlink\" title=\"JOIN\"></a>JOIN</h2><p><code>Join</code> 函数将字符串数组（或 <code>slice</code>）连接起来：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Join</span><span class=\"params\">(a []<span class=\"keyword\">string</span>, sep <span class=\"keyword\">string</span>)</span> <span class=\"title\">string</span></span></span><br></pre></td></tr></table></figure></p>\n<p>示例：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fmt.Println(strings.Join([]<span class=\"keyword\">string</span>&#123;<span class=\"string\">\"name=xxx\"</span>, <span class=\"string\">\"age=xx\"</span>&#125;, <span class=\"string\">\"&amp;\"</span>))</span><br></pre></td></tr></table></figure>\n<p>输出：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">name=xxx&amp;age=xx</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"分割字符串\"><a href=\"#分割字符串\" class=\"headerlink\" title=\"分割字符串\"></a>分割字符串</h2><h3 id=\"Fields\"><a href=\"#Fields\" class=\"headerlink\" title=\"Fields\"></a>Fields</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 用一个或多个连续的空格分隔字符串 s，返回子字符串的数组（slice）</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Fields</span><span class=\"params\">(s <span class=\"keyword\">string</span>)</span> []<span class=\"title\">string</span></span></span><br></pre></td></tr></table></figure>\n<p>示例：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fmt.Printf(<span class=\"string\">\"Fields are: %q\"</span>, strings.Fields(<span class=\"string\">\"  foo bar  baz   \"</span>)) <span class=\"comment\">// Fields are: [\"foo\" \"bar\" \"baz\"]</span></span><br></pre></td></tr></table></figure></p>\n<p><code>Fields</code> 使用一个或多个空格分隔，也就是说返回的字符串中不会包含空格字符串。</p>\n<blockquote>\n<p>如果字符串 s 只包含空格，则返回空列表 (<code>[]string</code> 的长度为 <code>0</code>）</p>\n</blockquote>\n<h3 id=\"Split-和-SplitAfter、-SplitN-和-SplitAfterN\"><a href=\"#Split-和-SplitAfter、-SplitN-和-SplitAfterN\" class=\"headerlink\" title=\"Split 和 SplitAfter、 SplitN 和 SplitAfterN\"></a>Split 和 SplitAfter、 SplitN 和 SplitAfterN</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Split</span><span class=\"params\">(s, sep <span class=\"keyword\">string</span>)</span> []<span class=\"title\">string</span></span> &#123; <span class=\"keyword\">return</span> genSplit(s, sep, <span class=\"number\">0</span>, <span class=\"number\">-1</span>) &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">SplitAfter</span><span class=\"params\">(s, sep <span class=\"keyword\">string</span>)</span> []<span class=\"title\">string</span></span> &#123; <span class=\"keyword\">return</span> genSplit(s, sep, <span class=\"built_in\">len</span>(sep), <span class=\"number\">-1</span>) &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">SplitN</span><span class=\"params\">(s, sep <span class=\"keyword\">string</span>, n <span class=\"keyword\">int</span>)</span> []<span class=\"title\">string</span></span> &#123; <span class=\"keyword\">return</span> genSplit(s, sep, <span class=\"number\">0</span>, n) &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">SplitAfterN</span><span class=\"params\">(s, sep <span class=\"keyword\">string</span>, n <span class=\"keyword\">int</span>)</span> []<span class=\"title\">string</span></span> &#123; <span class=\"keyword\">return</span> genSplit(s, sep, <span class=\"built_in\">len</span>(sep), n) &#125;</span><br></pre></td></tr></table></figure>\n<p>它们都调用了 <code>genSplit</code> 函数。这四个函数都是通过 <code>sep</code> 进行分割，返回 <code>[]string</code>。</p>\n<ul>\n<li>如果 <code>sep</code> 为空，相当于分成一个个的 UTF-8 字符，如 <code>Split(&quot;abc&quot;,&quot;&quot;)</code>，得到的是 <code>[a b c]</code>。</li>\n<li><code>Split(s, sep)</code> 和 <code>SplitN(s, sep, -1)</code> 等价。</li>\n<li><code>SplitAfter(s, sep)</code> 和 <code>SplitAfterN(s, sep, -1)</code> 等价。</li>\n</ul>\n<h4 id=\"Split-和-SplitAfter-的区别\"><a href=\"#Split-和-SplitAfter-的区别\" class=\"headerlink\" title=\"Split 和 SplitAfter 的区别\"></a>Split 和 SplitAfter 的区别</h4><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fmt.Printf(<span class=\"string\">\"%q\\n\"</span>, strings.Split(<span class=\"string\">\"foo,bar,baz\"</span>, <span class=\"string\">\",\"</span>))  <span class=\"comment\">// [\"foo\" \"bar\" \"baz\"]</span></span><br><span class=\"line\">fmt.Printf(<span class=\"string\">\"%q\\n\"</span>, strings.SplitAfter(<span class=\"string\">\"foo,bar,baz\"</span>, <span class=\"string\">\",\"</span>)) <span class=\"comment\">// [\"foo,\" \"bar,\" \"baz\"]</span></span><br></pre></td></tr></table></figure>\n<p>从输出可以看出，<code>SplitAfter</code> 会保留 <code>sep</code>。</p>\n<h4 id=\"SplitN-和-SplitAfterN\"><a href=\"#SplitN-和-SplitAfterN\" class=\"headerlink\" title=\"SplitN 和 SplitAfterN\"></a>SplitN 和 SplitAfterN</h4><p>这两个函数通过最后一个参数 <code>n</code> 控制返回的结果中的 <code>slice</code> 中的元素个数：</p>\n<ul>\n<li>当 <code>n &lt; 0</code> 时，返回所有的子字符串</li>\n<li>当 <code>n == 0</code> 时，返回的结果是 <code>nil</code></li>\n<li>当 <code>n &gt; 0</code> 时，表示返回的 <code>slice</code> 中最多只有 <code>n</code> 个元素，其中，最后一个元素不会分割</li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fmt.Printf(<span class=\"string\">\"%q\\n\"</span>, strings.SplitN(<span class=\"string\">\"foo,bar,baz\"</span>, <span class=\"string\">\",\"</span>, <span class=\"number\">2</span>))                <span class=\"comment\">// [\"foo\" \"bar,baz\"]</span></span><br><span class=\"line\">fmt.Printf(<span class=\"string\">\"%q\\n\"</span>, strings.Split(<span class=\"string\">\"a,b,c\"</span>, <span class=\"string\">\",\"</span>))                          <span class=\"comment\">// [\"a\" \"b\" \"c\"]</span></span><br><span class=\"line\">fmt.Printf(<span class=\"string\">\"%q\\n\"</span>, strings.Split(<span class=\"string\">\"a man a plan a canal panama\"</span>, <span class=\"string\">\"a \"</span>))   <span class=\"comment\">// [\"\" \"man \" \"plan \" \"canal panama\"]</span></span><br><span class=\"line\">fmt.Printf(<span class=\"string\">\"%q\\n\"</span>, strings.Split(<span class=\"string\">\" xyz \"</span>, <span class=\"string\">\"\"</span>))                           <span class=\"comment\">// [\" \" \"x\" \"y\" \"z\" \" \"]</span></span><br><span class=\"line\">fmt.Printf(<span class=\"string\">\"%q\\n\"</span>, strings.Split(<span class=\"string\">\"\"</span>, <span class=\"string\">\"Bernardo O'Higgins\"</span>))              <span class=\"comment\">// [\"\"]</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"从字符串中读取内容\"><a href=\"#从字符串中读取内容\" class=\"headerlink\" title=\"从字符串中读取内容\"></a>从字符串中读取内容</h2><p>函数 <code>strings.NewReader(str)</code> 用于生成一个 <code>Reader</code> 并读取字符串中的内容，然后返回指向该 <code>Reader</code> 的指针，从其它类型读取<br>内容的函数还有：</p>\n<ul>\n<li><code>Read()</code> 从 []byte 中读取内容。</li>\n<li><code>ReadByte()</code> 和 <code>ReadRune()</code> 从字符串中读取下一个 byte 或者 rune。</li>\n</ul>\n"},{"title":"math","_content":"\n# math\nmath 包实现的就是数学函数计算。\n\n## 三角函数\n\n正弦函数，反正弦函数，双曲正弦，反双曲正弦\n```\n- func Sin(x float64) float64\n- func Asin(x float64) float64\n- func Sinh(x float64) float64\n- func Asinh(x float64) float64\n```\n\n\n一次性返回 `sin`,`cos`\n\n- `func Sincos(x float64) (sin, cos float64)`\n\n余弦函数，反余弦函数，双曲余弦，反双曲余弦\n```\n- func Cos(x float64) float64\n- func Acos(x float64) float64\n- func Cosh(x float64) float64\n- func Acosh(x float64) float64\n```\n\n正切函数，反正切函数，双曲正切，反双曲正切\n```\n- func Tan(x float64) float64\n- func Atan(x float64) float64 和 func Atan2(y, x float64) float64\n- func Tanh(x float64) float64\n- func Atanh(x float64) float64\n```\n\n## 幂次函数\n```\n- func Cbrt(x float64) float64 // 立方根函数\n- func Pow(x, y float64) float64  // x 的幂函数\n- func Pow10(e int) float64 // 10 根的幂函数\n- func Sqrt(x float64) float64 // 平方根\n- func Log(x float64) float64 // 对数函数\n- func Log10(x float64) float64 // 10 为底的对数函数\n- func Log2(x float64) float64  // 2 为底的对数函数\n- func Log1p(x float64) float64 // log(1 + x)\n- func Logb(x float64) float64 // 相当于 log2(x) 的绝对值\n- func Ilogb(x float64) int // 相当于 log2(x) 的绝对值的整数部分\n- func Exp(x float64) float64 // 指数函数\n- func Exp2(x float64) float64 // 2 为底的指数函数\n- func Expm1(x float64) float64 // Exp(x) - 1\n```\n\n\n## 特殊函数\n```\n- func Inf(sign int) float64  // 正无穷\n- func IsInf(f float64, sign int) bool // 是否正无穷\n- func NaN() float64 // 无穷值\n- func IsNaN(f float64) (is bool) // 是否是无穷值\n- func Hypot(p, q float64) float64 // 计算直角三角形的斜边长\n```\n\n\n## 类型转化函数\n```\n- func Float32bits(f float32) uint32  // float32 和 unit32 的转换\n- func Float32frombits(b uint32) float32 // uint32 和 float32 的转换\n- func Float64bits(f float64) uint64 // float64 和 uint64 的转换\n- func Float64frombits(b uint64) float64 // uint64 和 float64 的转换\n```\n\n\n## 其他函数\n```\n- func Abs(x float64) float64 // 绝对值函数\n- func Ceil(x float64) float64  // 向上取整\n- func Floor(x float64) float64 // 向下取整\n- func Mod(x, y float64) float64 // 取模\n- func Modf(f float64) (int float64, frac float64) // 分解 f，以得到 f 的整数和小数部分\n- func Frexp(f float64) (frac float64, exp int) // 分解 f，得到 f 的位数和指数\n- func Max(x, y float64) float64  // 取大值\n- func Min(x, y float64) float64  // 取小值\n- func Dim(x, y float64) float64 // 复数的维数\n- func J0(x float64) float64  // 0 阶贝塞尔函数\n- func J1(x float64) float64  // 1 阶贝塞尔函数\n- func Jn(n int, x float64) float64 // n 阶贝塞尔函数\n- func Y0(x float64) float64  // 第二类贝塞尔函数 0 阶\n- func Y1(x float64) float64  // 第二类贝塞尔函数 1 阶\n- func Yn(n int, x float64) float64 // 第二类贝塞尔函数 n 阶\n- func Erf(x float64) float64 // 误差函数\n- func Erfc(x float64) float64 // 余补误差函数\n- func Copysign(x, y float64) float64 // 以 y 的符号返回 x 值\n- func Signbit(x float64) bool // 获取 x 的符号\n- func Gamma(x float64) float64 // 伽玛函数\n- func Lgamma(x float64) (lgamma float64, sign int) // 伽玛函数的自然对数\n- func Ldexp(frac float64, exp int) float64 // value 乘以 2 的 exp 次幂\n- func Nextafter(x, y float64) (r float64) // 返回参数 x 在参数 y 方向上可以表示的最接近的数值，若 x 等于 y，则返回 x\n- func Nextafter32(x, y float32) (r float32) // 返回参数 x 在参数 y 方向上可以表示的最接近的数值，若 x 等于 y，则返回 x\n- func Remainder(x, y float64) float64 // 取余运算\n- func Trunc(x float64) float64 // 截取函数\n```\n","source":"standards/data/math.md","raw":"---\ntitle: math\n---\n\n# math\nmath 包实现的就是数学函数计算。\n\n## 三角函数\n\n正弦函数，反正弦函数，双曲正弦，反双曲正弦\n```\n- func Sin(x float64) float64\n- func Asin(x float64) float64\n- func Sinh(x float64) float64\n- func Asinh(x float64) float64\n```\n\n\n一次性返回 `sin`,`cos`\n\n- `func Sincos(x float64) (sin, cos float64)`\n\n余弦函数，反余弦函数，双曲余弦，反双曲余弦\n```\n- func Cos(x float64) float64\n- func Acos(x float64) float64\n- func Cosh(x float64) float64\n- func Acosh(x float64) float64\n```\n\n正切函数，反正切函数，双曲正切，反双曲正切\n```\n- func Tan(x float64) float64\n- func Atan(x float64) float64 和 func Atan2(y, x float64) float64\n- func Tanh(x float64) float64\n- func Atanh(x float64) float64\n```\n\n## 幂次函数\n```\n- func Cbrt(x float64) float64 // 立方根函数\n- func Pow(x, y float64) float64  // x 的幂函数\n- func Pow10(e int) float64 // 10 根的幂函数\n- func Sqrt(x float64) float64 // 平方根\n- func Log(x float64) float64 // 对数函数\n- func Log10(x float64) float64 // 10 为底的对数函数\n- func Log2(x float64) float64  // 2 为底的对数函数\n- func Log1p(x float64) float64 // log(1 + x)\n- func Logb(x float64) float64 // 相当于 log2(x) 的绝对值\n- func Ilogb(x float64) int // 相当于 log2(x) 的绝对值的整数部分\n- func Exp(x float64) float64 // 指数函数\n- func Exp2(x float64) float64 // 2 为底的指数函数\n- func Expm1(x float64) float64 // Exp(x) - 1\n```\n\n\n## 特殊函数\n```\n- func Inf(sign int) float64  // 正无穷\n- func IsInf(f float64, sign int) bool // 是否正无穷\n- func NaN() float64 // 无穷值\n- func IsNaN(f float64) (is bool) // 是否是无穷值\n- func Hypot(p, q float64) float64 // 计算直角三角形的斜边长\n```\n\n\n## 类型转化函数\n```\n- func Float32bits(f float32) uint32  // float32 和 unit32 的转换\n- func Float32frombits(b uint32) float32 // uint32 和 float32 的转换\n- func Float64bits(f float64) uint64 // float64 和 uint64 的转换\n- func Float64frombits(b uint64) float64 // uint64 和 float64 的转换\n```\n\n\n## 其他函数\n```\n- func Abs(x float64) float64 // 绝对值函数\n- func Ceil(x float64) float64  // 向上取整\n- func Floor(x float64) float64 // 向下取整\n- func Mod(x, y float64) float64 // 取模\n- func Modf(f float64) (int float64, frac float64) // 分解 f，以得到 f 的整数和小数部分\n- func Frexp(f float64) (frac float64, exp int) // 分解 f，得到 f 的位数和指数\n- func Max(x, y float64) float64  // 取大值\n- func Min(x, y float64) float64  // 取小值\n- func Dim(x, y float64) float64 // 复数的维数\n- func J0(x float64) float64  // 0 阶贝塞尔函数\n- func J1(x float64) float64  // 1 阶贝塞尔函数\n- func Jn(n int, x float64) float64 // n 阶贝塞尔函数\n- func Y0(x float64) float64  // 第二类贝塞尔函数 0 阶\n- func Y1(x float64) float64  // 第二类贝塞尔函数 1 阶\n- func Yn(n int, x float64) float64 // 第二类贝塞尔函数 n 阶\n- func Erf(x float64) float64 // 误差函数\n- func Erfc(x float64) float64 // 余补误差函数\n- func Copysign(x, y float64) float64 // 以 y 的符号返回 x 值\n- func Signbit(x float64) bool // 获取 x 的符号\n- func Gamma(x float64) float64 // 伽玛函数\n- func Lgamma(x float64) (lgamma float64, sign int) // 伽玛函数的自然对数\n- func Ldexp(frac float64, exp int) float64 // value 乘以 2 的 exp 次幂\n- func Nextafter(x, y float64) (r float64) // 返回参数 x 在参数 y 方向上可以表示的最接近的数值，若 x 等于 y，则返回 x\n- func Nextafter32(x, y float32) (r float32) // 返回参数 x 在参数 y 方向上可以表示的最接近的数值，若 x 等于 y，则返回 x\n- func Remainder(x, y float64) float64 // 取余运算\n- func Trunc(x float64) float64 // 截取函数\n```\n","date":"2019-09-01T00:18:20.668Z","updated":"2019-09-01T00:18:20.668Z","path":"standards/data/math.html","comments":1,"layout":"page","_id":"ck1xm14lk0019fcw2chaaajr8","content":"<h1 id=\"math\"><a href=\"#math\" class=\"headerlink\" title=\"math\"></a>math</h1><p>math 包实现的就是数学函数计算。</p>\n<h2 id=\"三角函数\"><a href=\"#三角函数\" class=\"headerlink\" title=\"三角函数\"></a>三角函数</h2><p>正弦函数，反正弦函数，双曲正弦，反双曲正弦<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- func Sin(x float64) float64</span><br><span class=\"line\">- func Asin(x float64) float64</span><br><span class=\"line\">- func Sinh(x float64) float64</span><br><span class=\"line\">- func Asinh(x float64) float64</span><br></pre></td></tr></table></figure></p>\n<p>一次性返回 <code>sin</code>,<code>cos</code></p>\n<ul>\n<li><code>func Sincos(x float64) (sin, cos float64)</code></li>\n</ul>\n<p>余弦函数，反余弦函数，双曲余弦，反双曲余弦<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- func Cos(x float64) float64</span><br><span class=\"line\">- func Acos(x float64) float64</span><br><span class=\"line\">- func Cosh(x float64) float64</span><br><span class=\"line\">- func Acosh(x float64) float64</span><br></pre></td></tr></table></figure></p>\n<p>正切函数，反正切函数，双曲正切，反双曲正切<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- func Tan(x float64) float64</span><br><span class=\"line\">- func Atan(x float64) float64 和 func Atan2(y, x float64) float64</span><br><span class=\"line\">- func Tanh(x float64) float64</span><br><span class=\"line\">- func Atanh(x float64) float64</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"幂次函数\"><a href=\"#幂次函数\" class=\"headerlink\" title=\"幂次函数\"></a>幂次函数</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- func Cbrt(x float64) float64 // 立方根函数</span><br><span class=\"line\">- func Pow(x, y float64) float64  // x 的幂函数</span><br><span class=\"line\">- func Pow10(e int) float64 // 10 根的幂函数</span><br><span class=\"line\">- func Sqrt(x float64) float64 // 平方根</span><br><span class=\"line\">- func Log(x float64) float64 // 对数函数</span><br><span class=\"line\">- func Log10(x float64) float64 // 10 为底的对数函数</span><br><span class=\"line\">- func Log2(x float64) float64  // 2 为底的对数函数</span><br><span class=\"line\">- func Log1p(x float64) float64 // log(1 + x)</span><br><span class=\"line\">- func Logb(x float64) float64 // 相当于 log2(x) 的绝对值</span><br><span class=\"line\">- func Ilogb(x float64) int // 相当于 log2(x) 的绝对值的整数部分</span><br><span class=\"line\">- func Exp(x float64) float64 // 指数函数</span><br><span class=\"line\">- func Exp2(x float64) float64 // 2 为底的指数函数</span><br><span class=\"line\">- func Expm1(x float64) float64 // Exp(x) - 1</span><br></pre></td></tr></table></figure>\n<h2 id=\"特殊函数\"><a href=\"#特殊函数\" class=\"headerlink\" title=\"特殊函数\"></a>特殊函数</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- func Inf(sign int) float64  // 正无穷</span><br><span class=\"line\">- func IsInf(f float64, sign int) bool // 是否正无穷</span><br><span class=\"line\">- func NaN() float64 // 无穷值</span><br><span class=\"line\">- func IsNaN(f float64) (is bool) // 是否是无穷值</span><br><span class=\"line\">- func Hypot(p, q float64) float64 // 计算直角三角形的斜边长</span><br></pre></td></tr></table></figure>\n<h2 id=\"类型转化函数\"><a href=\"#类型转化函数\" class=\"headerlink\" title=\"类型转化函数\"></a>类型转化函数</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- func Float32bits(f float32) uint32  // float32 和 unit32 的转换</span><br><span class=\"line\">- func Float32frombits(b uint32) float32 // uint32 和 float32 的转换</span><br><span class=\"line\">- func Float64bits(f float64) uint64 // float64 和 uint64 的转换</span><br><span class=\"line\">- func Float64frombits(b uint64) float64 // uint64 和 float64 的转换</span><br></pre></td></tr></table></figure>\n<h2 id=\"其他函数\"><a href=\"#其他函数\" class=\"headerlink\" title=\"其他函数\"></a>其他函数</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- func Abs(x float64) float64 // 绝对值函数</span><br><span class=\"line\">- func Ceil(x float64) float64  // 向上取整</span><br><span class=\"line\">- func Floor(x float64) float64 // 向下取整</span><br><span class=\"line\">- func Mod(x, y float64) float64 // 取模</span><br><span class=\"line\">- func Modf(f float64) (int float64, frac float64) // 分解 f，以得到 f 的整数和小数部分</span><br><span class=\"line\">- func Frexp(f float64) (frac float64, exp int) // 分解 f，得到 f 的位数和指数</span><br><span class=\"line\">- func Max(x, y float64) float64  // 取大值</span><br><span class=\"line\">- func Min(x, y float64) float64  // 取小值</span><br><span class=\"line\">- func Dim(x, y float64) float64 // 复数的维数</span><br><span class=\"line\">- func J0(x float64) float64  // 0 阶贝塞尔函数</span><br><span class=\"line\">- func J1(x float64) float64  // 1 阶贝塞尔函数</span><br><span class=\"line\">- func Jn(n int, x float64) float64 // n 阶贝塞尔函数</span><br><span class=\"line\">- func Y0(x float64) float64  // 第二类贝塞尔函数 0 阶</span><br><span class=\"line\">- func Y1(x float64) float64  // 第二类贝塞尔函数 1 阶</span><br><span class=\"line\">- func Yn(n int, x float64) float64 // 第二类贝塞尔函数 n 阶</span><br><span class=\"line\">- func Erf(x float64) float64 // 误差函数</span><br><span class=\"line\">- func Erfc(x float64) float64 // 余补误差函数</span><br><span class=\"line\">- func Copysign(x, y float64) float64 // 以 y 的符号返回 x 值</span><br><span class=\"line\">- func Signbit(x float64) bool // 获取 x 的符号</span><br><span class=\"line\">- func Gamma(x float64) float64 // 伽玛函数</span><br><span class=\"line\">- func Lgamma(x float64) (lgamma float64, sign int) // 伽玛函数的自然对数</span><br><span class=\"line\">- func Ldexp(frac float64, exp int) float64 // value 乘以 2 的 exp 次幂</span><br><span class=\"line\">- func Nextafter(x, y float64) (r float64) // 返回参数 x 在参数 y 方向上可以表示的最接近的数值，若 x 等于 y，则返回 x</span><br><span class=\"line\">- func Nextafter32(x, y float32) (r float32) // 返回参数 x 在参数 y 方向上可以表示的最接近的数值，若 x 等于 y，则返回 x</span><br><span class=\"line\">- func Remainder(x, y float64) float64 // 取余运算</span><br><span class=\"line\">- func Trunc(x float64) float64 // 截取函数</span><br></pre></td></tr></table></figure>\n","site":{"data":{"navigation":{"logo":{"text":"Golang Learn","type":"link","path":"index.html"},"main":[{"text":"Golang 基础","type":"label"},{"text":"Go 环境配置","type":"link","path":"basic/env_config.html"},{"text":"包","type":"link","path":"basic/package.html"},{"text":"基础数据类型","type":"link","path":"basic/basic_data.html"},{"text":"变量","type":"link","path":"basic/var.html"},{"text":"常量","type":"link","path":"basic/constant.html"},{"text":"控制语句","type":"link","path":"basic/flow.html"},{"text":"运算符","type":"link","path":"basic/operator.html"},{"text":"作用域","type":"link","path":"basic/scope.html"},{"text":"指针","type":"link","path":"basic/pointer.html"},{"text":"数组","type":"link","path":"basic/array.html"},{"text":"切片","type":"link","path":"basic/slice.html"},{"text":"字典","type":"link","path":"basic/map.html"},{"text":"函数","type":"link","path":"basic/function.html"},{"text":"结构体","type":"link","path":"basic/struct.html"},{"text":"接口","type":"link","path":"basic/interface.html"},{"text":"面向对象","type":"link","path":"basic/oop.html"},{"text":"错误","type":"link","path":"basic/error.html"},{"text":"序列化","type":"link","path":"basic/json.html"},{"text":"反射","type":"link","path":"basic/reflect.html"},{"text":"测试","type":"link","path":"basic/test.html"},{"text":"并发编程","type":"label"},{"text":"goroutine","type":"link","path":"concurrent/goroutine.html"},{"text":"channel","type":"link","path":"concurrent/channel.html"},{"text":"同步和锁","type":"link","path":"concurrent/sync_lock.html"},{"text":"内存分配","type":"label"},{"text":"内存分配","type":"link","path":"advance/mm.html"},{"text":"垃圾回收","type":"label"},{"text":"垃圾回收","type":"link","path":"advance/gc.html"},{"text":"标准库","type":"label"},{"text":"fmt","type":"link","path":"standards/io/fmt.html"},{"text":"io","type":"link","path":"standards/io/io.html"},{"text":"ioutil","type":"link","path":"standards/io/ioutil.html"},{"text":"bufio","type":"link","path":"standards/io/bufio.html"},{"text":"os","type":"link","path":"standards/os/os.html"},{"text":"filepath","type":"link","path":"standards/os/filepath.html"},{"text":"strings","type":"link","path":"standards/text/strings.html"},{"text":"strconv","type":"link","path":"standards/text/strconv.html"},{"text":"unicode","type":"link","path":"standards/text/unicode.html"},{"text":"log","type":"link","path":"standards/log.html"},{"text":"time","type":"link","path":"standards/time.html"},{"text":"http","type":"link","path":"standards/net/http.html"},{"text":"math","type":"link","path":"standards/data/math.html"},{"text":"sort","type":"link","path":"standards/data/sort.html"},{"text":"big","type":"link","path":"standards/data/big.html"},{"text":"container","type":"link","path":"standards/data/container.html"},{"text":"sql","type":"link","path":"standards/database/sql.html"},{"text":"THEME","type":"label"},{"text":"使用文档主题","type":"link","path":"theme/theme-usage.html"},{"text":"SUPPORT AND FEEDBACK","type":"label"},{"text":"Raise an Issue on Github","type":"link","path":"https://github.com/shipengqi/golang-learn/issues/new"}]}}},"excerpt":"","more":"<h1 id=\"math\"><a href=\"#math\" class=\"headerlink\" title=\"math\"></a>math</h1><p>math 包实现的就是数学函数计算。</p>\n<h2 id=\"三角函数\"><a href=\"#三角函数\" class=\"headerlink\" title=\"三角函数\"></a>三角函数</h2><p>正弦函数，反正弦函数，双曲正弦，反双曲正弦<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- func Sin(x float64) float64</span><br><span class=\"line\">- func Asin(x float64) float64</span><br><span class=\"line\">- func Sinh(x float64) float64</span><br><span class=\"line\">- func Asinh(x float64) float64</span><br></pre></td></tr></table></figure></p>\n<p>一次性返回 <code>sin</code>,<code>cos</code></p>\n<ul>\n<li><code>func Sincos(x float64) (sin, cos float64)</code></li>\n</ul>\n<p>余弦函数，反余弦函数，双曲余弦，反双曲余弦<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- func Cos(x float64) float64</span><br><span class=\"line\">- func Acos(x float64) float64</span><br><span class=\"line\">- func Cosh(x float64) float64</span><br><span class=\"line\">- func Acosh(x float64) float64</span><br></pre></td></tr></table></figure></p>\n<p>正切函数，反正切函数，双曲正切，反双曲正切<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- func Tan(x float64) float64</span><br><span class=\"line\">- func Atan(x float64) float64 和 func Atan2(y, x float64) float64</span><br><span class=\"line\">- func Tanh(x float64) float64</span><br><span class=\"line\">- func Atanh(x float64) float64</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"幂次函数\"><a href=\"#幂次函数\" class=\"headerlink\" title=\"幂次函数\"></a>幂次函数</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- func Cbrt(x float64) float64 // 立方根函数</span><br><span class=\"line\">- func Pow(x, y float64) float64  // x 的幂函数</span><br><span class=\"line\">- func Pow10(e int) float64 // 10 根的幂函数</span><br><span class=\"line\">- func Sqrt(x float64) float64 // 平方根</span><br><span class=\"line\">- func Log(x float64) float64 // 对数函数</span><br><span class=\"line\">- func Log10(x float64) float64 // 10 为底的对数函数</span><br><span class=\"line\">- func Log2(x float64) float64  // 2 为底的对数函数</span><br><span class=\"line\">- func Log1p(x float64) float64 // log(1 + x)</span><br><span class=\"line\">- func Logb(x float64) float64 // 相当于 log2(x) 的绝对值</span><br><span class=\"line\">- func Ilogb(x float64) int // 相当于 log2(x) 的绝对值的整数部分</span><br><span class=\"line\">- func Exp(x float64) float64 // 指数函数</span><br><span class=\"line\">- func Exp2(x float64) float64 // 2 为底的指数函数</span><br><span class=\"line\">- func Expm1(x float64) float64 // Exp(x) - 1</span><br></pre></td></tr></table></figure>\n<h2 id=\"特殊函数\"><a href=\"#特殊函数\" class=\"headerlink\" title=\"特殊函数\"></a>特殊函数</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- func Inf(sign int) float64  // 正无穷</span><br><span class=\"line\">- func IsInf(f float64, sign int) bool // 是否正无穷</span><br><span class=\"line\">- func NaN() float64 // 无穷值</span><br><span class=\"line\">- func IsNaN(f float64) (is bool) // 是否是无穷值</span><br><span class=\"line\">- func Hypot(p, q float64) float64 // 计算直角三角形的斜边长</span><br></pre></td></tr></table></figure>\n<h2 id=\"类型转化函数\"><a href=\"#类型转化函数\" class=\"headerlink\" title=\"类型转化函数\"></a>类型转化函数</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- func Float32bits(f float32) uint32  // float32 和 unit32 的转换</span><br><span class=\"line\">- func Float32frombits(b uint32) float32 // uint32 和 float32 的转换</span><br><span class=\"line\">- func Float64bits(f float64) uint64 // float64 和 uint64 的转换</span><br><span class=\"line\">- func Float64frombits(b uint64) float64 // uint64 和 float64 的转换</span><br></pre></td></tr></table></figure>\n<h2 id=\"其他函数\"><a href=\"#其他函数\" class=\"headerlink\" title=\"其他函数\"></a>其他函数</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- func Abs(x float64) float64 // 绝对值函数</span><br><span class=\"line\">- func Ceil(x float64) float64  // 向上取整</span><br><span class=\"line\">- func Floor(x float64) float64 // 向下取整</span><br><span class=\"line\">- func Mod(x, y float64) float64 // 取模</span><br><span class=\"line\">- func Modf(f float64) (int float64, frac float64) // 分解 f，以得到 f 的整数和小数部分</span><br><span class=\"line\">- func Frexp(f float64) (frac float64, exp int) // 分解 f，得到 f 的位数和指数</span><br><span class=\"line\">- func Max(x, y float64) float64  // 取大值</span><br><span class=\"line\">- func Min(x, y float64) float64  // 取小值</span><br><span class=\"line\">- func Dim(x, y float64) float64 // 复数的维数</span><br><span class=\"line\">- func J0(x float64) float64  // 0 阶贝塞尔函数</span><br><span class=\"line\">- func J1(x float64) float64  // 1 阶贝塞尔函数</span><br><span class=\"line\">- func Jn(n int, x float64) float64 // n 阶贝塞尔函数</span><br><span class=\"line\">- func Y0(x float64) float64  // 第二类贝塞尔函数 0 阶</span><br><span class=\"line\">- func Y1(x float64) float64  // 第二类贝塞尔函数 1 阶</span><br><span class=\"line\">- func Yn(n int, x float64) float64 // 第二类贝塞尔函数 n 阶</span><br><span class=\"line\">- func Erf(x float64) float64 // 误差函数</span><br><span class=\"line\">- func Erfc(x float64) float64 // 余补误差函数</span><br><span class=\"line\">- func Copysign(x, y float64) float64 // 以 y 的符号返回 x 值</span><br><span class=\"line\">- func Signbit(x float64) bool // 获取 x 的符号</span><br><span class=\"line\">- func Gamma(x float64) float64 // 伽玛函数</span><br><span class=\"line\">- func Lgamma(x float64) (lgamma float64, sign int) // 伽玛函数的自然对数</span><br><span class=\"line\">- func Ldexp(frac float64, exp int) float64 // value 乘以 2 的 exp 次幂</span><br><span class=\"line\">- func Nextafter(x, y float64) (r float64) // 返回参数 x 在参数 y 方向上可以表示的最接近的数值，若 x 等于 y，则返回 x</span><br><span class=\"line\">- func Nextafter32(x, y float32) (r float32) // 返回参数 x 在参数 y 方向上可以表示的最接近的数值，若 x 等于 y，则返回 x</span><br><span class=\"line\">- func Remainder(x, y float64) float64 // 取余运算</span><br><span class=\"line\">- func Trunc(x float64) float64 // 截取函数</span><br></pre></td></tr></table></figure>\n"},{"title":"goroutine","_content":"\n# goroutine\n## 并发和并行\n### 并发\n一个 cpu 上能同时执行多项任务，在很短时间内，cpu 来回切换任务执行(在某段很短时间内执行程序 a，然后又迅速得切换到程序 b 去执行)，\n有时间上的重叠（宏观上是同时的，微观仍是顺序执行）,这样看起来多个任务像是同时执行，这就是**并发**。\n\n### 并行\n当系统有多个 CPU 时,每个 CPU 同一时刻都运行任务，互不抢占自己所在的 CPU 资源，同时进行，称为**并行**。并行是并发设计的\n理想模式。\n\n### 进程\n\ncpu 在切换程序的时候，如果不保存上一个程序的状态（也就是我们常说的 `context` --上下文），直接切换下一个程序，就会丢失上一个\n程序的一系列状态，于是引入了进程这个概念，用以划分好程序运行时所需要的资源。因此进程就是一个程序运行时候的所需要的基本资源单\n位（也可以说是程序运行的一个实体）。\n\n### 线程\ncpu 切换多个进程的时候，会花费不少的时间，因为切换进程需要切换到内核态，而每次调度需要内核态都需要读取用户态的数据，进程\n一旦多起来，cpu 调度会消耗一大堆资源，因此引入了线程的概念，线程本身几乎不占有资源，他们共享进程里的资源，内核调度起来不\n会那么像进程切换那么耗费资源。\n\n### 协程\n多线程和多进程是并行的基本条件，但是单线程可以利用**协程**做到并发。协程拥有自己的寄存器上下文和栈。协程在线程上通过主动\n切换来实现并发，减少了阻塞时间，还避免了线程切换的开销。但协程运行的并发本质上还是串行的。线程和进程的操作是由程序触发系统\n接口，最后的执行者是系统；协程的操作执行者则是用户自身程序。\n\n## goroutine\nGo 语言在语言层面上支持了并发，简单将 `goroutine` 归为协程并不合适。Go runtime 会创建多个线程来执行并发任务，而且任务\n可以跨线程调度。所以 goroutine 更像是多线程和协程的结合体。\n\n`goroutine` 可以简单理解为协程，开销较低 (大概是 `4~5KB` )，当然会根据相应的数据伸缩。也正因为如此，可同时运行成千\n上万个并发任务。`goroutine` 比 `thread` 更易用、更高效、更轻便。我们程序运行的 **`main` 函数在一个单独的 `goroutine` 中运行，\n叫做 `主 goroutine`**。在代码中可以使用 **`go` 关键字创建 `goroutine`**。\n\n```go\ngo f()\n```\n\n**`main` 函数返回时，所有 `goroutine` 都会被打断，程序退出**。除了从 `main` 函数退出或者直接终止程序之外，没有其它\n的编程方法能够让一个 `goroutine` 来打断另一个的执行，但是之后可以看到一种方式来实现这个目的，通过 `goroutine` 之间\n的通信来让一个 `goroutine` 请求其它的 `goroutine`，使被请求 `goroutine` 自行结束执行。\n\n### 什么是主 goroutine，它与我们启用的其他 goroutine 有什么不同\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tfor i := 0; i < 10; i++ {\n\t\tgo func() {\n\t\t\tfmt.Println(i)\n\t\t}()\n\t}\n}\n```\n上面的代码会打印出什么内容？\n\n回答是：不会有任何内容被打印出来。\n\nGo 语言不但有着独特的并发编程模型，以及用户级线程 `goroutine`，还拥有强大的用于调度 `goroutine`、对接系统级线程的\n**调度器**。\n\n调度器的主要有 3 个重要部分，分别是 M、G、P。\n- G（goroutine 的缩写）， 协程的实体，包括了调用栈，重要的调度信息，例如 channel 等。\n- P（processor 的缩写），是衔接 M 和 G 的调度上下文，一个 P 可以承载若干个 G，且能够使这些 G 适时地与 M 进行\n对接，并得到真正运行的中介。P 的数量可以通过 `runtime.GOMAXPROCS()` 来设置，P 的数量决定了系统内最大可并行的 G 的数量，\n即有多少个 `goroutine` 可以同时运行。\n- M（machine 的缩写），代表的是系统级线程，由操作系统管理。\n\n与一个进程总会有一个主线程类似，每一个独立的 Go 程序在运行时也总会有一个主 `goroutine`。这个主 `goroutine` 会在 Go 程\n序的运行准备工作完成后被自动地启用，并不需要我们做任何手动的操作。\n\n**每条 `go` 语句一般都会携带一个函数调用，这个被调用的函数常常被称为 `go` 函数。而主 `goroutine` 的 `go` 函数就是\n那个作为程序入口的 `main` 函数**。\n\n**`go` 函数真正被执行的时间总会与其所属的 `go` 语句被执行的时间不同**。\n\n当程序执行到一条 `go` 语句的时候，**`go` 关键字并不是执行并发操作，而是创建一个并发任务单元**。Go 语言的运行时系统，会先试图从某个\n存放空闲的 G 的队列中获取一个 G（也就是 `goroutine`），它只有在找不到空闲 G 的情况下才会去创建一个新的 G。已存在\n的 goroutine 总是会被优先复用。\n\n在拿到了一个空闲的 G 之后，Go 语言运行时系统会用这个 G 去包装当前的那个 `go` 函数（或者说该函数中的那些代码），然后再把这\n个 G 追加到某个存放可运行的 G 的队列中。这类队列中的 G 总是会按照先入先出的顺序，很快地由运行时系统内部的调度器安排运行。\n虽然这会很快，但是由于上面所说的那些准备工作还是不可避免的，所以耗时还是存在的。\n\n因此，**`go` 函数的执行时间总是会明显滞后于它所属的 `go` 语句的执行时间**。当然了，这里所说的“明显滞后”是对于计算机\n的 CPU 时钟和 Go 程序来说的。我们在大多数时候都不会有明显的感觉。\n\n请记住，**只要 `go` 语句本身执行完毕，Go 程序完全不会等待 `go` 函数的执行，它会立刻去执行后边的语句**。这就是所谓\n的**异步并发**地执行。\n\n上面的代码中那 10 个包装了 `go` 函数的 `goroutine` 往往还没有获得运行的机会。但是如果有机会运行，打印的结果是什么，\n全是 `10`？\n\n当 `for` 语句的最后一个迭代运行的时候，其中的那条 `go` 语句即是最后一条语句。所以，在执行完这条 `go` 语句之后，\n主 `goroutine` 中的代码也就执行完了，Go 程序会立即结束运行。那么，如果这样的话，还会有任何内容被打印出来吗？\n\nGo 语言并不会去保证这些 `goroutine` 会以怎样的顺序运行。由于主 `goroutine` 会与我们手动启用的其他 `goroutine` 一起接受\n调度，又因为调度器很可能会在 `goroutine` 中的代码只执行了一部分的时候暂停，以期所有的 goroutine 有更公平的运行机会。\n\n所以哪个 `goroutine` 先执行完、哪个 `goroutine` 后执行完往往是不可预知的，除非我们使用了某种 Go 语言提供的方式进行了人为\n干预。\n\n### 怎样才能让主 goroutine 等待其他 goroutine\n刚才说过，一旦主 `goroutine` 中的代码执行完毕，当前的 Go 程序就会结束运行，无论其他的 `goroutine` 是否已经在运行了。\n那么，怎样才能做到等其他的 `goroutine` 运行完毕之后，再让主 `goroutine` 结束运行呢？\n\n1. **使用 `time` 包**，可以简单粗暴的 `time.Sleep(time.Millisecond * 500)` 让主 `goroutine` “小睡”一会儿。\n在这里传入了“500 毫秒”\n\n问题是我们让主 `goroutine` “睡眠”多长时间才是合适的呢？如果“睡眠”太短，则很可能不足以让其他的 `goroutine` 运行完毕，\n而若“睡眠”太长则纯属浪费时间，这个时间就太难把握了。\n\n1. **使用通道**。\n2. **使用 `sync` 包的 `sync.WaitGroup` 类型**\n\n### 怎样让启用的多个 goroutine 按照既定的顺序运行\n首先，我们需要稍微改造一下 `for` 语句中的那个 `go` 函数:\n```go\nfor i := 0; i < 10; i++ {\n    go func(i int) {\n        fmt.Println(i)\n    }(i)\n}\n```\n只有这样，Go 语言才能保证每个 `goroutine` 都可以拿到一个唯一的整数。这里有点像 js。\n\n在 `go` 语句被执行时，我们**传给 `go` 函数的参数 `i` 会先被求值**，如此就得到了当次迭代的序号。之后，无论 `go` 函数\n会在什么时候执行，这个参数值都不会变。也就是说，`go` 函数中调用的 `fmt.Println` 函数打印的一定会是那个当次迭代的序号。\n\n```go\nvar count uint32 = 0\ntrigger := func(i uint32, fn func()) { // func() 代表的是既无参数声明也无结果声明的函数类型\n    for {\n        if n := atomic.LoadUint32(&count); n == i {\n            fn()\n            atomic.AddUint32(&count, 1)\n            break\n        }\n        time.Sleep(time.Nanosecond)\n    }\n}\nfor i := uint32(0); i < 10; i++ {\n    go func(i uint32) {\n        fn := func() {\n            fmt.Println(i)\n        }\n        trigger(i, fn)\n    }(i)\n}\ntrigger(10, func(){})\n```\n上面的代码中调用了一个名叫 `trigger` 的函数，并把 `go` 函数的参数 `i` 和刚刚声明的变量 `fn` 作为参数传给了它。\n**`func()` 代表的是既无参数声明也无结果声明的函数类型**。\n\n`trigger` 函数会不断地获取一个名叫 `count` 的变量的值，并判断该值是否与参数 `i` 的值相同。如果相同，那么就立\n即调用 `fn` 代表的函数，然后把 `count` 变量的值加 `1`，最后显式地退出当前的循环。否则，我们就先让当前的 \n`goroutine` “睡眠”一个纳秒再进入下一个迭代。\n\n操作变量 `count` 的时候使用的都是原子操作。这是由于 `trigger` 函数会被多个 `goroutine` 并发地调用，所以它用到的\n非本地变量 `count`，就被多个用户级线程共用了。因此，对它的操作就产生了竞态条件（race condition），破坏了程序的并\n发安全性。在 `sync/atomic` 包中声明了很多用于原子操作的函数。由于我选用的原子操作函数对被操作的数值的类型有约束，所\n以对 `count` 以及相关的变量和参数的类型进行了统一的变更（由 `int` 变为了 `uint32`）。\n\n纵观 `count` 变量、`trigger` 函数以及改造后的 `for` 语句和 `go` 函数，我要做的是，让 `count` 变量成为一个信号，\n它的值总是下一个可以调用打印函数的 `go` 函数的序号。\n\n这个序号其实就是启用 `goroutine` 时，那个当次迭代的序号。\n\n依然想让主 `goroutine` 最后一个运行完毕，所以还需要加一行代码。不过既然有了 `trigger` 函数，就没有再使用通道。\n```go\ntrigger(10, func(){})\n```\n\n### Gosched\n`runtime.Gosched()` 暂停，释放线程去执行其他任务。\n### Goexit\n`runtime.Goexit()` 立即终止当前任务，runtime 会确保所有 defer 函数被执行。该函数不会影响其他并发任务。\n\n### goroutine 泄漏\n`goroutine` 被永远卡住，就会导致 `goroutine` 泄漏，例如当使用了无缓存的 `channel`，`goroutine` 因为 `channel` 的\n数据没有被接收而被卡住。泄漏的 `goroutine` 不会被自动回收。\n\n## Goroutine 调度器\n\n### 调度器\nGo 的 runtime 负责对 `goroutine` 进行“调度”。调度本质上就是决定何时哪个 `goroutine` 将获得资源开始执行、哪个 `goroutine` \n应该停止执行让出资源、哪个 `goroutine` 应该被唤醒恢复执行等。\n\n操作系统对进程、线程的调度是指操作系统调度器将系统中的多个线程按照一定算法调度到物理 CPU 上去运行。C、C++ 等的并发实现就是基\n于操作系统调度的，即程序负责创建线程，操作系统负责调度。但是这种支持并发的方式有不少缺陷：\n- 对于很多网络服务程序，由于不能大量创建 thread，就要在少量 thread 里做网络多路复用，即：\n使用 `epoll/kqueue/IoCompletionPort` 这套机制，即便有 `libevent/libev` 这样的第三方库帮忙，写起这样的程序也是很不易的\n- 一个 thread 的代价已经比进程小了很多了，但我们依然不能大量创建 thread，因为除了每个 thread 占用的资源不小之外，操\n作系统调度切换 thread 的代价也不小；\n- 并发单元间通信困难，易错：多个 thread 之间的通信虽然有多种机制可选，但用起来是相当复杂；\n\nGo采用了**用户层轻量级 thread** 或者说是**类 coroutine** 的概念来解决这些问题，Go 将之称为 **goroutine**。\n\n**goroutine 占用的资源非常小(goroutine stack 的 size 默认为 2k)，goroutine 调度的切换也不用操作系统内核层完成，代价很低**。\n所有的 Go 代码都在 goroutine 中执行，go runtime 也一样。将这些 goroutines 按照一定算法放到“CPU”上执行的程序就叫做 \n**goroutine 调度器**或 **goroutine scheduler**。\n\n**一个 Go 程序对于操作系统来说只是一个用户层程序，对于操作系统而言，它的眼中只有 thread，它并不知道什么是 Goroutine。\ngoroutine 的调度全要靠 Go 自己完成，实现 Go 程序内 goroutine 之间“公平”的竞争 CPU 资源，这个任务就落到了 Go runtime 头上**，\n在一个 Go 程序中，除了用户代码，剩下的就是 go runtime 了。\n\nGoroutine 的调度问题就变成了 **go runtime 如何将程序内的众多 goroutine 按照一定算法调度到 CPU 资源上运行**了。\n\n但是在**操作系统层面，Thread 竞争的 CPU 资源是真实的物理 CPU**，但在 Go 程序层面，各个 Goroutine 要竞争的 CPU 资源是什么呢？\n\nGo 程序是用户层程序，它本身整体是运行在一个或多个操作系统线程上的，因此 **goroutine 们要竞争的所谓 CPU 资源就是操作系统线程**。\n\nGo scheduler 的任务：**将 goroutines 按照一定算法放到不同的操作系统线程中去执行**。这种在语言层面自带调度器的，我们称\n之为**原生支持并发**。\n\n### G-P-M 模型\n\n调度器的主要有 3 个重要部分，分别是 M、G、P。\n- G（goroutine 的缩写）， 协程的实体，并不是执行体，仅保存了并发任务的状态，包括了调用栈，重要的调度信息，例如 channel 等。\nG 任务创建之后被放置在 P 本地队列或者全局队列，等待工作线程调度。\n- P（processor 的缩写），是衔接 M 和 G 的调度上下文，一个 P 可以承载若干个 G，且能够使这些 G 适时地与 M 进行\n对接，并得到真正运行的中介。P 的数量可以通过 `runtime.GOMAXPROCS()` 来设置，P 的数量决定了系统内最大可并行的 G 的数量，\n即有多少个 `goroutine` 可以同时运行。（前提：系统的物理 `cpu 核数 >= P 的数量`），它维护了一个 G 队列（**runq**），里面存储\n了所有需要它来执行的 G。\n- M（machine 的缩写），代表的是系统线程。G 就是跑在 M 之上的。在绑定有效的 P 后，进入 schedule 循环；\n而 schedule 循环的机制大致是从各种队列、P 的本地队列中获取 G，切换到 G 的执行栈上并执行 G 的函数，调用 goexit 做清理工作\n并回到 M，如此反复。M 并不保留 G 状态，这是 G 可以跨 M 调度的基础。\n\n![](../imgs/goroutine-scheduler-model.png)\n\n简单来说，一个 G 的执行需要 P 和 M 的支持，P 和 M 绑定之后，就形成了一个 G 的运行环境（内核线程和上下文）。\n\nP 和 M 构成执行组合体，但两者的数量并不是一一对应的。一般情况下， **P 的数量相对恒定，默认与 CPU 核数相同，可能更多或更少。\nM 是由调度器按需创建的**。比如，如果一个 M 因系统调用时间长而阻塞，P 就会被监控线程抢走，并且新建一个 M 执行其他任务，M\n的数量就增加了。\n\n所有 P 是在调度器初始化阶段创建的，虽然可以使用 `runtime.GOMAXPROCS()` 在运行期间修改 P 的数量，但是代价很大。\n\n### 抢占式调度\nGo 并没有时间片的概念，只是在目标 G 上设置一个抢占标志。如果某个 G 没有进行 syscall、没有进行 I/O 操作、没有阻塞在一\n个 channel 操作上，那么 M 是**如何让 G 停下来并调度下一个 runnable G** 的呢？\n\n答案是：G 是被抢占调度的。\n\nGo 在设计之初并没考虑将 goroutine 设计成抢占式的。用户负责让各个 goroutine 交互合作完成任务。一个 goroutine 只有在涉及到加锁，\n读写通道或者主动让出 CPU 等操作时才会触发切换。\n\n垃圾回收器是需要 stop the world 的。如果垃圾回收器想要运行了，那么它必须先通知其它的 goroutine 合作停下来，这会造成较长时\n间的等待时间。考虑一种很极端的情况，所有的 goroutine 都停下来了，只有其中一个没有停，那么垃圾回收就会一直等待着没有停的那一个。\n\n抢占式调度可以解决这种问题，在抢占式情况下，如果一个 goroutine 运行时间过长，它就会被剥夺运行权。Go 还只是引入了一些很初级\n的抢占，只有长时间阻塞于系统调用，或者运行了较长时间才会被抢占。runtime 会在后台有一个检测线程，它会检测这些情况，\n并通知 goroutine 执行调度。\n\nGo 程序的初始化过程中，runtime 开了一条后台线程，运行一个 `sysmon` 函数(一般称为监控线程)。这个函数会周期性地做 epoll 操作，\n同时它还会检测每个 P 是否运行了较长时间。该 M 无需绑定 P 即可运行，该 M 在整个 Go 程序的运行过程中至关重要。\n\n`sysmon` 每 `20us~10ms` 运行一次，`sysmon` 主要完成如下工作：\n- 释放闲置超过 5 分钟的 span 物理内存；\n- 如果超过 2 分钟没有垃圾回收，强制执行；\n- 将长时间未处理的 netpoll 结果添加到任务队列；\n- 向长时间运行的 G 任务发出抢占调度；\n- 收回因 syscall 长时间阻塞的 P；\n\n### channel 阻塞或 network I/O 情况下的调度\n如果 G 被阻塞在某个 channel 操作或 network I/O 操作上时，G 会被放置到某个 wait 队列中，而 M 会尝试运行下一个 runnable \n的 G；如果此时没有 runnable 的 G 供 M 运行，那么 M 将解绑 P，并进入 sleep 状态。当 I/O available 或 channel 操作完成，\n在 wait 队列中的 G 会被唤醒，标记为 runnable，放入到某 P 的队列中，绑定一个 M 继续执行。\n\n### system call 阻塞情况下的调度\n如果 G 被阻塞在某个 system call 操作上，那么不光 G 会阻塞，执行该 G 的 M 也会解绑 P(实质是被 sysmon 抢走了)，\n与 G 一起进入 sleep 状态。如果此时有 idle 的 M，则 P 与其绑定继续执行其他 G；如果没有 idle M，但仍然有其他 G 要去执行，\n那么就会创建一个新 M。\n\n当阻塞在 syscall 上的 G 完成 syscall 调用后，G 会去尝试获取一个可用的 P，如果没有可用的 P，那么 G 会被标记为 runnable，\n之前的那个 sleep 的 M 将再次进入 sleep。","source":"concurrent/goroutine.md","raw":"---\ntitle: goroutine\n---\n\n# goroutine\n## 并发和并行\n### 并发\n一个 cpu 上能同时执行多项任务，在很短时间内，cpu 来回切换任务执行(在某段很短时间内执行程序 a，然后又迅速得切换到程序 b 去执行)，\n有时间上的重叠（宏观上是同时的，微观仍是顺序执行）,这样看起来多个任务像是同时执行，这就是**并发**。\n\n### 并行\n当系统有多个 CPU 时,每个 CPU 同一时刻都运行任务，互不抢占自己所在的 CPU 资源，同时进行，称为**并行**。并行是并发设计的\n理想模式。\n\n### 进程\n\ncpu 在切换程序的时候，如果不保存上一个程序的状态（也就是我们常说的 `context` --上下文），直接切换下一个程序，就会丢失上一个\n程序的一系列状态，于是引入了进程这个概念，用以划分好程序运行时所需要的资源。因此进程就是一个程序运行时候的所需要的基本资源单\n位（也可以说是程序运行的一个实体）。\n\n### 线程\ncpu 切换多个进程的时候，会花费不少的时间，因为切换进程需要切换到内核态，而每次调度需要内核态都需要读取用户态的数据，进程\n一旦多起来，cpu 调度会消耗一大堆资源，因此引入了线程的概念，线程本身几乎不占有资源，他们共享进程里的资源，内核调度起来不\n会那么像进程切换那么耗费资源。\n\n### 协程\n多线程和多进程是并行的基本条件，但是单线程可以利用**协程**做到并发。协程拥有自己的寄存器上下文和栈。协程在线程上通过主动\n切换来实现并发，减少了阻塞时间，还避免了线程切换的开销。但协程运行的并发本质上还是串行的。线程和进程的操作是由程序触发系统\n接口，最后的执行者是系统；协程的操作执行者则是用户自身程序。\n\n## goroutine\nGo 语言在语言层面上支持了并发，简单将 `goroutine` 归为协程并不合适。Go runtime 会创建多个线程来执行并发任务，而且任务\n可以跨线程调度。所以 goroutine 更像是多线程和协程的结合体。\n\n`goroutine` 可以简单理解为协程，开销较低 (大概是 `4~5KB` )，当然会根据相应的数据伸缩。也正因为如此，可同时运行成千\n上万个并发任务。`goroutine` 比 `thread` 更易用、更高效、更轻便。我们程序运行的 **`main` 函数在一个单独的 `goroutine` 中运行，\n叫做 `主 goroutine`**。在代码中可以使用 **`go` 关键字创建 `goroutine`**。\n\n```go\ngo f()\n```\n\n**`main` 函数返回时，所有 `goroutine` 都会被打断，程序退出**。除了从 `main` 函数退出或者直接终止程序之外，没有其它\n的编程方法能够让一个 `goroutine` 来打断另一个的执行，但是之后可以看到一种方式来实现这个目的，通过 `goroutine` 之间\n的通信来让一个 `goroutine` 请求其它的 `goroutine`，使被请求 `goroutine` 自行结束执行。\n\n### 什么是主 goroutine，它与我们启用的其他 goroutine 有什么不同\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tfor i := 0; i < 10; i++ {\n\t\tgo func() {\n\t\t\tfmt.Println(i)\n\t\t}()\n\t}\n}\n```\n上面的代码会打印出什么内容？\n\n回答是：不会有任何内容被打印出来。\n\nGo 语言不但有着独特的并发编程模型，以及用户级线程 `goroutine`，还拥有强大的用于调度 `goroutine`、对接系统级线程的\n**调度器**。\n\n调度器的主要有 3 个重要部分，分别是 M、G、P。\n- G（goroutine 的缩写）， 协程的实体，包括了调用栈，重要的调度信息，例如 channel 等。\n- P（processor 的缩写），是衔接 M 和 G 的调度上下文，一个 P 可以承载若干个 G，且能够使这些 G 适时地与 M 进行\n对接，并得到真正运行的中介。P 的数量可以通过 `runtime.GOMAXPROCS()` 来设置，P 的数量决定了系统内最大可并行的 G 的数量，\n即有多少个 `goroutine` 可以同时运行。\n- M（machine 的缩写），代表的是系统级线程，由操作系统管理。\n\n与一个进程总会有一个主线程类似，每一个独立的 Go 程序在运行时也总会有一个主 `goroutine`。这个主 `goroutine` 会在 Go 程\n序的运行准备工作完成后被自动地启用，并不需要我们做任何手动的操作。\n\n**每条 `go` 语句一般都会携带一个函数调用，这个被调用的函数常常被称为 `go` 函数。而主 `goroutine` 的 `go` 函数就是\n那个作为程序入口的 `main` 函数**。\n\n**`go` 函数真正被执行的时间总会与其所属的 `go` 语句被执行的时间不同**。\n\n当程序执行到一条 `go` 语句的时候，**`go` 关键字并不是执行并发操作，而是创建一个并发任务单元**。Go 语言的运行时系统，会先试图从某个\n存放空闲的 G 的队列中获取一个 G（也就是 `goroutine`），它只有在找不到空闲 G 的情况下才会去创建一个新的 G。已存在\n的 goroutine 总是会被优先复用。\n\n在拿到了一个空闲的 G 之后，Go 语言运行时系统会用这个 G 去包装当前的那个 `go` 函数（或者说该函数中的那些代码），然后再把这\n个 G 追加到某个存放可运行的 G 的队列中。这类队列中的 G 总是会按照先入先出的顺序，很快地由运行时系统内部的调度器安排运行。\n虽然这会很快，但是由于上面所说的那些准备工作还是不可避免的，所以耗时还是存在的。\n\n因此，**`go` 函数的执行时间总是会明显滞后于它所属的 `go` 语句的执行时间**。当然了，这里所说的“明显滞后”是对于计算机\n的 CPU 时钟和 Go 程序来说的。我们在大多数时候都不会有明显的感觉。\n\n请记住，**只要 `go` 语句本身执行完毕，Go 程序完全不会等待 `go` 函数的执行，它会立刻去执行后边的语句**。这就是所谓\n的**异步并发**地执行。\n\n上面的代码中那 10 个包装了 `go` 函数的 `goroutine` 往往还没有获得运行的机会。但是如果有机会运行，打印的结果是什么，\n全是 `10`？\n\n当 `for` 语句的最后一个迭代运行的时候，其中的那条 `go` 语句即是最后一条语句。所以，在执行完这条 `go` 语句之后，\n主 `goroutine` 中的代码也就执行完了，Go 程序会立即结束运行。那么，如果这样的话，还会有任何内容被打印出来吗？\n\nGo 语言并不会去保证这些 `goroutine` 会以怎样的顺序运行。由于主 `goroutine` 会与我们手动启用的其他 `goroutine` 一起接受\n调度，又因为调度器很可能会在 `goroutine` 中的代码只执行了一部分的时候暂停，以期所有的 goroutine 有更公平的运行机会。\n\n所以哪个 `goroutine` 先执行完、哪个 `goroutine` 后执行完往往是不可预知的，除非我们使用了某种 Go 语言提供的方式进行了人为\n干预。\n\n### 怎样才能让主 goroutine 等待其他 goroutine\n刚才说过，一旦主 `goroutine` 中的代码执行完毕，当前的 Go 程序就会结束运行，无论其他的 `goroutine` 是否已经在运行了。\n那么，怎样才能做到等其他的 `goroutine` 运行完毕之后，再让主 `goroutine` 结束运行呢？\n\n1. **使用 `time` 包**，可以简单粗暴的 `time.Sleep(time.Millisecond * 500)` 让主 `goroutine` “小睡”一会儿。\n在这里传入了“500 毫秒”\n\n问题是我们让主 `goroutine` “睡眠”多长时间才是合适的呢？如果“睡眠”太短，则很可能不足以让其他的 `goroutine` 运行完毕，\n而若“睡眠”太长则纯属浪费时间，这个时间就太难把握了。\n\n1. **使用通道**。\n2. **使用 `sync` 包的 `sync.WaitGroup` 类型**\n\n### 怎样让启用的多个 goroutine 按照既定的顺序运行\n首先，我们需要稍微改造一下 `for` 语句中的那个 `go` 函数:\n```go\nfor i := 0; i < 10; i++ {\n    go func(i int) {\n        fmt.Println(i)\n    }(i)\n}\n```\n只有这样，Go 语言才能保证每个 `goroutine` 都可以拿到一个唯一的整数。这里有点像 js。\n\n在 `go` 语句被执行时，我们**传给 `go` 函数的参数 `i` 会先被求值**，如此就得到了当次迭代的序号。之后，无论 `go` 函数\n会在什么时候执行，这个参数值都不会变。也就是说，`go` 函数中调用的 `fmt.Println` 函数打印的一定会是那个当次迭代的序号。\n\n```go\nvar count uint32 = 0\ntrigger := func(i uint32, fn func()) { // func() 代表的是既无参数声明也无结果声明的函数类型\n    for {\n        if n := atomic.LoadUint32(&count); n == i {\n            fn()\n            atomic.AddUint32(&count, 1)\n            break\n        }\n        time.Sleep(time.Nanosecond)\n    }\n}\nfor i := uint32(0); i < 10; i++ {\n    go func(i uint32) {\n        fn := func() {\n            fmt.Println(i)\n        }\n        trigger(i, fn)\n    }(i)\n}\ntrigger(10, func(){})\n```\n上面的代码中调用了一个名叫 `trigger` 的函数，并把 `go` 函数的参数 `i` 和刚刚声明的变量 `fn` 作为参数传给了它。\n**`func()` 代表的是既无参数声明也无结果声明的函数类型**。\n\n`trigger` 函数会不断地获取一个名叫 `count` 的变量的值，并判断该值是否与参数 `i` 的值相同。如果相同，那么就立\n即调用 `fn` 代表的函数，然后把 `count` 变量的值加 `1`，最后显式地退出当前的循环。否则，我们就先让当前的 \n`goroutine` “睡眠”一个纳秒再进入下一个迭代。\n\n操作变量 `count` 的时候使用的都是原子操作。这是由于 `trigger` 函数会被多个 `goroutine` 并发地调用，所以它用到的\n非本地变量 `count`，就被多个用户级线程共用了。因此，对它的操作就产生了竞态条件（race condition），破坏了程序的并\n发安全性。在 `sync/atomic` 包中声明了很多用于原子操作的函数。由于我选用的原子操作函数对被操作的数值的类型有约束，所\n以对 `count` 以及相关的变量和参数的类型进行了统一的变更（由 `int` 变为了 `uint32`）。\n\n纵观 `count` 变量、`trigger` 函数以及改造后的 `for` 语句和 `go` 函数，我要做的是，让 `count` 变量成为一个信号，\n它的值总是下一个可以调用打印函数的 `go` 函数的序号。\n\n这个序号其实就是启用 `goroutine` 时，那个当次迭代的序号。\n\n依然想让主 `goroutine` 最后一个运行完毕，所以还需要加一行代码。不过既然有了 `trigger` 函数，就没有再使用通道。\n```go\ntrigger(10, func(){})\n```\n\n### Gosched\n`runtime.Gosched()` 暂停，释放线程去执行其他任务。\n### Goexit\n`runtime.Goexit()` 立即终止当前任务，runtime 会确保所有 defer 函数被执行。该函数不会影响其他并发任务。\n\n### goroutine 泄漏\n`goroutine` 被永远卡住，就会导致 `goroutine` 泄漏，例如当使用了无缓存的 `channel`，`goroutine` 因为 `channel` 的\n数据没有被接收而被卡住。泄漏的 `goroutine` 不会被自动回收。\n\n## Goroutine 调度器\n\n### 调度器\nGo 的 runtime 负责对 `goroutine` 进行“调度”。调度本质上就是决定何时哪个 `goroutine` 将获得资源开始执行、哪个 `goroutine` \n应该停止执行让出资源、哪个 `goroutine` 应该被唤醒恢复执行等。\n\n操作系统对进程、线程的调度是指操作系统调度器将系统中的多个线程按照一定算法调度到物理 CPU 上去运行。C、C++ 等的并发实现就是基\n于操作系统调度的，即程序负责创建线程，操作系统负责调度。但是这种支持并发的方式有不少缺陷：\n- 对于很多网络服务程序，由于不能大量创建 thread，就要在少量 thread 里做网络多路复用，即：\n使用 `epoll/kqueue/IoCompletionPort` 这套机制，即便有 `libevent/libev` 这样的第三方库帮忙，写起这样的程序也是很不易的\n- 一个 thread 的代价已经比进程小了很多了，但我们依然不能大量创建 thread，因为除了每个 thread 占用的资源不小之外，操\n作系统调度切换 thread 的代价也不小；\n- 并发单元间通信困难，易错：多个 thread 之间的通信虽然有多种机制可选，但用起来是相当复杂；\n\nGo采用了**用户层轻量级 thread** 或者说是**类 coroutine** 的概念来解决这些问题，Go 将之称为 **goroutine**。\n\n**goroutine 占用的资源非常小(goroutine stack 的 size 默认为 2k)，goroutine 调度的切换也不用操作系统内核层完成，代价很低**。\n所有的 Go 代码都在 goroutine 中执行，go runtime 也一样。将这些 goroutines 按照一定算法放到“CPU”上执行的程序就叫做 \n**goroutine 调度器**或 **goroutine scheduler**。\n\n**一个 Go 程序对于操作系统来说只是一个用户层程序，对于操作系统而言，它的眼中只有 thread，它并不知道什么是 Goroutine。\ngoroutine 的调度全要靠 Go 自己完成，实现 Go 程序内 goroutine 之间“公平”的竞争 CPU 资源，这个任务就落到了 Go runtime 头上**，\n在一个 Go 程序中，除了用户代码，剩下的就是 go runtime 了。\n\nGoroutine 的调度问题就变成了 **go runtime 如何将程序内的众多 goroutine 按照一定算法调度到 CPU 资源上运行**了。\n\n但是在**操作系统层面，Thread 竞争的 CPU 资源是真实的物理 CPU**，但在 Go 程序层面，各个 Goroutine 要竞争的 CPU 资源是什么呢？\n\nGo 程序是用户层程序，它本身整体是运行在一个或多个操作系统线程上的，因此 **goroutine 们要竞争的所谓 CPU 资源就是操作系统线程**。\n\nGo scheduler 的任务：**将 goroutines 按照一定算法放到不同的操作系统线程中去执行**。这种在语言层面自带调度器的，我们称\n之为**原生支持并发**。\n\n### G-P-M 模型\n\n调度器的主要有 3 个重要部分，分别是 M、G、P。\n- G（goroutine 的缩写）， 协程的实体，并不是执行体，仅保存了并发任务的状态，包括了调用栈，重要的调度信息，例如 channel 等。\nG 任务创建之后被放置在 P 本地队列或者全局队列，等待工作线程调度。\n- P（processor 的缩写），是衔接 M 和 G 的调度上下文，一个 P 可以承载若干个 G，且能够使这些 G 适时地与 M 进行\n对接，并得到真正运行的中介。P 的数量可以通过 `runtime.GOMAXPROCS()` 来设置，P 的数量决定了系统内最大可并行的 G 的数量，\n即有多少个 `goroutine` 可以同时运行。（前提：系统的物理 `cpu 核数 >= P 的数量`），它维护了一个 G 队列（**runq**），里面存储\n了所有需要它来执行的 G。\n- M（machine 的缩写），代表的是系统线程。G 就是跑在 M 之上的。在绑定有效的 P 后，进入 schedule 循环；\n而 schedule 循环的机制大致是从各种队列、P 的本地队列中获取 G，切换到 G 的执行栈上并执行 G 的函数，调用 goexit 做清理工作\n并回到 M，如此反复。M 并不保留 G 状态，这是 G 可以跨 M 调度的基础。\n\n![](../imgs/goroutine-scheduler-model.png)\n\n简单来说，一个 G 的执行需要 P 和 M 的支持，P 和 M 绑定之后，就形成了一个 G 的运行环境（内核线程和上下文）。\n\nP 和 M 构成执行组合体，但两者的数量并不是一一对应的。一般情况下， **P 的数量相对恒定，默认与 CPU 核数相同，可能更多或更少。\nM 是由调度器按需创建的**。比如，如果一个 M 因系统调用时间长而阻塞，P 就会被监控线程抢走，并且新建一个 M 执行其他任务，M\n的数量就增加了。\n\n所有 P 是在调度器初始化阶段创建的，虽然可以使用 `runtime.GOMAXPROCS()` 在运行期间修改 P 的数量，但是代价很大。\n\n### 抢占式调度\nGo 并没有时间片的概念，只是在目标 G 上设置一个抢占标志。如果某个 G 没有进行 syscall、没有进行 I/O 操作、没有阻塞在一\n个 channel 操作上，那么 M 是**如何让 G 停下来并调度下一个 runnable G** 的呢？\n\n答案是：G 是被抢占调度的。\n\nGo 在设计之初并没考虑将 goroutine 设计成抢占式的。用户负责让各个 goroutine 交互合作完成任务。一个 goroutine 只有在涉及到加锁，\n读写通道或者主动让出 CPU 等操作时才会触发切换。\n\n垃圾回收器是需要 stop the world 的。如果垃圾回收器想要运行了，那么它必须先通知其它的 goroutine 合作停下来，这会造成较长时\n间的等待时间。考虑一种很极端的情况，所有的 goroutine 都停下来了，只有其中一个没有停，那么垃圾回收就会一直等待着没有停的那一个。\n\n抢占式调度可以解决这种问题，在抢占式情况下，如果一个 goroutine 运行时间过长，它就会被剥夺运行权。Go 还只是引入了一些很初级\n的抢占，只有长时间阻塞于系统调用，或者运行了较长时间才会被抢占。runtime 会在后台有一个检测线程，它会检测这些情况，\n并通知 goroutine 执行调度。\n\nGo 程序的初始化过程中，runtime 开了一条后台线程，运行一个 `sysmon` 函数(一般称为监控线程)。这个函数会周期性地做 epoll 操作，\n同时它还会检测每个 P 是否运行了较长时间。该 M 无需绑定 P 即可运行，该 M 在整个 Go 程序的运行过程中至关重要。\n\n`sysmon` 每 `20us~10ms` 运行一次，`sysmon` 主要完成如下工作：\n- 释放闲置超过 5 分钟的 span 物理内存；\n- 如果超过 2 分钟没有垃圾回收，强制执行；\n- 将长时间未处理的 netpoll 结果添加到任务队列；\n- 向长时间运行的 G 任务发出抢占调度；\n- 收回因 syscall 长时间阻塞的 P；\n\n### channel 阻塞或 network I/O 情况下的调度\n如果 G 被阻塞在某个 channel 操作或 network I/O 操作上时，G 会被放置到某个 wait 队列中，而 M 会尝试运行下一个 runnable \n的 G；如果此时没有 runnable 的 G 供 M 运行，那么 M 将解绑 P，并进入 sleep 状态。当 I/O available 或 channel 操作完成，\n在 wait 队列中的 G 会被唤醒，标记为 runnable，放入到某 P 的队列中，绑定一个 M 继续执行。\n\n### system call 阻塞情况下的调度\n如果 G 被阻塞在某个 system call 操作上，那么不光 G 会阻塞，执行该 G 的 M 也会解绑 P(实质是被 sysmon 抢走了)，\n与 G 一起进入 sleep 状态。如果此时有 idle 的 M，则 P 与其绑定继续执行其他 G；如果没有 idle M，但仍然有其他 G 要去执行，\n那么就会创建一个新 M。\n\n当阻塞在 syscall 上的 G 完成 syscall 调用后，G 会去尝试获取一个可用的 P，如果没有可用的 P，那么 G 会被标记为 runnable，\n之前的那个 sleep 的 M 将再次进入 sleep。","date":"2019-09-01T00:18:20.654Z","updated":"2019-09-01T00:18:20.654Z","path":"concurrent/goroutine.html","comments":1,"layout":"page","_id":"ck1xm14ll001afcw2289gmtqz","content":"<h1 id=\"goroutine\"><a href=\"#goroutine\" class=\"headerlink\" title=\"goroutine\"></a>goroutine</h1><h2 id=\"并发和并行\"><a href=\"#并发和并行\" class=\"headerlink\" title=\"并发和并行\"></a>并发和并行</h2><h3 id=\"并发\"><a href=\"#并发\" class=\"headerlink\" title=\"并发\"></a>并发</h3><p>一个 cpu 上能同时执行多项任务，在很短时间内，cpu 来回切换任务执行(在某段很短时间内执行程序 a，然后又迅速得切换到程序 b 去执行)，<br>有时间上的重叠（宏观上是同时的，微观仍是顺序执行）,这样看起来多个任务像是同时执行，这就是<strong>并发</strong>。</p>\n<h3 id=\"并行\"><a href=\"#并行\" class=\"headerlink\" title=\"并行\"></a>并行</h3><p>当系统有多个 CPU 时,每个 CPU 同一时刻都运行任务，互不抢占自己所在的 CPU 资源，同时进行，称为<strong>并行</strong>。并行是并发设计的<br>理想模式。</p>\n<h3 id=\"进程\"><a href=\"#进程\" class=\"headerlink\" title=\"进程\"></a>进程</h3><p>cpu 在切换程序的时候，如果不保存上一个程序的状态（也就是我们常说的 <code>context</code> –上下文），直接切换下一个程序，就会丢失上一个<br>程序的一系列状态，于是引入了进程这个概念，用以划分好程序运行时所需要的资源。因此进程就是一个程序运行时候的所需要的基本资源单<br>位（也可以说是程序运行的一个实体）。</p>\n<h3 id=\"线程\"><a href=\"#线程\" class=\"headerlink\" title=\"线程\"></a>线程</h3><p>cpu 切换多个进程的时候，会花费不少的时间，因为切换进程需要切换到内核态，而每次调度需要内核态都需要读取用户态的数据，进程<br>一旦多起来，cpu 调度会消耗一大堆资源，因此引入了线程的概念，线程本身几乎不占有资源，他们共享进程里的资源，内核调度起来不<br>会那么像进程切换那么耗费资源。</p>\n<h3 id=\"协程\"><a href=\"#协程\" class=\"headerlink\" title=\"协程\"></a>协程</h3><p>多线程和多进程是并行的基本条件，但是单线程可以利用<strong>协程</strong>做到并发。协程拥有自己的寄存器上下文和栈。协程在线程上通过主动<br>切换来实现并发，减少了阻塞时间，还避免了线程切换的开销。但协程运行的并发本质上还是串行的。线程和进程的操作是由程序触发系统<br>接口，最后的执行者是系统；协程的操作执行者则是用户自身程序。</p>\n<h2 id=\"goroutine-1\"><a href=\"#goroutine-1\" class=\"headerlink\" title=\"goroutine\"></a>goroutine</h2><p>Go 语言在语言层面上支持了并发，简单将 <code>goroutine</code> 归为协程并不合适。Go runtime 会创建多个线程来执行并发任务，而且任务<br>可以跨线程调度。所以 goroutine 更像是多线程和协程的结合体。</p>\n<p><code>goroutine</code> 可以简单理解为协程，开销较低 (大概是 <code>4~5KB</code> )，当然会根据相应的数据伸缩。也正因为如此，可同时运行成千<br>上万个并发任务。<code>goroutine</code> 比 <code>thread</code> 更易用、更高效、更轻便。我们程序运行的 <strong><code>main</code> 函数在一个单独的 <code>goroutine</code> 中运行，<br>叫做 <code>主 goroutine</code></strong>。在代码中可以使用 <strong><code>go</code> 关键字创建 <code>goroutine</code></strong>。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">go</span> f()</span><br></pre></td></tr></table></figure>\n<p><strong><code>main</code> 函数返回时，所有 <code>goroutine</code> 都会被打断，程序退出</strong>。除了从 <code>main</code> 函数退出或者直接终止程序之外，没有其它<br>的编程方法能够让一个 <code>goroutine</code> 来打断另一个的执行，但是之后可以看到一种方式来实现这个目的，通过 <code>goroutine</code> 之间<br>的通信来让一个 <code>goroutine</code> 请求其它的 <code>goroutine</code>，使被请求 <code>goroutine</code> 自行结束执行。</p>\n<h3 id=\"什么是主-goroutine，它与我们启用的其他-goroutine-有什么不同\"><a href=\"#什么是主-goroutine，它与我们启用的其他-goroutine-有什么不同\" class=\"headerlink\" title=\"什么是主 goroutine，它与我们启用的其他 goroutine 有什么不同\"></a>什么是主 goroutine，它与我们启用的其他 goroutine 有什么不同</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"fmt\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++ &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\t\tfmt.Println(i)</span><br><span class=\"line\">\t\t&#125;()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的代码会打印出什么内容？</p>\n<p>回答是：不会有任何内容被打印出来。</p>\n<p>Go 语言不但有着独特的并发编程模型，以及用户级线程 <code>goroutine</code>，还拥有强大的用于调度 <code>goroutine</code>、对接系统级线程的<br><strong>调度器</strong>。</p>\n<p>调度器的主要有 3 个重要部分，分别是 M、G、P。</p>\n<ul>\n<li>G（goroutine 的缩写）， 协程的实体，包括了调用栈，重要的调度信息，例如 channel 等。</li>\n<li>P（processor 的缩写），是衔接 M 和 G 的调度上下文，一个 P 可以承载若干个 G，且能够使这些 G 适时地与 M 进行<br>对接，并得到真正运行的中介。P 的数量可以通过 <code>runtime.GOMAXPROCS()</code> 来设置，P 的数量决定了系统内最大可并行的 G 的数量，<br>即有多少个 <code>goroutine</code> 可以同时运行。</li>\n<li>M（machine 的缩写），代表的是系统级线程，由操作系统管理。</li>\n</ul>\n<p>与一个进程总会有一个主线程类似，每一个独立的 Go 程序在运行时也总会有一个主 <code>goroutine</code>。这个主 <code>goroutine</code> 会在 Go 程<br>序的运行准备工作完成后被自动地启用，并不需要我们做任何手动的操作。</p>\n<p><strong>每条 <code>go</code> 语句一般都会携带一个函数调用，这个被调用的函数常常被称为 <code>go</code> 函数。而主 <code>goroutine</code> 的 <code>go</code> 函数就是<br>那个作为程序入口的 <code>main</code> 函数</strong>。</p>\n<p><strong><code>go</code> 函数真正被执行的时间总会与其所属的 <code>go</code> 语句被执行的时间不同</strong>。</p>\n<p>当程序执行到一条 <code>go</code> 语句的时候，<strong><code>go</code> 关键字并不是执行并发操作，而是创建一个并发任务单元</strong>。Go 语言的运行时系统，会先试图从某个<br>存放空闲的 G 的队列中获取一个 G（也就是 <code>goroutine</code>），它只有在找不到空闲 G 的情况下才会去创建一个新的 G。已存在<br>的 goroutine 总是会被优先复用。</p>\n<p>在拿到了一个空闲的 G 之后，Go 语言运行时系统会用这个 G 去包装当前的那个 <code>go</code> 函数（或者说该函数中的那些代码），然后再把这<br>个 G 追加到某个存放可运行的 G 的队列中。这类队列中的 G 总是会按照先入先出的顺序，很快地由运行时系统内部的调度器安排运行。<br>虽然这会很快，但是由于上面所说的那些准备工作还是不可避免的，所以耗时还是存在的。</p>\n<p>因此，<strong><code>go</code> 函数的执行时间总是会明显滞后于它所属的 <code>go</code> 语句的执行时间</strong>。当然了，这里所说的“明显滞后”是对于计算机<br>的 CPU 时钟和 Go 程序来说的。我们在大多数时候都不会有明显的感觉。</p>\n<p>请记住，<strong>只要 <code>go</code> 语句本身执行完毕，Go 程序完全不会等待 <code>go</code> 函数的执行，它会立刻去执行后边的语句</strong>。这就是所谓<br>的<strong>异步并发</strong>地执行。</p>\n<p>上面的代码中那 10 个包装了 <code>go</code> 函数的 <code>goroutine</code> 往往还没有获得运行的机会。但是如果有机会运行，打印的结果是什么，<br>全是 <code>10</code>？</p>\n<p>当 <code>for</code> 语句的最后一个迭代运行的时候，其中的那条 <code>go</code> 语句即是最后一条语句。所以，在执行完这条 <code>go</code> 语句之后，<br>主 <code>goroutine</code> 中的代码也就执行完了，Go 程序会立即结束运行。那么，如果这样的话，还会有任何内容被打印出来吗？</p>\n<p>Go 语言并不会去保证这些 <code>goroutine</code> 会以怎样的顺序运行。由于主 <code>goroutine</code> 会与我们手动启用的其他 <code>goroutine</code> 一起接受<br>调度，又因为调度器很可能会在 <code>goroutine</code> 中的代码只执行了一部分的时候暂停，以期所有的 goroutine 有更公平的运行机会。</p>\n<p>所以哪个 <code>goroutine</code> 先执行完、哪个 <code>goroutine</code> 后执行完往往是不可预知的，除非我们使用了某种 Go 语言提供的方式进行了人为<br>干预。</p>\n<h3 id=\"怎样才能让主-goroutine-等待其他-goroutine\"><a href=\"#怎样才能让主-goroutine-等待其他-goroutine\" class=\"headerlink\" title=\"怎样才能让主 goroutine 等待其他 goroutine\"></a>怎样才能让主 goroutine 等待其他 goroutine</h3><p>刚才说过，一旦主 <code>goroutine</code> 中的代码执行完毕，当前的 Go 程序就会结束运行，无论其他的 <code>goroutine</code> 是否已经在运行了。<br>那么，怎样才能做到等其他的 <code>goroutine</code> 运行完毕之后，再让主 <code>goroutine</code> 结束运行呢？</p>\n<ol>\n<li><strong>使用 <code>time</code> 包</strong>，可以简单粗暴的 <code>time.Sleep(time.Millisecond * 500)</code> 让主 <code>goroutine</code> “小睡”一会儿。<br>在这里传入了“500 毫秒”</li>\n</ol>\n<p>问题是我们让主 <code>goroutine</code> “睡眠”多长时间才是合适的呢？如果“睡眠”太短，则很可能不足以让其他的 <code>goroutine</code> 运行完毕，<br>而若“睡眠”太长则纯属浪费时间，这个时间就太难把握了。</p>\n<ol>\n<li><strong>使用通道</strong>。</li>\n<li><strong>使用 <code>sync</code> 包的 <code>sync.WaitGroup</code> 类型</strong></li>\n</ol>\n<h3 id=\"怎样让启用的多个-goroutine-按照既定的顺序运行\"><a href=\"#怎样让启用的多个-goroutine-按照既定的顺序运行\" class=\"headerlink\" title=\"怎样让启用的多个 goroutine 按照既定的顺序运行\"></a>怎样让启用的多个 goroutine 按照既定的顺序运行</h3><p>首先，我们需要稍微改造一下 <code>for</code> 语句中的那个 <code>go</code> 函数:<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++ &#123;</span><br><span class=\"line\">    <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(i <span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">        fmt.Println(i)</span><br><span class=\"line\">    &#125;(i)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>只有这样，Go 语言才能保证每个 <code>goroutine</code> 都可以拿到一个唯一的整数。这里有点像 js。</p>\n<p>在 <code>go</code> 语句被执行时，我们<strong>传给 <code>go</code> 函数的参数 <code>i</code> 会先被求值</strong>，如此就得到了当次迭代的序号。之后，无论 <code>go</code> 函数<br>会在什么时候执行，这个参数值都不会变。也就是说，<code>go</code> 函数中调用的 <code>fmt.Println</code> 函数打印的一定会是那个当次迭代的序号。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> count <span class=\"keyword\">uint32</span> = <span class=\"number\">0</span></span><br><span class=\"line\">trigger := <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(i <span class=\"keyword\">uint32</span>, fn <span class=\"keyword\">func</span>()</span>)</span> &#123; <span class=\"comment\">// func() 代表的是既无参数声明也无结果声明的函数类型</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> n := atomic.LoadUint32(&amp;count); n == i &#123;</span><br><span class=\"line\">            fn()</span><br><span class=\"line\">            atomic.AddUint32(&amp;count, <span class=\"number\">1</span>)</span><br><span class=\"line\">            <span class=\"keyword\">break</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        time.Sleep(time.Nanosecond)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">for</span> i := <span class=\"keyword\">uint32</span>(<span class=\"number\">0</span>); i &lt; <span class=\"number\">10</span>; i++ &#123;</span><br><span class=\"line\">    <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(i <span class=\"keyword\">uint32</span>)</span></span> &#123;</span><br><span class=\"line\">        fn := <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">            fmt.Println(i)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        trigger(i, fn)</span><br><span class=\"line\">    &#125;(i)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">trigger(<span class=\"number\">10</span>, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span>&#123;&#125;)</span><br></pre></td></tr></table></figure>\n<p>上面的代码中调用了一个名叫 <code>trigger</code> 的函数，并把 <code>go</code> 函数的参数 <code>i</code> 和刚刚声明的变量 <code>fn</code> 作为参数传给了它。<br><strong><code>func()</code> 代表的是既无参数声明也无结果声明的函数类型</strong>。</p>\n<p><code>trigger</code> 函数会不断地获取一个名叫 <code>count</code> 的变量的值，并判断该值是否与参数 <code>i</code> 的值相同。如果相同，那么就立<br>即调用 <code>fn</code> 代表的函数，然后把 <code>count</code> 变量的值加 <code>1</code>，最后显式地退出当前的循环。否则，我们就先让当前的<br><code>goroutine</code> “睡眠”一个纳秒再进入下一个迭代。</p>\n<p>操作变量 <code>count</code> 的时候使用的都是原子操作。这是由于 <code>trigger</code> 函数会被多个 <code>goroutine</code> 并发地调用，所以它用到的<br>非本地变量 <code>count</code>，就被多个用户级线程共用了。因此，对它的操作就产生了竞态条件（race condition），破坏了程序的并<br>发安全性。在 <code>sync/atomic</code> 包中声明了很多用于原子操作的函数。由于我选用的原子操作函数对被操作的数值的类型有约束，所<br>以对 <code>count</code> 以及相关的变量和参数的类型进行了统一的变更（由 <code>int</code> 变为了 <code>uint32</code>）。</p>\n<p>纵观 <code>count</code> 变量、<code>trigger</code> 函数以及改造后的 <code>for</code> 语句和 <code>go</code> 函数，我要做的是，让 <code>count</code> 变量成为一个信号，<br>它的值总是下一个可以调用打印函数的 <code>go</code> 函数的序号。</p>\n<p>这个序号其实就是启用 <code>goroutine</code> 时，那个当次迭代的序号。</p>\n<p>依然想让主 <code>goroutine</code> 最后一个运行完毕，所以还需要加一行代码。不过既然有了 <code>trigger</code> 函数，就没有再使用通道。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">trigger(<span class=\"number\">10</span>, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span>&#123;&#125;)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Gosched\"><a href=\"#Gosched\" class=\"headerlink\" title=\"Gosched\"></a>Gosched</h3><p><code>runtime.Gosched()</code> 暂停，释放线程去执行其他任务。</p>\n<h3 id=\"Goexit\"><a href=\"#Goexit\" class=\"headerlink\" title=\"Goexit\"></a>Goexit</h3><p><code>runtime.Goexit()</code> 立即终止当前任务，runtime 会确保所有 defer 函数被执行。该函数不会影响其他并发任务。</p>\n<h3 id=\"goroutine-泄漏\"><a href=\"#goroutine-泄漏\" class=\"headerlink\" title=\"goroutine 泄漏\"></a>goroutine 泄漏</h3><p><code>goroutine</code> 被永远卡住，就会导致 <code>goroutine</code> 泄漏，例如当使用了无缓存的 <code>channel</code>，<code>goroutine</code> 因为 <code>channel</code> 的<br>数据没有被接收而被卡住。泄漏的 <code>goroutine</code> 不会被自动回收。</p>\n<h2 id=\"Goroutine-调度器\"><a href=\"#Goroutine-调度器\" class=\"headerlink\" title=\"Goroutine 调度器\"></a>Goroutine 调度器</h2><h3 id=\"调度器\"><a href=\"#调度器\" class=\"headerlink\" title=\"调度器\"></a>调度器</h3><p>Go 的 runtime 负责对 <code>goroutine</code> 进行“调度”。调度本质上就是决定何时哪个 <code>goroutine</code> 将获得资源开始执行、哪个 <code>goroutine</code><br>应该停止执行让出资源、哪个 <code>goroutine</code> 应该被唤醒恢复执行等。</p>\n<p>操作系统对进程、线程的调度是指操作系统调度器将系统中的多个线程按照一定算法调度到物理 CPU 上去运行。C、C++ 等的并发实现就是基<br>于操作系统调度的，即程序负责创建线程，操作系统负责调度。但是这种支持并发的方式有不少缺陷：</p>\n<ul>\n<li>对于很多网络服务程序，由于不能大量创建 thread，就要在少量 thread 里做网络多路复用，即：<br>使用 <code>epoll/kqueue/IoCompletionPort</code> 这套机制，即便有 <code>libevent/libev</code> 这样的第三方库帮忙，写起这样的程序也是很不易的</li>\n<li>一个 thread 的代价已经比进程小了很多了，但我们依然不能大量创建 thread，因为除了每个 thread 占用的资源不小之外，操<br>作系统调度切换 thread 的代价也不小；</li>\n<li>并发单元间通信困难，易错：多个 thread 之间的通信虽然有多种机制可选，但用起来是相当复杂；</li>\n</ul>\n<p>Go采用了<strong>用户层轻量级 thread</strong> 或者说是<strong>类 coroutine</strong> 的概念来解决这些问题，Go 将之称为 <strong>goroutine</strong>。</p>\n<p><strong>goroutine 占用的资源非常小(goroutine stack 的 size 默认为 2k)，goroutine 调度的切换也不用操作系统内核层完成，代价很低</strong>。<br>所有的 Go 代码都在 goroutine 中执行，go runtime 也一样。将这些 goroutines 按照一定算法放到“CPU”上执行的程序就叫做<br><strong>goroutine 调度器</strong>或 <strong>goroutine scheduler</strong>。</p>\n<p><strong>一个 Go 程序对于操作系统来说只是一个用户层程序，对于操作系统而言，它的眼中只有 thread，它并不知道什么是 Goroutine。<br>goroutine 的调度全要靠 Go 自己完成，实现 Go 程序内 goroutine 之间“公平”的竞争 CPU 资源，这个任务就落到了 Go runtime 头上</strong>，<br>在一个 Go 程序中，除了用户代码，剩下的就是 go runtime 了。</p>\n<p>Goroutine 的调度问题就变成了 <strong>go runtime 如何将程序内的众多 goroutine 按照一定算法调度到 CPU 资源上运行</strong>了。</p>\n<p>但是在<strong>操作系统层面，Thread 竞争的 CPU 资源是真实的物理 CPU</strong>，但在 Go 程序层面，各个 Goroutine 要竞争的 CPU 资源是什么呢？</p>\n<p>Go 程序是用户层程序，它本身整体是运行在一个或多个操作系统线程上的，因此 <strong>goroutine 们要竞争的所谓 CPU 资源就是操作系统线程</strong>。</p>\n<p>Go scheduler 的任务：<strong>将 goroutines 按照一定算法放到不同的操作系统线程中去执行</strong>。这种在语言层面自带调度器的，我们称<br>之为<strong>原生支持并发</strong>。</p>\n<h3 id=\"G-P-M-模型\"><a href=\"#G-P-M-模型\" class=\"headerlink\" title=\"G-P-M 模型\"></a>G-P-M 模型</h3><p>调度器的主要有 3 个重要部分，分别是 M、G、P。</p>\n<ul>\n<li>G（goroutine 的缩写）， 协程的实体，并不是执行体，仅保存了并发任务的状态，包括了调用栈，重要的调度信息，例如 channel 等。<br>G 任务创建之后被放置在 P 本地队列或者全局队列，等待工作线程调度。</li>\n<li>P（processor 的缩写），是衔接 M 和 G 的调度上下文，一个 P 可以承载若干个 G，且能够使这些 G 适时地与 M 进行<br>对接，并得到真正运行的中介。P 的数量可以通过 <code>runtime.GOMAXPROCS()</code> 来设置，P 的数量决定了系统内最大可并行的 G 的数量，<br>即有多少个 <code>goroutine</code> 可以同时运行。（前提：系统的物理 <code>cpu 核数 &gt;= P 的数量</code>），它维护了一个 G 队列（<strong>runq</strong>），里面存储<br>了所有需要它来执行的 G。</li>\n<li>M（machine 的缩写），代表的是系统线程。G 就是跑在 M 之上的。在绑定有效的 P 后，进入 schedule 循环；<br>而 schedule 循环的机制大致是从各种队列、P 的本地队列中获取 G，切换到 G 的执行栈上并执行 G 的函数，调用 goexit 做清理工作<br>并回到 M，如此反复。M 并不保留 G 状态，这是 G 可以跨 M 调度的基础。</li>\n</ul>\n<p><img src=\"../imgs/goroutine-scheduler-model.png\" alt></p>\n<p>简单来说，一个 G 的执行需要 P 和 M 的支持，P 和 M 绑定之后，就形成了一个 G 的运行环境（内核线程和上下文）。</p>\n<p>P 和 M 构成执行组合体，但两者的数量并不是一一对应的。一般情况下， <strong>P 的数量相对恒定，默认与 CPU 核数相同，可能更多或更少。<br>M 是由调度器按需创建的</strong>。比如，如果一个 M 因系统调用时间长而阻塞，P 就会被监控线程抢走，并且新建一个 M 执行其他任务，M<br>的数量就增加了。</p>\n<p>所有 P 是在调度器初始化阶段创建的，虽然可以使用 <code>runtime.GOMAXPROCS()</code> 在运行期间修改 P 的数量，但是代价很大。</p>\n<h3 id=\"抢占式调度\"><a href=\"#抢占式调度\" class=\"headerlink\" title=\"抢占式调度\"></a>抢占式调度</h3><p>Go 并没有时间片的概念，只是在目标 G 上设置一个抢占标志。如果某个 G 没有进行 syscall、没有进行 I/O 操作、没有阻塞在一<br>个 channel 操作上，那么 M 是<strong>如何让 G 停下来并调度下一个 runnable G</strong> 的呢？</p>\n<p>答案是：G 是被抢占调度的。</p>\n<p>Go 在设计之初并没考虑将 goroutine 设计成抢占式的。用户负责让各个 goroutine 交互合作完成任务。一个 goroutine 只有在涉及到加锁，<br>读写通道或者主动让出 CPU 等操作时才会触发切换。</p>\n<p>垃圾回收器是需要 stop the world 的。如果垃圾回收器想要运行了，那么它必须先通知其它的 goroutine 合作停下来，这会造成较长时<br>间的等待时间。考虑一种很极端的情况，所有的 goroutine 都停下来了，只有其中一个没有停，那么垃圾回收就会一直等待着没有停的那一个。</p>\n<p>抢占式调度可以解决这种问题，在抢占式情况下，如果一个 goroutine 运行时间过长，它就会被剥夺运行权。Go 还只是引入了一些很初级<br>的抢占，只有长时间阻塞于系统调用，或者运行了较长时间才会被抢占。runtime 会在后台有一个检测线程，它会检测这些情况，<br>并通知 goroutine 执行调度。</p>\n<p>Go 程序的初始化过程中，runtime 开了一条后台线程，运行一个 <code>sysmon</code> 函数(一般称为监控线程)。这个函数会周期性地做 epoll 操作，<br>同时它还会检测每个 P 是否运行了较长时间。该 M 无需绑定 P 即可运行，该 M 在整个 Go 程序的运行过程中至关重要。</p>\n<p><code>sysmon</code> 每 <code>20us~10ms</code> 运行一次，<code>sysmon</code> 主要完成如下工作：</p>\n<ul>\n<li>释放闲置超过 5 分钟的 span 物理内存；</li>\n<li>如果超过 2 分钟没有垃圾回收，强制执行；</li>\n<li>将长时间未处理的 netpoll 结果添加到任务队列；</li>\n<li>向长时间运行的 G 任务发出抢占调度；</li>\n<li>收回因 syscall 长时间阻塞的 P；</li>\n</ul>\n<h3 id=\"channel-阻塞或-network-I-O-情况下的调度\"><a href=\"#channel-阻塞或-network-I-O-情况下的调度\" class=\"headerlink\" title=\"channel 阻塞或 network I/O 情况下的调度\"></a>channel 阻塞或 network I/O 情况下的调度</h3><p>如果 G 被阻塞在某个 channel 操作或 network I/O 操作上时，G 会被放置到某个 wait 队列中，而 M 会尝试运行下一个 runnable<br>的 G；如果此时没有 runnable 的 G 供 M 运行，那么 M 将解绑 P，并进入 sleep 状态。当 I/O available 或 channel 操作完成，<br>在 wait 队列中的 G 会被唤醒，标记为 runnable，放入到某 P 的队列中，绑定一个 M 继续执行。</p>\n<h3 id=\"system-call-阻塞情况下的调度\"><a href=\"#system-call-阻塞情况下的调度\" class=\"headerlink\" title=\"system call 阻塞情况下的调度\"></a>system call 阻塞情况下的调度</h3><p>如果 G 被阻塞在某个 system call 操作上，那么不光 G 会阻塞，执行该 G 的 M 也会解绑 P(实质是被 sysmon 抢走了)，<br>与 G 一起进入 sleep 状态。如果此时有 idle 的 M，则 P 与其绑定继续执行其他 G；如果没有 idle M，但仍然有其他 G 要去执行，<br>那么就会创建一个新 M。</p>\n<p>当阻塞在 syscall 上的 G 完成 syscall 调用后，G 会去尝试获取一个可用的 P，如果没有可用的 P，那么 G 会被标记为 runnable，<br>之前的那个 sleep 的 M 将再次进入 sleep。</p>\n","site":{"data":{"navigation":{"logo":{"text":"Golang Learn","type":"link","path":"index.html"},"main":[{"text":"Golang 基础","type":"label"},{"text":"Go 环境配置","type":"link","path":"basic/env_config.html"},{"text":"包","type":"link","path":"basic/package.html"},{"text":"基础数据类型","type":"link","path":"basic/basic_data.html"},{"text":"变量","type":"link","path":"basic/var.html"},{"text":"常量","type":"link","path":"basic/constant.html"},{"text":"控制语句","type":"link","path":"basic/flow.html"},{"text":"运算符","type":"link","path":"basic/operator.html"},{"text":"作用域","type":"link","path":"basic/scope.html"},{"text":"指针","type":"link","path":"basic/pointer.html"},{"text":"数组","type":"link","path":"basic/array.html"},{"text":"切片","type":"link","path":"basic/slice.html"},{"text":"字典","type":"link","path":"basic/map.html"},{"text":"函数","type":"link","path":"basic/function.html"},{"text":"结构体","type":"link","path":"basic/struct.html"},{"text":"接口","type":"link","path":"basic/interface.html"},{"text":"面向对象","type":"link","path":"basic/oop.html"},{"text":"错误","type":"link","path":"basic/error.html"},{"text":"序列化","type":"link","path":"basic/json.html"},{"text":"反射","type":"link","path":"basic/reflect.html"},{"text":"测试","type":"link","path":"basic/test.html"},{"text":"并发编程","type":"label"},{"text":"goroutine","type":"link","path":"concurrent/goroutine.html"},{"text":"channel","type":"link","path":"concurrent/channel.html"},{"text":"同步和锁","type":"link","path":"concurrent/sync_lock.html"},{"text":"内存分配","type":"label"},{"text":"内存分配","type":"link","path":"advance/mm.html"},{"text":"垃圾回收","type":"label"},{"text":"垃圾回收","type":"link","path":"advance/gc.html"},{"text":"标准库","type":"label"},{"text":"fmt","type":"link","path":"standards/io/fmt.html"},{"text":"io","type":"link","path":"standards/io/io.html"},{"text":"ioutil","type":"link","path":"standards/io/ioutil.html"},{"text":"bufio","type":"link","path":"standards/io/bufio.html"},{"text":"os","type":"link","path":"standards/os/os.html"},{"text":"filepath","type":"link","path":"standards/os/filepath.html"},{"text":"strings","type":"link","path":"standards/text/strings.html"},{"text":"strconv","type":"link","path":"standards/text/strconv.html"},{"text":"unicode","type":"link","path":"standards/text/unicode.html"},{"text":"log","type":"link","path":"standards/log.html"},{"text":"time","type":"link","path":"standards/time.html"},{"text":"http","type":"link","path":"standards/net/http.html"},{"text":"math","type":"link","path":"standards/data/math.html"},{"text":"sort","type":"link","path":"standards/data/sort.html"},{"text":"big","type":"link","path":"standards/data/big.html"},{"text":"container","type":"link","path":"standards/data/container.html"},{"text":"sql","type":"link","path":"standards/database/sql.html"},{"text":"THEME","type":"label"},{"text":"使用文档主题","type":"link","path":"theme/theme-usage.html"},{"text":"SUPPORT AND FEEDBACK","type":"label"},{"text":"Raise an Issue on Github","type":"link","path":"https://github.com/shipengqi/golang-learn/issues/new"}]}}},"excerpt":"","more":"<h1 id=\"goroutine\"><a href=\"#goroutine\" class=\"headerlink\" title=\"goroutine\"></a>goroutine</h1><h2 id=\"并发和并行\"><a href=\"#并发和并行\" class=\"headerlink\" title=\"并发和并行\"></a>并发和并行</h2><h3 id=\"并发\"><a href=\"#并发\" class=\"headerlink\" title=\"并发\"></a>并发</h3><p>一个 cpu 上能同时执行多项任务，在很短时间内，cpu 来回切换任务执行(在某段很短时间内执行程序 a，然后又迅速得切换到程序 b 去执行)，<br>有时间上的重叠（宏观上是同时的，微观仍是顺序执行）,这样看起来多个任务像是同时执行，这就是<strong>并发</strong>。</p>\n<h3 id=\"并行\"><a href=\"#并行\" class=\"headerlink\" title=\"并行\"></a>并行</h3><p>当系统有多个 CPU 时,每个 CPU 同一时刻都运行任务，互不抢占自己所在的 CPU 资源，同时进行，称为<strong>并行</strong>。并行是并发设计的<br>理想模式。</p>\n<h3 id=\"进程\"><a href=\"#进程\" class=\"headerlink\" title=\"进程\"></a>进程</h3><p>cpu 在切换程序的时候，如果不保存上一个程序的状态（也就是我们常说的 <code>context</code> –上下文），直接切换下一个程序，就会丢失上一个<br>程序的一系列状态，于是引入了进程这个概念，用以划分好程序运行时所需要的资源。因此进程就是一个程序运行时候的所需要的基本资源单<br>位（也可以说是程序运行的一个实体）。</p>\n<h3 id=\"线程\"><a href=\"#线程\" class=\"headerlink\" title=\"线程\"></a>线程</h3><p>cpu 切换多个进程的时候，会花费不少的时间，因为切换进程需要切换到内核态，而每次调度需要内核态都需要读取用户态的数据，进程<br>一旦多起来，cpu 调度会消耗一大堆资源，因此引入了线程的概念，线程本身几乎不占有资源，他们共享进程里的资源，内核调度起来不<br>会那么像进程切换那么耗费资源。</p>\n<h3 id=\"协程\"><a href=\"#协程\" class=\"headerlink\" title=\"协程\"></a>协程</h3><p>多线程和多进程是并行的基本条件，但是单线程可以利用<strong>协程</strong>做到并发。协程拥有自己的寄存器上下文和栈。协程在线程上通过主动<br>切换来实现并发，减少了阻塞时间，还避免了线程切换的开销。但协程运行的并发本质上还是串行的。线程和进程的操作是由程序触发系统<br>接口，最后的执行者是系统；协程的操作执行者则是用户自身程序。</p>\n<h2 id=\"goroutine-1\"><a href=\"#goroutine-1\" class=\"headerlink\" title=\"goroutine\"></a>goroutine</h2><p>Go 语言在语言层面上支持了并发，简单将 <code>goroutine</code> 归为协程并不合适。Go runtime 会创建多个线程来执行并发任务，而且任务<br>可以跨线程调度。所以 goroutine 更像是多线程和协程的结合体。</p>\n<p><code>goroutine</code> 可以简单理解为协程，开销较低 (大概是 <code>4~5KB</code> )，当然会根据相应的数据伸缩。也正因为如此，可同时运行成千<br>上万个并发任务。<code>goroutine</code> 比 <code>thread</code> 更易用、更高效、更轻便。我们程序运行的 <strong><code>main</code> 函数在一个单独的 <code>goroutine</code> 中运行，<br>叫做 <code>主 goroutine</code></strong>。在代码中可以使用 <strong><code>go</code> 关键字创建 <code>goroutine</code></strong>。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">go</span> f()</span><br></pre></td></tr></table></figure>\n<p><strong><code>main</code> 函数返回时，所有 <code>goroutine</code> 都会被打断，程序退出</strong>。除了从 <code>main</code> 函数退出或者直接终止程序之外，没有其它<br>的编程方法能够让一个 <code>goroutine</code> 来打断另一个的执行，但是之后可以看到一种方式来实现这个目的，通过 <code>goroutine</code> 之间<br>的通信来让一个 <code>goroutine</code> 请求其它的 <code>goroutine</code>，使被请求 <code>goroutine</code> 自行结束执行。</p>\n<h3 id=\"什么是主-goroutine，它与我们启用的其他-goroutine-有什么不同\"><a href=\"#什么是主-goroutine，它与我们启用的其他-goroutine-有什么不同\" class=\"headerlink\" title=\"什么是主 goroutine，它与我们启用的其他 goroutine 有什么不同\"></a>什么是主 goroutine，它与我们启用的其他 goroutine 有什么不同</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"fmt\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++ &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\t\tfmt.Println(i)</span><br><span class=\"line\">\t\t&#125;()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的代码会打印出什么内容？</p>\n<p>回答是：不会有任何内容被打印出来。</p>\n<p>Go 语言不但有着独特的并发编程模型，以及用户级线程 <code>goroutine</code>，还拥有强大的用于调度 <code>goroutine</code>、对接系统级线程的<br><strong>调度器</strong>。</p>\n<p>调度器的主要有 3 个重要部分，分别是 M、G、P。</p>\n<ul>\n<li>G（goroutine 的缩写）， 协程的实体，包括了调用栈，重要的调度信息，例如 channel 等。</li>\n<li>P（processor 的缩写），是衔接 M 和 G 的调度上下文，一个 P 可以承载若干个 G，且能够使这些 G 适时地与 M 进行<br>对接，并得到真正运行的中介。P 的数量可以通过 <code>runtime.GOMAXPROCS()</code> 来设置，P 的数量决定了系统内最大可并行的 G 的数量，<br>即有多少个 <code>goroutine</code> 可以同时运行。</li>\n<li>M（machine 的缩写），代表的是系统级线程，由操作系统管理。</li>\n</ul>\n<p>与一个进程总会有一个主线程类似，每一个独立的 Go 程序在运行时也总会有一个主 <code>goroutine</code>。这个主 <code>goroutine</code> 会在 Go 程<br>序的运行准备工作完成后被自动地启用，并不需要我们做任何手动的操作。</p>\n<p><strong>每条 <code>go</code> 语句一般都会携带一个函数调用，这个被调用的函数常常被称为 <code>go</code> 函数。而主 <code>goroutine</code> 的 <code>go</code> 函数就是<br>那个作为程序入口的 <code>main</code> 函数</strong>。</p>\n<p><strong><code>go</code> 函数真正被执行的时间总会与其所属的 <code>go</code> 语句被执行的时间不同</strong>。</p>\n<p>当程序执行到一条 <code>go</code> 语句的时候，<strong><code>go</code> 关键字并不是执行并发操作，而是创建一个并发任务单元</strong>。Go 语言的运行时系统，会先试图从某个<br>存放空闲的 G 的队列中获取一个 G（也就是 <code>goroutine</code>），它只有在找不到空闲 G 的情况下才会去创建一个新的 G。已存在<br>的 goroutine 总是会被优先复用。</p>\n<p>在拿到了一个空闲的 G 之后，Go 语言运行时系统会用这个 G 去包装当前的那个 <code>go</code> 函数（或者说该函数中的那些代码），然后再把这<br>个 G 追加到某个存放可运行的 G 的队列中。这类队列中的 G 总是会按照先入先出的顺序，很快地由运行时系统内部的调度器安排运行。<br>虽然这会很快，但是由于上面所说的那些准备工作还是不可避免的，所以耗时还是存在的。</p>\n<p>因此，<strong><code>go</code> 函数的执行时间总是会明显滞后于它所属的 <code>go</code> 语句的执行时间</strong>。当然了，这里所说的“明显滞后”是对于计算机<br>的 CPU 时钟和 Go 程序来说的。我们在大多数时候都不会有明显的感觉。</p>\n<p>请记住，<strong>只要 <code>go</code> 语句本身执行完毕，Go 程序完全不会等待 <code>go</code> 函数的执行，它会立刻去执行后边的语句</strong>。这就是所谓<br>的<strong>异步并发</strong>地执行。</p>\n<p>上面的代码中那 10 个包装了 <code>go</code> 函数的 <code>goroutine</code> 往往还没有获得运行的机会。但是如果有机会运行，打印的结果是什么，<br>全是 <code>10</code>？</p>\n<p>当 <code>for</code> 语句的最后一个迭代运行的时候，其中的那条 <code>go</code> 语句即是最后一条语句。所以，在执行完这条 <code>go</code> 语句之后，<br>主 <code>goroutine</code> 中的代码也就执行完了，Go 程序会立即结束运行。那么，如果这样的话，还会有任何内容被打印出来吗？</p>\n<p>Go 语言并不会去保证这些 <code>goroutine</code> 会以怎样的顺序运行。由于主 <code>goroutine</code> 会与我们手动启用的其他 <code>goroutine</code> 一起接受<br>调度，又因为调度器很可能会在 <code>goroutine</code> 中的代码只执行了一部分的时候暂停，以期所有的 goroutine 有更公平的运行机会。</p>\n<p>所以哪个 <code>goroutine</code> 先执行完、哪个 <code>goroutine</code> 后执行完往往是不可预知的，除非我们使用了某种 Go 语言提供的方式进行了人为<br>干预。</p>\n<h3 id=\"怎样才能让主-goroutine-等待其他-goroutine\"><a href=\"#怎样才能让主-goroutine-等待其他-goroutine\" class=\"headerlink\" title=\"怎样才能让主 goroutine 等待其他 goroutine\"></a>怎样才能让主 goroutine 等待其他 goroutine</h3><p>刚才说过，一旦主 <code>goroutine</code> 中的代码执行完毕，当前的 Go 程序就会结束运行，无论其他的 <code>goroutine</code> 是否已经在运行了。<br>那么，怎样才能做到等其他的 <code>goroutine</code> 运行完毕之后，再让主 <code>goroutine</code> 结束运行呢？</p>\n<ol>\n<li><strong>使用 <code>time</code> 包</strong>，可以简单粗暴的 <code>time.Sleep(time.Millisecond * 500)</code> 让主 <code>goroutine</code> “小睡”一会儿。<br>在这里传入了“500 毫秒”</li>\n</ol>\n<p>问题是我们让主 <code>goroutine</code> “睡眠”多长时间才是合适的呢？如果“睡眠”太短，则很可能不足以让其他的 <code>goroutine</code> 运行完毕，<br>而若“睡眠”太长则纯属浪费时间，这个时间就太难把握了。</p>\n<ol>\n<li><strong>使用通道</strong>。</li>\n<li><strong>使用 <code>sync</code> 包的 <code>sync.WaitGroup</code> 类型</strong></li>\n</ol>\n<h3 id=\"怎样让启用的多个-goroutine-按照既定的顺序运行\"><a href=\"#怎样让启用的多个-goroutine-按照既定的顺序运行\" class=\"headerlink\" title=\"怎样让启用的多个 goroutine 按照既定的顺序运行\"></a>怎样让启用的多个 goroutine 按照既定的顺序运行</h3><p>首先，我们需要稍微改造一下 <code>for</code> 语句中的那个 <code>go</code> 函数:<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++ &#123;</span><br><span class=\"line\">    <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(i <span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">        fmt.Println(i)</span><br><span class=\"line\">    &#125;(i)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>只有这样，Go 语言才能保证每个 <code>goroutine</code> 都可以拿到一个唯一的整数。这里有点像 js。</p>\n<p>在 <code>go</code> 语句被执行时，我们<strong>传给 <code>go</code> 函数的参数 <code>i</code> 会先被求值</strong>，如此就得到了当次迭代的序号。之后，无论 <code>go</code> 函数<br>会在什么时候执行，这个参数值都不会变。也就是说，<code>go</code> 函数中调用的 <code>fmt.Println</code> 函数打印的一定会是那个当次迭代的序号。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> count <span class=\"keyword\">uint32</span> = <span class=\"number\">0</span></span><br><span class=\"line\">trigger := <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(i <span class=\"keyword\">uint32</span>, fn <span class=\"keyword\">func</span>()</span>)</span> &#123; <span class=\"comment\">// func() 代表的是既无参数声明也无结果声明的函数类型</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> n := atomic.LoadUint32(&amp;count); n == i &#123;</span><br><span class=\"line\">            fn()</span><br><span class=\"line\">            atomic.AddUint32(&amp;count, <span class=\"number\">1</span>)</span><br><span class=\"line\">            <span class=\"keyword\">break</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        time.Sleep(time.Nanosecond)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">for</span> i := <span class=\"keyword\">uint32</span>(<span class=\"number\">0</span>); i &lt; <span class=\"number\">10</span>; i++ &#123;</span><br><span class=\"line\">    <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(i <span class=\"keyword\">uint32</span>)</span></span> &#123;</span><br><span class=\"line\">        fn := <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">            fmt.Println(i)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        trigger(i, fn)</span><br><span class=\"line\">    &#125;(i)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">trigger(<span class=\"number\">10</span>, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span>&#123;&#125;)</span><br></pre></td></tr></table></figure>\n<p>上面的代码中调用了一个名叫 <code>trigger</code> 的函数，并把 <code>go</code> 函数的参数 <code>i</code> 和刚刚声明的变量 <code>fn</code> 作为参数传给了它。<br><strong><code>func()</code> 代表的是既无参数声明也无结果声明的函数类型</strong>。</p>\n<p><code>trigger</code> 函数会不断地获取一个名叫 <code>count</code> 的变量的值，并判断该值是否与参数 <code>i</code> 的值相同。如果相同，那么就立<br>即调用 <code>fn</code> 代表的函数，然后把 <code>count</code> 变量的值加 <code>1</code>，最后显式地退出当前的循环。否则，我们就先让当前的<br><code>goroutine</code> “睡眠”一个纳秒再进入下一个迭代。</p>\n<p>操作变量 <code>count</code> 的时候使用的都是原子操作。这是由于 <code>trigger</code> 函数会被多个 <code>goroutine</code> 并发地调用，所以它用到的<br>非本地变量 <code>count</code>，就被多个用户级线程共用了。因此，对它的操作就产生了竞态条件（race condition），破坏了程序的并<br>发安全性。在 <code>sync/atomic</code> 包中声明了很多用于原子操作的函数。由于我选用的原子操作函数对被操作的数值的类型有约束，所<br>以对 <code>count</code> 以及相关的变量和参数的类型进行了统一的变更（由 <code>int</code> 变为了 <code>uint32</code>）。</p>\n<p>纵观 <code>count</code> 变量、<code>trigger</code> 函数以及改造后的 <code>for</code> 语句和 <code>go</code> 函数，我要做的是，让 <code>count</code> 变量成为一个信号，<br>它的值总是下一个可以调用打印函数的 <code>go</code> 函数的序号。</p>\n<p>这个序号其实就是启用 <code>goroutine</code> 时，那个当次迭代的序号。</p>\n<p>依然想让主 <code>goroutine</code> 最后一个运行完毕，所以还需要加一行代码。不过既然有了 <code>trigger</code> 函数，就没有再使用通道。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">trigger(<span class=\"number\">10</span>, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span>&#123;&#125;)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Gosched\"><a href=\"#Gosched\" class=\"headerlink\" title=\"Gosched\"></a>Gosched</h3><p><code>runtime.Gosched()</code> 暂停，释放线程去执行其他任务。</p>\n<h3 id=\"Goexit\"><a href=\"#Goexit\" class=\"headerlink\" title=\"Goexit\"></a>Goexit</h3><p><code>runtime.Goexit()</code> 立即终止当前任务，runtime 会确保所有 defer 函数被执行。该函数不会影响其他并发任务。</p>\n<h3 id=\"goroutine-泄漏\"><a href=\"#goroutine-泄漏\" class=\"headerlink\" title=\"goroutine 泄漏\"></a>goroutine 泄漏</h3><p><code>goroutine</code> 被永远卡住，就会导致 <code>goroutine</code> 泄漏，例如当使用了无缓存的 <code>channel</code>，<code>goroutine</code> 因为 <code>channel</code> 的<br>数据没有被接收而被卡住。泄漏的 <code>goroutine</code> 不会被自动回收。</p>\n<h2 id=\"Goroutine-调度器\"><a href=\"#Goroutine-调度器\" class=\"headerlink\" title=\"Goroutine 调度器\"></a>Goroutine 调度器</h2><h3 id=\"调度器\"><a href=\"#调度器\" class=\"headerlink\" title=\"调度器\"></a>调度器</h3><p>Go 的 runtime 负责对 <code>goroutine</code> 进行“调度”。调度本质上就是决定何时哪个 <code>goroutine</code> 将获得资源开始执行、哪个 <code>goroutine</code><br>应该停止执行让出资源、哪个 <code>goroutine</code> 应该被唤醒恢复执行等。</p>\n<p>操作系统对进程、线程的调度是指操作系统调度器将系统中的多个线程按照一定算法调度到物理 CPU 上去运行。C、C++ 等的并发实现就是基<br>于操作系统调度的，即程序负责创建线程，操作系统负责调度。但是这种支持并发的方式有不少缺陷：</p>\n<ul>\n<li>对于很多网络服务程序，由于不能大量创建 thread，就要在少量 thread 里做网络多路复用，即：<br>使用 <code>epoll/kqueue/IoCompletionPort</code> 这套机制，即便有 <code>libevent/libev</code> 这样的第三方库帮忙，写起这样的程序也是很不易的</li>\n<li>一个 thread 的代价已经比进程小了很多了，但我们依然不能大量创建 thread，因为除了每个 thread 占用的资源不小之外，操<br>作系统调度切换 thread 的代价也不小；</li>\n<li>并发单元间通信困难，易错：多个 thread 之间的通信虽然有多种机制可选，但用起来是相当复杂；</li>\n</ul>\n<p>Go采用了<strong>用户层轻量级 thread</strong> 或者说是<strong>类 coroutine</strong> 的概念来解决这些问题，Go 将之称为 <strong>goroutine</strong>。</p>\n<p><strong>goroutine 占用的资源非常小(goroutine stack 的 size 默认为 2k)，goroutine 调度的切换也不用操作系统内核层完成，代价很低</strong>。<br>所有的 Go 代码都在 goroutine 中执行，go runtime 也一样。将这些 goroutines 按照一定算法放到“CPU”上执行的程序就叫做<br><strong>goroutine 调度器</strong>或 <strong>goroutine scheduler</strong>。</p>\n<p><strong>一个 Go 程序对于操作系统来说只是一个用户层程序，对于操作系统而言，它的眼中只有 thread，它并不知道什么是 Goroutine。<br>goroutine 的调度全要靠 Go 自己完成，实现 Go 程序内 goroutine 之间“公平”的竞争 CPU 资源，这个任务就落到了 Go runtime 头上</strong>，<br>在一个 Go 程序中，除了用户代码，剩下的就是 go runtime 了。</p>\n<p>Goroutine 的调度问题就变成了 <strong>go runtime 如何将程序内的众多 goroutine 按照一定算法调度到 CPU 资源上运行</strong>了。</p>\n<p>但是在<strong>操作系统层面，Thread 竞争的 CPU 资源是真实的物理 CPU</strong>，但在 Go 程序层面，各个 Goroutine 要竞争的 CPU 资源是什么呢？</p>\n<p>Go 程序是用户层程序，它本身整体是运行在一个或多个操作系统线程上的，因此 <strong>goroutine 们要竞争的所谓 CPU 资源就是操作系统线程</strong>。</p>\n<p>Go scheduler 的任务：<strong>将 goroutines 按照一定算法放到不同的操作系统线程中去执行</strong>。这种在语言层面自带调度器的，我们称<br>之为<strong>原生支持并发</strong>。</p>\n<h3 id=\"G-P-M-模型\"><a href=\"#G-P-M-模型\" class=\"headerlink\" title=\"G-P-M 模型\"></a>G-P-M 模型</h3><p>调度器的主要有 3 个重要部分，分别是 M、G、P。</p>\n<ul>\n<li>G（goroutine 的缩写）， 协程的实体，并不是执行体，仅保存了并发任务的状态，包括了调用栈，重要的调度信息，例如 channel 等。<br>G 任务创建之后被放置在 P 本地队列或者全局队列，等待工作线程调度。</li>\n<li>P（processor 的缩写），是衔接 M 和 G 的调度上下文，一个 P 可以承载若干个 G，且能够使这些 G 适时地与 M 进行<br>对接，并得到真正运行的中介。P 的数量可以通过 <code>runtime.GOMAXPROCS()</code> 来设置，P 的数量决定了系统内最大可并行的 G 的数量，<br>即有多少个 <code>goroutine</code> 可以同时运行。（前提：系统的物理 <code>cpu 核数 &gt;= P 的数量</code>），它维护了一个 G 队列（<strong>runq</strong>），里面存储<br>了所有需要它来执行的 G。</li>\n<li>M（machine 的缩写），代表的是系统线程。G 就是跑在 M 之上的。在绑定有效的 P 后，进入 schedule 循环；<br>而 schedule 循环的机制大致是从各种队列、P 的本地队列中获取 G，切换到 G 的执行栈上并执行 G 的函数，调用 goexit 做清理工作<br>并回到 M，如此反复。M 并不保留 G 状态，这是 G 可以跨 M 调度的基础。</li>\n</ul>\n<p><img src=\"../imgs/goroutine-scheduler-model.png\" alt></p>\n<p>简单来说，一个 G 的执行需要 P 和 M 的支持，P 和 M 绑定之后，就形成了一个 G 的运行环境（内核线程和上下文）。</p>\n<p>P 和 M 构成执行组合体，但两者的数量并不是一一对应的。一般情况下， <strong>P 的数量相对恒定，默认与 CPU 核数相同，可能更多或更少。<br>M 是由调度器按需创建的</strong>。比如，如果一个 M 因系统调用时间长而阻塞，P 就会被监控线程抢走，并且新建一个 M 执行其他任务，M<br>的数量就增加了。</p>\n<p>所有 P 是在调度器初始化阶段创建的，虽然可以使用 <code>runtime.GOMAXPROCS()</code> 在运行期间修改 P 的数量，但是代价很大。</p>\n<h3 id=\"抢占式调度\"><a href=\"#抢占式调度\" class=\"headerlink\" title=\"抢占式调度\"></a>抢占式调度</h3><p>Go 并没有时间片的概念，只是在目标 G 上设置一个抢占标志。如果某个 G 没有进行 syscall、没有进行 I/O 操作、没有阻塞在一<br>个 channel 操作上，那么 M 是<strong>如何让 G 停下来并调度下一个 runnable G</strong> 的呢？</p>\n<p>答案是：G 是被抢占调度的。</p>\n<p>Go 在设计之初并没考虑将 goroutine 设计成抢占式的。用户负责让各个 goroutine 交互合作完成任务。一个 goroutine 只有在涉及到加锁，<br>读写通道或者主动让出 CPU 等操作时才会触发切换。</p>\n<p>垃圾回收器是需要 stop the world 的。如果垃圾回收器想要运行了，那么它必须先通知其它的 goroutine 合作停下来，这会造成较长时<br>间的等待时间。考虑一种很极端的情况，所有的 goroutine 都停下来了，只有其中一个没有停，那么垃圾回收就会一直等待着没有停的那一个。</p>\n<p>抢占式调度可以解决这种问题，在抢占式情况下，如果一个 goroutine 运行时间过长，它就会被剥夺运行权。Go 还只是引入了一些很初级<br>的抢占，只有长时间阻塞于系统调用，或者运行了较长时间才会被抢占。runtime 会在后台有一个检测线程，它会检测这些情况，<br>并通知 goroutine 执行调度。</p>\n<p>Go 程序的初始化过程中，runtime 开了一条后台线程，运行一个 <code>sysmon</code> 函数(一般称为监控线程)。这个函数会周期性地做 epoll 操作，<br>同时它还会检测每个 P 是否运行了较长时间。该 M 无需绑定 P 即可运行，该 M 在整个 Go 程序的运行过程中至关重要。</p>\n<p><code>sysmon</code> 每 <code>20us~10ms</code> 运行一次，<code>sysmon</code> 主要完成如下工作：</p>\n<ul>\n<li>释放闲置超过 5 分钟的 span 物理内存；</li>\n<li>如果超过 2 分钟没有垃圾回收，强制执行；</li>\n<li>将长时间未处理的 netpoll 结果添加到任务队列；</li>\n<li>向长时间运行的 G 任务发出抢占调度；</li>\n<li>收回因 syscall 长时间阻塞的 P；</li>\n</ul>\n<h3 id=\"channel-阻塞或-network-I-O-情况下的调度\"><a href=\"#channel-阻塞或-network-I-O-情况下的调度\" class=\"headerlink\" title=\"channel 阻塞或 network I/O 情况下的调度\"></a>channel 阻塞或 network I/O 情况下的调度</h3><p>如果 G 被阻塞在某个 channel 操作或 network I/O 操作上时，G 会被放置到某个 wait 队列中，而 M 会尝试运行下一个 runnable<br>的 G；如果此时没有 runnable 的 G 供 M 运行，那么 M 将解绑 P，并进入 sleep 状态。当 I/O available 或 channel 操作完成，<br>在 wait 队列中的 G 会被唤醒，标记为 runnable，放入到某 P 的队列中，绑定一个 M 继续执行。</p>\n<h3 id=\"system-call-阻塞情况下的调度\"><a href=\"#system-call-阻塞情况下的调度\" class=\"headerlink\" title=\"system call 阻塞情况下的调度\"></a>system call 阻塞情况下的调度</h3><p>如果 G 被阻塞在某个 system call 操作上，那么不光 G 会阻塞，执行该 G 的 M 也会解绑 P(实质是被 sysmon 抢走了)，<br>与 G 一起进入 sleep 状态。如果此时有 idle 的 M，则 P 与其绑定继续执行其他 G；如果没有 idle M，但仍然有其他 G 要去执行，<br>那么就会创建一个新 M。</p>\n<p>当阻塞在 syscall 上的 G 完成 syscall 调用后，G 会去尝试获取一个可用的 P，如果没有可用的 P，那么 G 会被标记为 runnable，<br>之前的那个 sleep 的 M 将再次进入 sleep。</p>\n"},{"title":"io","_content":"\n# io\n`io` 是对输入输出设备的抽象。`io` 库对这些功能进行了抽象，通过统一的接口对输入输出设备进行操作。\n最重要的是两个接口：`Reader` 和 `Writer`。\n\n## Reader\n\nReader 接口：\n\n```go\ntype Reader interface {\n    Read(p []byte) (n int, err error)\n}\n```\n\n> `Read` 将 `len(p)` 个字节读取到 `p` 中。它返回读取的字节数 `n`（`0 <= n <= len(p)`） 以及任何遇到的错误。\n即使 `Read` 返回的 `n < len(p)`，它也会在调用过程中占用 `len(p)` 个字节作为暂存空间。若可读取的数据不到 `len(p)` 个\n字节，`Read` 会返回可用数据，而不是等待更多数据。\n\n> 当 `Read` 在成功读取 `n > 0` 个字节后遇到一个错误或 `EOF` (`end-of-file`)，它会返回读取的字节数。它可能会同时在本次的调\n用中返回一个 `non-nil` 错误,或在下一次的调用中返回这个错误（且 `n` 为 0）。 一般情况下, `Reader` 会返回一个 非 0 字节数 `n`, \n若 `n = len(p)` 个字节从输入源的结尾处由 `Read` 返回，`Read` 可能返回 `err == EOF` 或者 `err == nil`。并且之后的 `Read` \n都应该返回 (`n:0, err:EOF`)。\n\n> 调用者在考虑错误之前应当首先处理返回的数据。这样做可以正确地处理在读取一些字节后产生的 I/O 错误，同时允许 `EOF` 的出现。\n\n```go\nfunc ReadFrom(reader io.Reader, num int) ([]byte, error) {\n\tp := make([]byte, num)\n\tn, err := reader.Read(p)\n\tif n > 0 {\n\t\treturn p[:n], nil\n\t}\n\treturn p, err\n}\n```\n\n`ReadFrom` 函数将 `io.Reader` 作为参数，也就是说，`ReadFrom` 可以从任意的地方读取数据，只要来源实现了 `io.Reader` 接口。\n比如，我们可以从标准输入、文件、字符串等读取数据，示例代码如下：\n\n```go\n// 从标准输入读取\ndata, err = ReadFrom(os.Stdin, 11)\n\n// 从普通文件读取，其中 file 是 os.File 的实例\ndata, err = ReadFrom(file, 9)\n\n// 从字符串读取\ndata, err = ReadFrom(strings.NewReader(\"from string\"), 12)\n```\n\n`io.EOF` 变量的定义：`var EOF = errors.New(\"EOF\")`，是 `error` 类型。根据 `reader` 接口的说明，在 `n > 0` 且数据被读完了\n的情况下，当次返回的 `error` 有可能是 `EOF` 也有可能是 `nil`。\n\n## Writer\n\nWriter 接口：\n\n```go\ntype Writer interface {\n    Write(p []byte) (n int, err error)\n}\n```\n\n> `Write` 将 `len(p)` 个字节从 `p` 中写入到基本数据流中。它返回从 `p` 中被写入的字节数 `n`（`0 <= n <= len(p)`）以及任何遇到的引\n起写入提前停止的错误。若 `Write` 返回的 `n < len(p)`，它就必须返回一个 **非 nil** 的错误。\n\n以 `fmt.Fprintln` 为例：\n\n```go\nfunc Println(a ...interface{}) (n int, err error) {\n\treturn Fprintln(os.Stdout, a...)\n}\n```\n\n可以看出 `fmt.Println` 会将内容输出到标准输出中。\n\n\n## 实现了 io.Reader 接口或 io.Writer 接口的类型\n\n标准库中有哪些类型实现了 `io.Reader` 或 `io.Writer` 接口？\n\n例如 `os.Stdin/Stdout`，它们分别实现了 `io.Reader/io.Writer` 接口：\n\n```go\nvar (\n    Stdin  = NewFile(uintptr(syscall.Stdin), \"/dev/stdin\")\n    Stdout = NewFile(uintptr(syscall.Stdout), \"/dev/stdout\")\n    Stderr = NewFile(uintptr(syscall.Stderr), \"/dev/stderr\")\n)\n```\n\n上面的代码可以看出，`Stdin/Stdout/Stderr` 只是三个特殊的文件类型的标识（都是 `os.File` 的实例），`os.File` 实现\n了 `io.Reader` 和 `io.Writer`。\n\n实现了 `io.Reader` 或 `io.Writer` 接口的类型：\n\n- `os.File` 同时实现了 `io.Reader` 和 `io.Writer`\n- `strings.Reader` 实现了 `io.Reader`\n- `bufio.Reader/Writer` 分别实现了 `io.Reader` 和 `io.Writer`\n- `bytes.Buffer` 同时实现了 `io.Reader` 和 `io.Writer`\n- `bytes.Reader` 实现了 `io.Reader`\n- `compress/gzip.Reader/Writer` 分别实现了 `io.Reader` 和 `io.Writer`\n- `crypto/cipher.StreamReader/StreamWriter` 分别实现了 `io.Reader` 和 `io.Writer`\n- `crypto/tls.Conn` 同时实现了 `io.Reader` 和 `io.Writer`\n- `encoding/csv.Reader/Writer` 分别实现了 `io.Reader` 和 `io.Writer`\n- `mime/multipart.Part` 实现了 `io.Reader`\n- `net/conn` 分别实现了 `io.Reader` 和 `io.Writer`(Conn接口定义了Read/Write)\n\n**io 包本身实现这两个接口的类型**：\n\n- 实现了 `Reader` 的类型：`LimitedReader`、`PipeReader`、`SectionReader`\n- 实现了 `Writer` 的类型：`PipeWriter`\n\n\n## ReaderAt 和 WriterAt\n\n**`ReaderAt` 接口**：\n\n```go\ntype ReaderAt interface {\n    ReadAt(p []byte, off int64) (n int, err error)\n}\n```\n\n> `ReadAt` 从基本输入源的偏移量 `off` 处开始，将 `len(p)` 个字节读到 `p` 中。它返回读取的字节数 `n`（`0 <= n <= len(p)`）以及任\n何遇到的错误。\n\n> 当 `ReadAt` 返回的 `n < len(p)` 时，它就会返回一个 **非 nil** 的错误来解释为什么没有返回更多的字节。\n\n> 即使 `ReadAt` 返回的 `n < len(p)`，它也会在调用过程中使用 `p` 的全部作为暂存空间。若可读取的数据不到 `len(p)` 字节，`ReadAt` 就会\n阻塞,直到所有数据都可用或一个错误发生。\n\n> 若 `n = len(p)` 个字节从输入源的结尾处由 `ReadAt` 返回，`Read` 可能返回 `err == EOF` 或者 `err == nil`\n\n> 若 `ReadAt` 携带一个偏移量从输入源读取，`ReadAt` 应当既不影响偏移量也不被它所影响。\n\n> 可对相同的输入源并行执行 `ReadAt` 调用。\n\n可见，`ReadAt` 接口使得可以从指定偏移量处开始读取数据。\n\n简单示例代码如下：\n\n```go\nreader := strings.NewReader(\"Hello world\")\np := make([]byte, 6)\nn, err := reader.ReadAt(p, 2)\nif err != nil {\n    panic(err)\n}\nfmt.Printf(\"%s, %d\\n\", p, n) // llo wo, 6\n```\n\n**`WriterAt` 接口**：\n\n```go\ntype WriterAt interface {\n    WriteAt(p []byte, off int64) (n int, err error)\n}\n```\n\n\n> `WriteAt` 从 `p` 中将 `len(p)` 个字节写入到偏移量 `off` 处的基本数据流中。它返回从 `p` 中被写入的字节数 `n`（`0 <= n <= len(p)`）\n以及任何遇到的引起写入提前停止的错误。若 `WriteAt` 返回的 `n < len(p)`，它就必须返回一个 **非 nil** 的错误。\n\n> 若 `WriteAt` 携带一个偏移量写入到目标中，`WriteAt` 应当既不影响偏移量也不被它所影响。\n\n> 若被写区域没有重叠，可对相同的目标并行执行 `WriteAt` 调用。\n\n我们可以通过该接口将数据写入到数据流的特定偏移量之后。\n\n```go\nfile, err := os.Create(\"writeAt.txt\")\nif err != nil {\n    panic(err)\n}\ndefer file.Close()\n_, _ = file.WriteString(\"Hello world----ignore\")\nn, err := file.WriteAt([]byte(\"Golang\"), 15)\nif err != nil {\n    panic(err)\n}\nfmt.Println(n)\n```\n\n打开文件 `WriteAt.txt`，内容是：`Hello world----Golang`。\n\n分析：\n\n`file.WriteString(\"Hello world----ignore\")` 往文件中写入 `Hello world----ignore`，之后 \n`file.WriteAt([]byte(\"Golang\"), 15)` 在文件流的 `offset=15` 处写入 `Golang`（会覆盖该位置的内容）。\n\n## ReaderFrom 和 WriterTo\n这两个接口实现了**一次性从某个地方读或写到某个地方去**。\n**ReaderFrom**：\n\n```go\ntype ReaderFrom interface {\n    ReadFrom(r Reader) (n int64, err error)\n}\n```\n\n> `ReadFrom` 从 `r` 中读取数据，直到 `EOF` 或发生错误。其返回值 `n` 为读取的字节数。除 `io.EOF` 之外，在读取过程中遇到的任何错误也\n将被返回。\n\n> 如果 `ReaderFrom` 可用，`Copy` 函数就会使用它。\n\n注意：`ReadFrom` 方法不会返回 `err == EOF`。\n\n将文件中的数据全部读取（显示在标准输出）：\n\n```go\nfile, err := os.Open(\"writeAt.txt\")\nif err != nil {\n    panic(err)\n}\ndefer file.Close()\nwriter := bufio.NewWriter(os.Stdout)\nwriter.ReadFrom(file)\nwriter.Flush()\n```\n\n也可以通过 `ioutil` 包的 `ReadFile` 函数获取文件全部内容。其实，跟踪一下 `ioutil.ReadFile` 的源码，会发现其实也是通过 `ReadFrom` 方\n法实现（用的是 `bytes.Buffer`，它实现了 `ReaderFrom` 接口）。\n\n**WriterTo**：\n\n```go\ntype WriterTo interface {\n    WriteTo(w Writer) (n int64, err error)\n}\n```\n\n> `WriteTo` 将数据写入 `w` 中，直到没有数据可写或发生错误。其返回值 `n` 为写入的字节数。 在写入过程中遇到的任何错误也将被返回。\n\n> 如果 `WriterTo` 可用，`Copy` 函数就会使用它。\n\n将一段文本输出到标准输出：\n\n```go\nreader := bytes.NewReader([]byte(\"Hello world\"))\nreader.WriteTo(os.Stdout)\n```\n\n## Seeker\n\n```go\ntype Seeker interface {\n    Seek(offset int64, whence int) (ret int64, err error)\n}\n```\n\n> `Seek` 设置下一次 `Read` 或 `Write` 的偏移量为 `offset`，它的解释取决于 `whence`：  **0 表示相对于文件的起始处，1 表示相对\n于当前的偏移，而 2 表示相对于其结尾处**。 `Seek` 返回新的偏移量和一个错误，如果有的话。\n\n也就是说，`Seek` 方法是用于设置偏移量的，这样可以从某个特定位置开始操作数据流。听起来和 `ReaderAt/WriteAt` 接口有些类似，\n不过 `Seeker` 接口更灵活，可以更好的控制读写数据流的位置。\n\n获取倒数第二个字符（需要考虑 UTF-8 编码，这里的代码只是一个示例）：\n\n```go\nreader := strings.NewReader(\"Hello world\")\nreader.Seek(-6, io.SeekEnd)\nr, _, _ := reader.ReadRune()\nfmt.Printf(\"%c\\n\", r)\n```\n\n`whence` 的值，在 io 包中定义了相应的常量，应该使用这些常量\n\n```go\nconst (\n  SeekStart   = 0 // seek relative to the origin of the file\n  SeekCurrent = 1 // seek relative to the current offset\n  SeekEnd     = 2 // seek relative to the end\n)\n```\n\n而原先 `os` 包中的常量已经被标注为 Deprecated\n\n```go\n// Deprecated: Use io.SeekStart, io.SeekCurrent, and io.SeekEnd.\nconst (\n  SEEK_SET int = 0 // seek relative to the origin of the file\n  SEEK_CUR int = 1 // seek relative to the current offset\n  SEEK_END int = 2 // seek relative to the end\n)\n```\n\n## Closer\n\n```go\ntype Closer interface {\n    Close() error\n}\n```\n\n该接口比较简单，只有一个 `Close()` 方法，用于关闭数据流。\n\n文件 (`os.File`)、归档（压缩包）、数据库连接、`Socket` 等需要手动关闭的资源都实现了 `Closer` 接口。\n\n实际编程中，经常将 `Close` 方法的调用放在 `defer` 语句中。\n\n```go\nfile, err := os.Open(\"studygolang.txt\")\ndefer file.Close()\nif err != nil {\n\t...\n}\n```\n\n当文件 `studygolang.txt` 不存在或找不到时，`file.Close()` 会返回错误，因为 `file` 是 `nil`。\n因此，应该**将 `defer file.Close()` 放在错误检查之后**。\n\n```go\nfunc (f *File) Close() error {\n\tif f == nil {\n\t\treturn ErrInvalid\n\t}\n\treturn f.file.close()\n}\n```\n\n## 其他接口\n\n### ByteReader 和 ByteWriter\n\n读或写一个字节：\n\n```go\ntype ByteReader interface {\n    ReadByte() (c byte, err error)\n}\n\ntype ByteWriter interface {\n    WriteByte(c byte) error\n}\n```\n\n下面类型都实现了这两个接口:\n\n- `bufio.Reader/Writer` 分别实现了 `io.ByteReader` 和 `io.ByteWriter`\n- `bytes.Buffer` 同时实现了 `io.ByteReader` 和 `io.ByteWriter`\n- `bytes.Reader` 实现了 `io.ByteReader`\n- `strings.Reader` 实现了 `io.ByteReader`\n\n通过 `bytes.Buffer` 来一次读取或写入一个字节：\n\n```go\nvar ch byte\nfmt.Scanf(\"%c\\n\", &ch)\n\nbuffer := new(bytes.Buffer)\nerr := buffer.WriteByte(ch)\nif err == nil {\n\tfmt.Println(\"写入一个字节成功！准备读取该字节……\")\n\tnewCh, _ := buffer.ReadByte()\n\tfmt.Printf(\"读取的字节：%c\\n\", newCh)\n} else {\n\tfmt.Println(\"写入错误\")\n}\n```\n\n程序从标准输入接收一个字节（ASCII 字符），调用 `buffer` 的 `WriteByte` 将该字节写入 `buffer` 中，之后通过 `ReadByte` 读取该字节。\n\n### ByteScanner、RuneReader 和 RuneScanner\n\n`ByteScanner` 接口：\n\n```go\ntype ByteScanner interface {\n    ByteReader\n    UnreadByte() error\n}\n```\n\n内嵌了 `ByteReader` 接口，`UnreadByte` 方法的意思是：将上一次 `ReadByte` 的字节还原，使得再次调用 `ReadByte` 返回的结果和上一次调\n用相同，也就是说，`UnreadByte` 是重置上一次的 `ReadByte`。注意，**`UnreadByte` 调用之前必须调用了 `ReadByte`，且不能连续调\n用 `UnreadByte`**。即：\n\n```go\nbuffer := bytes.NewBuffer([]byte{'a', 'b'})\nerr := buffer.UnreadByte()\n```\n\n和\n\n```go\nbuffer := bytes.NewBuffer([]byte{'a', 'b'})\nbuffer.ReadByte()\nerr := buffer.UnreadByte()\nerr = buffer.UnreadByte()\n```\n\n`err` 都 **非 nil**，错误为：`bytes.Buffer: UnreadByte: previous operation was not a read`\n\n`RuneReader` 接口和 `ByteReader` 类似，只是 `ReadRune` 方法读取单个 UTF-8 字符，返回其 `rune` 和该字符占用的字节数。\n\n`RuneScanner` 接口和 `ByteScanner` 类似。\n\n### ReadCloser、ReadSeeker、ReadWriteCloser、ReadWriteSeeker、ReadWriter、WriteCloser 和 WriteSeeker\n\n这些接口是上面介绍的接口的两个或三个组合而成的新接口。`ReadWriter` 接口：\n\n```go\ntype ReadWriter interface {\n    Reader\n    Writer\n}\n```\n\n`Reader` 和 `Writer` 接口的组合。\n\n这些接口的作用是：有些时候同时需要某两个接口的所有功能，即必须同时实现了某两个接口的类型才能够被传入使用。\n\n## SectionReader 类型\n\n`SectionReader` 是一个 `struct`，实现了 `Read`, `Seek` 和 `ReadAt`，同时，内嵌了 `ReaderAt` 接口。结构定义如下：\n\n```go\ntype SectionReader struct {\n\tr     ReaderAt\t// 该类型最终的 Read/ReadAt 最终都是通过 r 的 ReadAt 实现\n\tbase  int64\t\t// NewSectionReader 会将 base 设置为 off\n\toff   int64\t\t// 从 r 中的 off 偏移处开始读取数据\n\tlimit int64\t\t// limit - off = SectionReader 流的长度\n}\n```\n\n该类型读取数据流中部分数据。\n\n```go\nfunc NewSectionReader(r ReaderAt, off int64, n int64) *SectionReader\n```\n\n\n> `NewSectionReader` 返回一个 `SectionReader`，它从 `r` 中的偏移量 `off` 处读取 `n` 个字节后以 `EOF` 停止。\n\n也就是说，SectionReader 只是内部 ReaderAt 表示的数据流的一部分：从 off 开始后的 n 个字节。\n\n这个类型的作用是：方便重复操作某一段 (section) 数据流；或者同时需要 ReadAt 和 Seek 的功能。\n\n由于该类型所支持的操作，前面都有介绍，因此不提供示例代码了。\n\n## LimitedReader 类型\n\n```go\ntype LimitedReader struct {\n    R Reader // underlying reader，最终的读取操作通过 R.Read 完成\n    N int64  // max bytes remaining\n}\n```\n\n\n> 从 `R` 读取但将返回的数据量限制为 `N` 字节。每调用一次 `Read` 都将更新 `N` 来反应新的剩余数量。\n\n也就是说，最多只能返回 `N` 字节数据。\n\n`LimitedReader` 只实现了 `Read` 方法。\n\n示例：\n\n```go\ncontent := \"This Is LimitReader Example\"\nreader := strings.NewReader(content)\nlimitReader := &io.LimitedReader{R: reader, N: 8}\nfor limitReader.N > 0 {\n\ttmp := make([]byte, 2)\n\tlimitReader.Read(tmp)\n\tfmt.Printf(\"%s\", tmp) // This Is\n}\n```\n\n通过该类型可以达到 **只允许读取一定长度数据** 的目的。\n\n在 `io` 包中，`LimitReader` 函数的实现其实就是调用 `LimitedReader`：\n\n```go\nfunc LimitReader(r Reader, n int64) Reader { return &LimitedReader{r, n} }\n```\n\n## PipeReader 和 PipeWriter 类型\n\n`PipeReader` 是管道的读取端。它实现了 `io.Reader` 和 `io.Closer` 接口：\n```go\ntype PipeReader struct {\n\tp *pipe\n}\n```\n\n> 从管道中读取数据。该方法会堵塞，直到管道写入端开始写入数据或写入端被关闭。如果写入端关闭时带有 `error`（即调用 `CloseWithError` 关闭），\n该 `Read` 返回的 `err` 就是写入端传递的 `error`；否则 `err` 为 `EOF`。\n\n`PipeWriter` 是管道的写入端。它实现了 `io.Writer` 和 `io.Closer` 接口：\n```go\ntype PipeWriter struct {\n\tp *pipe\n}\n```\n\n> 写数据到管道中。该方法会堵塞，直到管道读取端读完所有数据或读取端被关闭。如果读取端关闭时\n带有 `error`（即调用 `CloseWithError` 关闭），该 `Write` 返回的 `err` 就是读取端传递的 `error`；否则 `err` 为 `ErrClosedPipe`。\n\n示例：\n\n```go\nfunc main() {\n    pipeReader, pipeWriter := io.Pipe()\n    go PipeWrite(pipeWriter)\n    go PipeRead(pipeReader)\n    time.Sleep(30 * time.Second)\n}\n\nfunc PipeWrite(writer *io.PipeWriter){\n\tdata := []byte(\"Go语言中文网\")\n\tfor i := 0; i < 3; i++{\n\t\tn, err := writer.Write(data)\n\t\tif err != nil{\n\t\t\tfmt.Println(err)\n\t\t\treturn\n\t\t}\n\t\tfmt.Printf(\"写入字节 %d\\n\",n)\n\t}\n\twriter.CloseWithError(errors.New(\"写入段已关闭\"))\n}\n\nfunc PipeRead(reader *io.PipeReader){\n\tbuf := make([]byte, 128)\n\tfor{\n\t\tfmt.Println(\"接口端开始阻塞5秒钟...\")\n\t\ttime.Sleep(5 * time.Second)\n\t\tfmt.Println(\"接收端开始接受\")\n\t\tn, err := reader.Read(buf)\n\t\tif err != nil{\n\t\t\tfmt.Println(err)\n\t\t\treturn\n\t\t}\n\t\tfmt.Printf(\"收到字节: %d\\n buf内容: %s\\n\",n,buf)\n\t}\n}\n```\n\n`io.Pipe()` 用于创建一个同步的内存管道：\n\n```go\nfunc Pipe() (*PipeReader, *PipeWriter)\n```\n\n它将 `io.Reader` 连接到 `io.Writer`。一端的读取匹配另一端的写入，直接在这两端之间复制数据；它没有内部缓存。它对于并行调用 `Read`\n 和 `Write` 以及其它函数或 `Close` 来说都是安全的。一旦等待的 I/O 结束，`Close` 就会完成。并行调用 `Read` 或并行调用 `Write` 也\n同样安全：同种类的调用将按顺序进行控制。\n\n正因为是**同步**的，因此不能在一个 goroutine 中进行读和写。\n\n另外，对于管道的 `close` 方法（非 `CloseWithError` 时），`err` 会被置为 `EOF`。\n\n## Copy 和 CopyN 函数\n\n**Copy 函数**：\n\n```go\nfunc Copy(dst Writer, src Reader) (written int64, err error)\n```\n\n函数文档：\n\n> `Copy` 将 `src` 复制到 `dst`，直到在 `src` 上到达 `EOF` 或发生错误。它返回复制的字节数，如果有错误的话，还会返回在复制时遇到的第一\n个错误。\n\n> 成功的 `Copy` 返回 `err == nil`，而非 `err == EOF`。由于 `Copy` 被定义为从 `src` 读取直到 `EOF` 为止，因此它不会将来\n自 `Read` 的 `EOF` 当做错误来报告。\n\n> 若 `dst` 实现了 `ReaderFrom` 接口，其复制操作可通过调用 `dst.ReadFrom(src)` 实现。此外，若 `src` 实现了 `WriterTo` 接口，其复\n制操作可通过调用 `src.WriteTo(dst)` 实现。\n\n代码：\n\n```go\nio.Copy(os.Stdout, strings.NewReader(\"Go语言中文网\"))\n```\n\n直接将内容输出（写入 Stdout 中）：\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n)\n\nfunc main() {\n\t_, _ = io.Copy(os.Stdout, os.Stdin)\n\tfmt.Println(\"Got EOF -- bye\")\n}\n```\n\n执行：`echo \"Hello, World\" | go run main.go`\n\n\n**CopyN 函数**：\n\n```go\nfunc CopyN(dst Writer, src Reader, n int64) (written int64, err error)\n```\n\n> `CopyN` 将 `n` 个字节(或到一个 `error`)从 `src` 复制到 `dst`。 它返回复制的字节数以及在复制时遇到的最早的错误。\n当且仅当 `err == nil` 时,`written == n` 。\n\n> 若 `dst` 实现了 `ReaderFrom` 接口，复制操作也就会使用它来实现。\n\n代码：\n\n```go\nio.CopyN(os.Stdout, strings.NewReader(\"Go语言中文网\"), 8) // Go语言\n```\n\n## ReadAtLeast 和 ReadFull 函数\n\n**ReadAtLeast 函数**：\n\n```go\nfunc ReadAtLeast(r Reader, buf []byte, min int) (n int, err error)\n```\n\n函数文档：\n\n> `ReadAtLeast` 将 `r` 读取到 `buf` 中，直到读了最少 `min` 个字节为止。它返回复制的字节数，如果读取的字节较少，还会返回一个错误。\n若没有读取到字节，错误就只是 `EOF`。如果一个 `EOF` 发生在读取了少于 `min` 个字节之后，`ReadAtLeast` 就会返回 `ErrUnexpectedEOF`。\n若 `min` 大于 `buf` 的长度，`ReadAtLeast` 就会返回 `ErrShortBuffer`。对于返回值，当且仅当 `err == nil` 时，才有 `n >= min`。\n\n**ReadFull 函数**：\n\n```go\nfunc ReadFull(r Reader, buf []byte) (n int, err error)\n```\n\n函数文档：\n\n> `ReadFull` 精确地从 `r` 中将 `len(buf)` 个字节读取到 `buf` 中。它返回复制的字节数，如果读取的字节较少，还会返回一个错误。若没有读\n取到字节，错误就只是 `EOF`。如果一个 `EOF` 发生在读取了一些但不是所有的字节后，`ReadFull` 就会返回 `ErrUnexpectedEOF`。对于返回值，\n当且仅当 `err == nil` 时，才有 `n == len(buf)`。\n\n注意该函数和 `ReadAtLeast` 的区别：\n- `ReadFull` 将 `buf` 读满\n- `ReadAtLeast` 是最少读取 `min` 个字节。\n\n\n## WriteString 函数\n\n这是为了方便写入 `string` 类型提供的函数，函数签名：\n\n```go\nfunc WriteString(w Writer, s string) (n int, err error)\n```\n\n函数文档：\n\n> `WriteString` 将 ``s 的内容写入 `w` 中，当 `w` 实现了 `WriteString` 方法时，会直接调用该方法，否则执行 `w.Write([]byte(s))`。\n\n## MultiReader 和 MultiWriter 函数\n\n```go\nfunc MultiReader(readers ...Reader) Reader\nfunc MultiWriter(writers ...Writer) Writer\n```\n\n它们接收多个 `Reader` 或 `Writer`，返回一个 `Reader` 或 `Writer`。我们可以猜想到这两个函数就是操作多个 `Reader` 或 `Writer` 就像\n操作一个。\n\n事实上，在 `io` 包中定义了两个非导出类型：`mutilReader` 和 `multiWriter`，它们分别实现了 `io.Reader` 和 `io.Writer` 接口：\n\n```go\ntype multiReader struct {\n\treaders []Reader\n}\n\ntype multiWriter struct {\n\twriters []Writer\n}\n```\n\n对于这两种类型对应的实现方法（`Read` 和 `Write` 方法）的使用，示例：\n\n**MultiReader 的使用**：\n\n```go\nreaders := []io.Reader{\n\tstrings.NewReader(\"from strings reader\"),\n\tbytes.NewBufferString(\"from bytes buffer\"),\n}\nreader := io.MultiReader(readers...)\ndata := make([]byte, 0, 128)\nbuf := make([]byte, 10)\n\t\nfor n, err := reader.Read(buf); err != io.EOF ; n, err = reader.Read(buf){\n\tif err != nil{\n\t\tpanic(err)\n\t}\n\tdata = append(data,buf[:n]...)\n}\nfmt.Printf(\"%s\\n\", data) // from strings readerfrom bytes buffer\n```\n\n代码中首先构造了一个 `io.Reader` 的 `slice`，然后通过 `MultiReader` 得到新的 `Reader`，循环读取新 `Reader` 中的内容。从输出结果\n可以看到，第一次调用 `Reader` 的 `Read` 方法获取到的是 `slice` 中第一个元素的内容……也就是说，`MultiReader` 只是逻辑上将多\n个 `Reader` 组合起来，并不能通过调用一次 `Read` 方法获取所有 `Reader` 的内容。在所有的 `Reader` 内容都被读\n完后，`Reader` 会返回 `EOF`。\n\n**MultiWriter 的使用**：\n\n```go\nfile, err := os.Create(\"tmp.txt\")\nif err != nil {\n    panic(err)\n}\ndefer file.Close()\nwriters := []io.Writer{\n\tfile,\n\tos.Stdout,\n}\nwriter := io.MultiWriter(writers...)\nwriter.Write([]byte(\"Go语言中文网\"))\n```\n\n这段程序执行后在生成 `tmp.txt` 文件，同时在文件和屏幕中都输出：`Go语言中文网`。这和 Unix 中的 tee 命令类似。\n\n\n\n## TeeReader 函数\n\n\n```go\nfunc TeeReader(r Reader, w Writer) Reader\n```\n\n> `TeeReader` 返回一个 `Reader`，它将从 `r` 中读到的数据写入 `w` 中。所有经由它处理的从 `r` 的读取都匹配于对应的对 `w` 的写入。它没\n有内部缓存，即写入必须在读取完成前完成。任何在写入时遇到的错误都将作为读取错误返回。\n\n也就是说，我们通过 `Reader` 读取内容后，会自动写入到 `Writer` 中去。例子代码如下：\n\n```go\nreader := io.TeeReader(strings.NewReader(\"Go语言中文网\"), os.Stdout)\nreader.Read(make([]byte, 20)) // Go语言中文网\n```\n\n\n这种功能的实现其实挺简单，无非是在 `Read` 完后执行 `Write`。","source":"standards/io/io.md","raw":"---\ntitle: io\n---\n\n# io\n`io` 是对输入输出设备的抽象。`io` 库对这些功能进行了抽象，通过统一的接口对输入输出设备进行操作。\n最重要的是两个接口：`Reader` 和 `Writer`。\n\n## Reader\n\nReader 接口：\n\n```go\ntype Reader interface {\n    Read(p []byte) (n int, err error)\n}\n```\n\n> `Read` 将 `len(p)` 个字节读取到 `p` 中。它返回读取的字节数 `n`（`0 <= n <= len(p)`） 以及任何遇到的错误。\n即使 `Read` 返回的 `n < len(p)`，它也会在调用过程中占用 `len(p)` 个字节作为暂存空间。若可读取的数据不到 `len(p)` 个\n字节，`Read` 会返回可用数据，而不是等待更多数据。\n\n> 当 `Read` 在成功读取 `n > 0` 个字节后遇到一个错误或 `EOF` (`end-of-file`)，它会返回读取的字节数。它可能会同时在本次的调\n用中返回一个 `non-nil` 错误,或在下一次的调用中返回这个错误（且 `n` 为 0）。 一般情况下, `Reader` 会返回一个 非 0 字节数 `n`, \n若 `n = len(p)` 个字节从输入源的结尾处由 `Read` 返回，`Read` 可能返回 `err == EOF` 或者 `err == nil`。并且之后的 `Read` \n都应该返回 (`n:0, err:EOF`)。\n\n> 调用者在考虑错误之前应当首先处理返回的数据。这样做可以正确地处理在读取一些字节后产生的 I/O 错误，同时允许 `EOF` 的出现。\n\n```go\nfunc ReadFrom(reader io.Reader, num int) ([]byte, error) {\n\tp := make([]byte, num)\n\tn, err := reader.Read(p)\n\tif n > 0 {\n\t\treturn p[:n], nil\n\t}\n\treturn p, err\n}\n```\n\n`ReadFrom` 函数将 `io.Reader` 作为参数，也就是说，`ReadFrom` 可以从任意的地方读取数据，只要来源实现了 `io.Reader` 接口。\n比如，我们可以从标准输入、文件、字符串等读取数据，示例代码如下：\n\n```go\n// 从标准输入读取\ndata, err = ReadFrom(os.Stdin, 11)\n\n// 从普通文件读取，其中 file 是 os.File 的实例\ndata, err = ReadFrom(file, 9)\n\n// 从字符串读取\ndata, err = ReadFrom(strings.NewReader(\"from string\"), 12)\n```\n\n`io.EOF` 变量的定义：`var EOF = errors.New(\"EOF\")`，是 `error` 类型。根据 `reader` 接口的说明，在 `n > 0` 且数据被读完了\n的情况下，当次返回的 `error` 有可能是 `EOF` 也有可能是 `nil`。\n\n## Writer\n\nWriter 接口：\n\n```go\ntype Writer interface {\n    Write(p []byte) (n int, err error)\n}\n```\n\n> `Write` 将 `len(p)` 个字节从 `p` 中写入到基本数据流中。它返回从 `p` 中被写入的字节数 `n`（`0 <= n <= len(p)`）以及任何遇到的引\n起写入提前停止的错误。若 `Write` 返回的 `n < len(p)`，它就必须返回一个 **非 nil** 的错误。\n\n以 `fmt.Fprintln` 为例：\n\n```go\nfunc Println(a ...interface{}) (n int, err error) {\n\treturn Fprintln(os.Stdout, a...)\n}\n```\n\n可以看出 `fmt.Println` 会将内容输出到标准输出中。\n\n\n## 实现了 io.Reader 接口或 io.Writer 接口的类型\n\n标准库中有哪些类型实现了 `io.Reader` 或 `io.Writer` 接口？\n\n例如 `os.Stdin/Stdout`，它们分别实现了 `io.Reader/io.Writer` 接口：\n\n```go\nvar (\n    Stdin  = NewFile(uintptr(syscall.Stdin), \"/dev/stdin\")\n    Stdout = NewFile(uintptr(syscall.Stdout), \"/dev/stdout\")\n    Stderr = NewFile(uintptr(syscall.Stderr), \"/dev/stderr\")\n)\n```\n\n上面的代码可以看出，`Stdin/Stdout/Stderr` 只是三个特殊的文件类型的标识（都是 `os.File` 的实例），`os.File` 实现\n了 `io.Reader` 和 `io.Writer`。\n\n实现了 `io.Reader` 或 `io.Writer` 接口的类型：\n\n- `os.File` 同时实现了 `io.Reader` 和 `io.Writer`\n- `strings.Reader` 实现了 `io.Reader`\n- `bufio.Reader/Writer` 分别实现了 `io.Reader` 和 `io.Writer`\n- `bytes.Buffer` 同时实现了 `io.Reader` 和 `io.Writer`\n- `bytes.Reader` 实现了 `io.Reader`\n- `compress/gzip.Reader/Writer` 分别实现了 `io.Reader` 和 `io.Writer`\n- `crypto/cipher.StreamReader/StreamWriter` 分别实现了 `io.Reader` 和 `io.Writer`\n- `crypto/tls.Conn` 同时实现了 `io.Reader` 和 `io.Writer`\n- `encoding/csv.Reader/Writer` 分别实现了 `io.Reader` 和 `io.Writer`\n- `mime/multipart.Part` 实现了 `io.Reader`\n- `net/conn` 分别实现了 `io.Reader` 和 `io.Writer`(Conn接口定义了Read/Write)\n\n**io 包本身实现这两个接口的类型**：\n\n- 实现了 `Reader` 的类型：`LimitedReader`、`PipeReader`、`SectionReader`\n- 实现了 `Writer` 的类型：`PipeWriter`\n\n\n## ReaderAt 和 WriterAt\n\n**`ReaderAt` 接口**：\n\n```go\ntype ReaderAt interface {\n    ReadAt(p []byte, off int64) (n int, err error)\n}\n```\n\n> `ReadAt` 从基本输入源的偏移量 `off` 处开始，将 `len(p)` 个字节读到 `p` 中。它返回读取的字节数 `n`（`0 <= n <= len(p)`）以及任\n何遇到的错误。\n\n> 当 `ReadAt` 返回的 `n < len(p)` 时，它就会返回一个 **非 nil** 的错误来解释为什么没有返回更多的字节。\n\n> 即使 `ReadAt` 返回的 `n < len(p)`，它也会在调用过程中使用 `p` 的全部作为暂存空间。若可读取的数据不到 `len(p)` 字节，`ReadAt` 就会\n阻塞,直到所有数据都可用或一个错误发生。\n\n> 若 `n = len(p)` 个字节从输入源的结尾处由 `ReadAt` 返回，`Read` 可能返回 `err == EOF` 或者 `err == nil`\n\n> 若 `ReadAt` 携带一个偏移量从输入源读取，`ReadAt` 应当既不影响偏移量也不被它所影响。\n\n> 可对相同的输入源并行执行 `ReadAt` 调用。\n\n可见，`ReadAt` 接口使得可以从指定偏移量处开始读取数据。\n\n简单示例代码如下：\n\n```go\nreader := strings.NewReader(\"Hello world\")\np := make([]byte, 6)\nn, err := reader.ReadAt(p, 2)\nif err != nil {\n    panic(err)\n}\nfmt.Printf(\"%s, %d\\n\", p, n) // llo wo, 6\n```\n\n**`WriterAt` 接口**：\n\n```go\ntype WriterAt interface {\n    WriteAt(p []byte, off int64) (n int, err error)\n}\n```\n\n\n> `WriteAt` 从 `p` 中将 `len(p)` 个字节写入到偏移量 `off` 处的基本数据流中。它返回从 `p` 中被写入的字节数 `n`（`0 <= n <= len(p)`）\n以及任何遇到的引起写入提前停止的错误。若 `WriteAt` 返回的 `n < len(p)`，它就必须返回一个 **非 nil** 的错误。\n\n> 若 `WriteAt` 携带一个偏移量写入到目标中，`WriteAt` 应当既不影响偏移量也不被它所影响。\n\n> 若被写区域没有重叠，可对相同的目标并行执行 `WriteAt` 调用。\n\n我们可以通过该接口将数据写入到数据流的特定偏移量之后。\n\n```go\nfile, err := os.Create(\"writeAt.txt\")\nif err != nil {\n    panic(err)\n}\ndefer file.Close()\n_, _ = file.WriteString(\"Hello world----ignore\")\nn, err := file.WriteAt([]byte(\"Golang\"), 15)\nif err != nil {\n    panic(err)\n}\nfmt.Println(n)\n```\n\n打开文件 `WriteAt.txt`，内容是：`Hello world----Golang`。\n\n分析：\n\n`file.WriteString(\"Hello world----ignore\")` 往文件中写入 `Hello world----ignore`，之后 \n`file.WriteAt([]byte(\"Golang\"), 15)` 在文件流的 `offset=15` 处写入 `Golang`（会覆盖该位置的内容）。\n\n## ReaderFrom 和 WriterTo\n这两个接口实现了**一次性从某个地方读或写到某个地方去**。\n**ReaderFrom**：\n\n```go\ntype ReaderFrom interface {\n    ReadFrom(r Reader) (n int64, err error)\n}\n```\n\n> `ReadFrom` 从 `r` 中读取数据，直到 `EOF` 或发生错误。其返回值 `n` 为读取的字节数。除 `io.EOF` 之外，在读取过程中遇到的任何错误也\n将被返回。\n\n> 如果 `ReaderFrom` 可用，`Copy` 函数就会使用它。\n\n注意：`ReadFrom` 方法不会返回 `err == EOF`。\n\n将文件中的数据全部读取（显示在标准输出）：\n\n```go\nfile, err := os.Open(\"writeAt.txt\")\nif err != nil {\n    panic(err)\n}\ndefer file.Close()\nwriter := bufio.NewWriter(os.Stdout)\nwriter.ReadFrom(file)\nwriter.Flush()\n```\n\n也可以通过 `ioutil` 包的 `ReadFile` 函数获取文件全部内容。其实，跟踪一下 `ioutil.ReadFile` 的源码，会发现其实也是通过 `ReadFrom` 方\n法实现（用的是 `bytes.Buffer`，它实现了 `ReaderFrom` 接口）。\n\n**WriterTo**：\n\n```go\ntype WriterTo interface {\n    WriteTo(w Writer) (n int64, err error)\n}\n```\n\n> `WriteTo` 将数据写入 `w` 中，直到没有数据可写或发生错误。其返回值 `n` 为写入的字节数。 在写入过程中遇到的任何错误也将被返回。\n\n> 如果 `WriterTo` 可用，`Copy` 函数就会使用它。\n\n将一段文本输出到标准输出：\n\n```go\nreader := bytes.NewReader([]byte(\"Hello world\"))\nreader.WriteTo(os.Stdout)\n```\n\n## Seeker\n\n```go\ntype Seeker interface {\n    Seek(offset int64, whence int) (ret int64, err error)\n}\n```\n\n> `Seek` 设置下一次 `Read` 或 `Write` 的偏移量为 `offset`，它的解释取决于 `whence`：  **0 表示相对于文件的起始处，1 表示相对\n于当前的偏移，而 2 表示相对于其结尾处**。 `Seek` 返回新的偏移量和一个错误，如果有的话。\n\n也就是说，`Seek` 方法是用于设置偏移量的，这样可以从某个特定位置开始操作数据流。听起来和 `ReaderAt/WriteAt` 接口有些类似，\n不过 `Seeker` 接口更灵活，可以更好的控制读写数据流的位置。\n\n获取倒数第二个字符（需要考虑 UTF-8 编码，这里的代码只是一个示例）：\n\n```go\nreader := strings.NewReader(\"Hello world\")\nreader.Seek(-6, io.SeekEnd)\nr, _, _ := reader.ReadRune()\nfmt.Printf(\"%c\\n\", r)\n```\n\n`whence` 的值，在 io 包中定义了相应的常量，应该使用这些常量\n\n```go\nconst (\n  SeekStart   = 0 // seek relative to the origin of the file\n  SeekCurrent = 1 // seek relative to the current offset\n  SeekEnd     = 2 // seek relative to the end\n)\n```\n\n而原先 `os` 包中的常量已经被标注为 Deprecated\n\n```go\n// Deprecated: Use io.SeekStart, io.SeekCurrent, and io.SeekEnd.\nconst (\n  SEEK_SET int = 0 // seek relative to the origin of the file\n  SEEK_CUR int = 1 // seek relative to the current offset\n  SEEK_END int = 2 // seek relative to the end\n)\n```\n\n## Closer\n\n```go\ntype Closer interface {\n    Close() error\n}\n```\n\n该接口比较简单，只有一个 `Close()` 方法，用于关闭数据流。\n\n文件 (`os.File`)、归档（压缩包）、数据库连接、`Socket` 等需要手动关闭的资源都实现了 `Closer` 接口。\n\n实际编程中，经常将 `Close` 方法的调用放在 `defer` 语句中。\n\n```go\nfile, err := os.Open(\"studygolang.txt\")\ndefer file.Close()\nif err != nil {\n\t...\n}\n```\n\n当文件 `studygolang.txt` 不存在或找不到时，`file.Close()` 会返回错误，因为 `file` 是 `nil`。\n因此，应该**将 `defer file.Close()` 放在错误检查之后**。\n\n```go\nfunc (f *File) Close() error {\n\tif f == nil {\n\t\treturn ErrInvalid\n\t}\n\treturn f.file.close()\n}\n```\n\n## 其他接口\n\n### ByteReader 和 ByteWriter\n\n读或写一个字节：\n\n```go\ntype ByteReader interface {\n    ReadByte() (c byte, err error)\n}\n\ntype ByteWriter interface {\n    WriteByte(c byte) error\n}\n```\n\n下面类型都实现了这两个接口:\n\n- `bufio.Reader/Writer` 分别实现了 `io.ByteReader` 和 `io.ByteWriter`\n- `bytes.Buffer` 同时实现了 `io.ByteReader` 和 `io.ByteWriter`\n- `bytes.Reader` 实现了 `io.ByteReader`\n- `strings.Reader` 实现了 `io.ByteReader`\n\n通过 `bytes.Buffer` 来一次读取或写入一个字节：\n\n```go\nvar ch byte\nfmt.Scanf(\"%c\\n\", &ch)\n\nbuffer := new(bytes.Buffer)\nerr := buffer.WriteByte(ch)\nif err == nil {\n\tfmt.Println(\"写入一个字节成功！准备读取该字节……\")\n\tnewCh, _ := buffer.ReadByte()\n\tfmt.Printf(\"读取的字节：%c\\n\", newCh)\n} else {\n\tfmt.Println(\"写入错误\")\n}\n```\n\n程序从标准输入接收一个字节（ASCII 字符），调用 `buffer` 的 `WriteByte` 将该字节写入 `buffer` 中，之后通过 `ReadByte` 读取该字节。\n\n### ByteScanner、RuneReader 和 RuneScanner\n\n`ByteScanner` 接口：\n\n```go\ntype ByteScanner interface {\n    ByteReader\n    UnreadByte() error\n}\n```\n\n内嵌了 `ByteReader` 接口，`UnreadByte` 方法的意思是：将上一次 `ReadByte` 的字节还原，使得再次调用 `ReadByte` 返回的结果和上一次调\n用相同，也就是说，`UnreadByte` 是重置上一次的 `ReadByte`。注意，**`UnreadByte` 调用之前必须调用了 `ReadByte`，且不能连续调\n用 `UnreadByte`**。即：\n\n```go\nbuffer := bytes.NewBuffer([]byte{'a', 'b'})\nerr := buffer.UnreadByte()\n```\n\n和\n\n```go\nbuffer := bytes.NewBuffer([]byte{'a', 'b'})\nbuffer.ReadByte()\nerr := buffer.UnreadByte()\nerr = buffer.UnreadByte()\n```\n\n`err` 都 **非 nil**，错误为：`bytes.Buffer: UnreadByte: previous operation was not a read`\n\n`RuneReader` 接口和 `ByteReader` 类似，只是 `ReadRune` 方法读取单个 UTF-8 字符，返回其 `rune` 和该字符占用的字节数。\n\n`RuneScanner` 接口和 `ByteScanner` 类似。\n\n### ReadCloser、ReadSeeker、ReadWriteCloser、ReadWriteSeeker、ReadWriter、WriteCloser 和 WriteSeeker\n\n这些接口是上面介绍的接口的两个或三个组合而成的新接口。`ReadWriter` 接口：\n\n```go\ntype ReadWriter interface {\n    Reader\n    Writer\n}\n```\n\n`Reader` 和 `Writer` 接口的组合。\n\n这些接口的作用是：有些时候同时需要某两个接口的所有功能，即必须同时实现了某两个接口的类型才能够被传入使用。\n\n## SectionReader 类型\n\n`SectionReader` 是一个 `struct`，实现了 `Read`, `Seek` 和 `ReadAt`，同时，内嵌了 `ReaderAt` 接口。结构定义如下：\n\n```go\ntype SectionReader struct {\n\tr     ReaderAt\t// 该类型最终的 Read/ReadAt 最终都是通过 r 的 ReadAt 实现\n\tbase  int64\t\t// NewSectionReader 会将 base 设置为 off\n\toff   int64\t\t// 从 r 中的 off 偏移处开始读取数据\n\tlimit int64\t\t// limit - off = SectionReader 流的长度\n}\n```\n\n该类型读取数据流中部分数据。\n\n```go\nfunc NewSectionReader(r ReaderAt, off int64, n int64) *SectionReader\n```\n\n\n> `NewSectionReader` 返回一个 `SectionReader`，它从 `r` 中的偏移量 `off` 处读取 `n` 个字节后以 `EOF` 停止。\n\n也就是说，SectionReader 只是内部 ReaderAt 表示的数据流的一部分：从 off 开始后的 n 个字节。\n\n这个类型的作用是：方便重复操作某一段 (section) 数据流；或者同时需要 ReadAt 和 Seek 的功能。\n\n由于该类型所支持的操作，前面都有介绍，因此不提供示例代码了。\n\n## LimitedReader 类型\n\n```go\ntype LimitedReader struct {\n    R Reader // underlying reader，最终的读取操作通过 R.Read 完成\n    N int64  // max bytes remaining\n}\n```\n\n\n> 从 `R` 读取但将返回的数据量限制为 `N` 字节。每调用一次 `Read` 都将更新 `N` 来反应新的剩余数量。\n\n也就是说，最多只能返回 `N` 字节数据。\n\n`LimitedReader` 只实现了 `Read` 方法。\n\n示例：\n\n```go\ncontent := \"This Is LimitReader Example\"\nreader := strings.NewReader(content)\nlimitReader := &io.LimitedReader{R: reader, N: 8}\nfor limitReader.N > 0 {\n\ttmp := make([]byte, 2)\n\tlimitReader.Read(tmp)\n\tfmt.Printf(\"%s\", tmp) // This Is\n}\n```\n\n通过该类型可以达到 **只允许读取一定长度数据** 的目的。\n\n在 `io` 包中，`LimitReader` 函数的实现其实就是调用 `LimitedReader`：\n\n```go\nfunc LimitReader(r Reader, n int64) Reader { return &LimitedReader{r, n} }\n```\n\n## PipeReader 和 PipeWriter 类型\n\n`PipeReader` 是管道的读取端。它实现了 `io.Reader` 和 `io.Closer` 接口：\n```go\ntype PipeReader struct {\n\tp *pipe\n}\n```\n\n> 从管道中读取数据。该方法会堵塞，直到管道写入端开始写入数据或写入端被关闭。如果写入端关闭时带有 `error`（即调用 `CloseWithError` 关闭），\n该 `Read` 返回的 `err` 就是写入端传递的 `error`；否则 `err` 为 `EOF`。\n\n`PipeWriter` 是管道的写入端。它实现了 `io.Writer` 和 `io.Closer` 接口：\n```go\ntype PipeWriter struct {\n\tp *pipe\n}\n```\n\n> 写数据到管道中。该方法会堵塞，直到管道读取端读完所有数据或读取端被关闭。如果读取端关闭时\n带有 `error`（即调用 `CloseWithError` 关闭），该 `Write` 返回的 `err` 就是读取端传递的 `error`；否则 `err` 为 `ErrClosedPipe`。\n\n示例：\n\n```go\nfunc main() {\n    pipeReader, pipeWriter := io.Pipe()\n    go PipeWrite(pipeWriter)\n    go PipeRead(pipeReader)\n    time.Sleep(30 * time.Second)\n}\n\nfunc PipeWrite(writer *io.PipeWriter){\n\tdata := []byte(\"Go语言中文网\")\n\tfor i := 0; i < 3; i++{\n\t\tn, err := writer.Write(data)\n\t\tif err != nil{\n\t\t\tfmt.Println(err)\n\t\t\treturn\n\t\t}\n\t\tfmt.Printf(\"写入字节 %d\\n\",n)\n\t}\n\twriter.CloseWithError(errors.New(\"写入段已关闭\"))\n}\n\nfunc PipeRead(reader *io.PipeReader){\n\tbuf := make([]byte, 128)\n\tfor{\n\t\tfmt.Println(\"接口端开始阻塞5秒钟...\")\n\t\ttime.Sleep(5 * time.Second)\n\t\tfmt.Println(\"接收端开始接受\")\n\t\tn, err := reader.Read(buf)\n\t\tif err != nil{\n\t\t\tfmt.Println(err)\n\t\t\treturn\n\t\t}\n\t\tfmt.Printf(\"收到字节: %d\\n buf内容: %s\\n\",n,buf)\n\t}\n}\n```\n\n`io.Pipe()` 用于创建一个同步的内存管道：\n\n```go\nfunc Pipe() (*PipeReader, *PipeWriter)\n```\n\n它将 `io.Reader` 连接到 `io.Writer`。一端的读取匹配另一端的写入，直接在这两端之间复制数据；它没有内部缓存。它对于并行调用 `Read`\n 和 `Write` 以及其它函数或 `Close` 来说都是安全的。一旦等待的 I/O 结束，`Close` 就会完成。并行调用 `Read` 或并行调用 `Write` 也\n同样安全：同种类的调用将按顺序进行控制。\n\n正因为是**同步**的，因此不能在一个 goroutine 中进行读和写。\n\n另外，对于管道的 `close` 方法（非 `CloseWithError` 时），`err` 会被置为 `EOF`。\n\n## Copy 和 CopyN 函数\n\n**Copy 函数**：\n\n```go\nfunc Copy(dst Writer, src Reader) (written int64, err error)\n```\n\n函数文档：\n\n> `Copy` 将 `src` 复制到 `dst`，直到在 `src` 上到达 `EOF` 或发生错误。它返回复制的字节数，如果有错误的话，还会返回在复制时遇到的第一\n个错误。\n\n> 成功的 `Copy` 返回 `err == nil`，而非 `err == EOF`。由于 `Copy` 被定义为从 `src` 读取直到 `EOF` 为止，因此它不会将来\n自 `Read` 的 `EOF` 当做错误来报告。\n\n> 若 `dst` 实现了 `ReaderFrom` 接口，其复制操作可通过调用 `dst.ReadFrom(src)` 实现。此外，若 `src` 实现了 `WriterTo` 接口，其复\n制操作可通过调用 `src.WriteTo(dst)` 实现。\n\n代码：\n\n```go\nio.Copy(os.Stdout, strings.NewReader(\"Go语言中文网\"))\n```\n\n直接将内容输出（写入 Stdout 中）：\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n)\n\nfunc main() {\n\t_, _ = io.Copy(os.Stdout, os.Stdin)\n\tfmt.Println(\"Got EOF -- bye\")\n}\n```\n\n执行：`echo \"Hello, World\" | go run main.go`\n\n\n**CopyN 函数**：\n\n```go\nfunc CopyN(dst Writer, src Reader, n int64) (written int64, err error)\n```\n\n> `CopyN` 将 `n` 个字节(或到一个 `error`)从 `src` 复制到 `dst`。 它返回复制的字节数以及在复制时遇到的最早的错误。\n当且仅当 `err == nil` 时,`written == n` 。\n\n> 若 `dst` 实现了 `ReaderFrom` 接口，复制操作也就会使用它来实现。\n\n代码：\n\n```go\nio.CopyN(os.Stdout, strings.NewReader(\"Go语言中文网\"), 8) // Go语言\n```\n\n## ReadAtLeast 和 ReadFull 函数\n\n**ReadAtLeast 函数**：\n\n```go\nfunc ReadAtLeast(r Reader, buf []byte, min int) (n int, err error)\n```\n\n函数文档：\n\n> `ReadAtLeast` 将 `r` 读取到 `buf` 中，直到读了最少 `min` 个字节为止。它返回复制的字节数，如果读取的字节较少，还会返回一个错误。\n若没有读取到字节，错误就只是 `EOF`。如果一个 `EOF` 发生在读取了少于 `min` 个字节之后，`ReadAtLeast` 就会返回 `ErrUnexpectedEOF`。\n若 `min` 大于 `buf` 的长度，`ReadAtLeast` 就会返回 `ErrShortBuffer`。对于返回值，当且仅当 `err == nil` 时，才有 `n >= min`。\n\n**ReadFull 函数**：\n\n```go\nfunc ReadFull(r Reader, buf []byte) (n int, err error)\n```\n\n函数文档：\n\n> `ReadFull` 精确地从 `r` 中将 `len(buf)` 个字节读取到 `buf` 中。它返回复制的字节数，如果读取的字节较少，还会返回一个错误。若没有读\n取到字节，错误就只是 `EOF`。如果一个 `EOF` 发生在读取了一些但不是所有的字节后，`ReadFull` 就会返回 `ErrUnexpectedEOF`。对于返回值，\n当且仅当 `err == nil` 时，才有 `n == len(buf)`。\n\n注意该函数和 `ReadAtLeast` 的区别：\n- `ReadFull` 将 `buf` 读满\n- `ReadAtLeast` 是最少读取 `min` 个字节。\n\n\n## WriteString 函数\n\n这是为了方便写入 `string` 类型提供的函数，函数签名：\n\n```go\nfunc WriteString(w Writer, s string) (n int, err error)\n```\n\n函数文档：\n\n> `WriteString` 将 ``s 的内容写入 `w` 中，当 `w` 实现了 `WriteString` 方法时，会直接调用该方法，否则执行 `w.Write([]byte(s))`。\n\n## MultiReader 和 MultiWriter 函数\n\n```go\nfunc MultiReader(readers ...Reader) Reader\nfunc MultiWriter(writers ...Writer) Writer\n```\n\n它们接收多个 `Reader` 或 `Writer`，返回一个 `Reader` 或 `Writer`。我们可以猜想到这两个函数就是操作多个 `Reader` 或 `Writer` 就像\n操作一个。\n\n事实上，在 `io` 包中定义了两个非导出类型：`mutilReader` 和 `multiWriter`，它们分别实现了 `io.Reader` 和 `io.Writer` 接口：\n\n```go\ntype multiReader struct {\n\treaders []Reader\n}\n\ntype multiWriter struct {\n\twriters []Writer\n}\n```\n\n对于这两种类型对应的实现方法（`Read` 和 `Write` 方法）的使用，示例：\n\n**MultiReader 的使用**：\n\n```go\nreaders := []io.Reader{\n\tstrings.NewReader(\"from strings reader\"),\n\tbytes.NewBufferString(\"from bytes buffer\"),\n}\nreader := io.MultiReader(readers...)\ndata := make([]byte, 0, 128)\nbuf := make([]byte, 10)\n\t\nfor n, err := reader.Read(buf); err != io.EOF ; n, err = reader.Read(buf){\n\tif err != nil{\n\t\tpanic(err)\n\t}\n\tdata = append(data,buf[:n]...)\n}\nfmt.Printf(\"%s\\n\", data) // from strings readerfrom bytes buffer\n```\n\n代码中首先构造了一个 `io.Reader` 的 `slice`，然后通过 `MultiReader` 得到新的 `Reader`，循环读取新 `Reader` 中的内容。从输出结果\n可以看到，第一次调用 `Reader` 的 `Read` 方法获取到的是 `slice` 中第一个元素的内容……也就是说，`MultiReader` 只是逻辑上将多\n个 `Reader` 组合起来，并不能通过调用一次 `Read` 方法获取所有 `Reader` 的内容。在所有的 `Reader` 内容都被读\n完后，`Reader` 会返回 `EOF`。\n\n**MultiWriter 的使用**：\n\n```go\nfile, err := os.Create(\"tmp.txt\")\nif err != nil {\n    panic(err)\n}\ndefer file.Close()\nwriters := []io.Writer{\n\tfile,\n\tos.Stdout,\n}\nwriter := io.MultiWriter(writers...)\nwriter.Write([]byte(\"Go语言中文网\"))\n```\n\n这段程序执行后在生成 `tmp.txt` 文件，同时在文件和屏幕中都输出：`Go语言中文网`。这和 Unix 中的 tee 命令类似。\n\n\n\n## TeeReader 函数\n\n\n```go\nfunc TeeReader(r Reader, w Writer) Reader\n```\n\n> `TeeReader` 返回一个 `Reader`，它将从 `r` 中读到的数据写入 `w` 中。所有经由它处理的从 `r` 的读取都匹配于对应的对 `w` 的写入。它没\n有内部缓存，即写入必须在读取完成前完成。任何在写入时遇到的错误都将作为读取错误返回。\n\n也就是说，我们通过 `Reader` 读取内容后，会自动写入到 `Writer` 中去。例子代码如下：\n\n```go\nreader := io.TeeReader(strings.NewReader(\"Go语言中文网\"), os.Stdout)\nreader.Read(make([]byte, 20)) // Go语言中文网\n```\n\n\n这种功能的实现其实挺简单，无非是在 `Read` 完后执行 `Write`。","date":"2019-10-19T13:40:15.178Z","updated":"2019-10-19T13:40:15.178Z","path":"standards/io/io.html","comments":1,"layout":"page","_id":"ck1xm14ll001bfcw2zikuuds4","content":"<h1 id=\"io\"><a href=\"#io\" class=\"headerlink\" title=\"io\"></a>io</h1><p><code>io</code> 是对输入输出设备的抽象。<code>io</code> 库对这些功能进行了抽象，通过统一的接口对输入输出设备进行操作。<br>最重要的是两个接口：<code>Reader</code> 和 <code>Writer</code>。</p>\n<h2 id=\"Reader\"><a href=\"#Reader\" class=\"headerlink\" title=\"Reader\"></a>Reader</h2><p>Reader 接口：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Reader <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">    Read(p []<span class=\"keyword\">byte</span>) (n <span class=\"keyword\">int</span>, err error)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>Read</code> 将 <code>len(p)</code> 个字节读取到 <code>p</code> 中。它返回读取的字节数 <code>n</code>（<code>0 &lt;= n &lt;= len(p)</code>） 以及任何遇到的错误。<br>即使 <code>Read</code> 返回的 <code>n &lt; len(p)</code>，它也会在调用过程中占用 <code>len(p)</code> 个字节作为暂存空间。若可读取的数据不到 <code>len(p)</code> 个<br>字节，<code>Read</code> 会返回可用数据，而不是等待更多数据。</p>\n</blockquote>\n<blockquote>\n<p>当 <code>Read</code> 在成功读取 <code>n &gt; 0</code> 个字节后遇到一个错误或 <code>EOF</code> (<code>end-of-file</code>)，它会返回读取的字节数。它可能会同时在本次的调<br>用中返回一个 <code>non-nil</code> 错误,或在下一次的调用中返回这个错误（且 <code>n</code> 为 0）。 一般情况下, <code>Reader</code> 会返回一个 非 0 字节数 <code>n</code>,<br>若 <code>n = len(p)</code> 个字节从输入源的结尾处由 <code>Read</code> 返回，<code>Read</code> 可能返回 <code>err == EOF</code> 或者 <code>err == nil</code>。并且之后的 <code>Read</code><br>都应该返回 (<code>n:0, err:EOF</code>)。</p>\n</blockquote>\n<blockquote>\n<p>调用者在考虑错误之前应当首先处理返回的数据。这样做可以正确地处理在读取一些字节后产生的 I/O 错误，同时允许 <code>EOF</code> 的出现。</p>\n</blockquote>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">ReadFrom</span><span class=\"params\">(reader io.Reader, num <span class=\"keyword\">int</span>)</span> <span class=\"params\">([]<span class=\"keyword\">byte</span>, error)</span></span> &#123;</span><br><span class=\"line\">\tp := <span class=\"built_in\">make</span>([]<span class=\"keyword\">byte</span>, num)</span><br><span class=\"line\">\tn, err := reader.Read(p)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> n &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> p[:n], <span class=\"literal\">nil</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> p, err</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>ReadFrom</code> 函数将 <code>io.Reader</code> 作为参数，也就是说，<code>ReadFrom</code> 可以从任意的地方读取数据，只要来源实现了 <code>io.Reader</code> 接口。<br>比如，我们可以从标准输入、文件、字符串等读取数据，示例代码如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 从标准输入读取</span></span><br><span class=\"line\">data, err = ReadFrom(os.Stdin, <span class=\"number\">11</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 从普通文件读取，其中 file 是 os.File 的实例</span></span><br><span class=\"line\">data, err = ReadFrom(file, <span class=\"number\">9</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 从字符串读取</span></span><br><span class=\"line\">data, err = ReadFrom(strings.NewReader(<span class=\"string\">\"from string\"</span>), <span class=\"number\">12</span>)</span><br></pre></td></tr></table></figure>\n<p><code>io.EOF</code> 变量的定义：<code>var EOF = errors.New(&quot;EOF&quot;)</code>，是 <code>error</code> 类型。根据 <code>reader</code> 接口的说明，在 <code>n &gt; 0</code> 且数据被读完了<br>的情况下，当次返回的 <code>error</code> 有可能是 <code>EOF</code> 也有可能是 <code>nil</code>。</p>\n<h2 id=\"Writer\"><a href=\"#Writer\" class=\"headerlink\" title=\"Writer\"></a>Writer</h2><p>Writer 接口：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Writer <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">    Write(p []<span class=\"keyword\">byte</span>) (n <span class=\"keyword\">int</span>, err error)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>Write</code> 将 <code>len(p)</code> 个字节从 <code>p</code> 中写入到基本数据流中。它返回从 <code>p</code> 中被写入的字节数 <code>n</code>（<code>0 &lt;= n &lt;= len(p)</code>）以及任何遇到的引<br>起写入提前停止的错误。若 <code>Write</code> 返回的 <code>n &lt; len(p)</code>，它就必须返回一个 <strong>非 nil</strong> 的错误。</p>\n</blockquote>\n<p>以 <code>fmt.Fprintln</code> 为例：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Println</span><span class=\"params\">(a ...<span class=\"keyword\">interface</span>&#123;&#125;)</span> <span class=\"params\">(n <span class=\"keyword\">int</span>, err error)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> Fprintln(os.Stdout, a...)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看出 <code>fmt.Println</code> 会将内容输出到标准输出中。</p>\n<h2 id=\"实现了-io-Reader-接口或-io-Writer-接口的类型\"><a href=\"#实现了-io-Reader-接口或-io-Writer-接口的类型\" class=\"headerlink\" title=\"实现了 io.Reader 接口或 io.Writer 接口的类型\"></a>实现了 io.Reader 接口或 io.Writer 接口的类型</h2><p>标准库中有哪些类型实现了 <code>io.Reader</code> 或 <code>io.Writer</code> 接口？</p>\n<p>例如 <code>os.Stdin/Stdout</code>，它们分别实现了 <code>io.Reader/io.Writer</code> 接口：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> (</span><br><span class=\"line\">    Stdin  = NewFile(<span class=\"keyword\">uintptr</span>(syscall.Stdin), <span class=\"string\">\"/dev/stdin\"</span>)</span><br><span class=\"line\">    Stdout = NewFile(<span class=\"keyword\">uintptr</span>(syscall.Stdout), <span class=\"string\">\"/dev/stdout\"</span>)</span><br><span class=\"line\">    Stderr = NewFile(<span class=\"keyword\">uintptr</span>(syscall.Stderr), <span class=\"string\">\"/dev/stderr\"</span>)</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>上面的代码可以看出，<code>Stdin/Stdout/Stderr</code> 只是三个特殊的文件类型的标识（都是 <code>os.File</code> 的实例），<code>os.File</code> 实现<br>了 <code>io.Reader</code> 和 <code>io.Writer</code>。</p>\n<p>实现了 <code>io.Reader</code> 或 <code>io.Writer</code> 接口的类型：</p>\n<ul>\n<li><code>os.File</code> 同时实现了 <code>io.Reader</code> 和 <code>io.Writer</code></li>\n<li><code>strings.Reader</code> 实现了 <code>io.Reader</code></li>\n<li><code>bufio.Reader/Writer</code> 分别实现了 <code>io.Reader</code> 和 <code>io.Writer</code></li>\n<li><code>bytes.Buffer</code> 同时实现了 <code>io.Reader</code> 和 <code>io.Writer</code></li>\n<li><code>bytes.Reader</code> 实现了 <code>io.Reader</code></li>\n<li><code>compress/gzip.Reader/Writer</code> 分别实现了 <code>io.Reader</code> 和 <code>io.Writer</code></li>\n<li><code>crypto/cipher.StreamReader/StreamWriter</code> 分别实现了 <code>io.Reader</code> 和 <code>io.Writer</code></li>\n<li><code>crypto/tls.Conn</code> 同时实现了 <code>io.Reader</code> 和 <code>io.Writer</code></li>\n<li><code>encoding/csv.Reader/Writer</code> 分别实现了 <code>io.Reader</code> 和 <code>io.Writer</code></li>\n<li><code>mime/multipart.Part</code> 实现了 <code>io.Reader</code></li>\n<li><code>net/conn</code> 分别实现了 <code>io.Reader</code> 和 <code>io.Writer</code>(Conn接口定义了Read/Write)</li>\n</ul>\n<p><strong>io 包本身实现这两个接口的类型</strong>：</p>\n<ul>\n<li>实现了 <code>Reader</code> 的类型：<code>LimitedReader</code>、<code>PipeReader</code>、<code>SectionReader</code></li>\n<li>实现了 <code>Writer</code> 的类型：<code>PipeWriter</code></li>\n</ul>\n<h2 id=\"ReaderAt-和-WriterAt\"><a href=\"#ReaderAt-和-WriterAt\" class=\"headerlink\" title=\"ReaderAt 和 WriterAt\"></a>ReaderAt 和 WriterAt</h2><p><strong><code>ReaderAt</code> 接口</strong>：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> ReaderAt <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">    ReadAt(p []<span class=\"keyword\">byte</span>, off <span class=\"keyword\">int64</span>) (n <span class=\"keyword\">int</span>, err error)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>ReadAt</code> 从基本输入源的偏移量 <code>off</code> 处开始，将 <code>len(p)</code> 个字节读到 <code>p</code> 中。它返回读取的字节数 <code>n</code>（<code>0 &lt;= n &lt;= len(p)</code>）以及任<br>何遇到的错误。</p>\n</blockquote>\n<blockquote>\n<p>当 <code>ReadAt</code> 返回的 <code>n &lt; len(p)</code> 时，它就会返回一个 <strong>非 nil</strong> 的错误来解释为什么没有返回更多的字节。</p>\n</blockquote>\n<blockquote>\n<p>即使 <code>ReadAt</code> 返回的 <code>n &lt; len(p)</code>，它也会在调用过程中使用 <code>p</code> 的全部作为暂存空间。若可读取的数据不到 <code>len(p)</code> 字节，<code>ReadAt</code> 就会<br>阻塞,直到所有数据都可用或一个错误发生。</p>\n</blockquote>\n<blockquote>\n<p>若 <code>n = len(p)</code> 个字节从输入源的结尾处由 <code>ReadAt</code> 返回，<code>Read</code> 可能返回 <code>err == EOF</code> 或者 <code>err == nil</code></p>\n</blockquote>\n<blockquote>\n<p>若 <code>ReadAt</code> 携带一个偏移量从输入源读取，<code>ReadAt</code> 应当既不影响偏移量也不被它所影响。</p>\n</blockquote>\n<blockquote>\n<p>可对相同的输入源并行执行 <code>ReadAt</code> 调用。</p>\n</blockquote>\n<p>可见，<code>ReadAt</code> 接口使得可以从指定偏移量处开始读取数据。</p>\n<p>简单示例代码如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">reader := strings.NewReader(<span class=\"string\">\"Hello world\"</span>)</span><br><span class=\"line\">p := <span class=\"built_in\">make</span>([]<span class=\"keyword\">byte</span>, <span class=\"number\">6</span>)</span><br><span class=\"line\">n, err := reader.ReadAt(p, <span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">panic</span>(err)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fmt.Printf(<span class=\"string\">\"%s, %d\\n\"</span>, p, n) <span class=\"comment\">// llo wo, 6</span></span><br></pre></td></tr></table></figure>\n<p><strong><code>WriterAt</code> 接口</strong>：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> WriterAt <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">    WriteAt(p []<span class=\"keyword\">byte</span>, off <span class=\"keyword\">int64</span>) (n <span class=\"keyword\">int</span>, err error)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>WriteAt</code> 从 <code>p</code> 中将 <code>len(p)</code> 个字节写入到偏移量 <code>off</code> 处的基本数据流中。它返回从 <code>p</code> 中被写入的字节数 <code>n</code>（<code>0 &lt;= n &lt;= len(p)</code>）<br>以及任何遇到的引起写入提前停止的错误。若 <code>WriteAt</code> 返回的 <code>n &lt; len(p)</code>，它就必须返回一个 <strong>非 nil</strong> 的错误。</p>\n</blockquote>\n<blockquote>\n<p>若 <code>WriteAt</code> 携带一个偏移量写入到目标中，<code>WriteAt</code> 应当既不影响偏移量也不被它所影响。</p>\n</blockquote>\n<blockquote>\n<p>若被写区域没有重叠，可对相同的目标并行执行 <code>WriteAt</code> 调用。</p>\n</blockquote>\n<p>我们可以通过该接口将数据写入到数据流的特定偏移量之后。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">file, err := os.Create(<span class=\"string\">\"writeAt.txt\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">panic</span>(err)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">defer</span> file.Close()</span><br><span class=\"line\">_, _ = file.WriteString(<span class=\"string\">\"Hello world----ignore\"</span>)</span><br><span class=\"line\">n, err := file.WriteAt([]<span class=\"keyword\">byte</span>(<span class=\"string\">\"Golang\"</span>), <span class=\"number\">15</span>)</span><br><span class=\"line\"><span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">panic</span>(err)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fmt.Println(n)</span><br></pre></td></tr></table></figure>\n<p>打开文件 <code>WriteAt.txt</code>，内容是：<code>Hello world----Golang</code>。</p>\n<p>分析：</p>\n<p><code>file.WriteString(&quot;Hello world----ignore&quot;)</code> 往文件中写入 <code>Hello world----ignore</code>，之后<br><code>file.WriteAt([]byte(&quot;Golang&quot;), 15)</code> 在文件流的 <code>offset=15</code> 处写入 <code>Golang</code>（会覆盖该位置的内容）。</p>\n<h2 id=\"ReaderFrom-和-WriterTo\"><a href=\"#ReaderFrom-和-WriterTo\" class=\"headerlink\" title=\"ReaderFrom 和 WriterTo\"></a>ReaderFrom 和 WriterTo</h2><p>这两个接口实现了<strong>一次性从某个地方读或写到某个地方去</strong>。<br><strong>ReaderFrom</strong>：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> ReaderFrom <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">    ReadFrom(r Reader) (n <span class=\"keyword\">int64</span>, err error)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>ReadFrom</code> 从 <code>r</code> 中读取数据，直到 <code>EOF</code> 或发生错误。其返回值 <code>n</code> 为读取的字节数。除 <code>io.EOF</code> 之外，在读取过程中遇到的任何错误也<br>将被返回。</p>\n</blockquote>\n<blockquote>\n<p>如果 <code>ReaderFrom</code> 可用，<code>Copy</code> 函数就会使用它。</p>\n</blockquote>\n<p>注意：<code>ReadFrom</code> 方法不会返回 <code>err == EOF</code>。</p>\n<p>将文件中的数据全部读取（显示在标准输出）：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">file, err := os.Open(<span class=\"string\">\"writeAt.txt\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">panic</span>(err)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">defer</span> file.Close()</span><br><span class=\"line\">writer := bufio.NewWriter(os.Stdout)</span><br><span class=\"line\">writer.ReadFrom(file)</span><br><span class=\"line\">writer.Flush()</span><br></pre></td></tr></table></figure>\n<p>也可以通过 <code>ioutil</code> 包的 <code>ReadFile</code> 函数获取文件全部内容。其实，跟踪一下 <code>ioutil.ReadFile</code> 的源码，会发现其实也是通过 <code>ReadFrom</code> 方<br>法实现（用的是 <code>bytes.Buffer</code>，它实现了 <code>ReaderFrom</code> 接口）。</p>\n<p><strong>WriterTo</strong>：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> WriterTo <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">    WriteTo(w Writer) (n <span class=\"keyword\">int64</span>, err error)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>WriteTo</code> 将数据写入 <code>w</code> 中，直到没有数据可写或发生错误。其返回值 <code>n</code> 为写入的字节数。 在写入过程中遇到的任何错误也将被返回。</p>\n</blockquote>\n<blockquote>\n<p>如果 <code>WriterTo</code> 可用，<code>Copy</code> 函数就会使用它。</p>\n</blockquote>\n<p>将一段文本输出到标准输出：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">reader := bytes.NewReader([]<span class=\"keyword\">byte</span>(<span class=\"string\">\"Hello world\"</span>))</span><br><span class=\"line\">reader.WriteTo(os.Stdout)</span><br></pre></td></tr></table></figure>\n<h2 id=\"Seeker\"><a href=\"#Seeker\" class=\"headerlink\" title=\"Seeker\"></a>Seeker</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Seeker <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">    Seek(offset <span class=\"keyword\">int64</span>, whence <span class=\"keyword\">int</span>) (ret <span class=\"keyword\">int64</span>, err error)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>Seek</code> 设置下一次 <code>Read</code> 或 <code>Write</code> 的偏移量为 <code>offset</code>，它的解释取决于 <code>whence</code>：  <strong>0 表示相对于文件的起始处，1 表示相对<br>于当前的偏移，而 2 表示相对于其结尾处</strong>。 <code>Seek</code> 返回新的偏移量和一个错误，如果有的话。</p>\n</blockquote>\n<p>也就是说，<code>Seek</code> 方法是用于设置偏移量的，这样可以从某个特定位置开始操作数据流。听起来和 <code>ReaderAt/WriteAt</code> 接口有些类似，<br>不过 <code>Seeker</code> 接口更灵活，可以更好的控制读写数据流的位置。</p>\n<p>获取倒数第二个字符（需要考虑 UTF-8 编码，这里的代码只是一个示例）：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">reader := strings.NewReader(<span class=\"string\">\"Hello world\"</span>)</span><br><span class=\"line\">reader.Seek(<span class=\"number\">-6</span>, io.SeekEnd)</span><br><span class=\"line\">r, _, _ := reader.ReadRune()</span><br><span class=\"line\">fmt.Printf(<span class=\"string\">\"%c\\n\"</span>, r)</span><br></pre></td></tr></table></figure>\n<p><code>whence</code> 的值，在 io 包中定义了相应的常量，应该使用这些常量</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">  SeekStart   = <span class=\"number\">0</span> <span class=\"comment\">// seek relative to the origin of the file</span></span><br><span class=\"line\">  SeekCurrent = <span class=\"number\">1</span> <span class=\"comment\">// seek relative to the current offset</span></span><br><span class=\"line\">  SeekEnd     = <span class=\"number\">2</span> <span class=\"comment\">// seek relative to the end</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>而原先 <code>os</code> 包中的常量已经被标注为 Deprecated</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Deprecated: Use io.SeekStart, io.SeekCurrent, and io.SeekEnd.</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">  SEEK_SET <span class=\"keyword\">int</span> = <span class=\"number\">0</span> <span class=\"comment\">// seek relative to the origin of the file</span></span><br><span class=\"line\">  SEEK_CUR <span class=\"keyword\">int</span> = <span class=\"number\">1</span> <span class=\"comment\">// seek relative to the current offset</span></span><br><span class=\"line\">  SEEK_END <span class=\"keyword\">int</span> = <span class=\"number\">2</span> <span class=\"comment\">// seek relative to the end</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<h2 id=\"Closer\"><a href=\"#Closer\" class=\"headerlink\" title=\"Closer\"></a>Closer</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Closer <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">    Close() error</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该接口比较简单，只有一个 <code>Close()</code> 方法，用于关闭数据流。</p>\n<p>文件 (<code>os.File</code>)、归档（压缩包）、数据库连接、<code>Socket</code> 等需要手动关闭的资源都实现了 <code>Closer</code> 接口。</p>\n<p>实际编程中，经常将 <code>Close</code> 方法的调用放在 <code>defer</code> 语句中。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">file, err := os.Open(<span class=\"string\">\"studygolang.txt\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">defer</span> file.Close()</span><br><span class=\"line\"><span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当文件 <code>studygolang.txt</code> 不存在或找不到时，<code>file.Close()</code> 会返回错误，因为 <code>file</code> 是 <code>nil</code>。<br>因此，应该<strong>将 <code>defer file.Close()</code> 放在错误检查之后</strong>。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(f *File)</span> <span class=\"title\">Close</span><span class=\"params\">()</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> f == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ErrInvalid</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> f.file.<span class=\"built_in\">close</span>()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"其他接口\"><a href=\"#其他接口\" class=\"headerlink\" title=\"其他接口\"></a>其他接口</h2><h3 id=\"ByteReader-和-ByteWriter\"><a href=\"#ByteReader-和-ByteWriter\" class=\"headerlink\" title=\"ByteReader 和 ByteWriter\"></a>ByteReader 和 ByteWriter</h3><p>读或写一个字节：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> ByteReader <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">    ReadByte() (c <span class=\"keyword\">byte</span>, err error)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> ByteWriter <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">    WriteByte(c <span class=\"keyword\">byte</span>) error</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>下面类型都实现了这两个接口:</p>\n<ul>\n<li><code>bufio.Reader/Writer</code> 分别实现了 <code>io.ByteReader</code> 和 <code>io.ByteWriter</code></li>\n<li><code>bytes.Buffer</code> 同时实现了 <code>io.ByteReader</code> 和 <code>io.ByteWriter</code></li>\n<li><code>bytes.Reader</code> 实现了 <code>io.ByteReader</code></li>\n<li><code>strings.Reader</code> 实现了 <code>io.ByteReader</code></li>\n</ul>\n<p>通过 <code>bytes.Buffer</code> 来一次读取或写入一个字节：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> ch <span class=\"keyword\">byte</span></span><br><span class=\"line\">fmt.Scanf(<span class=\"string\">\"%c\\n\"</span>, &amp;ch)</span><br><span class=\"line\"></span><br><span class=\"line\">buffer := <span class=\"built_in\">new</span>(bytes.Buffer)</span><br><span class=\"line\">err := buffer.WriteByte(ch)</span><br><span class=\"line\"><span class=\"keyword\">if</span> err == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">\"写入一个字节成功！准备读取该字节……\"</span>)</span><br><span class=\"line\">\tnewCh, _ := buffer.ReadByte()</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"读取的字节：%c\\n\"</span>, newCh)</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">\"写入错误\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>程序从标准输入接收一个字节（ASCII 字符），调用 <code>buffer</code> 的 <code>WriteByte</code> 将该字节写入 <code>buffer</code> 中，之后通过 <code>ReadByte</code> 读取该字节。</p>\n<h3 id=\"ByteScanner、RuneReader-和-RuneScanner\"><a href=\"#ByteScanner、RuneReader-和-RuneScanner\" class=\"headerlink\" title=\"ByteScanner、RuneReader 和 RuneScanner\"></a>ByteScanner、RuneReader 和 RuneScanner</h3><p><code>ByteScanner</code> 接口：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> ByteScanner <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">    ByteReader</span><br><span class=\"line\">    UnreadByte() error</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>内嵌了 <code>ByteReader</code> 接口，<code>UnreadByte</code> 方法的意思是：将上一次 <code>ReadByte</code> 的字节还原，使得再次调用 <code>ReadByte</code> 返回的结果和上一次调<br>用相同，也就是说，<code>UnreadByte</code> 是重置上一次的 <code>ReadByte</code>。注意，<strong><code>UnreadByte</code> 调用之前必须调用了 <code>ReadByte</code>，且不能连续调<br>用 <code>UnreadByte</code></strong>。即：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">buffer := bytes.NewBuffer([]<span class=\"keyword\">byte</span>&#123;<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>&#125;)</span><br><span class=\"line\">err := buffer.UnreadByte()</span><br></pre></td></tr></table></figure>\n<p>和</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">buffer := bytes.NewBuffer([]<span class=\"keyword\">byte</span>&#123;<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>&#125;)</span><br><span class=\"line\">buffer.ReadByte()</span><br><span class=\"line\">err := buffer.UnreadByte()</span><br><span class=\"line\">err = buffer.UnreadByte()</span><br></pre></td></tr></table></figure>\n<p><code>err</code> 都 <strong>非 nil</strong>，错误为：<code>bytes.Buffer: UnreadByte: previous operation was not a read</code></p>\n<p><code>RuneReader</code> 接口和 <code>ByteReader</code> 类似，只是 <code>ReadRune</code> 方法读取单个 UTF-8 字符，返回其 <code>rune</code> 和该字符占用的字节数。</p>\n<p><code>RuneScanner</code> 接口和 <code>ByteScanner</code> 类似。</p>\n<h3 id=\"ReadCloser、ReadSeeker、ReadWriteCloser、ReadWriteSeeker、ReadWriter、WriteCloser-和-WriteSeeker\"><a href=\"#ReadCloser、ReadSeeker、ReadWriteCloser、ReadWriteSeeker、ReadWriter、WriteCloser-和-WriteSeeker\" class=\"headerlink\" title=\"ReadCloser、ReadSeeker、ReadWriteCloser、ReadWriteSeeker、ReadWriter、WriteCloser 和 WriteSeeker\"></a>ReadCloser、ReadSeeker、ReadWriteCloser、ReadWriteSeeker、ReadWriter、WriteCloser 和 WriteSeeker</h3><p>这些接口是上面介绍的接口的两个或三个组合而成的新接口。<code>ReadWriter</code> 接口：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> ReadWriter <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">    Reader</span><br><span class=\"line\">    Writer</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>Reader</code> 和 <code>Writer</code> 接口的组合。</p>\n<p>这些接口的作用是：有些时候同时需要某两个接口的所有功能，即必须同时实现了某两个接口的类型才能够被传入使用。</p>\n<h2 id=\"SectionReader-类型\"><a href=\"#SectionReader-类型\" class=\"headerlink\" title=\"SectionReader 类型\"></a>SectionReader 类型</h2><p><code>SectionReader</code> 是一个 <code>struct</code>，实现了 <code>Read</code>, <code>Seek</code> 和 <code>ReadAt</code>，同时，内嵌了 <code>ReaderAt</code> 接口。结构定义如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> SectionReader <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tr     ReaderAt\t<span class=\"comment\">// 该类型最终的 Read/ReadAt 最终都是通过 r 的 ReadAt 实现</span></span><br><span class=\"line\">\tbase  <span class=\"keyword\">int64</span>\t\t<span class=\"comment\">// NewSectionReader 会将 base 设置为 off</span></span><br><span class=\"line\">\toff   <span class=\"keyword\">int64</span>\t\t<span class=\"comment\">// 从 r 中的 off 偏移处开始读取数据</span></span><br><span class=\"line\">\tlimit <span class=\"keyword\">int64</span>\t\t<span class=\"comment\">// limit - off = SectionReader 流的长度</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该类型读取数据流中部分数据。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewSectionReader</span><span class=\"params\">(r ReaderAt, off <span class=\"keyword\">int64</span>, n <span class=\"keyword\">int64</span>)</span> *<span class=\"title\">SectionReader</span></span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>NewSectionReader</code> 返回一个 <code>SectionReader</code>，它从 <code>r</code> 中的偏移量 <code>off</code> 处读取 <code>n</code> 个字节后以 <code>EOF</code> 停止。</p>\n</blockquote>\n<p>也就是说，SectionReader 只是内部 ReaderAt 表示的数据流的一部分：从 off 开始后的 n 个字节。</p>\n<p>这个类型的作用是：方便重复操作某一段 (section) 数据流；或者同时需要 ReadAt 和 Seek 的功能。</p>\n<p>由于该类型所支持的操作，前面都有介绍，因此不提供示例代码了。</p>\n<h2 id=\"LimitedReader-类型\"><a href=\"#LimitedReader-类型\" class=\"headerlink\" title=\"LimitedReader 类型\"></a>LimitedReader 类型</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> LimitedReader <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    R Reader <span class=\"comment\">// underlying reader，最终的读取操作通过 R.Read 完成</span></span><br><span class=\"line\">    N <span class=\"keyword\">int64</span>  <span class=\"comment\">// max bytes remaining</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>从 <code>R</code> 读取但将返回的数据量限制为 <code>N</code> 字节。每调用一次 <code>Read</code> 都将更新 <code>N</code> 来反应新的剩余数量。</p>\n</blockquote>\n<p>也就是说，最多只能返回 <code>N</code> 字节数据。</p>\n<p><code>LimitedReader</code> 只实现了 <code>Read</code> 方法。</p>\n<p>示例：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">content := <span class=\"string\">\"This Is LimitReader Example\"</span></span><br><span class=\"line\">reader := strings.NewReader(content)</span><br><span class=\"line\">limitReader := &amp;io.LimitedReader&#123;R: reader, N: <span class=\"number\">8</span>&#125;</span><br><span class=\"line\"><span class=\"keyword\">for</span> limitReader.N &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\ttmp := <span class=\"built_in\">make</span>([]<span class=\"keyword\">byte</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\">\tlimitReader.Read(tmp)</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"%s\"</span>, tmp) <span class=\"comment\">// This Is</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过该类型可以达到 <strong>只允许读取一定长度数据</strong> 的目的。</p>\n<p>在 <code>io</code> 包中，<code>LimitReader</code> 函数的实现其实就是调用 <code>LimitedReader</code>：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">LimitReader</span><span class=\"params\">(r Reader, n <span class=\"keyword\">int64</span>)</span> <span class=\"title\">Reader</span></span> &#123; <span class=\"keyword\">return</span> &amp;LimitedReader&#123;r, n&#125; &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"PipeReader-和-PipeWriter-类型\"><a href=\"#PipeReader-和-PipeWriter-类型\" class=\"headerlink\" title=\"PipeReader 和 PipeWriter 类型\"></a>PipeReader 和 PipeWriter 类型</h2><p><code>PipeReader</code> 是管道的读取端。它实现了 <code>io.Reader</code> 和 <code>io.Closer</code> 接口：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> PipeReader <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tp *pipe</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>从管道中读取数据。该方法会堵塞，直到管道写入端开始写入数据或写入端被关闭。如果写入端关闭时带有 <code>error</code>（即调用 <code>CloseWithError</code> 关闭），<br>该 <code>Read</code> 返回的 <code>err</code> 就是写入端传递的 <code>error</code>；否则 <code>err</code> 为 <code>EOF</code>。</p>\n</blockquote>\n<p><code>PipeWriter</code> 是管道的写入端。它实现了 <code>io.Writer</code> 和 <code>io.Closer</code> 接口：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> PipeWriter <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tp *pipe</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>写数据到管道中。该方法会堵塞，直到管道读取端读完所有数据或读取端被关闭。如果读取端关闭时<br>带有 <code>error</code>（即调用 <code>CloseWithError</code> 关闭），该 <code>Write</code> 返回的 <code>err</code> 就是读取端传递的 <code>error</code>；否则 <code>err</code> 为 <code>ErrClosedPipe</code>。</p>\n</blockquote>\n<p>示例：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    pipeReader, pipeWriter := io.Pipe()</span><br><span class=\"line\">    <span class=\"keyword\">go</span> PipeWrite(pipeWriter)</span><br><span class=\"line\">    <span class=\"keyword\">go</span> PipeRead(pipeReader)</span><br><span class=\"line\">    time.Sleep(<span class=\"number\">30</span> * time.Second)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">PipeWrite</span><span class=\"params\">(writer *io.PipeWriter)</span></span>&#123;</span><br><span class=\"line\">\tdata := []<span class=\"keyword\">byte</span>(<span class=\"string\">\"Go语言中文网\"</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">3</span>; i++&#123;</span><br><span class=\"line\">\t\tn, err := writer.Write(data)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span>&#123;</span><br><span class=\"line\">\t\t\tfmt.Println(err)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tfmt.Printf(<span class=\"string\">\"写入字节 %d\\n\"</span>,n)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\twriter.CloseWithError(errors.New(<span class=\"string\">\"写入段已关闭\"</span>))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">PipeRead</span><span class=\"params\">(reader *io.PipeReader)</span></span>&#123;</span><br><span class=\"line\">\tbuf := <span class=\"built_in\">make</span>([]<span class=\"keyword\">byte</span>, <span class=\"number\">128</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>&#123;</span><br><span class=\"line\">\t\tfmt.Println(<span class=\"string\">\"接口端开始阻塞5秒钟...\"</span>)</span><br><span class=\"line\">\t\ttime.Sleep(<span class=\"number\">5</span> * time.Second)</span><br><span class=\"line\">\t\tfmt.Println(<span class=\"string\">\"接收端开始接受\"</span>)</span><br><span class=\"line\">\t\tn, err := reader.Read(buf)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span>&#123;</span><br><span class=\"line\">\t\t\tfmt.Println(err)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tfmt.Printf(<span class=\"string\">\"收到字节: %d\\n buf内容: %s\\n\"</span>,n,buf)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>io.Pipe()</code> 用于创建一个同步的内存管道：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Pipe</span><span class=\"params\">()</span> <span class=\"params\">(*PipeReader, *PipeWriter)</span></span></span><br></pre></td></tr></table></figure>\n<p>它将 <code>io.Reader</code> 连接到 <code>io.Writer</code>。一端的读取匹配另一端的写入，直接在这两端之间复制数据；它没有内部缓存。它对于并行调用 <code>Read</code><br> 和 <code>Write</code> 以及其它函数或 <code>Close</code> 来说都是安全的。一旦等待的 I/O 结束，<code>Close</code> 就会完成。并行调用 <code>Read</code> 或并行调用 <code>Write</code> 也<br>同样安全：同种类的调用将按顺序进行控制。</p>\n<p>正因为是<strong>同步</strong>的，因此不能在一个 goroutine 中进行读和写。</p>\n<p>另外，对于管道的 <code>close</code> 方法（非 <code>CloseWithError</code> 时），<code>err</code> 会被置为 <code>EOF</code>。</p>\n<h2 id=\"Copy-和-CopyN-函数\"><a href=\"#Copy-和-CopyN-函数\" class=\"headerlink\" title=\"Copy 和 CopyN 函数\"></a>Copy 和 CopyN 函数</h2><p><strong>Copy 函数</strong>：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Copy</span><span class=\"params\">(dst Writer, src Reader)</span> <span class=\"params\">(written <span class=\"keyword\">int64</span>, err error)</span></span></span><br></pre></td></tr></table></figure>\n<p>函数文档：</p>\n<blockquote>\n<p><code>Copy</code> 将 <code>src</code> 复制到 <code>dst</code>，直到在 <code>src</code> 上到达 <code>EOF</code> 或发生错误。它返回复制的字节数，如果有错误的话，还会返回在复制时遇到的第一<br>个错误。</p>\n</blockquote>\n<blockquote>\n<p>成功的 <code>Copy</code> 返回 <code>err == nil</code>，而非 <code>err == EOF</code>。由于 <code>Copy</code> 被定义为从 <code>src</code> 读取直到 <code>EOF</code> 为止，因此它不会将来<br>自 <code>Read</code> 的 <code>EOF</code> 当做错误来报告。</p>\n</blockquote>\n<blockquote>\n<p>若 <code>dst</code> 实现了 <code>ReaderFrom</code> 接口，其复制操作可通过调用 <code>dst.ReadFrom(src)</code> 实现。此外，若 <code>src</code> 实现了 <code>WriterTo</code> 接口，其复<br>制操作可通过调用 <code>src.WriteTo(dst)</code> 实现。</p>\n</blockquote>\n<p>代码：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">io.Copy(os.Stdout, strings.NewReader(<span class=\"string\">\"Go语言中文网\"</span>))</span><br></pre></td></tr></table></figure>\n<p>直接将内容输出（写入 Stdout 中）：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">\"fmt\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"io\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"os\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t_, _ = io.Copy(os.Stdout, os.Stdin)</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">\"Got EOF -- bye\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>执行：<code>echo &quot;Hello, World&quot; | go run main.go</code></p>\n<p><strong>CopyN 函数</strong>：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">CopyN</span><span class=\"params\">(dst Writer, src Reader, n <span class=\"keyword\">int64</span>)</span> <span class=\"params\">(written <span class=\"keyword\">int64</span>, err error)</span></span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>CopyN</code> 将 <code>n</code> 个字节(或到一个 <code>error</code>)从 <code>src</code> 复制到 <code>dst</code>。 它返回复制的字节数以及在复制时遇到的最早的错误。<br>当且仅当 <code>err == nil</code> 时,<code>written == n</code> 。</p>\n</blockquote>\n<blockquote>\n<p>若 <code>dst</code> 实现了 <code>ReaderFrom</code> 接口，复制操作也就会使用它来实现。</p>\n</blockquote>\n<p>代码：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">io.CopyN(os.Stdout, strings.NewReader(<span class=\"string\">\"Go语言中文网\"</span>), <span class=\"number\">8</span>) <span class=\"comment\">// Go语言</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"ReadAtLeast-和-ReadFull-函数\"><a href=\"#ReadAtLeast-和-ReadFull-函数\" class=\"headerlink\" title=\"ReadAtLeast 和 ReadFull 函数\"></a>ReadAtLeast 和 ReadFull 函数</h2><p><strong>ReadAtLeast 函数</strong>：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">ReadAtLeast</span><span class=\"params\">(r Reader, buf []<span class=\"keyword\">byte</span>, min <span class=\"keyword\">int</span>)</span> <span class=\"params\">(n <span class=\"keyword\">int</span>, err error)</span></span></span><br></pre></td></tr></table></figure>\n<p>函数文档：</p>\n<blockquote>\n<p><code>ReadAtLeast</code> 将 <code>r</code> 读取到 <code>buf</code> 中，直到读了最少 <code>min</code> 个字节为止。它返回复制的字节数，如果读取的字节较少，还会返回一个错误。<br>若没有读取到字节，错误就只是 <code>EOF</code>。如果一个 <code>EOF</code> 发生在读取了少于 <code>min</code> 个字节之后，<code>ReadAtLeast</code> 就会返回 <code>ErrUnexpectedEOF</code>。<br>若 <code>min</code> 大于 <code>buf</code> 的长度，<code>ReadAtLeast</code> 就会返回 <code>ErrShortBuffer</code>。对于返回值，当且仅当 <code>err == nil</code> 时，才有 <code>n &gt;= min</code>。</p>\n</blockquote>\n<p><strong>ReadFull 函数</strong>：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">ReadFull</span><span class=\"params\">(r Reader, buf []<span class=\"keyword\">byte</span>)</span> <span class=\"params\">(n <span class=\"keyword\">int</span>, err error)</span></span></span><br></pre></td></tr></table></figure>\n<p>函数文档：</p>\n<blockquote>\n<p><code>ReadFull</code> 精确地从 <code>r</code> 中将 <code>len(buf)</code> 个字节读取到 <code>buf</code> 中。它返回复制的字节数，如果读取的字节较少，还会返回一个错误。若没有读<br>取到字节，错误就只是 <code>EOF</code>。如果一个 <code>EOF</code> 发生在读取了一些但不是所有的字节后，<code>ReadFull</code> 就会返回 <code>ErrUnexpectedEOF</code>。对于返回值，<br>当且仅当 <code>err == nil</code> 时，才有 <code>n == len(buf)</code>。</p>\n</blockquote>\n<p>注意该函数和 <code>ReadAtLeast</code> 的区别：</p>\n<ul>\n<li><code>ReadFull</code> 将 <code>buf</code> 读满</li>\n<li><code>ReadAtLeast</code> 是最少读取 <code>min</code> 个字节。</li>\n</ul>\n<h2 id=\"WriteString-函数\"><a href=\"#WriteString-函数\" class=\"headerlink\" title=\"WriteString 函数\"></a>WriteString 函数</h2><p>这是为了方便写入 <code>string</code> 类型提供的函数，函数签名：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">WriteString</span><span class=\"params\">(w Writer, s <span class=\"keyword\">string</span>)</span> <span class=\"params\">(n <span class=\"keyword\">int</span>, err error)</span></span></span><br></pre></td></tr></table></figure>\n<p>函数文档：</p>\n<blockquote>\n<p><code>WriteString</code> 将 <code></code>s 的内容写入 <code>w</code> 中，当 <code>w</code> 实现了 <code>WriteString</code> 方法时，会直接调用该方法，否则执行 <code>w.Write([]byte(s))</code>。</p>\n</blockquote>\n<h2 id=\"MultiReader-和-MultiWriter-函数\"><a href=\"#MultiReader-和-MultiWriter-函数\" class=\"headerlink\" title=\"MultiReader 和 MultiWriter 函数\"></a>MultiReader 和 MultiWriter 函数</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">MultiReader</span><span class=\"params\">(readers ...Reader)</span> <span class=\"title\">Reader</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">MultiWriter</span><span class=\"params\">(writers ...Writer)</span> <span class=\"title\">Writer</span></span></span><br></pre></td></tr></table></figure>\n<p>它们接收多个 <code>Reader</code> 或 <code>Writer</code>，返回一个 <code>Reader</code> 或 <code>Writer</code>。我们可以猜想到这两个函数就是操作多个 <code>Reader</code> 或 <code>Writer</code> 就像<br>操作一个。</p>\n<p>事实上，在 <code>io</code> 包中定义了两个非导出类型：<code>mutilReader</code> 和 <code>multiWriter</code>，它们分别实现了 <code>io.Reader</code> 和 <code>io.Writer</code> 接口：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> multiReader <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\treaders []Reader</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> multiWriter <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\twriters []Writer</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对于这两种类型对应的实现方法（<code>Read</code> 和 <code>Write</code> 方法）的使用，示例：</p>\n<p><strong>MultiReader 的使用</strong>：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">readers := []io.Reader&#123;</span><br><span class=\"line\">\tstrings.NewReader(<span class=\"string\">\"from strings reader\"</span>),</span><br><span class=\"line\">\tbytes.NewBufferString(<span class=\"string\">\"from bytes buffer\"</span>),</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">reader := io.MultiReader(readers...)</span><br><span class=\"line\">data := <span class=\"built_in\">make</span>([]<span class=\"keyword\">byte</span>, <span class=\"number\">0</span>, <span class=\"number\">128</span>)</span><br><span class=\"line\">buf := <span class=\"built_in\">make</span>([]<span class=\"keyword\">byte</span>, <span class=\"number\">10</span>)</span><br><span class=\"line\">\t</span><br><span class=\"line\"><span class=\"keyword\">for</span> n, err := reader.Read(buf); err != io.EOF ; n, err = reader.Read(buf)&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">panic</span>(err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tdata = <span class=\"built_in\">append</span>(data,buf[:n]...)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fmt.Printf(<span class=\"string\">\"%s\\n\"</span>, data) <span class=\"comment\">// from strings readerfrom bytes buffer</span></span><br></pre></td></tr></table></figure>\n<p>代码中首先构造了一个 <code>io.Reader</code> 的 <code>slice</code>，然后通过 <code>MultiReader</code> 得到新的 <code>Reader</code>，循环读取新 <code>Reader</code> 中的内容。从输出结果<br>可以看到，第一次调用 <code>Reader</code> 的 <code>Read</code> 方法获取到的是 <code>slice</code> 中第一个元素的内容……也就是说，<code>MultiReader</code> 只是逻辑上将多<br>个 <code>Reader</code> 组合起来，并不能通过调用一次 <code>Read</code> 方法获取所有 <code>Reader</code> 的内容。在所有的 <code>Reader</code> 内容都被读<br>完后，<code>Reader</code> 会返回 <code>EOF</code>。</p>\n<p><strong>MultiWriter 的使用</strong>：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">file, err := os.Create(<span class=\"string\">\"tmp.txt\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">panic</span>(err)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">defer</span> file.Close()</span><br><span class=\"line\">writers := []io.Writer&#123;</span><br><span class=\"line\">\tfile,</span><br><span class=\"line\">\tos.Stdout,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">writer := io.MultiWriter(writers...)</span><br><span class=\"line\">writer.Write([]<span class=\"keyword\">byte</span>(<span class=\"string\">\"Go语言中文网\"</span>))</span><br></pre></td></tr></table></figure>\n<p>这段程序执行后在生成 <code>tmp.txt</code> 文件，同时在文件和屏幕中都输出：<code>Go语言中文网</code>。这和 Unix 中的 tee 命令类似。</p>\n<h2 id=\"TeeReader-函数\"><a href=\"#TeeReader-函数\" class=\"headerlink\" title=\"TeeReader 函数\"></a>TeeReader 函数</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TeeReader</span><span class=\"params\">(r Reader, w Writer)</span> <span class=\"title\">Reader</span></span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>TeeReader</code> 返回一个 <code>Reader</code>，它将从 <code>r</code> 中读到的数据写入 <code>w</code> 中。所有经由它处理的从 <code>r</code> 的读取都匹配于对应的对 <code>w</code> 的写入。它没<br>有内部缓存，即写入必须在读取完成前完成。任何在写入时遇到的错误都将作为读取错误返回。</p>\n</blockquote>\n<p>也就是说，我们通过 <code>Reader</code> 读取内容后，会自动写入到 <code>Writer</code> 中去。例子代码如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">reader := io.TeeReader(strings.NewReader(<span class=\"string\">\"Go语言中文网\"</span>), os.Stdout)</span><br><span class=\"line\">reader.Read(<span class=\"built_in\">make</span>([]<span class=\"keyword\">byte</span>, <span class=\"number\">20</span>)) <span class=\"comment\">// Go语言中文网</span></span><br></pre></td></tr></table></figure>\n<p>这种功能的实现其实挺简单，无非是在 <code>Read</code> 完后执行 <code>Write</code>。</p>\n","site":{"data":{"navigation":{"logo":{"text":"Golang Learn","type":"link","path":"index.html"},"main":[{"text":"Golang 基础","type":"label"},{"text":"Go 环境配置","type":"link","path":"basic/env_config.html"},{"text":"包","type":"link","path":"basic/package.html"},{"text":"基础数据类型","type":"link","path":"basic/basic_data.html"},{"text":"变量","type":"link","path":"basic/var.html"},{"text":"常量","type":"link","path":"basic/constant.html"},{"text":"控制语句","type":"link","path":"basic/flow.html"},{"text":"运算符","type":"link","path":"basic/operator.html"},{"text":"作用域","type":"link","path":"basic/scope.html"},{"text":"指针","type":"link","path":"basic/pointer.html"},{"text":"数组","type":"link","path":"basic/array.html"},{"text":"切片","type":"link","path":"basic/slice.html"},{"text":"字典","type":"link","path":"basic/map.html"},{"text":"函数","type":"link","path":"basic/function.html"},{"text":"结构体","type":"link","path":"basic/struct.html"},{"text":"接口","type":"link","path":"basic/interface.html"},{"text":"面向对象","type":"link","path":"basic/oop.html"},{"text":"错误","type":"link","path":"basic/error.html"},{"text":"序列化","type":"link","path":"basic/json.html"},{"text":"反射","type":"link","path":"basic/reflect.html"},{"text":"测试","type":"link","path":"basic/test.html"},{"text":"并发编程","type":"label"},{"text":"goroutine","type":"link","path":"concurrent/goroutine.html"},{"text":"channel","type":"link","path":"concurrent/channel.html"},{"text":"同步和锁","type":"link","path":"concurrent/sync_lock.html"},{"text":"内存分配","type":"label"},{"text":"内存分配","type":"link","path":"advance/mm.html"},{"text":"垃圾回收","type":"label"},{"text":"垃圾回收","type":"link","path":"advance/gc.html"},{"text":"标准库","type":"label"},{"text":"fmt","type":"link","path":"standards/io/fmt.html"},{"text":"io","type":"link","path":"standards/io/io.html"},{"text":"ioutil","type":"link","path":"standards/io/ioutil.html"},{"text":"bufio","type":"link","path":"standards/io/bufio.html"},{"text":"os","type":"link","path":"standards/os/os.html"},{"text":"filepath","type":"link","path":"standards/os/filepath.html"},{"text":"strings","type":"link","path":"standards/text/strings.html"},{"text":"strconv","type":"link","path":"standards/text/strconv.html"},{"text":"unicode","type":"link","path":"standards/text/unicode.html"},{"text":"log","type":"link","path":"standards/log.html"},{"text":"time","type":"link","path":"standards/time.html"},{"text":"http","type":"link","path":"standards/net/http.html"},{"text":"math","type":"link","path":"standards/data/math.html"},{"text":"sort","type":"link","path":"standards/data/sort.html"},{"text":"big","type":"link","path":"standards/data/big.html"},{"text":"container","type":"link","path":"standards/data/container.html"},{"text":"sql","type":"link","path":"standards/database/sql.html"},{"text":"THEME","type":"label"},{"text":"使用文档主题","type":"link","path":"theme/theme-usage.html"},{"text":"SUPPORT AND FEEDBACK","type":"label"},{"text":"Raise an Issue on Github","type":"link","path":"https://github.com/shipengqi/golang-learn/issues/new"}]}}},"excerpt":"","more":"<h1 id=\"io\"><a href=\"#io\" class=\"headerlink\" title=\"io\"></a>io</h1><p><code>io</code> 是对输入输出设备的抽象。<code>io</code> 库对这些功能进行了抽象，通过统一的接口对输入输出设备进行操作。<br>最重要的是两个接口：<code>Reader</code> 和 <code>Writer</code>。</p>\n<h2 id=\"Reader\"><a href=\"#Reader\" class=\"headerlink\" title=\"Reader\"></a>Reader</h2><p>Reader 接口：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Reader <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">    Read(p []<span class=\"keyword\">byte</span>) (n <span class=\"keyword\">int</span>, err error)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>Read</code> 将 <code>len(p)</code> 个字节读取到 <code>p</code> 中。它返回读取的字节数 <code>n</code>（<code>0 &lt;= n &lt;= len(p)</code>） 以及任何遇到的错误。<br>即使 <code>Read</code> 返回的 <code>n &lt; len(p)</code>，它也会在调用过程中占用 <code>len(p)</code> 个字节作为暂存空间。若可读取的数据不到 <code>len(p)</code> 个<br>字节，<code>Read</code> 会返回可用数据，而不是等待更多数据。</p>\n</blockquote>\n<blockquote>\n<p>当 <code>Read</code> 在成功读取 <code>n &gt; 0</code> 个字节后遇到一个错误或 <code>EOF</code> (<code>end-of-file</code>)，它会返回读取的字节数。它可能会同时在本次的调<br>用中返回一个 <code>non-nil</code> 错误,或在下一次的调用中返回这个错误（且 <code>n</code> 为 0）。 一般情况下, <code>Reader</code> 会返回一个 非 0 字节数 <code>n</code>,<br>若 <code>n = len(p)</code> 个字节从输入源的结尾处由 <code>Read</code> 返回，<code>Read</code> 可能返回 <code>err == EOF</code> 或者 <code>err == nil</code>。并且之后的 <code>Read</code><br>都应该返回 (<code>n:0, err:EOF</code>)。</p>\n</blockquote>\n<blockquote>\n<p>调用者在考虑错误之前应当首先处理返回的数据。这样做可以正确地处理在读取一些字节后产生的 I/O 错误，同时允许 <code>EOF</code> 的出现。</p>\n</blockquote>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">ReadFrom</span><span class=\"params\">(reader io.Reader, num <span class=\"keyword\">int</span>)</span> <span class=\"params\">([]<span class=\"keyword\">byte</span>, error)</span></span> &#123;</span><br><span class=\"line\">\tp := <span class=\"built_in\">make</span>([]<span class=\"keyword\">byte</span>, num)</span><br><span class=\"line\">\tn, err := reader.Read(p)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> n &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> p[:n], <span class=\"literal\">nil</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> p, err</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>ReadFrom</code> 函数将 <code>io.Reader</code> 作为参数，也就是说，<code>ReadFrom</code> 可以从任意的地方读取数据，只要来源实现了 <code>io.Reader</code> 接口。<br>比如，我们可以从标准输入、文件、字符串等读取数据，示例代码如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 从标准输入读取</span></span><br><span class=\"line\">data, err = ReadFrom(os.Stdin, <span class=\"number\">11</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 从普通文件读取，其中 file 是 os.File 的实例</span></span><br><span class=\"line\">data, err = ReadFrom(file, <span class=\"number\">9</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 从字符串读取</span></span><br><span class=\"line\">data, err = ReadFrom(strings.NewReader(<span class=\"string\">\"from string\"</span>), <span class=\"number\">12</span>)</span><br></pre></td></tr></table></figure>\n<p><code>io.EOF</code> 变量的定义：<code>var EOF = errors.New(&quot;EOF&quot;)</code>，是 <code>error</code> 类型。根据 <code>reader</code> 接口的说明，在 <code>n &gt; 0</code> 且数据被读完了<br>的情况下，当次返回的 <code>error</code> 有可能是 <code>EOF</code> 也有可能是 <code>nil</code>。</p>\n<h2 id=\"Writer\"><a href=\"#Writer\" class=\"headerlink\" title=\"Writer\"></a>Writer</h2><p>Writer 接口：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Writer <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">    Write(p []<span class=\"keyword\">byte</span>) (n <span class=\"keyword\">int</span>, err error)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>Write</code> 将 <code>len(p)</code> 个字节从 <code>p</code> 中写入到基本数据流中。它返回从 <code>p</code> 中被写入的字节数 <code>n</code>（<code>0 &lt;= n &lt;= len(p)</code>）以及任何遇到的引<br>起写入提前停止的错误。若 <code>Write</code> 返回的 <code>n &lt; len(p)</code>，它就必须返回一个 <strong>非 nil</strong> 的错误。</p>\n</blockquote>\n<p>以 <code>fmt.Fprintln</code> 为例：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Println</span><span class=\"params\">(a ...<span class=\"keyword\">interface</span>&#123;&#125;)</span> <span class=\"params\">(n <span class=\"keyword\">int</span>, err error)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> Fprintln(os.Stdout, a...)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看出 <code>fmt.Println</code> 会将内容输出到标准输出中。</p>\n<h2 id=\"实现了-io-Reader-接口或-io-Writer-接口的类型\"><a href=\"#实现了-io-Reader-接口或-io-Writer-接口的类型\" class=\"headerlink\" title=\"实现了 io.Reader 接口或 io.Writer 接口的类型\"></a>实现了 io.Reader 接口或 io.Writer 接口的类型</h2><p>标准库中有哪些类型实现了 <code>io.Reader</code> 或 <code>io.Writer</code> 接口？</p>\n<p>例如 <code>os.Stdin/Stdout</code>，它们分别实现了 <code>io.Reader/io.Writer</code> 接口：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> (</span><br><span class=\"line\">    Stdin  = NewFile(<span class=\"keyword\">uintptr</span>(syscall.Stdin), <span class=\"string\">\"/dev/stdin\"</span>)</span><br><span class=\"line\">    Stdout = NewFile(<span class=\"keyword\">uintptr</span>(syscall.Stdout), <span class=\"string\">\"/dev/stdout\"</span>)</span><br><span class=\"line\">    Stderr = NewFile(<span class=\"keyword\">uintptr</span>(syscall.Stderr), <span class=\"string\">\"/dev/stderr\"</span>)</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>上面的代码可以看出，<code>Stdin/Stdout/Stderr</code> 只是三个特殊的文件类型的标识（都是 <code>os.File</code> 的实例），<code>os.File</code> 实现<br>了 <code>io.Reader</code> 和 <code>io.Writer</code>。</p>\n<p>实现了 <code>io.Reader</code> 或 <code>io.Writer</code> 接口的类型：</p>\n<ul>\n<li><code>os.File</code> 同时实现了 <code>io.Reader</code> 和 <code>io.Writer</code></li>\n<li><code>strings.Reader</code> 实现了 <code>io.Reader</code></li>\n<li><code>bufio.Reader/Writer</code> 分别实现了 <code>io.Reader</code> 和 <code>io.Writer</code></li>\n<li><code>bytes.Buffer</code> 同时实现了 <code>io.Reader</code> 和 <code>io.Writer</code></li>\n<li><code>bytes.Reader</code> 实现了 <code>io.Reader</code></li>\n<li><code>compress/gzip.Reader/Writer</code> 分别实现了 <code>io.Reader</code> 和 <code>io.Writer</code></li>\n<li><code>crypto/cipher.StreamReader/StreamWriter</code> 分别实现了 <code>io.Reader</code> 和 <code>io.Writer</code></li>\n<li><code>crypto/tls.Conn</code> 同时实现了 <code>io.Reader</code> 和 <code>io.Writer</code></li>\n<li><code>encoding/csv.Reader/Writer</code> 分别实现了 <code>io.Reader</code> 和 <code>io.Writer</code></li>\n<li><code>mime/multipart.Part</code> 实现了 <code>io.Reader</code></li>\n<li><code>net/conn</code> 分别实现了 <code>io.Reader</code> 和 <code>io.Writer</code>(Conn接口定义了Read/Write)</li>\n</ul>\n<p><strong>io 包本身实现这两个接口的类型</strong>：</p>\n<ul>\n<li>实现了 <code>Reader</code> 的类型：<code>LimitedReader</code>、<code>PipeReader</code>、<code>SectionReader</code></li>\n<li>实现了 <code>Writer</code> 的类型：<code>PipeWriter</code></li>\n</ul>\n<h2 id=\"ReaderAt-和-WriterAt\"><a href=\"#ReaderAt-和-WriterAt\" class=\"headerlink\" title=\"ReaderAt 和 WriterAt\"></a>ReaderAt 和 WriterAt</h2><p><strong><code>ReaderAt</code> 接口</strong>：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> ReaderAt <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">    ReadAt(p []<span class=\"keyword\">byte</span>, off <span class=\"keyword\">int64</span>) (n <span class=\"keyword\">int</span>, err error)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>ReadAt</code> 从基本输入源的偏移量 <code>off</code> 处开始，将 <code>len(p)</code> 个字节读到 <code>p</code> 中。它返回读取的字节数 <code>n</code>（<code>0 &lt;= n &lt;= len(p)</code>）以及任<br>何遇到的错误。</p>\n</blockquote>\n<blockquote>\n<p>当 <code>ReadAt</code> 返回的 <code>n &lt; len(p)</code> 时，它就会返回一个 <strong>非 nil</strong> 的错误来解释为什么没有返回更多的字节。</p>\n</blockquote>\n<blockquote>\n<p>即使 <code>ReadAt</code> 返回的 <code>n &lt; len(p)</code>，它也会在调用过程中使用 <code>p</code> 的全部作为暂存空间。若可读取的数据不到 <code>len(p)</code> 字节，<code>ReadAt</code> 就会<br>阻塞,直到所有数据都可用或一个错误发生。</p>\n</blockquote>\n<blockquote>\n<p>若 <code>n = len(p)</code> 个字节从输入源的结尾处由 <code>ReadAt</code> 返回，<code>Read</code> 可能返回 <code>err == EOF</code> 或者 <code>err == nil</code></p>\n</blockquote>\n<blockquote>\n<p>若 <code>ReadAt</code> 携带一个偏移量从输入源读取，<code>ReadAt</code> 应当既不影响偏移量也不被它所影响。</p>\n</blockquote>\n<blockquote>\n<p>可对相同的输入源并行执行 <code>ReadAt</code> 调用。</p>\n</blockquote>\n<p>可见，<code>ReadAt</code> 接口使得可以从指定偏移量处开始读取数据。</p>\n<p>简单示例代码如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">reader := strings.NewReader(<span class=\"string\">\"Hello world\"</span>)</span><br><span class=\"line\">p := <span class=\"built_in\">make</span>([]<span class=\"keyword\">byte</span>, <span class=\"number\">6</span>)</span><br><span class=\"line\">n, err := reader.ReadAt(p, <span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">panic</span>(err)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fmt.Printf(<span class=\"string\">\"%s, %d\\n\"</span>, p, n) <span class=\"comment\">// llo wo, 6</span></span><br></pre></td></tr></table></figure>\n<p><strong><code>WriterAt</code> 接口</strong>：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> WriterAt <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">    WriteAt(p []<span class=\"keyword\">byte</span>, off <span class=\"keyword\">int64</span>) (n <span class=\"keyword\">int</span>, err error)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>WriteAt</code> 从 <code>p</code> 中将 <code>len(p)</code> 个字节写入到偏移量 <code>off</code> 处的基本数据流中。它返回从 <code>p</code> 中被写入的字节数 <code>n</code>（<code>0 &lt;= n &lt;= len(p)</code>）<br>以及任何遇到的引起写入提前停止的错误。若 <code>WriteAt</code> 返回的 <code>n &lt; len(p)</code>，它就必须返回一个 <strong>非 nil</strong> 的错误。</p>\n</blockquote>\n<blockquote>\n<p>若 <code>WriteAt</code> 携带一个偏移量写入到目标中，<code>WriteAt</code> 应当既不影响偏移量也不被它所影响。</p>\n</blockquote>\n<blockquote>\n<p>若被写区域没有重叠，可对相同的目标并行执行 <code>WriteAt</code> 调用。</p>\n</blockquote>\n<p>我们可以通过该接口将数据写入到数据流的特定偏移量之后。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">file, err := os.Create(<span class=\"string\">\"writeAt.txt\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">panic</span>(err)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">defer</span> file.Close()</span><br><span class=\"line\">_, _ = file.WriteString(<span class=\"string\">\"Hello world----ignore\"</span>)</span><br><span class=\"line\">n, err := file.WriteAt([]<span class=\"keyword\">byte</span>(<span class=\"string\">\"Golang\"</span>), <span class=\"number\">15</span>)</span><br><span class=\"line\"><span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">panic</span>(err)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fmt.Println(n)</span><br></pre></td></tr></table></figure>\n<p>打开文件 <code>WriteAt.txt</code>，内容是：<code>Hello world----Golang</code>。</p>\n<p>分析：</p>\n<p><code>file.WriteString(&quot;Hello world----ignore&quot;)</code> 往文件中写入 <code>Hello world----ignore</code>，之后<br><code>file.WriteAt([]byte(&quot;Golang&quot;), 15)</code> 在文件流的 <code>offset=15</code> 处写入 <code>Golang</code>（会覆盖该位置的内容）。</p>\n<h2 id=\"ReaderFrom-和-WriterTo\"><a href=\"#ReaderFrom-和-WriterTo\" class=\"headerlink\" title=\"ReaderFrom 和 WriterTo\"></a>ReaderFrom 和 WriterTo</h2><p>这两个接口实现了<strong>一次性从某个地方读或写到某个地方去</strong>。<br><strong>ReaderFrom</strong>：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> ReaderFrom <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">    ReadFrom(r Reader) (n <span class=\"keyword\">int64</span>, err error)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>ReadFrom</code> 从 <code>r</code> 中读取数据，直到 <code>EOF</code> 或发生错误。其返回值 <code>n</code> 为读取的字节数。除 <code>io.EOF</code> 之外，在读取过程中遇到的任何错误也<br>将被返回。</p>\n</blockquote>\n<blockquote>\n<p>如果 <code>ReaderFrom</code> 可用，<code>Copy</code> 函数就会使用它。</p>\n</blockquote>\n<p>注意：<code>ReadFrom</code> 方法不会返回 <code>err == EOF</code>。</p>\n<p>将文件中的数据全部读取（显示在标准输出）：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">file, err := os.Open(<span class=\"string\">\"writeAt.txt\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">panic</span>(err)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">defer</span> file.Close()</span><br><span class=\"line\">writer := bufio.NewWriter(os.Stdout)</span><br><span class=\"line\">writer.ReadFrom(file)</span><br><span class=\"line\">writer.Flush()</span><br></pre></td></tr></table></figure>\n<p>也可以通过 <code>ioutil</code> 包的 <code>ReadFile</code> 函数获取文件全部内容。其实，跟踪一下 <code>ioutil.ReadFile</code> 的源码，会发现其实也是通过 <code>ReadFrom</code> 方<br>法实现（用的是 <code>bytes.Buffer</code>，它实现了 <code>ReaderFrom</code> 接口）。</p>\n<p><strong>WriterTo</strong>：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> WriterTo <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">    WriteTo(w Writer) (n <span class=\"keyword\">int64</span>, err error)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>WriteTo</code> 将数据写入 <code>w</code> 中，直到没有数据可写或发生错误。其返回值 <code>n</code> 为写入的字节数。 在写入过程中遇到的任何错误也将被返回。</p>\n</blockquote>\n<blockquote>\n<p>如果 <code>WriterTo</code> 可用，<code>Copy</code> 函数就会使用它。</p>\n</blockquote>\n<p>将一段文本输出到标准输出：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">reader := bytes.NewReader([]<span class=\"keyword\">byte</span>(<span class=\"string\">\"Hello world\"</span>))</span><br><span class=\"line\">reader.WriteTo(os.Stdout)</span><br></pre></td></tr></table></figure>\n<h2 id=\"Seeker\"><a href=\"#Seeker\" class=\"headerlink\" title=\"Seeker\"></a>Seeker</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Seeker <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">    Seek(offset <span class=\"keyword\">int64</span>, whence <span class=\"keyword\">int</span>) (ret <span class=\"keyword\">int64</span>, err error)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>Seek</code> 设置下一次 <code>Read</code> 或 <code>Write</code> 的偏移量为 <code>offset</code>，它的解释取决于 <code>whence</code>：  <strong>0 表示相对于文件的起始处，1 表示相对<br>于当前的偏移，而 2 表示相对于其结尾处</strong>。 <code>Seek</code> 返回新的偏移量和一个错误，如果有的话。</p>\n</blockquote>\n<p>也就是说，<code>Seek</code> 方法是用于设置偏移量的，这样可以从某个特定位置开始操作数据流。听起来和 <code>ReaderAt/WriteAt</code> 接口有些类似，<br>不过 <code>Seeker</code> 接口更灵活，可以更好的控制读写数据流的位置。</p>\n<p>获取倒数第二个字符（需要考虑 UTF-8 编码，这里的代码只是一个示例）：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">reader := strings.NewReader(<span class=\"string\">\"Hello world\"</span>)</span><br><span class=\"line\">reader.Seek(<span class=\"number\">-6</span>, io.SeekEnd)</span><br><span class=\"line\">r, _, _ := reader.ReadRune()</span><br><span class=\"line\">fmt.Printf(<span class=\"string\">\"%c\\n\"</span>, r)</span><br></pre></td></tr></table></figure>\n<p><code>whence</code> 的值，在 io 包中定义了相应的常量，应该使用这些常量</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">  SeekStart   = <span class=\"number\">0</span> <span class=\"comment\">// seek relative to the origin of the file</span></span><br><span class=\"line\">  SeekCurrent = <span class=\"number\">1</span> <span class=\"comment\">// seek relative to the current offset</span></span><br><span class=\"line\">  SeekEnd     = <span class=\"number\">2</span> <span class=\"comment\">// seek relative to the end</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>而原先 <code>os</code> 包中的常量已经被标注为 Deprecated</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Deprecated: Use io.SeekStart, io.SeekCurrent, and io.SeekEnd.</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">  SEEK_SET <span class=\"keyword\">int</span> = <span class=\"number\">0</span> <span class=\"comment\">// seek relative to the origin of the file</span></span><br><span class=\"line\">  SEEK_CUR <span class=\"keyword\">int</span> = <span class=\"number\">1</span> <span class=\"comment\">// seek relative to the current offset</span></span><br><span class=\"line\">  SEEK_END <span class=\"keyword\">int</span> = <span class=\"number\">2</span> <span class=\"comment\">// seek relative to the end</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<h2 id=\"Closer\"><a href=\"#Closer\" class=\"headerlink\" title=\"Closer\"></a>Closer</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Closer <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">    Close() error</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该接口比较简单，只有一个 <code>Close()</code> 方法，用于关闭数据流。</p>\n<p>文件 (<code>os.File</code>)、归档（压缩包）、数据库连接、<code>Socket</code> 等需要手动关闭的资源都实现了 <code>Closer</code> 接口。</p>\n<p>实际编程中，经常将 <code>Close</code> 方法的调用放在 <code>defer</code> 语句中。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">file, err := os.Open(<span class=\"string\">\"studygolang.txt\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">defer</span> file.Close()</span><br><span class=\"line\"><span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当文件 <code>studygolang.txt</code> 不存在或找不到时，<code>file.Close()</code> 会返回错误，因为 <code>file</code> 是 <code>nil</code>。<br>因此，应该<strong>将 <code>defer file.Close()</code> 放在错误检查之后</strong>。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(f *File)</span> <span class=\"title\">Close</span><span class=\"params\">()</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> f == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ErrInvalid</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> f.file.<span class=\"built_in\">close</span>()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"其他接口\"><a href=\"#其他接口\" class=\"headerlink\" title=\"其他接口\"></a>其他接口</h2><h3 id=\"ByteReader-和-ByteWriter\"><a href=\"#ByteReader-和-ByteWriter\" class=\"headerlink\" title=\"ByteReader 和 ByteWriter\"></a>ByteReader 和 ByteWriter</h3><p>读或写一个字节：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> ByteReader <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">    ReadByte() (c <span class=\"keyword\">byte</span>, err error)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> ByteWriter <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">    WriteByte(c <span class=\"keyword\">byte</span>) error</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>下面类型都实现了这两个接口:</p>\n<ul>\n<li><code>bufio.Reader/Writer</code> 分别实现了 <code>io.ByteReader</code> 和 <code>io.ByteWriter</code></li>\n<li><code>bytes.Buffer</code> 同时实现了 <code>io.ByteReader</code> 和 <code>io.ByteWriter</code></li>\n<li><code>bytes.Reader</code> 实现了 <code>io.ByteReader</code></li>\n<li><code>strings.Reader</code> 实现了 <code>io.ByteReader</code></li>\n</ul>\n<p>通过 <code>bytes.Buffer</code> 来一次读取或写入一个字节：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> ch <span class=\"keyword\">byte</span></span><br><span class=\"line\">fmt.Scanf(<span class=\"string\">\"%c\\n\"</span>, &amp;ch)</span><br><span class=\"line\"></span><br><span class=\"line\">buffer := <span class=\"built_in\">new</span>(bytes.Buffer)</span><br><span class=\"line\">err := buffer.WriteByte(ch)</span><br><span class=\"line\"><span class=\"keyword\">if</span> err == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">\"写入一个字节成功！准备读取该字节……\"</span>)</span><br><span class=\"line\">\tnewCh, _ := buffer.ReadByte()</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"读取的字节：%c\\n\"</span>, newCh)</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">\"写入错误\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>程序从标准输入接收一个字节（ASCII 字符），调用 <code>buffer</code> 的 <code>WriteByte</code> 将该字节写入 <code>buffer</code> 中，之后通过 <code>ReadByte</code> 读取该字节。</p>\n<h3 id=\"ByteScanner、RuneReader-和-RuneScanner\"><a href=\"#ByteScanner、RuneReader-和-RuneScanner\" class=\"headerlink\" title=\"ByteScanner、RuneReader 和 RuneScanner\"></a>ByteScanner、RuneReader 和 RuneScanner</h3><p><code>ByteScanner</code> 接口：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> ByteScanner <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">    ByteReader</span><br><span class=\"line\">    UnreadByte() error</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>内嵌了 <code>ByteReader</code> 接口，<code>UnreadByte</code> 方法的意思是：将上一次 <code>ReadByte</code> 的字节还原，使得再次调用 <code>ReadByte</code> 返回的结果和上一次调<br>用相同，也就是说，<code>UnreadByte</code> 是重置上一次的 <code>ReadByte</code>。注意，<strong><code>UnreadByte</code> 调用之前必须调用了 <code>ReadByte</code>，且不能连续调<br>用 <code>UnreadByte</code></strong>。即：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">buffer := bytes.NewBuffer([]<span class=\"keyword\">byte</span>&#123;<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>&#125;)</span><br><span class=\"line\">err := buffer.UnreadByte()</span><br></pre></td></tr></table></figure>\n<p>和</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">buffer := bytes.NewBuffer([]<span class=\"keyword\">byte</span>&#123;<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>&#125;)</span><br><span class=\"line\">buffer.ReadByte()</span><br><span class=\"line\">err := buffer.UnreadByte()</span><br><span class=\"line\">err = buffer.UnreadByte()</span><br></pre></td></tr></table></figure>\n<p><code>err</code> 都 <strong>非 nil</strong>，错误为：<code>bytes.Buffer: UnreadByte: previous operation was not a read</code></p>\n<p><code>RuneReader</code> 接口和 <code>ByteReader</code> 类似，只是 <code>ReadRune</code> 方法读取单个 UTF-8 字符，返回其 <code>rune</code> 和该字符占用的字节数。</p>\n<p><code>RuneScanner</code> 接口和 <code>ByteScanner</code> 类似。</p>\n<h3 id=\"ReadCloser、ReadSeeker、ReadWriteCloser、ReadWriteSeeker、ReadWriter、WriteCloser-和-WriteSeeker\"><a href=\"#ReadCloser、ReadSeeker、ReadWriteCloser、ReadWriteSeeker、ReadWriter、WriteCloser-和-WriteSeeker\" class=\"headerlink\" title=\"ReadCloser、ReadSeeker、ReadWriteCloser、ReadWriteSeeker、ReadWriter、WriteCloser 和 WriteSeeker\"></a>ReadCloser、ReadSeeker、ReadWriteCloser、ReadWriteSeeker、ReadWriter、WriteCloser 和 WriteSeeker</h3><p>这些接口是上面介绍的接口的两个或三个组合而成的新接口。<code>ReadWriter</code> 接口：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> ReadWriter <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">    Reader</span><br><span class=\"line\">    Writer</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>Reader</code> 和 <code>Writer</code> 接口的组合。</p>\n<p>这些接口的作用是：有些时候同时需要某两个接口的所有功能，即必须同时实现了某两个接口的类型才能够被传入使用。</p>\n<h2 id=\"SectionReader-类型\"><a href=\"#SectionReader-类型\" class=\"headerlink\" title=\"SectionReader 类型\"></a>SectionReader 类型</h2><p><code>SectionReader</code> 是一个 <code>struct</code>，实现了 <code>Read</code>, <code>Seek</code> 和 <code>ReadAt</code>，同时，内嵌了 <code>ReaderAt</code> 接口。结构定义如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> SectionReader <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tr     ReaderAt\t<span class=\"comment\">// 该类型最终的 Read/ReadAt 最终都是通过 r 的 ReadAt 实现</span></span><br><span class=\"line\">\tbase  <span class=\"keyword\">int64</span>\t\t<span class=\"comment\">// NewSectionReader 会将 base 设置为 off</span></span><br><span class=\"line\">\toff   <span class=\"keyword\">int64</span>\t\t<span class=\"comment\">// 从 r 中的 off 偏移处开始读取数据</span></span><br><span class=\"line\">\tlimit <span class=\"keyword\">int64</span>\t\t<span class=\"comment\">// limit - off = SectionReader 流的长度</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该类型读取数据流中部分数据。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewSectionReader</span><span class=\"params\">(r ReaderAt, off <span class=\"keyword\">int64</span>, n <span class=\"keyword\">int64</span>)</span> *<span class=\"title\">SectionReader</span></span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>NewSectionReader</code> 返回一个 <code>SectionReader</code>，它从 <code>r</code> 中的偏移量 <code>off</code> 处读取 <code>n</code> 个字节后以 <code>EOF</code> 停止。</p>\n</blockquote>\n<p>也就是说，SectionReader 只是内部 ReaderAt 表示的数据流的一部分：从 off 开始后的 n 个字节。</p>\n<p>这个类型的作用是：方便重复操作某一段 (section) 数据流；或者同时需要 ReadAt 和 Seek 的功能。</p>\n<p>由于该类型所支持的操作，前面都有介绍，因此不提供示例代码了。</p>\n<h2 id=\"LimitedReader-类型\"><a href=\"#LimitedReader-类型\" class=\"headerlink\" title=\"LimitedReader 类型\"></a>LimitedReader 类型</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> LimitedReader <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    R Reader <span class=\"comment\">// underlying reader，最终的读取操作通过 R.Read 完成</span></span><br><span class=\"line\">    N <span class=\"keyword\">int64</span>  <span class=\"comment\">// max bytes remaining</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>从 <code>R</code> 读取但将返回的数据量限制为 <code>N</code> 字节。每调用一次 <code>Read</code> 都将更新 <code>N</code> 来反应新的剩余数量。</p>\n</blockquote>\n<p>也就是说，最多只能返回 <code>N</code> 字节数据。</p>\n<p><code>LimitedReader</code> 只实现了 <code>Read</code> 方法。</p>\n<p>示例：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">content := <span class=\"string\">\"This Is LimitReader Example\"</span></span><br><span class=\"line\">reader := strings.NewReader(content)</span><br><span class=\"line\">limitReader := &amp;io.LimitedReader&#123;R: reader, N: <span class=\"number\">8</span>&#125;</span><br><span class=\"line\"><span class=\"keyword\">for</span> limitReader.N &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\ttmp := <span class=\"built_in\">make</span>([]<span class=\"keyword\">byte</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\">\tlimitReader.Read(tmp)</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"%s\"</span>, tmp) <span class=\"comment\">// This Is</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过该类型可以达到 <strong>只允许读取一定长度数据</strong> 的目的。</p>\n<p>在 <code>io</code> 包中，<code>LimitReader</code> 函数的实现其实就是调用 <code>LimitedReader</code>：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">LimitReader</span><span class=\"params\">(r Reader, n <span class=\"keyword\">int64</span>)</span> <span class=\"title\">Reader</span></span> &#123; <span class=\"keyword\">return</span> &amp;LimitedReader&#123;r, n&#125; &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"PipeReader-和-PipeWriter-类型\"><a href=\"#PipeReader-和-PipeWriter-类型\" class=\"headerlink\" title=\"PipeReader 和 PipeWriter 类型\"></a>PipeReader 和 PipeWriter 类型</h2><p><code>PipeReader</code> 是管道的读取端。它实现了 <code>io.Reader</code> 和 <code>io.Closer</code> 接口：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> PipeReader <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tp *pipe</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>从管道中读取数据。该方法会堵塞，直到管道写入端开始写入数据或写入端被关闭。如果写入端关闭时带有 <code>error</code>（即调用 <code>CloseWithError</code> 关闭），<br>该 <code>Read</code> 返回的 <code>err</code> 就是写入端传递的 <code>error</code>；否则 <code>err</code> 为 <code>EOF</code>。</p>\n</blockquote>\n<p><code>PipeWriter</code> 是管道的写入端。它实现了 <code>io.Writer</code> 和 <code>io.Closer</code> 接口：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> PipeWriter <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tp *pipe</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>写数据到管道中。该方法会堵塞，直到管道读取端读完所有数据或读取端被关闭。如果读取端关闭时<br>带有 <code>error</code>（即调用 <code>CloseWithError</code> 关闭），该 <code>Write</code> 返回的 <code>err</code> 就是读取端传递的 <code>error</code>；否则 <code>err</code> 为 <code>ErrClosedPipe</code>。</p>\n</blockquote>\n<p>示例：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    pipeReader, pipeWriter := io.Pipe()</span><br><span class=\"line\">    <span class=\"keyword\">go</span> PipeWrite(pipeWriter)</span><br><span class=\"line\">    <span class=\"keyword\">go</span> PipeRead(pipeReader)</span><br><span class=\"line\">    time.Sleep(<span class=\"number\">30</span> * time.Second)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">PipeWrite</span><span class=\"params\">(writer *io.PipeWriter)</span></span>&#123;</span><br><span class=\"line\">\tdata := []<span class=\"keyword\">byte</span>(<span class=\"string\">\"Go语言中文网\"</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">3</span>; i++&#123;</span><br><span class=\"line\">\t\tn, err := writer.Write(data)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span>&#123;</span><br><span class=\"line\">\t\t\tfmt.Println(err)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tfmt.Printf(<span class=\"string\">\"写入字节 %d\\n\"</span>,n)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\twriter.CloseWithError(errors.New(<span class=\"string\">\"写入段已关闭\"</span>))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">PipeRead</span><span class=\"params\">(reader *io.PipeReader)</span></span>&#123;</span><br><span class=\"line\">\tbuf := <span class=\"built_in\">make</span>([]<span class=\"keyword\">byte</span>, <span class=\"number\">128</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>&#123;</span><br><span class=\"line\">\t\tfmt.Println(<span class=\"string\">\"接口端开始阻塞5秒钟...\"</span>)</span><br><span class=\"line\">\t\ttime.Sleep(<span class=\"number\">5</span> * time.Second)</span><br><span class=\"line\">\t\tfmt.Println(<span class=\"string\">\"接收端开始接受\"</span>)</span><br><span class=\"line\">\t\tn, err := reader.Read(buf)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span>&#123;</span><br><span class=\"line\">\t\t\tfmt.Println(err)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tfmt.Printf(<span class=\"string\">\"收到字节: %d\\n buf内容: %s\\n\"</span>,n,buf)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>io.Pipe()</code> 用于创建一个同步的内存管道：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Pipe</span><span class=\"params\">()</span> <span class=\"params\">(*PipeReader, *PipeWriter)</span></span></span><br></pre></td></tr></table></figure>\n<p>它将 <code>io.Reader</code> 连接到 <code>io.Writer</code>。一端的读取匹配另一端的写入，直接在这两端之间复制数据；它没有内部缓存。它对于并行调用 <code>Read</code><br> 和 <code>Write</code> 以及其它函数或 <code>Close</code> 来说都是安全的。一旦等待的 I/O 结束，<code>Close</code> 就会完成。并行调用 <code>Read</code> 或并行调用 <code>Write</code> 也<br>同样安全：同种类的调用将按顺序进行控制。</p>\n<p>正因为是<strong>同步</strong>的，因此不能在一个 goroutine 中进行读和写。</p>\n<p>另外，对于管道的 <code>close</code> 方法（非 <code>CloseWithError</code> 时），<code>err</code> 会被置为 <code>EOF</code>。</p>\n<h2 id=\"Copy-和-CopyN-函数\"><a href=\"#Copy-和-CopyN-函数\" class=\"headerlink\" title=\"Copy 和 CopyN 函数\"></a>Copy 和 CopyN 函数</h2><p><strong>Copy 函数</strong>：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Copy</span><span class=\"params\">(dst Writer, src Reader)</span> <span class=\"params\">(written <span class=\"keyword\">int64</span>, err error)</span></span></span><br></pre></td></tr></table></figure>\n<p>函数文档：</p>\n<blockquote>\n<p><code>Copy</code> 将 <code>src</code> 复制到 <code>dst</code>，直到在 <code>src</code> 上到达 <code>EOF</code> 或发生错误。它返回复制的字节数，如果有错误的话，还会返回在复制时遇到的第一<br>个错误。</p>\n</blockquote>\n<blockquote>\n<p>成功的 <code>Copy</code> 返回 <code>err == nil</code>，而非 <code>err == EOF</code>。由于 <code>Copy</code> 被定义为从 <code>src</code> 读取直到 <code>EOF</code> 为止，因此它不会将来<br>自 <code>Read</code> 的 <code>EOF</code> 当做错误来报告。</p>\n</blockquote>\n<blockquote>\n<p>若 <code>dst</code> 实现了 <code>ReaderFrom</code> 接口，其复制操作可通过调用 <code>dst.ReadFrom(src)</code> 实现。此外，若 <code>src</code> 实现了 <code>WriterTo</code> 接口，其复<br>制操作可通过调用 <code>src.WriteTo(dst)</code> 实现。</p>\n</blockquote>\n<p>代码：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">io.Copy(os.Stdout, strings.NewReader(<span class=\"string\">\"Go语言中文网\"</span>))</span><br></pre></td></tr></table></figure>\n<p>直接将内容输出（写入 Stdout 中）：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">\"fmt\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"io\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"os\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t_, _ = io.Copy(os.Stdout, os.Stdin)</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">\"Got EOF -- bye\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>执行：<code>echo &quot;Hello, World&quot; | go run main.go</code></p>\n<p><strong>CopyN 函数</strong>：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">CopyN</span><span class=\"params\">(dst Writer, src Reader, n <span class=\"keyword\">int64</span>)</span> <span class=\"params\">(written <span class=\"keyword\">int64</span>, err error)</span></span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>CopyN</code> 将 <code>n</code> 个字节(或到一个 <code>error</code>)从 <code>src</code> 复制到 <code>dst</code>。 它返回复制的字节数以及在复制时遇到的最早的错误。<br>当且仅当 <code>err == nil</code> 时,<code>written == n</code> 。</p>\n</blockquote>\n<blockquote>\n<p>若 <code>dst</code> 实现了 <code>ReaderFrom</code> 接口，复制操作也就会使用它来实现。</p>\n</blockquote>\n<p>代码：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">io.CopyN(os.Stdout, strings.NewReader(<span class=\"string\">\"Go语言中文网\"</span>), <span class=\"number\">8</span>) <span class=\"comment\">// Go语言</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"ReadAtLeast-和-ReadFull-函数\"><a href=\"#ReadAtLeast-和-ReadFull-函数\" class=\"headerlink\" title=\"ReadAtLeast 和 ReadFull 函数\"></a>ReadAtLeast 和 ReadFull 函数</h2><p><strong>ReadAtLeast 函数</strong>：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">ReadAtLeast</span><span class=\"params\">(r Reader, buf []<span class=\"keyword\">byte</span>, min <span class=\"keyword\">int</span>)</span> <span class=\"params\">(n <span class=\"keyword\">int</span>, err error)</span></span></span><br></pre></td></tr></table></figure>\n<p>函数文档：</p>\n<blockquote>\n<p><code>ReadAtLeast</code> 将 <code>r</code> 读取到 <code>buf</code> 中，直到读了最少 <code>min</code> 个字节为止。它返回复制的字节数，如果读取的字节较少，还会返回一个错误。<br>若没有读取到字节，错误就只是 <code>EOF</code>。如果一个 <code>EOF</code> 发生在读取了少于 <code>min</code> 个字节之后，<code>ReadAtLeast</code> 就会返回 <code>ErrUnexpectedEOF</code>。<br>若 <code>min</code> 大于 <code>buf</code> 的长度，<code>ReadAtLeast</code> 就会返回 <code>ErrShortBuffer</code>。对于返回值，当且仅当 <code>err == nil</code> 时，才有 <code>n &gt;= min</code>。</p>\n</blockquote>\n<p><strong>ReadFull 函数</strong>：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">ReadFull</span><span class=\"params\">(r Reader, buf []<span class=\"keyword\">byte</span>)</span> <span class=\"params\">(n <span class=\"keyword\">int</span>, err error)</span></span></span><br></pre></td></tr></table></figure>\n<p>函数文档：</p>\n<blockquote>\n<p><code>ReadFull</code> 精确地从 <code>r</code> 中将 <code>len(buf)</code> 个字节读取到 <code>buf</code> 中。它返回复制的字节数，如果读取的字节较少，还会返回一个错误。若没有读<br>取到字节，错误就只是 <code>EOF</code>。如果一个 <code>EOF</code> 发生在读取了一些但不是所有的字节后，<code>ReadFull</code> 就会返回 <code>ErrUnexpectedEOF</code>。对于返回值，<br>当且仅当 <code>err == nil</code> 时，才有 <code>n == len(buf)</code>。</p>\n</blockquote>\n<p>注意该函数和 <code>ReadAtLeast</code> 的区别：</p>\n<ul>\n<li><code>ReadFull</code> 将 <code>buf</code> 读满</li>\n<li><code>ReadAtLeast</code> 是最少读取 <code>min</code> 个字节。</li>\n</ul>\n<h2 id=\"WriteString-函数\"><a href=\"#WriteString-函数\" class=\"headerlink\" title=\"WriteString 函数\"></a>WriteString 函数</h2><p>这是为了方便写入 <code>string</code> 类型提供的函数，函数签名：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">WriteString</span><span class=\"params\">(w Writer, s <span class=\"keyword\">string</span>)</span> <span class=\"params\">(n <span class=\"keyword\">int</span>, err error)</span></span></span><br></pre></td></tr></table></figure>\n<p>函数文档：</p>\n<blockquote>\n<p><code>WriteString</code> 将 <code></code>s 的内容写入 <code>w</code> 中，当 <code>w</code> 实现了 <code>WriteString</code> 方法时，会直接调用该方法，否则执行 <code>w.Write([]byte(s))</code>。</p>\n</blockquote>\n<h2 id=\"MultiReader-和-MultiWriter-函数\"><a href=\"#MultiReader-和-MultiWriter-函数\" class=\"headerlink\" title=\"MultiReader 和 MultiWriter 函数\"></a>MultiReader 和 MultiWriter 函数</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">MultiReader</span><span class=\"params\">(readers ...Reader)</span> <span class=\"title\">Reader</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">MultiWriter</span><span class=\"params\">(writers ...Writer)</span> <span class=\"title\">Writer</span></span></span><br></pre></td></tr></table></figure>\n<p>它们接收多个 <code>Reader</code> 或 <code>Writer</code>，返回一个 <code>Reader</code> 或 <code>Writer</code>。我们可以猜想到这两个函数就是操作多个 <code>Reader</code> 或 <code>Writer</code> 就像<br>操作一个。</p>\n<p>事实上，在 <code>io</code> 包中定义了两个非导出类型：<code>mutilReader</code> 和 <code>multiWriter</code>，它们分别实现了 <code>io.Reader</code> 和 <code>io.Writer</code> 接口：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> multiReader <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\treaders []Reader</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> multiWriter <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\twriters []Writer</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对于这两种类型对应的实现方法（<code>Read</code> 和 <code>Write</code> 方法）的使用，示例：</p>\n<p><strong>MultiReader 的使用</strong>：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">readers := []io.Reader&#123;</span><br><span class=\"line\">\tstrings.NewReader(<span class=\"string\">\"from strings reader\"</span>),</span><br><span class=\"line\">\tbytes.NewBufferString(<span class=\"string\">\"from bytes buffer\"</span>),</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">reader := io.MultiReader(readers...)</span><br><span class=\"line\">data := <span class=\"built_in\">make</span>([]<span class=\"keyword\">byte</span>, <span class=\"number\">0</span>, <span class=\"number\">128</span>)</span><br><span class=\"line\">buf := <span class=\"built_in\">make</span>([]<span class=\"keyword\">byte</span>, <span class=\"number\">10</span>)</span><br><span class=\"line\">\t</span><br><span class=\"line\"><span class=\"keyword\">for</span> n, err := reader.Read(buf); err != io.EOF ; n, err = reader.Read(buf)&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">panic</span>(err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tdata = <span class=\"built_in\">append</span>(data,buf[:n]...)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fmt.Printf(<span class=\"string\">\"%s\\n\"</span>, data) <span class=\"comment\">// from strings readerfrom bytes buffer</span></span><br></pre></td></tr></table></figure>\n<p>代码中首先构造了一个 <code>io.Reader</code> 的 <code>slice</code>，然后通过 <code>MultiReader</code> 得到新的 <code>Reader</code>，循环读取新 <code>Reader</code> 中的内容。从输出结果<br>可以看到，第一次调用 <code>Reader</code> 的 <code>Read</code> 方法获取到的是 <code>slice</code> 中第一个元素的内容……也就是说，<code>MultiReader</code> 只是逻辑上将多<br>个 <code>Reader</code> 组合起来，并不能通过调用一次 <code>Read</code> 方法获取所有 <code>Reader</code> 的内容。在所有的 <code>Reader</code> 内容都被读<br>完后，<code>Reader</code> 会返回 <code>EOF</code>。</p>\n<p><strong>MultiWriter 的使用</strong>：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">file, err := os.Create(<span class=\"string\">\"tmp.txt\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">panic</span>(err)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">defer</span> file.Close()</span><br><span class=\"line\">writers := []io.Writer&#123;</span><br><span class=\"line\">\tfile,</span><br><span class=\"line\">\tos.Stdout,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">writer := io.MultiWriter(writers...)</span><br><span class=\"line\">writer.Write([]<span class=\"keyword\">byte</span>(<span class=\"string\">\"Go语言中文网\"</span>))</span><br></pre></td></tr></table></figure>\n<p>这段程序执行后在生成 <code>tmp.txt</code> 文件，同时在文件和屏幕中都输出：<code>Go语言中文网</code>。这和 Unix 中的 tee 命令类似。</p>\n<h2 id=\"TeeReader-函数\"><a href=\"#TeeReader-函数\" class=\"headerlink\" title=\"TeeReader 函数\"></a>TeeReader 函数</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TeeReader</span><span class=\"params\">(r Reader, w Writer)</span> <span class=\"title\">Reader</span></span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>TeeReader</code> 返回一个 <code>Reader</code>，它将从 <code>r</code> 中读到的数据写入 <code>w</code> 中。所有经由它处理的从 <code>r</code> 的读取都匹配于对应的对 <code>w</code> 的写入。它没<br>有内部缓存，即写入必须在读取完成前完成。任何在写入时遇到的错误都将作为读取错误返回。</p>\n</blockquote>\n<p>也就是说，我们通过 <code>Reader</code> 读取内容后，会自动写入到 <code>Writer</code> 中去。例子代码如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">reader := io.TeeReader(strings.NewReader(<span class=\"string\">\"Go语言中文网\"</span>), os.Stdout)</span><br><span class=\"line\">reader.Read(<span class=\"built_in\">make</span>([]<span class=\"keyword\">byte</span>, <span class=\"number\">20</span>)) <span class=\"comment\">// Go语言中文网</span></span><br></pre></td></tr></table></figure>\n<p>这种功能的实现其实挺简单，无非是在 <code>Read</code> 完后执行 <code>Write</code>。</p>\n"},{"title":"os","_content":"\n# os\n\n`os` 包提供了平台无关的操作系统功能接口。例如 Linux、macOS、Windows 等系统 `os` 包提供统一的使用接口。 \n\n例子，打开一个文件并从中读取一些数据：\n\n```go\nfile, err := os.Open(\"file.go\") // For read access.\nif err != nil {\n\tlog.Fatal(err) // `open file.go: no such file or directory`\n}\n```\n\n## 文件 I/O\n\n在 Go 中，文件描述符封装在 `os.File` 结构中，通过 `File.Fd()` 可以获得底层的文件描述符：`fd`。\n\n大多数程序都期望能够使用 3 种标准的文件描述符：0- 标准输入；1- 标准输出；2- 标准错误。`os` 包提供了 3 个 `File` 对象，分别\n代表这 3 种标准描述符：`Stdin`、`Stdout` 和 `Stderr`，它们对应的文件名分别是：`/dev/stdin`、`/dev/stdout` 和 `/dev/stderr`。\n注意，这里说的文件名，并不一定存在，比如 Windows 下就没有。\n\n### OpenFile\n```go\nfunc OpenFile(name string, flag int, perm FileMode) (*File, error)\n```\n\n`OpenFile` 既能打开一个已经存在的文件，也能创建并打开一个新文件。\n\n`OpenFile` 是一个更一般性的文件打开函数，大多数调用者都应用 `Open` 或 `Create` 代替本函数。它会使用指定的选项（如 `O_RDONLY` 等）、\n指定的模式（如 `0666` 等）打开指定名称的文件。如果操作成功，返回的文件对象可用于 I/O。如果出错，错误底层类型是 `*PathError`。\n\n要打开的文件由参数 `name` 指定，它可以是绝对路径或相对路径（相对于进程当前工作目录），也可以是一个符号链接（会对其进行解引用）。\n\n位掩码参数 `flag` 用于指定文件的访问模式，可用的值在 `os` 中定义为常量（以下值并非所有操作系统都可用）：\n\n```go\nconst (\n    O_RDONLY int = syscall.O_RDONLY // 只读模式打开文件\n    O_WRONLY int = syscall.O_WRONLY // 只写模式打开文件\n    O_RDWR   int = syscall.O_RDWR   // 读写模式打开文件\n    O_APPEND int = syscall.O_APPEND // 写操作时将数据附加到文件尾部\n    O_CREATE int = syscall.O_CREAT  // 如果不存在将创建一个新文件\n    O_EXCL   int = syscall.O_EXCL   // 和 O_CREATE 配合使用，文件必须不存在\n    O_SYNC   int = syscall.O_SYNC   // 打开文件用于同步 I/O\n    O_TRUNC  int = syscall.O_TRUNC  // 如果可能，打开时清空文件\n)\n```\n其中，`O_RDONLY`、`O_WRONLY`、`O_RDWR` 只指定一个，剩下的通过 `|` 操作符来指定。该函数内部会给 `flags` 加上 `syscall.O_CLOEXEC`，\n在 `fork` 子进程时会关闭通过 `OpenFile` 打开的文件，即子进程不会重用该文件描述符。\n\n位掩码参数 `perm` 指定了文件的模式和权限位，类型是 `os.FileMode`，文件模式位常量定义在 `os` 中：\n\n```go\nconst (\n    // 单字符是被 String 方法用于格式化的属性缩写。\n    ModeDir        FileMode = 1 << (32 - 1 - iota) // d: 目录\n    ModeAppend                                     // a: 只能写入，且只能写入到末尾\n    ModeExclusive                                  // l: 用于执行\n    ModeTemporary                                  // T: 临时文件（非备份文件）\n    ModeSymlink                                    // L: 符号链接（不是快捷方式文件）\n    ModeDevice                                     // D: 设备\n    ModeNamedPipe                                  // p: 命名管道（FIFO）\n    ModeSocket                                     // S: Unix 域 socket\n    ModeSetuid                                     // u: 表示文件具有其创建者用户 id 权限\n    ModeSetgid                                     // g: 表示文件具有其创建者组 id 的权限\n    ModeCharDevice                                 // c: 字符设备，需已设置 ModeDevice\n    ModeSticky                                     // t: 只有 root/ 创建者能删除 / 移动文件\n    \n    // 覆盖所有类型位（用于通过 & 获取类型位），对普通文件，所有这些位都不应被设置\n    ModeType = ModeDir | ModeSymlink | ModeNamedPipe | ModeSocket | ModeDevice\n    ModePerm FileMode = 0777 // 覆盖所有 Unix 权限位（用于通过 & 获取类型位）\n)\n```\n以上常量在所有操作系统都有相同的含义（可用时），因此文件的信息可以在不同的操作系统之间安全的移植。不是所有的位都能用于所有的系统，\n唯一共有的是用于表示目录的 `ModeDir` 位。\n\n以上这些被定义的位是 `FileMode` 最重要的位。另外 9 个位（权限位）为标准 Unix `rwxrwxrwx` 权限（所有人都可读、写、运行）。\n\n`FileMode` 还定义了几个方法，用于判断文件类型的 `IsDir()` 和 `IsRegular()`，用于获取权限的 `Perm()`。\n\n返回的 `error`，具体实现是 `*os.PathError`，它会记录具体操作、文件路径和错误原因。\n\n另外，在 `OpenFile` 内部会调用 `NewFile`，来得到 `File` 对象。\n\n**使用方法**\n\n打开一个文件，一般通过 `Open` 或 `Create`，这两个函数的实现。\n\n```go\nfunc Open(name string) (*File, error) {\n\treturn OpenFile(name, O_RDONLY, 0)\n}\n\nfunc Create(name string) (*File, error) {\n\treturn OpenFile(name, O_RDWR|O_CREATE|O_TRUNC, 0666)\n}\n```\n\n### Read\n```go\nfunc (f *File) Read(b []byte) (n int, err error)\n```\n\n`Read` 方法从 `f` 中读取最多 `len(b)` 字节数据并写入 `b`。它返回读取的字节数和可能遇到的任何错误。文件终止标志是读取 0 个字节且返回\n值 `err` 为 `io.EOF`。\n\n对比下 `ReadAt` 方法：\n```go\nfunc (f *File) ReadAt(b []byte, off int64) (n int, err error)\n```\n\n`ReadAt` 从指定的位置（相对于文件开始位置）读取长度为 `len(b)` 个字节数据并写入 `b`。它返回读取的字节数和可能遇到的任何错误。\n当 `n<len(b)` 时，本方法总是会返回错误；如果是因为到达文件结尾，返回值 `err` 会是 `io.EOF`。它对应的系统调用是 `pread`。\n\n**`Read` 和 `ReadAt` 的区别**：前者从文件当前偏移量处读，且会改变文件当前的偏移量；而后者从 `off` 指定的位置开始读，且**不会改变**文件\n当前偏移量。\n\n### Write\n```go\nfunc (f *File) Write(b []byte) (n int, err error)\n```\n\n`Write` 向文件中写入 `len(b)` 字节数据。它返回写入的字节数和可能遇到的任何错误。如果返回值 `n != len(b)`，本方法会返回一个 **非 nil**\n 的错误。\n\n`Write` 与 `WriteAt` 的区别同 `Read` 与 `ReadAt` 的区别一样。为了方便，还提供了 `WriteString` 方法，它实际是对 `Write` 的封装。\n\n注意：`Write` 调用成功并不能保证数据已经写入磁盘，因为内核会缓存磁盘的 I/O 操作。如果希望立刻将数据写入磁盘（一般场景不建议这么做，因为会\n影响性能），有两种办法：\n\n1. 打开文件时指定 `os.O_SYNC`；\n2. 调用 `File.Sync()` 方法。\n\n说明：`File.Sync()` 底层调用的是 `fsync` 系统调用，这会将数据和元数据都刷到磁盘；如果只想刷数据到磁盘（比如，文件大小没变，只是变了文件\n数据），需要自己封装，调用 `fdatasync` 系统调用。（`syscall.Fdatasync`）\n\n### Close\n```go\nfunc (f *File) Close() error\n```\n`close()` 系统调用关闭一个打开的文件描述符，并将其释放回调用进程，供该进程继续使用。当进程终止时，将自动关闭其已打开的所有文件描述符。\n\n`os.File.Close()` 是对 `close()` 的封装。文件描述符是资源，Go 的 gc 是针对内存的，并不会自动回收资源，如果不关闭文件描述符，\n长期运行的服务可能会把文件描述符耗尽。\n\n所以，通常的写法如下：\n\n```go\nfile, err := os.Open(\"/tmp/studygolang.txt\")\nif err != nil {\n\t// 错误处理，一般会阻止程序往下执行\n\treturn\n}\ndefer file.Close()\n```\n\n**关于返回值 `error`**\n\n以下两种情况会导致 `Close` 返回错误：\n\n1. 关闭一个未打开的文件；\n2. 两次关闭同一个文件；\n\n通常，不会去检查 `Close` 的错误。\n\n### Seek\n\n对于每个打开的文件，系统内核会记录其文件偏移量，有时也将文件偏移量称为读写偏移量或指针。文件偏移量是指执行下一个 `Read` 或 `Write` 操作\n的文件真实位置，会以相对于文件头部起始点的文件当前位置来表示。文件第一个字节的偏移量为 0。\n\n文件打开时，会将文件偏移量设置为指向文件开始，以后每次 `Read` 或 `Write` 调用将自动对其进行调整，以指向已读或已写数据后的下一个字节。因\n此，连续的 `Read` 和 `Write` 调用将按顺序递进，对文件进行操作。\n\n`Seek` 可以调整文件偏移量：\n```go\nfunc (f *File) Seek(offset int64, whence int) (ret int64, err error)\n```\n\n`Seek` 设置下一次读/写的位置。`offset` 为相对偏移量，而 `whence` 决定相对位置：0 为相对文件开头，1 为相对当前位置，2 为相对文件结尾。它\n返回新的偏移量（相对开头）和可能的错误。\n\n注意：`Seek` 只是调整内核中与文件描述符相关的文件偏移量记录，并没有访问任何物理设备。\n\n一些 `Seek` 的使用例子（file 为打开的文件对象），注释说明了将文件偏移量移动到的具体位置：\n\n```go\nfile.Seek(0, os.SEEK_SET)\t// 文件开始处\nfile.Seek(0, SEEK_END)\t\t// 文件结尾处的下一个字节\nfile.Seek(-1, SEEK_END)\t\t// 文件最后一个字节\nfile.Seek(-10, SEEK_CUR) \t// 当前位置前 10 个字节\nfile.Seek(1000, SEEK_END)\t// 文件结尾处的下 1001 个字节\n```\n最后一个例子在文件中会产生“空洞”。\n\n`Seek` 对应系统调用 `lseek`。该系统调用并不适用于所有类型，不允许将 `lseek ` 应用于管道、FIFO、socket 或 终端。\n\n## 截断文件\n\n`trucate` 和 `ftruncate` 系统调用将文件大小设置为 `size` 参数指定的值；Go 语言中相应的包装函数是 `os.Truncate` 和 \n`os.File.Truncate`。\n\n```go\nfunc Truncate(name string, size int64) error\nfunc (f *File) Truncate(size int64) error\n```\n如果文件当前长度大于参数 `size`，调用将丢弃超出部分，若小于参数 `size`，调用将在文件尾部添加一系列空字节或是一个文件空洞。\n\n它们之间的区别在于如何指定操作文件：\n\n1. `Truncate` 以路径名称字符串来指定文件，并要求可访问该文件（即对组成路径名的各目录拥有可执行 (x) 权限），且对文件拥有写权限。\n若文件名为符号链接，那么调用将对其进行解引用。\n2. 很明显，调用 `File.Truncate` 前，需要先以可写方式打开操作文件，该方法不会修改文件偏移量。\n\n## 文件属性\n\n文件属性，也即文件元数据。在 Go 中，文件属性具体信息通过 `os.FileInfo` 接口获取。函数 `Stat`、`Lstat` 和 `File.Stat` 可以得到该接口\n的实例。这三个函数对应三个系统调用：`stat`、`lstat` 和 `fstat`。\n\n这三个函数的区别：\n\n1. `stat` 会返回所命名文件的相关信息。\n2. `lstat` 与 `stat` 类似，区别在于如果文件是符号链接，那么所返回的信息针对的是符号链接自身（而非符号链接所指向的文件）。\n3. `fstat` 则会返回由某个打开文件描述符（Go 中则是当前打开文件 File）所指代文件的相关信息。\n\n`Stat` 和 `Lstat` 无需对其所操作的文件本身拥有任何权限，但针对指定 `name `的父目录要有执行（搜索）权限。而只要 `File` 对象 `ok`，\n`File.Stat` 总是成功。\n\n`FileInfo` 接口如下：\n\n```go\ntype FileInfo interface {\n    Name() string       // 文件的名字（不含扩展名）\n    Size() int64        // 普通文件返回值表示其大小；其他文件的返回值含义各系统不同\n    Mode() FileMode     // 文件的模式位\n    ModTime() time.Time // 文件的修改时间\n    IsDir() bool        // 等价于 Mode().IsDir()\n    Sys() interface{}   // 底层数据来源（可以返回 nil）\n}\n```\n\n`Sys()` 底层数据的 C 语言 结构 `statbuf` 格式如下：\n\n```go\nstruct stat {\n\tdev_t\tst_dev;\t// 设备 ID\n\tino_t\tst_ino;\t// 文件 i 节点号\n\tmode_t\tst_mode;\t// 位掩码，文件类型和文件权限\n\tnlink_t\tst_nlink;\t// 硬链接数\n\tuid_t\tst_uid;\t// 文件属主，用户 ID\n\tgid_t\tst_gid;\t// 文件属组，组 ID\n\tdev_t\tst_rdev;\t// 如果针对设备 i 节点，则此字段包含主、辅 ID\n\toff_t\tst_size;\t// 常规文件，则是文件字节数；符号链接，则是链接所指路径名的长度，字节为单位；对于共享内存对象，则是对象大小\n\tblksize_t\tst_blsize;\t// 分配给文件的总块数，块大小为 512 字节\n\tblkcnt_t\tst_blocks;\t// 实际分配给文件的磁盘块数量\n\ttime_t\tst_atime;\t\t// 对文件上次访问时间\n\ttime_t\tst_mtime;\t\t// 对文件上次修改时间\n\ttime_t\tst_ctime;\t\t// 文件状态发生改变的上次时间\n}\n```\nGo 中 `syscal.Stat_t` 与该结构对应。\n\n如果我们要获取 `FileInfo` 接口没法直接返回的信息，比如想获取文件的上次访问时间，示例如下：\n\n```go\nfileInfo, err := os.Stat(\"test.log\")\nif err != nil {\n\tlog.Fatal(err)\n}\nsys := fileInfo.Sys()\nstat := sys.(*syscall.Stat_t)\nfmt.Println(time.Unix(stat.Atimespec.Unix()))\n```\n\n### 改变文件时间戳\n\n可以显式改变文件的访问时间和修改时间。\n```go\nfunc Chtimes(name string, atime time.Time, mtime time.Time) error\n```\n\n`Chtimes` 修改 `name` 指定的文件对象的访问时间和修改时间，类似 Unix 的 `utime()` 或 `utimes()` 函数。底层的文件系统可能会截断/舍入\n时间单位到更低的精确度。如果出错，会返回 `*PathError` 类型的错误。在 Unix 中，底层实现会调用 `utimenstat()`，它提供纳秒级别的精度。\n\n### 文件属主\n\n每个文件都有一个与之关联的用户 ID（UID）和组 ID（GID），籍此可以判定文件的属主和属组。系统调用 `chown`、`lchown` 和 `fchown` 可用来\n改变文件的属主和属组，Go 中对应的函数或方法：\n\n```go\nfunc Chown(name string, uid, gid int) error\nfunc Lchown(name string, uid, gid int) error\nfunc (f *File) Chown(uid, gid int) error\n```\n它们的区别和上文提到的 `Stat` 相关函数类似。\n\n### 文件权限\n\n这里介绍是应用于文件和目录的权限方案，尽管此处讨论的权限主要是针对普通文件和目录，但其规则可适用于所有文件类型，包括设备文件、FIFO 以\n及 Unix 域套接字等。\n\n#### 相关函数或方法\n\n在文件相关操作报错时，可以通过 `os.IsPermission` 检查是否是权限的问题。\n```go\nfunc IsPermission(err error) bool\n```\n\n返回一个布尔值说明该错误是否表示因权限不足要求被拒绝。`ErrPermission` 和一些系统调用错误会使它返回真。\n\n另外，`syscall.Access` 可以获取文件的权限。这对应系统调用 `access`。\n\n#### Sticky 位\n\n除了 9 位用来表明属主、属组和其他用户的权限外，文件权限掩码还另设有 3 个附加位，分别是\n`set-user-ID`(bit 04000)、`set-group-ID`(bit 02000) 和 `sticky`(bit 01000) 位。\n\nSticky 位一般用于目录，起限制删除位的作用，表明仅当非特权进程具有对目录的写权限，且为文件或目录的属主时，才能对目录下的文件进行删除和重命名操\n作。根据这个机制来创建为多个用户共享的一个目录，各个用户可在其下创建或删除属于自己的文件，但不能删除隶属于其他用户的文件。`/tmp` 目录就设\n置了 sticky 位，正是出于这个原因。\n\n`chmod` 命令或系统调用可以设置文件的 sticky 位。若对某文件设置了 sticky 位，则 `ls -l` 显示文件时，会在其他用户执行权限字段上看到字\n母 t（有执行权限时） 或 T（无执行权限时）。\n\n`os.Chmod` 和 `os.File.Chmod` 可以修改文件权限（包括 sticky 位），分别对应系统调用 `chmod` 和 `fchmod`。\n\n```go\nfunc main() {\n    file, err := os.Create(\"studygolang.txt\")\n    if err != nil {\n        log.Fatal(\"error:\", err)\n    }\n    defer file.Close()\n\n    fileMode := getFileMode(file)\n    log.Println(\"file mode:\", fileMode)\n    file.Chmod(fileMode | os.ModeSticky)\n\n    log.Println(\"change after, file mode:\", getFileMode(file))\n}\n\nfunc getFileMode(file *os.File) os.FileMode {\n    fileInfo, err := file.Stat()\n    if err != nil {\n        log.Fatal(\"file stat error:\", err)\n    }\n\n    return fileInfo.Mode()\n}\n\n// Output:\n// 2016/06/18 15:59:06 file mode: -rw-rw-r--\n// 2016/06/18 15:59:06 change after, file mode: trw-rw-r--\n// ls -l 看到的 studygolang.tx 是：-rw-rw-r-T\n// 当然这里是给文件设置了 sticky 位，对权限不起作用。系统会忽略它。\n```\n\n## 目录与链接\n\n在 Unix 文件系统中，目录的存储方式类似于普通文件。目录和普通文件的区别有二：\n\n- 在其 `i-node` 条目中，会将目录标记为一种不同的文件类型。\n- 目录是经特殊组织而成的文件。本质上说就是一个表格，包含文件名和 `i-node` 标号。\n\n### 创建和移除（硬）链接\n\n硬链接是针对文件而言的，目录不允许创建硬链接。\n\n`link` 和 `unlink` 系统调用用于创建和移除（硬）链接。Go 中 `os.Link` 对应 `link` 系统调用；但 `os.Remove` 的实现会先执行 `unlink` \n系统调用，如果要移除的是目录，则 `unlink` 会失败，这时 `Remove` 会再调用 `rmdir` 系统调用。\n```go\nfunc Link(oldname, newname string) error\n```\n\n`Link` 创建一个名为 `newname` 指向 `oldname` 的硬链接。如果出错，会返回 `*LinkError` 类型的错误。\n```go\nfunc Remove(name string) error\n```\n\n`Remove` 删除 `name` 指定的文件或目录。如果出错，会返回 `*PathError` 类型的错误。如果目录不为空，`Remove` 会返回失败。\n\n### 更改文件名\n\n系统调用 `rename` 既可以重命名文件，又可以将文件移至同一个文件系统中的另一个目录。该系统调用既可以用于文件，也可以用于目录。相关细节，\n请查阅相关资料。\n\nGo 中的 `os.Rename` 是对应的封装函数。\n```go\nfunc Rename(oldpath, newpath string) error\n```\n\n`Rename` 修改一个文件的名字或移动一个文件。如果 `newpath` 已经存在，则替换它。注意，可能会有一些个操作系统特定的限制。\n\n### 使用符号链接\n\n`symlink` 系统调用用于为指定路径名创建一个新的符号链接（想要移除符号链接，使用 `unlink`）。Go 中的 `os.Symlink` 是对应的封装函数。\n```go\nfunc Symlink(oldname, newname string) error\n```\n\n`Symlink` 创建一个名为 `newname` 指向 `oldname` 的符号链接。如果出错，会返回 `*LinkError` 类型的错误。\n\n由 `oldname` 所命名的文件或目录在调用时无需存在。因为即便当时存在，也无法阻止后来将其删除。这时，`newname` 成为“悬空链接”，其他系统\n调用试图对其进行解引用操作都将错误（通常错误号是 `ENOENT`）。\n\n有时候，我们希望通过符号链接，能获取其所指向的路径名。系统调用 `readlink` 能做到，Go 的封装函数是 `os.Readlink`：\n```go\nfunc Readlink(name string) (string, error)\n```\n\n`Readlink` 获取 `name` 指定的符号链接指向的文件的路径。如果出错，会返回 `*PathError` 类型的错误。我们看看 `Readlink` 的实现。\n\n```go\nfunc Readlink(name string) (string, error) {\n\tfor len := 128; ; len *= 2 {\n\t\tb := make([]byte, len)\n\t\tn, e := fixCount(syscall.Readlink(name, b))\n\t\tif e != nil {\n\t\t\treturn \"\", &PathError{\"readlink\", name, e}\n\t\t}\n\t\tif n < len {\n\t\t\treturn string(b[0:n]), nil\n\t\t}\n\t}\n}\n```\n这里之所以用循环，是因为我们没法知道文件的路径到底多长，如果 `b` 长度不够，文件名会被截断，而 `readlink` 系统调用无非分辨所返回的字\n符串到底是经过截断处理，还是恰巧将 `b` 填满。这里采用的验证方法是分配一个更大的（两倍）`b` 并再次调用 `readlink`。\n\n### 创建和移除目录\n\n`mkdir` 系统调用创建一个新目录，Go 中的 `os.Mkdir` 是对应的封装函数。\n```go\nfunc Mkdir(name string, perm FileMode) error\n```\n\n`Mkdir` 使用指定的权限和名称创建一个目录。如果出错，会返回 `*PathError` 类型的错误。\n\n`name` 参数指定了新目录的路径名，可以是相对路径，也可以是绝对路径。如果已经存在，则调用失败并返回 `os.ErrExist` 错误。\n\n`perm` 参数指定了新目录的权限。对该位掩码值的指定方式和 `os.OpenFile` 相同，也可以直接赋予八进制数值。注意，`perm` 值还将于进程掩码相\n与（&）。如果 `perm` 中设置了 sticky 位，那么将对新目录设置该权限。\n\n因为 `Mkdir` 所创建的只是路径名中的最后一部分，如果父目录不存在，创建会失败。`os.MkdirAll` 用于递归创建所有不存在的目录。\n\n建议读者阅读下 `os.MkdirAll` 的源码，了解其实现方式、技巧。\n\n`rmdir` 系统调用移除一个指定的目录，目录可以是绝对路径或相对路径。在讲解 `unlink` 时，已经介绍了 Go 中的 `os.Remove`。注意，这里要求\n目录必须为空。为了方便使用，Go 中封装了一个 `os.RemoveAll` 函数：\n```go\nfunc RemoveAll(path string) error\n```\n\n`RemoveAll` 删除 `path` 指定的文件，或目录及它包含的任何下级对象。它会尝试删除所有东西，除非遇到错误并返回。如果 `path` 指定的对象不\n存在，`RemoveAll` 会返回 `nil` 而不返回错误。\n\n`RemoveAll` 的内部实现逻辑如下：\n\n1. 调用 `Remove` 尝试进行删除，如果成功或返回 `path` 不存在，则直接返回 nil；\n2. 调用 `Lstat` 获取 `path` 信息，以便判断是否是目录。注意，这里使用 `Lstat`，表示不对符号链接解引用；\n3. 调用 `Open` 打开目录，递归读取目录中内容，执行删除操作。\n\n### 读目录\n\n`POSIX` 与 `SUS` 定义了读取目录相关的 C 语言标准，各个操作系统提供的系统调用却不尽相同。Go 没有基于 C 语言，而是自己通过系统调用实现\n了读目录功能。\n```go\nfunc (f *File) Readdirnames(n int) (names []string, err error)\n```\n\n`Readdirnames` 读取目录 `f` 的内容，返回一个最多有 `n` 个成员的 `[]string`，切片成员为目录中文件对象的名字，采用目录顺序。对本函数的下一\n次调用会返回上一次调用未读取的内容的信息。\n\n如果 `n>0`，`Readdirnames` 函数会返回一个最多 `n` 个成员的切片。这时，如果 `Readdirnames` 返回一个空切片，它会返回一个非 `nil` 的错\n误说明原因。如果到达了目录 `f` 的结尾，返回值 `err` 会是 `io.EOF`。\n\n如果 `n<=0`，`Readdirnames` 函数返回目录中剩余所有文件对象的名字构成的切片。此时，如果 `Readdirnames` 调用成功（读取所有内容直到结尾），\n它会返回该切片和 `nil` 的错误值。如果在到达结尾前遇到错误，会返回之前成功读取的名字构成的切片和该错误。\n```go\nfunc (f *File) Readdir(n int) (fi []FileInfo, err error)\n```\n\n`Readdir` 内部会调用 `Readdirnames`，将得到的 `names` 构造路径，通过 `Lstat` 构造出 `[]FileInfo`。\n\n`ioutil.ReadDir` 也可以实现类似的功能。","source":"standards/os/os.md","raw":"---\ntitle: os\n---\n\n# os\n\n`os` 包提供了平台无关的操作系统功能接口。例如 Linux、macOS、Windows 等系统 `os` 包提供统一的使用接口。 \n\n例子，打开一个文件并从中读取一些数据：\n\n```go\nfile, err := os.Open(\"file.go\") // For read access.\nif err != nil {\n\tlog.Fatal(err) // `open file.go: no such file or directory`\n}\n```\n\n## 文件 I/O\n\n在 Go 中，文件描述符封装在 `os.File` 结构中，通过 `File.Fd()` 可以获得底层的文件描述符：`fd`。\n\n大多数程序都期望能够使用 3 种标准的文件描述符：0- 标准输入；1- 标准输出；2- 标准错误。`os` 包提供了 3 个 `File` 对象，分别\n代表这 3 种标准描述符：`Stdin`、`Stdout` 和 `Stderr`，它们对应的文件名分别是：`/dev/stdin`、`/dev/stdout` 和 `/dev/stderr`。\n注意，这里说的文件名，并不一定存在，比如 Windows 下就没有。\n\n### OpenFile\n```go\nfunc OpenFile(name string, flag int, perm FileMode) (*File, error)\n```\n\n`OpenFile` 既能打开一个已经存在的文件，也能创建并打开一个新文件。\n\n`OpenFile` 是一个更一般性的文件打开函数，大多数调用者都应用 `Open` 或 `Create` 代替本函数。它会使用指定的选项（如 `O_RDONLY` 等）、\n指定的模式（如 `0666` 等）打开指定名称的文件。如果操作成功，返回的文件对象可用于 I/O。如果出错，错误底层类型是 `*PathError`。\n\n要打开的文件由参数 `name` 指定，它可以是绝对路径或相对路径（相对于进程当前工作目录），也可以是一个符号链接（会对其进行解引用）。\n\n位掩码参数 `flag` 用于指定文件的访问模式，可用的值在 `os` 中定义为常量（以下值并非所有操作系统都可用）：\n\n```go\nconst (\n    O_RDONLY int = syscall.O_RDONLY // 只读模式打开文件\n    O_WRONLY int = syscall.O_WRONLY // 只写模式打开文件\n    O_RDWR   int = syscall.O_RDWR   // 读写模式打开文件\n    O_APPEND int = syscall.O_APPEND // 写操作时将数据附加到文件尾部\n    O_CREATE int = syscall.O_CREAT  // 如果不存在将创建一个新文件\n    O_EXCL   int = syscall.O_EXCL   // 和 O_CREATE 配合使用，文件必须不存在\n    O_SYNC   int = syscall.O_SYNC   // 打开文件用于同步 I/O\n    O_TRUNC  int = syscall.O_TRUNC  // 如果可能，打开时清空文件\n)\n```\n其中，`O_RDONLY`、`O_WRONLY`、`O_RDWR` 只指定一个，剩下的通过 `|` 操作符来指定。该函数内部会给 `flags` 加上 `syscall.O_CLOEXEC`，\n在 `fork` 子进程时会关闭通过 `OpenFile` 打开的文件，即子进程不会重用该文件描述符。\n\n位掩码参数 `perm` 指定了文件的模式和权限位，类型是 `os.FileMode`，文件模式位常量定义在 `os` 中：\n\n```go\nconst (\n    // 单字符是被 String 方法用于格式化的属性缩写。\n    ModeDir        FileMode = 1 << (32 - 1 - iota) // d: 目录\n    ModeAppend                                     // a: 只能写入，且只能写入到末尾\n    ModeExclusive                                  // l: 用于执行\n    ModeTemporary                                  // T: 临时文件（非备份文件）\n    ModeSymlink                                    // L: 符号链接（不是快捷方式文件）\n    ModeDevice                                     // D: 设备\n    ModeNamedPipe                                  // p: 命名管道（FIFO）\n    ModeSocket                                     // S: Unix 域 socket\n    ModeSetuid                                     // u: 表示文件具有其创建者用户 id 权限\n    ModeSetgid                                     // g: 表示文件具有其创建者组 id 的权限\n    ModeCharDevice                                 // c: 字符设备，需已设置 ModeDevice\n    ModeSticky                                     // t: 只有 root/ 创建者能删除 / 移动文件\n    \n    // 覆盖所有类型位（用于通过 & 获取类型位），对普通文件，所有这些位都不应被设置\n    ModeType = ModeDir | ModeSymlink | ModeNamedPipe | ModeSocket | ModeDevice\n    ModePerm FileMode = 0777 // 覆盖所有 Unix 权限位（用于通过 & 获取类型位）\n)\n```\n以上常量在所有操作系统都有相同的含义（可用时），因此文件的信息可以在不同的操作系统之间安全的移植。不是所有的位都能用于所有的系统，\n唯一共有的是用于表示目录的 `ModeDir` 位。\n\n以上这些被定义的位是 `FileMode` 最重要的位。另外 9 个位（权限位）为标准 Unix `rwxrwxrwx` 权限（所有人都可读、写、运行）。\n\n`FileMode` 还定义了几个方法，用于判断文件类型的 `IsDir()` 和 `IsRegular()`，用于获取权限的 `Perm()`。\n\n返回的 `error`，具体实现是 `*os.PathError`，它会记录具体操作、文件路径和错误原因。\n\n另外，在 `OpenFile` 内部会调用 `NewFile`，来得到 `File` 对象。\n\n**使用方法**\n\n打开一个文件，一般通过 `Open` 或 `Create`，这两个函数的实现。\n\n```go\nfunc Open(name string) (*File, error) {\n\treturn OpenFile(name, O_RDONLY, 0)\n}\n\nfunc Create(name string) (*File, error) {\n\treturn OpenFile(name, O_RDWR|O_CREATE|O_TRUNC, 0666)\n}\n```\n\n### Read\n```go\nfunc (f *File) Read(b []byte) (n int, err error)\n```\n\n`Read` 方法从 `f` 中读取最多 `len(b)` 字节数据并写入 `b`。它返回读取的字节数和可能遇到的任何错误。文件终止标志是读取 0 个字节且返回\n值 `err` 为 `io.EOF`。\n\n对比下 `ReadAt` 方法：\n```go\nfunc (f *File) ReadAt(b []byte, off int64) (n int, err error)\n```\n\n`ReadAt` 从指定的位置（相对于文件开始位置）读取长度为 `len(b)` 个字节数据并写入 `b`。它返回读取的字节数和可能遇到的任何错误。\n当 `n<len(b)` 时，本方法总是会返回错误；如果是因为到达文件结尾，返回值 `err` 会是 `io.EOF`。它对应的系统调用是 `pread`。\n\n**`Read` 和 `ReadAt` 的区别**：前者从文件当前偏移量处读，且会改变文件当前的偏移量；而后者从 `off` 指定的位置开始读，且**不会改变**文件\n当前偏移量。\n\n### Write\n```go\nfunc (f *File) Write(b []byte) (n int, err error)\n```\n\n`Write` 向文件中写入 `len(b)` 字节数据。它返回写入的字节数和可能遇到的任何错误。如果返回值 `n != len(b)`，本方法会返回一个 **非 nil**\n 的错误。\n\n`Write` 与 `WriteAt` 的区别同 `Read` 与 `ReadAt` 的区别一样。为了方便，还提供了 `WriteString` 方法，它实际是对 `Write` 的封装。\n\n注意：`Write` 调用成功并不能保证数据已经写入磁盘，因为内核会缓存磁盘的 I/O 操作。如果希望立刻将数据写入磁盘（一般场景不建议这么做，因为会\n影响性能），有两种办法：\n\n1. 打开文件时指定 `os.O_SYNC`；\n2. 调用 `File.Sync()` 方法。\n\n说明：`File.Sync()` 底层调用的是 `fsync` 系统调用，这会将数据和元数据都刷到磁盘；如果只想刷数据到磁盘（比如，文件大小没变，只是变了文件\n数据），需要自己封装，调用 `fdatasync` 系统调用。（`syscall.Fdatasync`）\n\n### Close\n```go\nfunc (f *File) Close() error\n```\n`close()` 系统调用关闭一个打开的文件描述符，并将其释放回调用进程，供该进程继续使用。当进程终止时，将自动关闭其已打开的所有文件描述符。\n\n`os.File.Close()` 是对 `close()` 的封装。文件描述符是资源，Go 的 gc 是针对内存的，并不会自动回收资源，如果不关闭文件描述符，\n长期运行的服务可能会把文件描述符耗尽。\n\n所以，通常的写法如下：\n\n```go\nfile, err := os.Open(\"/tmp/studygolang.txt\")\nif err != nil {\n\t// 错误处理，一般会阻止程序往下执行\n\treturn\n}\ndefer file.Close()\n```\n\n**关于返回值 `error`**\n\n以下两种情况会导致 `Close` 返回错误：\n\n1. 关闭一个未打开的文件；\n2. 两次关闭同一个文件；\n\n通常，不会去检查 `Close` 的错误。\n\n### Seek\n\n对于每个打开的文件，系统内核会记录其文件偏移量，有时也将文件偏移量称为读写偏移量或指针。文件偏移量是指执行下一个 `Read` 或 `Write` 操作\n的文件真实位置，会以相对于文件头部起始点的文件当前位置来表示。文件第一个字节的偏移量为 0。\n\n文件打开时，会将文件偏移量设置为指向文件开始，以后每次 `Read` 或 `Write` 调用将自动对其进行调整，以指向已读或已写数据后的下一个字节。因\n此，连续的 `Read` 和 `Write` 调用将按顺序递进，对文件进行操作。\n\n`Seek` 可以调整文件偏移量：\n```go\nfunc (f *File) Seek(offset int64, whence int) (ret int64, err error)\n```\n\n`Seek` 设置下一次读/写的位置。`offset` 为相对偏移量，而 `whence` 决定相对位置：0 为相对文件开头，1 为相对当前位置，2 为相对文件结尾。它\n返回新的偏移量（相对开头）和可能的错误。\n\n注意：`Seek` 只是调整内核中与文件描述符相关的文件偏移量记录，并没有访问任何物理设备。\n\n一些 `Seek` 的使用例子（file 为打开的文件对象），注释说明了将文件偏移量移动到的具体位置：\n\n```go\nfile.Seek(0, os.SEEK_SET)\t// 文件开始处\nfile.Seek(0, SEEK_END)\t\t// 文件结尾处的下一个字节\nfile.Seek(-1, SEEK_END)\t\t// 文件最后一个字节\nfile.Seek(-10, SEEK_CUR) \t// 当前位置前 10 个字节\nfile.Seek(1000, SEEK_END)\t// 文件结尾处的下 1001 个字节\n```\n最后一个例子在文件中会产生“空洞”。\n\n`Seek` 对应系统调用 `lseek`。该系统调用并不适用于所有类型，不允许将 `lseek ` 应用于管道、FIFO、socket 或 终端。\n\n## 截断文件\n\n`trucate` 和 `ftruncate` 系统调用将文件大小设置为 `size` 参数指定的值；Go 语言中相应的包装函数是 `os.Truncate` 和 \n`os.File.Truncate`。\n\n```go\nfunc Truncate(name string, size int64) error\nfunc (f *File) Truncate(size int64) error\n```\n如果文件当前长度大于参数 `size`，调用将丢弃超出部分，若小于参数 `size`，调用将在文件尾部添加一系列空字节或是一个文件空洞。\n\n它们之间的区别在于如何指定操作文件：\n\n1. `Truncate` 以路径名称字符串来指定文件，并要求可访问该文件（即对组成路径名的各目录拥有可执行 (x) 权限），且对文件拥有写权限。\n若文件名为符号链接，那么调用将对其进行解引用。\n2. 很明显，调用 `File.Truncate` 前，需要先以可写方式打开操作文件，该方法不会修改文件偏移量。\n\n## 文件属性\n\n文件属性，也即文件元数据。在 Go 中，文件属性具体信息通过 `os.FileInfo` 接口获取。函数 `Stat`、`Lstat` 和 `File.Stat` 可以得到该接口\n的实例。这三个函数对应三个系统调用：`stat`、`lstat` 和 `fstat`。\n\n这三个函数的区别：\n\n1. `stat` 会返回所命名文件的相关信息。\n2. `lstat` 与 `stat` 类似，区别在于如果文件是符号链接，那么所返回的信息针对的是符号链接自身（而非符号链接所指向的文件）。\n3. `fstat` 则会返回由某个打开文件描述符（Go 中则是当前打开文件 File）所指代文件的相关信息。\n\n`Stat` 和 `Lstat` 无需对其所操作的文件本身拥有任何权限，但针对指定 `name `的父目录要有执行（搜索）权限。而只要 `File` 对象 `ok`，\n`File.Stat` 总是成功。\n\n`FileInfo` 接口如下：\n\n```go\ntype FileInfo interface {\n    Name() string       // 文件的名字（不含扩展名）\n    Size() int64        // 普通文件返回值表示其大小；其他文件的返回值含义各系统不同\n    Mode() FileMode     // 文件的模式位\n    ModTime() time.Time // 文件的修改时间\n    IsDir() bool        // 等价于 Mode().IsDir()\n    Sys() interface{}   // 底层数据来源（可以返回 nil）\n}\n```\n\n`Sys()` 底层数据的 C 语言 结构 `statbuf` 格式如下：\n\n```go\nstruct stat {\n\tdev_t\tst_dev;\t// 设备 ID\n\tino_t\tst_ino;\t// 文件 i 节点号\n\tmode_t\tst_mode;\t// 位掩码，文件类型和文件权限\n\tnlink_t\tst_nlink;\t// 硬链接数\n\tuid_t\tst_uid;\t// 文件属主，用户 ID\n\tgid_t\tst_gid;\t// 文件属组，组 ID\n\tdev_t\tst_rdev;\t// 如果针对设备 i 节点，则此字段包含主、辅 ID\n\toff_t\tst_size;\t// 常规文件，则是文件字节数；符号链接，则是链接所指路径名的长度，字节为单位；对于共享内存对象，则是对象大小\n\tblksize_t\tst_blsize;\t// 分配给文件的总块数，块大小为 512 字节\n\tblkcnt_t\tst_blocks;\t// 实际分配给文件的磁盘块数量\n\ttime_t\tst_atime;\t\t// 对文件上次访问时间\n\ttime_t\tst_mtime;\t\t// 对文件上次修改时间\n\ttime_t\tst_ctime;\t\t// 文件状态发生改变的上次时间\n}\n```\nGo 中 `syscal.Stat_t` 与该结构对应。\n\n如果我们要获取 `FileInfo` 接口没法直接返回的信息，比如想获取文件的上次访问时间，示例如下：\n\n```go\nfileInfo, err := os.Stat(\"test.log\")\nif err != nil {\n\tlog.Fatal(err)\n}\nsys := fileInfo.Sys()\nstat := sys.(*syscall.Stat_t)\nfmt.Println(time.Unix(stat.Atimespec.Unix()))\n```\n\n### 改变文件时间戳\n\n可以显式改变文件的访问时间和修改时间。\n```go\nfunc Chtimes(name string, atime time.Time, mtime time.Time) error\n```\n\n`Chtimes` 修改 `name` 指定的文件对象的访问时间和修改时间，类似 Unix 的 `utime()` 或 `utimes()` 函数。底层的文件系统可能会截断/舍入\n时间单位到更低的精确度。如果出错，会返回 `*PathError` 类型的错误。在 Unix 中，底层实现会调用 `utimenstat()`，它提供纳秒级别的精度。\n\n### 文件属主\n\n每个文件都有一个与之关联的用户 ID（UID）和组 ID（GID），籍此可以判定文件的属主和属组。系统调用 `chown`、`lchown` 和 `fchown` 可用来\n改变文件的属主和属组，Go 中对应的函数或方法：\n\n```go\nfunc Chown(name string, uid, gid int) error\nfunc Lchown(name string, uid, gid int) error\nfunc (f *File) Chown(uid, gid int) error\n```\n它们的区别和上文提到的 `Stat` 相关函数类似。\n\n### 文件权限\n\n这里介绍是应用于文件和目录的权限方案，尽管此处讨论的权限主要是针对普通文件和目录，但其规则可适用于所有文件类型，包括设备文件、FIFO 以\n及 Unix 域套接字等。\n\n#### 相关函数或方法\n\n在文件相关操作报错时，可以通过 `os.IsPermission` 检查是否是权限的问题。\n```go\nfunc IsPermission(err error) bool\n```\n\n返回一个布尔值说明该错误是否表示因权限不足要求被拒绝。`ErrPermission` 和一些系统调用错误会使它返回真。\n\n另外，`syscall.Access` 可以获取文件的权限。这对应系统调用 `access`。\n\n#### Sticky 位\n\n除了 9 位用来表明属主、属组和其他用户的权限外，文件权限掩码还另设有 3 个附加位，分别是\n`set-user-ID`(bit 04000)、`set-group-ID`(bit 02000) 和 `sticky`(bit 01000) 位。\n\nSticky 位一般用于目录，起限制删除位的作用，表明仅当非特权进程具有对目录的写权限，且为文件或目录的属主时，才能对目录下的文件进行删除和重命名操\n作。根据这个机制来创建为多个用户共享的一个目录，各个用户可在其下创建或删除属于自己的文件，但不能删除隶属于其他用户的文件。`/tmp` 目录就设\n置了 sticky 位，正是出于这个原因。\n\n`chmod` 命令或系统调用可以设置文件的 sticky 位。若对某文件设置了 sticky 位，则 `ls -l` 显示文件时，会在其他用户执行权限字段上看到字\n母 t（有执行权限时） 或 T（无执行权限时）。\n\n`os.Chmod` 和 `os.File.Chmod` 可以修改文件权限（包括 sticky 位），分别对应系统调用 `chmod` 和 `fchmod`。\n\n```go\nfunc main() {\n    file, err := os.Create(\"studygolang.txt\")\n    if err != nil {\n        log.Fatal(\"error:\", err)\n    }\n    defer file.Close()\n\n    fileMode := getFileMode(file)\n    log.Println(\"file mode:\", fileMode)\n    file.Chmod(fileMode | os.ModeSticky)\n\n    log.Println(\"change after, file mode:\", getFileMode(file))\n}\n\nfunc getFileMode(file *os.File) os.FileMode {\n    fileInfo, err := file.Stat()\n    if err != nil {\n        log.Fatal(\"file stat error:\", err)\n    }\n\n    return fileInfo.Mode()\n}\n\n// Output:\n// 2016/06/18 15:59:06 file mode: -rw-rw-r--\n// 2016/06/18 15:59:06 change after, file mode: trw-rw-r--\n// ls -l 看到的 studygolang.tx 是：-rw-rw-r-T\n// 当然这里是给文件设置了 sticky 位，对权限不起作用。系统会忽略它。\n```\n\n## 目录与链接\n\n在 Unix 文件系统中，目录的存储方式类似于普通文件。目录和普通文件的区别有二：\n\n- 在其 `i-node` 条目中，会将目录标记为一种不同的文件类型。\n- 目录是经特殊组织而成的文件。本质上说就是一个表格，包含文件名和 `i-node` 标号。\n\n### 创建和移除（硬）链接\n\n硬链接是针对文件而言的，目录不允许创建硬链接。\n\n`link` 和 `unlink` 系统调用用于创建和移除（硬）链接。Go 中 `os.Link` 对应 `link` 系统调用；但 `os.Remove` 的实现会先执行 `unlink` \n系统调用，如果要移除的是目录，则 `unlink` 会失败，这时 `Remove` 会再调用 `rmdir` 系统调用。\n```go\nfunc Link(oldname, newname string) error\n```\n\n`Link` 创建一个名为 `newname` 指向 `oldname` 的硬链接。如果出错，会返回 `*LinkError` 类型的错误。\n```go\nfunc Remove(name string) error\n```\n\n`Remove` 删除 `name` 指定的文件或目录。如果出错，会返回 `*PathError` 类型的错误。如果目录不为空，`Remove` 会返回失败。\n\n### 更改文件名\n\n系统调用 `rename` 既可以重命名文件，又可以将文件移至同一个文件系统中的另一个目录。该系统调用既可以用于文件，也可以用于目录。相关细节，\n请查阅相关资料。\n\nGo 中的 `os.Rename` 是对应的封装函数。\n```go\nfunc Rename(oldpath, newpath string) error\n```\n\n`Rename` 修改一个文件的名字或移动一个文件。如果 `newpath` 已经存在，则替换它。注意，可能会有一些个操作系统特定的限制。\n\n### 使用符号链接\n\n`symlink` 系统调用用于为指定路径名创建一个新的符号链接（想要移除符号链接，使用 `unlink`）。Go 中的 `os.Symlink` 是对应的封装函数。\n```go\nfunc Symlink(oldname, newname string) error\n```\n\n`Symlink` 创建一个名为 `newname` 指向 `oldname` 的符号链接。如果出错，会返回 `*LinkError` 类型的错误。\n\n由 `oldname` 所命名的文件或目录在调用时无需存在。因为即便当时存在，也无法阻止后来将其删除。这时，`newname` 成为“悬空链接”，其他系统\n调用试图对其进行解引用操作都将错误（通常错误号是 `ENOENT`）。\n\n有时候，我们希望通过符号链接，能获取其所指向的路径名。系统调用 `readlink` 能做到，Go 的封装函数是 `os.Readlink`：\n```go\nfunc Readlink(name string) (string, error)\n```\n\n`Readlink` 获取 `name` 指定的符号链接指向的文件的路径。如果出错，会返回 `*PathError` 类型的错误。我们看看 `Readlink` 的实现。\n\n```go\nfunc Readlink(name string) (string, error) {\n\tfor len := 128; ; len *= 2 {\n\t\tb := make([]byte, len)\n\t\tn, e := fixCount(syscall.Readlink(name, b))\n\t\tif e != nil {\n\t\t\treturn \"\", &PathError{\"readlink\", name, e}\n\t\t}\n\t\tif n < len {\n\t\t\treturn string(b[0:n]), nil\n\t\t}\n\t}\n}\n```\n这里之所以用循环，是因为我们没法知道文件的路径到底多长，如果 `b` 长度不够，文件名会被截断，而 `readlink` 系统调用无非分辨所返回的字\n符串到底是经过截断处理，还是恰巧将 `b` 填满。这里采用的验证方法是分配一个更大的（两倍）`b` 并再次调用 `readlink`。\n\n### 创建和移除目录\n\n`mkdir` 系统调用创建一个新目录，Go 中的 `os.Mkdir` 是对应的封装函数。\n```go\nfunc Mkdir(name string, perm FileMode) error\n```\n\n`Mkdir` 使用指定的权限和名称创建一个目录。如果出错，会返回 `*PathError` 类型的错误。\n\n`name` 参数指定了新目录的路径名，可以是相对路径，也可以是绝对路径。如果已经存在，则调用失败并返回 `os.ErrExist` 错误。\n\n`perm` 参数指定了新目录的权限。对该位掩码值的指定方式和 `os.OpenFile` 相同，也可以直接赋予八进制数值。注意，`perm` 值还将于进程掩码相\n与（&）。如果 `perm` 中设置了 sticky 位，那么将对新目录设置该权限。\n\n因为 `Mkdir` 所创建的只是路径名中的最后一部分，如果父目录不存在，创建会失败。`os.MkdirAll` 用于递归创建所有不存在的目录。\n\n建议读者阅读下 `os.MkdirAll` 的源码，了解其实现方式、技巧。\n\n`rmdir` 系统调用移除一个指定的目录，目录可以是绝对路径或相对路径。在讲解 `unlink` 时，已经介绍了 Go 中的 `os.Remove`。注意，这里要求\n目录必须为空。为了方便使用，Go 中封装了一个 `os.RemoveAll` 函数：\n```go\nfunc RemoveAll(path string) error\n```\n\n`RemoveAll` 删除 `path` 指定的文件，或目录及它包含的任何下级对象。它会尝试删除所有东西，除非遇到错误并返回。如果 `path` 指定的对象不\n存在，`RemoveAll` 会返回 `nil` 而不返回错误。\n\n`RemoveAll` 的内部实现逻辑如下：\n\n1. 调用 `Remove` 尝试进行删除，如果成功或返回 `path` 不存在，则直接返回 nil；\n2. 调用 `Lstat` 获取 `path` 信息，以便判断是否是目录。注意，这里使用 `Lstat`，表示不对符号链接解引用；\n3. 调用 `Open` 打开目录，递归读取目录中内容，执行删除操作。\n\n### 读目录\n\n`POSIX` 与 `SUS` 定义了读取目录相关的 C 语言标准，各个操作系统提供的系统调用却不尽相同。Go 没有基于 C 语言，而是自己通过系统调用实现\n了读目录功能。\n```go\nfunc (f *File) Readdirnames(n int) (names []string, err error)\n```\n\n`Readdirnames` 读取目录 `f` 的内容，返回一个最多有 `n` 个成员的 `[]string`，切片成员为目录中文件对象的名字，采用目录顺序。对本函数的下一\n次调用会返回上一次调用未读取的内容的信息。\n\n如果 `n>0`，`Readdirnames` 函数会返回一个最多 `n` 个成员的切片。这时，如果 `Readdirnames` 返回一个空切片，它会返回一个非 `nil` 的错\n误说明原因。如果到达了目录 `f` 的结尾，返回值 `err` 会是 `io.EOF`。\n\n如果 `n<=0`，`Readdirnames` 函数返回目录中剩余所有文件对象的名字构成的切片。此时，如果 `Readdirnames` 调用成功（读取所有内容直到结尾），\n它会返回该切片和 `nil` 的错误值。如果在到达结尾前遇到错误，会返回之前成功读取的名字构成的切片和该错误。\n```go\nfunc (f *File) Readdir(n int) (fi []FileInfo, err error)\n```\n\n`Readdir` 内部会调用 `Readdirnames`，将得到的 `names` 构造路径，通过 `Lstat` 构造出 `[]FileInfo`。\n\n`ioutil.ReadDir` 也可以实现类似的功能。","date":"2019-10-19T13:40:15.183Z","updated":"2019-10-19T13:40:15.183Z","path":"standards/os/os.html","comments":1,"layout":"page","_id":"ck1xm14lm001cfcw22f1f2ync","content":"<h1 id=\"os\"><a href=\"#os\" class=\"headerlink\" title=\"os\"></a>os</h1><p><code>os</code> 包提供了平台无关的操作系统功能接口。例如 Linux、macOS、Windows 等系统 <code>os</code> 包提供统一的使用接口。 </p>\n<p>例子，打开一个文件并从中读取一些数据：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">file, err := os.Open(<span class=\"string\">\"file.go\"</span>) <span class=\"comment\">// For read access.</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\tlog.Fatal(err) <span class=\"comment\">// `open file.go: no such file or directory`</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"文件-I-O\"><a href=\"#文件-I-O\" class=\"headerlink\" title=\"文件 I/O\"></a>文件 I/O</h2><p>在 Go 中，文件描述符封装在 <code>os.File</code> 结构中，通过 <code>File.Fd()</code> 可以获得底层的文件描述符：<code>fd</code>。</p>\n<p>大多数程序都期望能够使用 3 种标准的文件描述符：0- 标准输入；1- 标准输出；2- 标准错误。<code>os</code> 包提供了 3 个 <code>File</code> 对象，分别<br>代表这 3 种标准描述符：<code>Stdin</code>、<code>Stdout</code> 和 <code>Stderr</code>，它们对应的文件名分别是：<code>/dev/stdin</code>、<code>/dev/stdout</code> 和 <code>/dev/stderr</code>。<br>注意，这里说的文件名，并不一定存在，比如 Windows 下就没有。</p>\n<h3 id=\"OpenFile\"><a href=\"#OpenFile\" class=\"headerlink\" title=\"OpenFile\"></a>OpenFile</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">OpenFile</span><span class=\"params\">(name <span class=\"keyword\">string</span>, flag <span class=\"keyword\">int</span>, perm FileMode)</span> <span class=\"params\">(*File, error)</span></span></span><br></pre></td></tr></table></figure>\n<p><code>OpenFile</code> 既能打开一个已经存在的文件，也能创建并打开一个新文件。</p>\n<p><code>OpenFile</code> 是一个更一般性的文件打开函数，大多数调用者都应用 <code>Open</code> 或 <code>Create</code> 代替本函数。它会使用指定的选项（如 <code>O_RDONLY</code> 等）、<br>指定的模式（如 <code>0666</code> 等）打开指定名称的文件。如果操作成功，返回的文件对象可用于 I/O。如果出错，错误底层类型是 <code>*PathError</code>。</p>\n<p>要打开的文件由参数 <code>name</code> 指定，它可以是绝对路径或相对路径（相对于进程当前工作目录），也可以是一个符号链接（会对其进行解引用）。</p>\n<p>位掩码参数 <code>flag</code> 用于指定文件的访问模式，可用的值在 <code>os</code> 中定义为常量（以下值并非所有操作系统都可用）：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">    O_RDONLY <span class=\"keyword\">int</span> = syscall.O_RDONLY <span class=\"comment\">// 只读模式打开文件</span></span><br><span class=\"line\">    O_WRONLY <span class=\"keyword\">int</span> = syscall.O_WRONLY <span class=\"comment\">// 只写模式打开文件</span></span><br><span class=\"line\">    O_RDWR   <span class=\"keyword\">int</span> = syscall.O_RDWR   <span class=\"comment\">// 读写模式打开文件</span></span><br><span class=\"line\">    O_APPEND <span class=\"keyword\">int</span> = syscall.O_APPEND <span class=\"comment\">// 写操作时将数据附加到文件尾部</span></span><br><span class=\"line\">    O_CREATE <span class=\"keyword\">int</span> = syscall.O_CREAT  <span class=\"comment\">// 如果不存在将创建一个新文件</span></span><br><span class=\"line\">    O_EXCL   <span class=\"keyword\">int</span> = syscall.O_EXCL   <span class=\"comment\">// 和 O_CREATE 配合使用，文件必须不存在</span></span><br><span class=\"line\">    O_SYNC   <span class=\"keyword\">int</span> = syscall.O_SYNC   <span class=\"comment\">// 打开文件用于同步 I/O</span></span><br><span class=\"line\">    O_TRUNC  <span class=\"keyword\">int</span> = syscall.O_TRUNC  <span class=\"comment\">// 如果可能，打开时清空文件</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>其中，<code>O_RDONLY</code>、<code>O_WRONLY</code>、<code>O_RDWR</code> 只指定一个，剩下的通过 <code>|</code> 操作符来指定。该函数内部会给 <code>flags</code> 加上 <code>syscall.O_CLOEXEC</code>，<br>在 <code>fork</code> 子进程时会关闭通过 <code>OpenFile</code> 打开的文件，即子进程不会重用该文件描述符。</p>\n<p>位掩码参数 <code>perm</code> 指定了文件的模式和权限位，类型是 <code>os.FileMode</code>，文件模式位常量定义在 <code>os</code> 中：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">    <span class=\"comment\">// 单字符是被 String 方法用于格式化的属性缩写。</span></span><br><span class=\"line\">    ModeDir        FileMode = <span class=\"number\">1</span> &lt;&lt; (<span class=\"number\">32</span> - <span class=\"number\">1</span> - <span class=\"literal\">iota</span>) <span class=\"comment\">// d: 目录</span></span><br><span class=\"line\">    ModeAppend                                     <span class=\"comment\">// a: 只能写入，且只能写入到末尾</span></span><br><span class=\"line\">    ModeExclusive                                  <span class=\"comment\">// l: 用于执行</span></span><br><span class=\"line\">    ModeTemporary                                  <span class=\"comment\">// T: 临时文件（非备份文件）</span></span><br><span class=\"line\">    ModeSymlink                                    <span class=\"comment\">// L: 符号链接（不是快捷方式文件）</span></span><br><span class=\"line\">    ModeDevice                                     <span class=\"comment\">// D: 设备</span></span><br><span class=\"line\">    ModeNamedPipe                                  <span class=\"comment\">// p: 命名管道（FIFO）</span></span><br><span class=\"line\">    ModeSocket                                     <span class=\"comment\">// S: Unix 域 socket</span></span><br><span class=\"line\">    ModeSetuid                                     <span class=\"comment\">// u: 表示文件具有其创建者用户 id 权限</span></span><br><span class=\"line\">    ModeSetgid                                     <span class=\"comment\">// g: 表示文件具有其创建者组 id 的权限</span></span><br><span class=\"line\">    ModeCharDevice                                 <span class=\"comment\">// c: 字符设备，需已设置 ModeDevice</span></span><br><span class=\"line\">    ModeSticky                                     <span class=\"comment\">// t: 只有 root/ 创建者能删除 / 移动文件</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 覆盖所有类型位（用于通过 &amp; 获取类型位），对普通文件，所有这些位都不应被设置</span></span><br><span class=\"line\">    ModeType = ModeDir | ModeSymlink | ModeNamedPipe | ModeSocket | ModeDevice</span><br><span class=\"line\">    ModePerm FileMode = <span class=\"number\">0777</span> <span class=\"comment\">// 覆盖所有 Unix 权限位（用于通过 &amp; 获取类型位）</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>以上常量在所有操作系统都有相同的含义（可用时），因此文件的信息可以在不同的操作系统之间安全的移植。不是所有的位都能用于所有的系统，<br>唯一共有的是用于表示目录的 <code>ModeDir</code> 位。</p>\n<p>以上这些被定义的位是 <code>FileMode</code> 最重要的位。另外 9 个位（权限位）为标准 Unix <code>rwxrwxrwx</code> 权限（所有人都可读、写、运行）。</p>\n<p><code>FileMode</code> 还定义了几个方法，用于判断文件类型的 <code>IsDir()</code> 和 <code>IsRegular()</code>，用于获取权限的 <code>Perm()</code>。</p>\n<p>返回的 <code>error</code>，具体实现是 <code>*os.PathError</code>，它会记录具体操作、文件路径和错误原因。</p>\n<p>另外，在 <code>OpenFile</code> 内部会调用 <code>NewFile</code>，来得到 <code>File</code> 对象。</p>\n<p><strong>使用方法</strong></p>\n<p>打开一个文件，一般通过 <code>Open</code> 或 <code>Create</code>，这两个函数的实现。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Open</span><span class=\"params\">(name <span class=\"keyword\">string</span>)</span> <span class=\"params\">(*File, error)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> OpenFile(name, O_RDONLY, <span class=\"number\">0</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Create</span><span class=\"params\">(name <span class=\"keyword\">string</span>)</span> <span class=\"params\">(*File, error)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> OpenFile(name, O_RDWR|O_CREATE|O_TRUNC, <span class=\"number\">0666</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Read\"><a href=\"#Read\" class=\"headerlink\" title=\"Read\"></a>Read</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(f *File)</span> <span class=\"title\">Read</span><span class=\"params\">(b []<span class=\"keyword\">byte</span>)</span> <span class=\"params\">(n <span class=\"keyword\">int</span>, err error)</span></span></span><br></pre></td></tr></table></figure>\n<p><code>Read</code> 方法从 <code>f</code> 中读取最多 <code>len(b)</code> 字节数据并写入 <code>b</code>。它返回读取的字节数和可能遇到的任何错误。文件终止标志是读取 0 个字节且返回<br>值 <code>err</code> 为 <code>io.EOF</code>。</p>\n<p>对比下 <code>ReadAt</code> 方法：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(f *File)</span> <span class=\"title\">ReadAt</span><span class=\"params\">(b []<span class=\"keyword\">byte</span>, off <span class=\"keyword\">int64</span>)</span> <span class=\"params\">(n <span class=\"keyword\">int</span>, err error)</span></span></span><br></pre></td></tr></table></figure></p>\n<p><code>ReadAt</code> 从指定的位置（相对于文件开始位置）读取长度为 <code>len(b)</code> 个字节数据并写入 <code>b</code>。它返回读取的字节数和可能遇到的任何错误。<br>当 <code>n&lt;len(b)</code> 时，本方法总是会返回错误；如果是因为到达文件结尾，返回值 <code>err</code> 会是 <code>io.EOF</code>。它对应的系统调用是 <code>pread</code>。</p>\n<p><strong><code>Read</code> 和 <code>ReadAt</code> 的区别</strong>：前者从文件当前偏移量处读，且会改变文件当前的偏移量；而后者从 <code>off</code> 指定的位置开始读，且<strong>不会改变</strong>文件<br>当前偏移量。</p>\n<h3 id=\"Write\"><a href=\"#Write\" class=\"headerlink\" title=\"Write\"></a>Write</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(f *File)</span> <span class=\"title\">Write</span><span class=\"params\">(b []<span class=\"keyword\">byte</span>)</span> <span class=\"params\">(n <span class=\"keyword\">int</span>, err error)</span></span></span><br></pre></td></tr></table></figure>\n<p><code>Write</code> 向文件中写入 <code>len(b)</code> 字节数据。它返回写入的字节数和可能遇到的任何错误。如果返回值 <code>n != len(b)</code>，本方法会返回一个 <strong>非 nil</strong><br> 的错误。</p>\n<p><code>Write</code> 与 <code>WriteAt</code> 的区别同 <code>Read</code> 与 <code>ReadAt</code> 的区别一样。为了方便，还提供了 <code>WriteString</code> 方法，它实际是对 <code>Write</code> 的封装。</p>\n<p>注意：<code>Write</code> 调用成功并不能保证数据已经写入磁盘，因为内核会缓存磁盘的 I/O 操作。如果希望立刻将数据写入磁盘（一般场景不建议这么做，因为会<br>影响性能），有两种办法：</p>\n<ol>\n<li>打开文件时指定 <code>os.O_SYNC</code>；</li>\n<li>调用 <code>File.Sync()</code> 方法。</li>\n</ol>\n<p>说明：<code>File.Sync()</code> 底层调用的是 <code>fsync</code> 系统调用，这会将数据和元数据都刷到磁盘；如果只想刷数据到磁盘（比如，文件大小没变，只是变了文件<br>数据），需要自己封装，调用 <code>fdatasync</code> 系统调用。（<code>syscall.Fdatasync</code>）</p>\n<h3 id=\"Close\"><a href=\"#Close\" class=\"headerlink\" title=\"Close\"></a>Close</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(f *File)</span> <span class=\"title\">Close</span><span class=\"params\">()</span> <span class=\"title\">error</span></span></span><br></pre></td></tr></table></figure>\n<p><code>close()</code> 系统调用关闭一个打开的文件描述符，并将其释放回调用进程，供该进程继续使用。当进程终止时，将自动关闭其已打开的所有文件描述符。</p>\n<p><code>os.File.Close()</code> 是对 <code>close()</code> 的封装。文件描述符是资源，Go 的 gc 是针对内存的，并不会自动回收资源，如果不关闭文件描述符，<br>长期运行的服务可能会把文件描述符耗尽。</p>\n<p>所以，通常的写法如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">file, err := os.Open(<span class=\"string\">\"/tmp/studygolang.txt\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 错误处理，一般会阻止程序往下执行</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">defer</span> file.Close()</span><br></pre></td></tr></table></figure>\n<p><strong>关于返回值 <code>error</code></strong></p>\n<p>以下两种情况会导致 <code>Close</code> 返回错误：</p>\n<ol>\n<li>关闭一个未打开的文件；</li>\n<li>两次关闭同一个文件；</li>\n</ol>\n<p>通常，不会去检查 <code>Close</code> 的错误。</p>\n<h3 id=\"Seek\"><a href=\"#Seek\" class=\"headerlink\" title=\"Seek\"></a>Seek</h3><p>对于每个打开的文件，系统内核会记录其文件偏移量，有时也将文件偏移量称为读写偏移量或指针。文件偏移量是指执行下一个 <code>Read</code> 或 <code>Write</code> 操作<br>的文件真实位置，会以相对于文件头部起始点的文件当前位置来表示。文件第一个字节的偏移量为 0。</p>\n<p>文件打开时，会将文件偏移量设置为指向文件开始，以后每次 <code>Read</code> 或 <code>Write</code> 调用将自动对其进行调整，以指向已读或已写数据后的下一个字节。因<br>此，连续的 <code>Read</code> 和 <code>Write</code> 调用将按顺序递进，对文件进行操作。</p>\n<p><code>Seek</code> 可以调整文件偏移量：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(f *File)</span> <span class=\"title\">Seek</span><span class=\"params\">(offset <span class=\"keyword\">int64</span>, whence <span class=\"keyword\">int</span>)</span> <span class=\"params\">(ret <span class=\"keyword\">int64</span>, err error)</span></span></span><br></pre></td></tr></table></figure></p>\n<p><code>Seek</code> 设置下一次读/写的位置。<code>offset</code> 为相对偏移量，而 <code>whence</code> 决定相对位置：0 为相对文件开头，1 为相对当前位置，2 为相对文件结尾。它<br>返回新的偏移量（相对开头）和可能的错误。</p>\n<p>注意：<code>Seek</code> 只是调整内核中与文件描述符相关的文件偏移量记录，并没有访问任何物理设备。</p>\n<p>一些 <code>Seek</code> 的使用例子（file 为打开的文件对象），注释说明了将文件偏移量移动到的具体位置：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">file.Seek(<span class=\"number\">0</span>, os.SEEK_SET)\t<span class=\"comment\">// 文件开始处</span></span><br><span class=\"line\">file.Seek(<span class=\"number\">0</span>, SEEK_END)\t\t<span class=\"comment\">// 文件结尾处的下一个字节</span></span><br><span class=\"line\">file.Seek(<span class=\"number\">-1</span>, SEEK_END)\t\t<span class=\"comment\">// 文件最后一个字节</span></span><br><span class=\"line\">file.Seek(<span class=\"number\">-10</span>, SEEK_CUR) \t<span class=\"comment\">// 当前位置前 10 个字节</span></span><br><span class=\"line\">file.Seek(<span class=\"number\">1000</span>, SEEK_END)\t<span class=\"comment\">// 文件结尾处的下 1001 个字节</span></span><br></pre></td></tr></table></figure>\n<p>最后一个例子在文件中会产生“空洞”。</p>\n<p><code>Seek</code> 对应系统调用 <code>lseek</code>。该系统调用并不适用于所有类型，不允许将 <code>lseek</code> 应用于管道、FIFO、socket 或 终端。</p>\n<h2 id=\"截断文件\"><a href=\"#截断文件\" class=\"headerlink\" title=\"截断文件\"></a>截断文件</h2><p><code>trucate</code> 和 <code>ftruncate</code> 系统调用将文件大小设置为 <code>size</code> 参数指定的值；Go 语言中相应的包装函数是 <code>os.Truncate</code> 和<br><code>os.File.Truncate</code>。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Truncate</span><span class=\"params\">(name <span class=\"keyword\">string</span>, size <span class=\"keyword\">int64</span>)</span> <span class=\"title\">error</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"params\">(f *File)</span> <span class=\"title\">Truncate</span><span class=\"params\">(size <span class=\"keyword\">int64</span>)</span> <span class=\"title\">error</span></span></span><br></pre></td></tr></table></figure>\n<p>如果文件当前长度大于参数 <code>size</code>，调用将丢弃超出部分，若小于参数 <code>size</code>，调用将在文件尾部添加一系列空字节或是一个文件空洞。</p>\n<p>它们之间的区别在于如何指定操作文件：</p>\n<ol>\n<li><code>Truncate</code> 以路径名称字符串来指定文件，并要求可访问该文件（即对组成路径名的各目录拥有可执行 (x) 权限），且对文件拥有写权限。<br>若文件名为符号链接，那么调用将对其进行解引用。</li>\n<li>很明显，调用 <code>File.Truncate</code> 前，需要先以可写方式打开操作文件，该方法不会修改文件偏移量。</li>\n</ol>\n<h2 id=\"文件属性\"><a href=\"#文件属性\" class=\"headerlink\" title=\"文件属性\"></a>文件属性</h2><p>文件属性，也即文件元数据。在 Go 中，文件属性具体信息通过 <code>os.FileInfo</code> 接口获取。函数 <code>Stat</code>、<code>Lstat</code> 和 <code>File.Stat</code> 可以得到该接口<br>的实例。这三个函数对应三个系统调用：<code>stat</code>、<code>lstat</code> 和 <code>fstat</code>。</p>\n<p>这三个函数的区别：</p>\n<ol>\n<li><code>stat</code> 会返回所命名文件的相关信息。</li>\n<li><code>lstat</code> 与 <code>stat</code> 类似，区别在于如果文件是符号链接，那么所返回的信息针对的是符号链接自身（而非符号链接所指向的文件）。</li>\n<li><code>fstat</code> 则会返回由某个打开文件描述符（Go 中则是当前打开文件 File）所指代文件的相关信息。</li>\n</ol>\n<p><code>Stat</code> 和 <code>Lstat</code> 无需对其所操作的文件本身拥有任何权限，但针对指定 <code>name</code>的父目录要有执行（搜索）权限。而只要 <code>File</code> 对象 <code>ok</code>，<br><code>File.Stat</code> 总是成功。</p>\n<p><code>FileInfo</code> 接口如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> FileInfo <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">    Name() <span class=\"keyword\">string</span>       <span class=\"comment\">// 文件的名字（不含扩展名）</span></span><br><span class=\"line\">    Size() <span class=\"keyword\">int64</span>        <span class=\"comment\">// 普通文件返回值表示其大小；其他文件的返回值含义各系统不同</span></span><br><span class=\"line\">    Mode() FileMode     <span class=\"comment\">// 文件的模式位</span></span><br><span class=\"line\">    ModTime() time.Time <span class=\"comment\">// 文件的修改时间</span></span><br><span class=\"line\">    IsDir() <span class=\"keyword\">bool</span>        <span class=\"comment\">// 等价于 Mode().IsDir()</span></span><br><span class=\"line\">    Sys() <span class=\"keyword\">interface</span>&#123;&#125;   <span class=\"comment\">// 底层数据来源（可以返回 nil）</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>Sys()</code> 底层数据的 C 语言 结构 <code>statbuf</code> 格式如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> stat &#123;</span><br><span class=\"line\">\tdev_t\tst_dev;\t<span class=\"comment\">// 设备 ID</span></span><br><span class=\"line\">\tino_t\tst_ino;\t<span class=\"comment\">// 文件 i 节点号</span></span><br><span class=\"line\">\tmode_t\tst_mode;\t<span class=\"comment\">// 位掩码，文件类型和文件权限</span></span><br><span class=\"line\">\tnlink_t\tst_nlink;\t<span class=\"comment\">// 硬链接数</span></span><br><span class=\"line\">\tuid_t\tst_uid;\t<span class=\"comment\">// 文件属主，用户 ID</span></span><br><span class=\"line\">\tgid_t\tst_gid;\t<span class=\"comment\">// 文件属组，组 ID</span></span><br><span class=\"line\">\tdev_t\tst_rdev;\t<span class=\"comment\">// 如果针对设备 i 节点，则此字段包含主、辅 ID</span></span><br><span class=\"line\">\toff_t\tst_size;\t<span class=\"comment\">// 常规文件，则是文件字节数；符号链接，则是链接所指路径名的长度，字节为单位；对于共享内存对象，则是对象大小</span></span><br><span class=\"line\">\tblksize_t\tst_blsize;\t<span class=\"comment\">// 分配给文件的总块数，块大小为 512 字节</span></span><br><span class=\"line\">\tblkcnt_t\tst_blocks;\t<span class=\"comment\">// 实际分配给文件的磁盘块数量</span></span><br><span class=\"line\">\ttime_t\tst_atime;\t\t<span class=\"comment\">// 对文件上次访问时间</span></span><br><span class=\"line\">\ttime_t\tst_mtime;\t\t<span class=\"comment\">// 对文件上次修改时间</span></span><br><span class=\"line\">\ttime_t\tst_ctime;\t\t<span class=\"comment\">// 文件状态发生改变的上次时间</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Go 中 <code>syscal.Stat_t</code> 与该结构对应。</p>\n<p>如果我们要获取 <code>FileInfo</code> 接口没法直接返回的信息，比如想获取文件的上次访问时间，示例如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fileInfo, err := os.Stat(<span class=\"string\">\"test.log\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\tlog.Fatal(err)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">sys := fileInfo.Sys()</span><br><span class=\"line\">stat := sys.(*syscall.Stat_t)</span><br><span class=\"line\">fmt.Println(time.Unix(stat.Atimespec.Unix()))</span><br></pre></td></tr></table></figure>\n<h3 id=\"改变文件时间戳\"><a href=\"#改变文件时间戳\" class=\"headerlink\" title=\"改变文件时间戳\"></a>改变文件时间戳</h3><p>可以显式改变文件的访问时间和修改时间。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Chtimes</span><span class=\"params\">(name <span class=\"keyword\">string</span>, atime time.Time, mtime time.Time)</span> <span class=\"title\">error</span></span></span><br></pre></td></tr></table></figure></p>\n<p><code>Chtimes</code> 修改 <code>name</code> 指定的文件对象的访问时间和修改时间，类似 Unix 的 <code>utime()</code> 或 <code>utimes()</code> 函数。底层的文件系统可能会截断/舍入<br>时间单位到更低的精确度。如果出错，会返回 <code>*PathError</code> 类型的错误。在 Unix 中，底层实现会调用 <code>utimenstat()</code>，它提供纳秒级别的精度。</p>\n<h3 id=\"文件属主\"><a href=\"#文件属主\" class=\"headerlink\" title=\"文件属主\"></a>文件属主</h3><p>每个文件都有一个与之关联的用户 ID（UID）和组 ID（GID），籍此可以判定文件的属主和属组。系统调用 <code>chown</code>、<code>lchown</code> 和 <code>fchown</code> 可用来<br>改变文件的属主和属组，Go 中对应的函数或方法：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Chown</span><span class=\"params\">(name <span class=\"keyword\">string</span>, uid, gid <span class=\"keyword\">int</span>)</span> <span class=\"title\">error</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">Lchown</span><span class=\"params\">(name <span class=\"keyword\">string</span>, uid, gid <span class=\"keyword\">int</span>)</span> <span class=\"title\">error</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"params\">(f *File)</span> <span class=\"title\">Chown</span><span class=\"params\">(uid, gid <span class=\"keyword\">int</span>)</span> <span class=\"title\">error</span></span></span><br></pre></td></tr></table></figure>\n<p>它们的区别和上文提到的 <code>Stat</code> 相关函数类似。</p>\n<h3 id=\"文件权限\"><a href=\"#文件权限\" class=\"headerlink\" title=\"文件权限\"></a>文件权限</h3><p>这里介绍是应用于文件和目录的权限方案，尽管此处讨论的权限主要是针对普通文件和目录，但其规则可适用于所有文件类型，包括设备文件、FIFO 以<br>及 Unix 域套接字等。</p>\n<h4 id=\"相关函数或方法\"><a href=\"#相关函数或方法\" class=\"headerlink\" title=\"相关函数或方法\"></a>相关函数或方法</h4><p>在文件相关操作报错时，可以通过 <code>os.IsPermission</code> 检查是否是权限的问题。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">IsPermission</span><span class=\"params\">(err error)</span> <span class=\"title\">bool</span></span></span><br></pre></td></tr></table></figure></p>\n<p>返回一个布尔值说明该错误是否表示因权限不足要求被拒绝。<code>ErrPermission</code> 和一些系统调用错误会使它返回真。</p>\n<p>另外，<code>syscall.Access</code> 可以获取文件的权限。这对应系统调用 <code>access</code>。</p>\n<h4 id=\"Sticky-位\"><a href=\"#Sticky-位\" class=\"headerlink\" title=\"Sticky 位\"></a>Sticky 位</h4><p>除了 9 位用来表明属主、属组和其他用户的权限外，文件权限掩码还另设有 3 个附加位，分别是<br><code>set-user-ID</code>(bit 04000)、<code>set-group-ID</code>(bit 02000) 和 <code>sticky</code>(bit 01000) 位。</p>\n<p>Sticky 位一般用于目录，起限制删除位的作用，表明仅当非特权进程具有对目录的写权限，且为文件或目录的属主时，才能对目录下的文件进行删除和重命名操<br>作。根据这个机制来创建为多个用户共享的一个目录，各个用户可在其下创建或删除属于自己的文件，但不能删除隶属于其他用户的文件。<code>/tmp</code> 目录就设<br>置了 sticky 位，正是出于这个原因。</p>\n<p><code>chmod</code> 命令或系统调用可以设置文件的 sticky 位。若对某文件设置了 sticky 位，则 <code>ls -l</code> 显示文件时，会在其他用户执行权限字段上看到字<br>母 t（有执行权限时） 或 T（无执行权限时）。</p>\n<p><code>os.Chmod</code> 和 <code>os.File.Chmod</code> 可以修改文件权限（包括 sticky 位），分别对应系统调用 <code>chmod</code> 和 <code>fchmod</code>。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    file, err := os.Create(<span class=\"string\">\"studygolang.txt\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        log.Fatal(<span class=\"string\">\"error:\"</span>, err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">defer</span> file.Close()</span><br><span class=\"line\"></span><br><span class=\"line\">    fileMode := getFileMode(file)</span><br><span class=\"line\">    log.Println(<span class=\"string\">\"file mode:\"</span>, fileMode)</span><br><span class=\"line\">    file.Chmod(fileMode | os.ModeSticky)</span><br><span class=\"line\"></span><br><span class=\"line\">    log.Println(<span class=\"string\">\"change after, file mode:\"</span>, getFileMode(file))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">getFileMode</span><span class=\"params\">(file *os.File)</span> <span class=\"title\">os</span>.<span class=\"title\">FileMode</span></span> &#123;</span><br><span class=\"line\">    fileInfo, err := file.Stat()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        log.Fatal(<span class=\"string\">\"file stat error:\"</span>, err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> fileInfo.Mode()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Output:</span></span><br><span class=\"line\"><span class=\"comment\">// 2016/06/18 15:59:06 file mode: -rw-rw-r--</span></span><br><span class=\"line\"><span class=\"comment\">// 2016/06/18 15:59:06 change after, file mode: trw-rw-r--</span></span><br><span class=\"line\"><span class=\"comment\">// ls -l 看到的 studygolang.tx 是：-rw-rw-r-T</span></span><br><span class=\"line\"><span class=\"comment\">// 当然这里是给文件设置了 sticky 位，对权限不起作用。系统会忽略它。</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"目录与链接\"><a href=\"#目录与链接\" class=\"headerlink\" title=\"目录与链接\"></a>目录与链接</h2><p>在 Unix 文件系统中，目录的存储方式类似于普通文件。目录和普通文件的区别有二：</p>\n<ul>\n<li>在其 <code>i-node</code> 条目中，会将目录标记为一种不同的文件类型。</li>\n<li>目录是经特殊组织而成的文件。本质上说就是一个表格，包含文件名和 <code>i-node</code> 标号。</li>\n</ul>\n<h3 id=\"创建和移除（硬）链接\"><a href=\"#创建和移除（硬）链接\" class=\"headerlink\" title=\"创建和移除（硬）链接\"></a>创建和移除（硬）链接</h3><p>硬链接是针对文件而言的，目录不允许创建硬链接。</p>\n<p><code>link</code> 和 <code>unlink</code> 系统调用用于创建和移除（硬）链接。Go 中 <code>os.Link</code> 对应 <code>link</code> 系统调用；但 <code>os.Remove</code> 的实现会先执行 <code>unlink</code><br>系统调用，如果要移除的是目录，则 <code>unlink</code> 会失败，这时 <code>Remove</code> 会再调用 <code>rmdir</code> 系统调用。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Link</span><span class=\"params\">(oldname, newname <span class=\"keyword\">string</span>)</span> <span class=\"title\">error</span></span></span><br></pre></td></tr></table></figure></p>\n<p><code>Link</code> 创建一个名为 <code>newname</code> 指向 <code>oldname</code> 的硬链接。如果出错，会返回 <code>*LinkError</code> 类型的错误。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Remove</span><span class=\"params\">(name <span class=\"keyword\">string</span>)</span> <span class=\"title\">error</span></span></span><br></pre></td></tr></table></figure></p>\n<p><code>Remove</code> 删除 <code>name</code> 指定的文件或目录。如果出错，会返回 <code>*PathError</code> 类型的错误。如果目录不为空，<code>Remove</code> 会返回失败。</p>\n<h3 id=\"更改文件名\"><a href=\"#更改文件名\" class=\"headerlink\" title=\"更改文件名\"></a>更改文件名</h3><p>系统调用 <code>rename</code> 既可以重命名文件，又可以将文件移至同一个文件系统中的另一个目录。该系统调用既可以用于文件，也可以用于目录。相关细节，<br>请查阅相关资料。</p>\n<p>Go 中的 <code>os.Rename</code> 是对应的封装函数。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Rename</span><span class=\"params\">(oldpath, newpath <span class=\"keyword\">string</span>)</span> <span class=\"title\">error</span></span></span><br></pre></td></tr></table></figure></p>\n<p><code>Rename</code> 修改一个文件的名字或移动一个文件。如果 <code>newpath</code> 已经存在，则替换它。注意，可能会有一些个操作系统特定的限制。</p>\n<h3 id=\"使用符号链接\"><a href=\"#使用符号链接\" class=\"headerlink\" title=\"使用符号链接\"></a>使用符号链接</h3><p><code>symlink</code> 系统调用用于为指定路径名创建一个新的符号链接（想要移除符号链接，使用 <code>unlink</code>）。Go 中的 <code>os.Symlink</code> 是对应的封装函数。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Symlink</span><span class=\"params\">(oldname, newname <span class=\"keyword\">string</span>)</span> <span class=\"title\">error</span></span></span><br></pre></td></tr></table></figure></p>\n<p><code>Symlink</code> 创建一个名为 <code>newname</code> 指向 <code>oldname</code> 的符号链接。如果出错，会返回 <code>*LinkError</code> 类型的错误。</p>\n<p>由 <code>oldname</code> 所命名的文件或目录在调用时无需存在。因为即便当时存在，也无法阻止后来将其删除。这时，<code>newname</code> 成为“悬空链接”，其他系统<br>调用试图对其进行解引用操作都将错误（通常错误号是 <code>ENOENT</code>）。</p>\n<p>有时候，我们希望通过符号链接，能获取其所指向的路径名。系统调用 <code>readlink</code> 能做到，Go 的封装函数是 <code>os.Readlink</code>：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Readlink</span><span class=\"params\">(name <span class=\"keyword\">string</span>)</span> <span class=\"params\">(<span class=\"keyword\">string</span>, error)</span></span></span><br></pre></td></tr></table></figure></p>\n<p><code>Readlink</code> 获取 <code>name</code> 指定的符号链接指向的文件的路径。如果出错，会返回 <code>*PathError</code> 类型的错误。我们看看 <code>Readlink</code> 的实现。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Readlink</span><span class=\"params\">(name <span class=\"keyword\">string</span>)</span> <span class=\"params\">(<span class=\"keyword\">string</span>, error)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> <span class=\"built_in\">len</span> := <span class=\"number\">128</span>; ; <span class=\"built_in\">len</span> *= <span class=\"number\">2</span> &#123;</span><br><span class=\"line\">\t\tb := <span class=\"built_in\">make</span>([]<span class=\"keyword\">byte</span>, <span class=\"built_in\">len</span>)</span><br><span class=\"line\">\t\tn, e := fixCount(syscall.Readlink(name, b))</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> e != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"string\">\"\"</span>, &amp;PathError&#123;<span class=\"string\">\"readlink\"</span>, name, e&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> n &lt; <span class=\"built_in\">len</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">string</span>(b[<span class=\"number\">0</span>:n]), <span class=\"literal\">nil</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里之所以用循环，是因为我们没法知道文件的路径到底多长，如果 <code>b</code> 长度不够，文件名会被截断，而 <code>readlink</code> 系统调用无非分辨所返回的字<br>符串到底是经过截断处理，还是恰巧将 <code>b</code> 填满。这里采用的验证方法是分配一个更大的（两倍）<code>b</code> 并再次调用 <code>readlink</code>。</p>\n<h3 id=\"创建和移除目录\"><a href=\"#创建和移除目录\" class=\"headerlink\" title=\"创建和移除目录\"></a>创建和移除目录</h3><p><code>mkdir</code> 系统调用创建一个新目录，Go 中的 <code>os.Mkdir</code> 是对应的封装函数。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Mkdir</span><span class=\"params\">(name <span class=\"keyword\">string</span>, perm FileMode)</span> <span class=\"title\">error</span></span></span><br></pre></td></tr></table></figure></p>\n<p><code>Mkdir</code> 使用指定的权限和名称创建一个目录。如果出错，会返回 <code>*PathError</code> 类型的错误。</p>\n<p><code>name</code> 参数指定了新目录的路径名，可以是相对路径，也可以是绝对路径。如果已经存在，则调用失败并返回 <code>os.ErrExist</code> 错误。</p>\n<p><code>perm</code> 参数指定了新目录的权限。对该位掩码值的指定方式和 <code>os.OpenFile</code> 相同，也可以直接赋予八进制数值。注意，<code>perm</code> 值还将于进程掩码相<br>与（&amp;）。如果 <code>perm</code> 中设置了 sticky 位，那么将对新目录设置该权限。</p>\n<p>因为 <code>Mkdir</code> 所创建的只是路径名中的最后一部分，如果父目录不存在，创建会失败。<code>os.MkdirAll</code> 用于递归创建所有不存在的目录。</p>\n<p>建议读者阅读下 <code>os.MkdirAll</code> 的源码，了解其实现方式、技巧。</p>\n<p><code>rmdir</code> 系统调用移除一个指定的目录，目录可以是绝对路径或相对路径。在讲解 <code>unlink</code> 时，已经介绍了 Go 中的 <code>os.Remove</code>。注意，这里要求<br>目录必须为空。为了方便使用，Go 中封装了一个 <code>os.RemoveAll</code> 函数：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">RemoveAll</span><span class=\"params\">(path <span class=\"keyword\">string</span>)</span> <span class=\"title\">error</span></span></span><br></pre></td></tr></table></figure></p>\n<p><code>RemoveAll</code> 删除 <code>path</code> 指定的文件，或目录及它包含的任何下级对象。它会尝试删除所有东西，除非遇到错误并返回。如果 <code>path</code> 指定的对象不<br>存在，<code>RemoveAll</code> 会返回 <code>nil</code> 而不返回错误。</p>\n<p><code>RemoveAll</code> 的内部实现逻辑如下：</p>\n<ol>\n<li>调用 <code>Remove</code> 尝试进行删除，如果成功或返回 <code>path</code> 不存在，则直接返回 nil；</li>\n<li>调用 <code>Lstat</code> 获取 <code>path</code> 信息，以便判断是否是目录。注意，这里使用 <code>Lstat</code>，表示不对符号链接解引用；</li>\n<li>调用 <code>Open</code> 打开目录，递归读取目录中内容，执行删除操作。</li>\n</ol>\n<h3 id=\"读目录\"><a href=\"#读目录\" class=\"headerlink\" title=\"读目录\"></a>读目录</h3><p><code>POSIX</code> 与 <code>SUS</code> 定义了读取目录相关的 C 语言标准，各个操作系统提供的系统调用却不尽相同。Go 没有基于 C 语言，而是自己通过系统调用实现<br>了读目录功能。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(f *File)</span> <span class=\"title\">Readdirnames</span><span class=\"params\">(n <span class=\"keyword\">int</span>)</span> <span class=\"params\">(names []<span class=\"keyword\">string</span>, err error)</span></span></span><br></pre></td></tr></table></figure></p>\n<p><code>Readdirnames</code> 读取目录 <code>f</code> 的内容，返回一个最多有 <code>n</code> 个成员的 <code>[]string</code>，切片成员为目录中文件对象的名字，采用目录顺序。对本函数的下一<br>次调用会返回上一次调用未读取的内容的信息。</p>\n<p>如果 <code>n&gt;0</code>，<code>Readdirnames</code> 函数会返回一个最多 <code>n</code> 个成员的切片。这时，如果 <code>Readdirnames</code> 返回一个空切片，它会返回一个非 <code>nil</code> 的错<br>误说明原因。如果到达了目录 <code>f</code> 的结尾，返回值 <code>err</code> 会是 <code>io.EOF</code>。</p>\n<p>如果 <code>n&lt;=0</code>，<code>Readdirnames</code> 函数返回目录中剩余所有文件对象的名字构成的切片。此时，如果 <code>Readdirnames</code> 调用成功（读取所有内容直到结尾），<br>它会返回该切片和 <code>nil</code> 的错误值。如果在到达结尾前遇到错误，会返回之前成功读取的名字构成的切片和该错误。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(f *File)</span> <span class=\"title\">Readdir</span><span class=\"params\">(n <span class=\"keyword\">int</span>)</span> <span class=\"params\">(fi []FileInfo, err error)</span></span></span><br></pre></td></tr></table></figure></p>\n<p><code>Readdir</code> 内部会调用 <code>Readdirnames</code>，将得到的 <code>names</code> 构造路径，通过 <code>Lstat</code> 构造出 <code>[]FileInfo</code>。</p>\n<p><code>ioutil.ReadDir</code> 也可以实现类似的功能。</p>\n","site":{"data":{"navigation":{"logo":{"text":"Golang Learn","type":"link","path":"index.html"},"main":[{"text":"Golang 基础","type":"label"},{"text":"Go 环境配置","type":"link","path":"basic/env_config.html"},{"text":"包","type":"link","path":"basic/package.html"},{"text":"基础数据类型","type":"link","path":"basic/basic_data.html"},{"text":"变量","type":"link","path":"basic/var.html"},{"text":"常量","type":"link","path":"basic/constant.html"},{"text":"控制语句","type":"link","path":"basic/flow.html"},{"text":"运算符","type":"link","path":"basic/operator.html"},{"text":"作用域","type":"link","path":"basic/scope.html"},{"text":"指针","type":"link","path":"basic/pointer.html"},{"text":"数组","type":"link","path":"basic/array.html"},{"text":"切片","type":"link","path":"basic/slice.html"},{"text":"字典","type":"link","path":"basic/map.html"},{"text":"函数","type":"link","path":"basic/function.html"},{"text":"结构体","type":"link","path":"basic/struct.html"},{"text":"接口","type":"link","path":"basic/interface.html"},{"text":"面向对象","type":"link","path":"basic/oop.html"},{"text":"错误","type":"link","path":"basic/error.html"},{"text":"序列化","type":"link","path":"basic/json.html"},{"text":"反射","type":"link","path":"basic/reflect.html"},{"text":"测试","type":"link","path":"basic/test.html"},{"text":"并发编程","type":"label"},{"text":"goroutine","type":"link","path":"concurrent/goroutine.html"},{"text":"channel","type":"link","path":"concurrent/channel.html"},{"text":"同步和锁","type":"link","path":"concurrent/sync_lock.html"},{"text":"内存分配","type":"label"},{"text":"内存分配","type":"link","path":"advance/mm.html"},{"text":"垃圾回收","type":"label"},{"text":"垃圾回收","type":"link","path":"advance/gc.html"},{"text":"标准库","type":"label"},{"text":"fmt","type":"link","path":"standards/io/fmt.html"},{"text":"io","type":"link","path":"standards/io/io.html"},{"text":"ioutil","type":"link","path":"standards/io/ioutil.html"},{"text":"bufio","type":"link","path":"standards/io/bufio.html"},{"text":"os","type":"link","path":"standards/os/os.html"},{"text":"filepath","type":"link","path":"standards/os/filepath.html"},{"text":"strings","type":"link","path":"standards/text/strings.html"},{"text":"strconv","type":"link","path":"standards/text/strconv.html"},{"text":"unicode","type":"link","path":"standards/text/unicode.html"},{"text":"log","type":"link","path":"standards/log.html"},{"text":"time","type":"link","path":"standards/time.html"},{"text":"http","type":"link","path":"standards/net/http.html"},{"text":"math","type":"link","path":"standards/data/math.html"},{"text":"sort","type":"link","path":"standards/data/sort.html"},{"text":"big","type":"link","path":"standards/data/big.html"},{"text":"container","type":"link","path":"standards/data/container.html"},{"text":"sql","type":"link","path":"standards/database/sql.html"},{"text":"THEME","type":"label"},{"text":"使用文档主题","type":"link","path":"theme/theme-usage.html"},{"text":"SUPPORT AND FEEDBACK","type":"label"},{"text":"Raise an Issue on Github","type":"link","path":"https://github.com/shipengqi/golang-learn/issues/new"}]}}},"excerpt":"","more":"<h1 id=\"os\"><a href=\"#os\" class=\"headerlink\" title=\"os\"></a>os</h1><p><code>os</code> 包提供了平台无关的操作系统功能接口。例如 Linux、macOS、Windows 等系统 <code>os</code> 包提供统一的使用接口。 </p>\n<p>例子，打开一个文件并从中读取一些数据：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">file, err := os.Open(<span class=\"string\">\"file.go\"</span>) <span class=\"comment\">// For read access.</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\tlog.Fatal(err) <span class=\"comment\">// `open file.go: no such file or directory`</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"文件-I-O\"><a href=\"#文件-I-O\" class=\"headerlink\" title=\"文件 I/O\"></a>文件 I/O</h2><p>在 Go 中，文件描述符封装在 <code>os.File</code> 结构中，通过 <code>File.Fd()</code> 可以获得底层的文件描述符：<code>fd</code>。</p>\n<p>大多数程序都期望能够使用 3 种标准的文件描述符：0- 标准输入；1- 标准输出；2- 标准错误。<code>os</code> 包提供了 3 个 <code>File</code> 对象，分别<br>代表这 3 种标准描述符：<code>Stdin</code>、<code>Stdout</code> 和 <code>Stderr</code>，它们对应的文件名分别是：<code>/dev/stdin</code>、<code>/dev/stdout</code> 和 <code>/dev/stderr</code>。<br>注意，这里说的文件名，并不一定存在，比如 Windows 下就没有。</p>\n<h3 id=\"OpenFile\"><a href=\"#OpenFile\" class=\"headerlink\" title=\"OpenFile\"></a>OpenFile</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">OpenFile</span><span class=\"params\">(name <span class=\"keyword\">string</span>, flag <span class=\"keyword\">int</span>, perm FileMode)</span> <span class=\"params\">(*File, error)</span></span></span><br></pre></td></tr></table></figure>\n<p><code>OpenFile</code> 既能打开一个已经存在的文件，也能创建并打开一个新文件。</p>\n<p><code>OpenFile</code> 是一个更一般性的文件打开函数，大多数调用者都应用 <code>Open</code> 或 <code>Create</code> 代替本函数。它会使用指定的选项（如 <code>O_RDONLY</code> 等）、<br>指定的模式（如 <code>0666</code> 等）打开指定名称的文件。如果操作成功，返回的文件对象可用于 I/O。如果出错，错误底层类型是 <code>*PathError</code>。</p>\n<p>要打开的文件由参数 <code>name</code> 指定，它可以是绝对路径或相对路径（相对于进程当前工作目录），也可以是一个符号链接（会对其进行解引用）。</p>\n<p>位掩码参数 <code>flag</code> 用于指定文件的访问模式，可用的值在 <code>os</code> 中定义为常量（以下值并非所有操作系统都可用）：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">    O_RDONLY <span class=\"keyword\">int</span> = syscall.O_RDONLY <span class=\"comment\">// 只读模式打开文件</span></span><br><span class=\"line\">    O_WRONLY <span class=\"keyword\">int</span> = syscall.O_WRONLY <span class=\"comment\">// 只写模式打开文件</span></span><br><span class=\"line\">    O_RDWR   <span class=\"keyword\">int</span> = syscall.O_RDWR   <span class=\"comment\">// 读写模式打开文件</span></span><br><span class=\"line\">    O_APPEND <span class=\"keyword\">int</span> = syscall.O_APPEND <span class=\"comment\">// 写操作时将数据附加到文件尾部</span></span><br><span class=\"line\">    O_CREATE <span class=\"keyword\">int</span> = syscall.O_CREAT  <span class=\"comment\">// 如果不存在将创建一个新文件</span></span><br><span class=\"line\">    O_EXCL   <span class=\"keyword\">int</span> = syscall.O_EXCL   <span class=\"comment\">// 和 O_CREATE 配合使用，文件必须不存在</span></span><br><span class=\"line\">    O_SYNC   <span class=\"keyword\">int</span> = syscall.O_SYNC   <span class=\"comment\">// 打开文件用于同步 I/O</span></span><br><span class=\"line\">    O_TRUNC  <span class=\"keyword\">int</span> = syscall.O_TRUNC  <span class=\"comment\">// 如果可能，打开时清空文件</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>其中，<code>O_RDONLY</code>、<code>O_WRONLY</code>、<code>O_RDWR</code> 只指定一个，剩下的通过 <code>|</code> 操作符来指定。该函数内部会给 <code>flags</code> 加上 <code>syscall.O_CLOEXEC</code>，<br>在 <code>fork</code> 子进程时会关闭通过 <code>OpenFile</code> 打开的文件，即子进程不会重用该文件描述符。</p>\n<p>位掩码参数 <code>perm</code> 指定了文件的模式和权限位，类型是 <code>os.FileMode</code>，文件模式位常量定义在 <code>os</code> 中：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">    <span class=\"comment\">// 单字符是被 String 方法用于格式化的属性缩写。</span></span><br><span class=\"line\">    ModeDir        FileMode = <span class=\"number\">1</span> &lt;&lt; (<span class=\"number\">32</span> - <span class=\"number\">1</span> - <span class=\"literal\">iota</span>) <span class=\"comment\">// d: 目录</span></span><br><span class=\"line\">    ModeAppend                                     <span class=\"comment\">// a: 只能写入，且只能写入到末尾</span></span><br><span class=\"line\">    ModeExclusive                                  <span class=\"comment\">// l: 用于执行</span></span><br><span class=\"line\">    ModeTemporary                                  <span class=\"comment\">// T: 临时文件（非备份文件）</span></span><br><span class=\"line\">    ModeSymlink                                    <span class=\"comment\">// L: 符号链接（不是快捷方式文件）</span></span><br><span class=\"line\">    ModeDevice                                     <span class=\"comment\">// D: 设备</span></span><br><span class=\"line\">    ModeNamedPipe                                  <span class=\"comment\">// p: 命名管道（FIFO）</span></span><br><span class=\"line\">    ModeSocket                                     <span class=\"comment\">// S: Unix 域 socket</span></span><br><span class=\"line\">    ModeSetuid                                     <span class=\"comment\">// u: 表示文件具有其创建者用户 id 权限</span></span><br><span class=\"line\">    ModeSetgid                                     <span class=\"comment\">// g: 表示文件具有其创建者组 id 的权限</span></span><br><span class=\"line\">    ModeCharDevice                                 <span class=\"comment\">// c: 字符设备，需已设置 ModeDevice</span></span><br><span class=\"line\">    ModeSticky                                     <span class=\"comment\">// t: 只有 root/ 创建者能删除 / 移动文件</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 覆盖所有类型位（用于通过 &amp; 获取类型位），对普通文件，所有这些位都不应被设置</span></span><br><span class=\"line\">    ModeType = ModeDir | ModeSymlink | ModeNamedPipe | ModeSocket | ModeDevice</span><br><span class=\"line\">    ModePerm FileMode = <span class=\"number\">0777</span> <span class=\"comment\">// 覆盖所有 Unix 权限位（用于通过 &amp; 获取类型位）</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>以上常量在所有操作系统都有相同的含义（可用时），因此文件的信息可以在不同的操作系统之间安全的移植。不是所有的位都能用于所有的系统，<br>唯一共有的是用于表示目录的 <code>ModeDir</code> 位。</p>\n<p>以上这些被定义的位是 <code>FileMode</code> 最重要的位。另外 9 个位（权限位）为标准 Unix <code>rwxrwxrwx</code> 权限（所有人都可读、写、运行）。</p>\n<p><code>FileMode</code> 还定义了几个方法，用于判断文件类型的 <code>IsDir()</code> 和 <code>IsRegular()</code>，用于获取权限的 <code>Perm()</code>。</p>\n<p>返回的 <code>error</code>，具体实现是 <code>*os.PathError</code>，它会记录具体操作、文件路径和错误原因。</p>\n<p>另外，在 <code>OpenFile</code> 内部会调用 <code>NewFile</code>，来得到 <code>File</code> 对象。</p>\n<p><strong>使用方法</strong></p>\n<p>打开一个文件，一般通过 <code>Open</code> 或 <code>Create</code>，这两个函数的实现。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Open</span><span class=\"params\">(name <span class=\"keyword\">string</span>)</span> <span class=\"params\">(*File, error)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> OpenFile(name, O_RDONLY, <span class=\"number\">0</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Create</span><span class=\"params\">(name <span class=\"keyword\">string</span>)</span> <span class=\"params\">(*File, error)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> OpenFile(name, O_RDWR|O_CREATE|O_TRUNC, <span class=\"number\">0666</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Read\"><a href=\"#Read\" class=\"headerlink\" title=\"Read\"></a>Read</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(f *File)</span> <span class=\"title\">Read</span><span class=\"params\">(b []<span class=\"keyword\">byte</span>)</span> <span class=\"params\">(n <span class=\"keyword\">int</span>, err error)</span></span></span><br></pre></td></tr></table></figure>\n<p><code>Read</code> 方法从 <code>f</code> 中读取最多 <code>len(b)</code> 字节数据并写入 <code>b</code>。它返回读取的字节数和可能遇到的任何错误。文件终止标志是读取 0 个字节且返回<br>值 <code>err</code> 为 <code>io.EOF</code>。</p>\n<p>对比下 <code>ReadAt</code> 方法：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(f *File)</span> <span class=\"title\">ReadAt</span><span class=\"params\">(b []<span class=\"keyword\">byte</span>, off <span class=\"keyword\">int64</span>)</span> <span class=\"params\">(n <span class=\"keyword\">int</span>, err error)</span></span></span><br></pre></td></tr></table></figure></p>\n<p><code>ReadAt</code> 从指定的位置（相对于文件开始位置）读取长度为 <code>len(b)</code> 个字节数据并写入 <code>b</code>。它返回读取的字节数和可能遇到的任何错误。<br>当 <code>n&lt;len(b)</code> 时，本方法总是会返回错误；如果是因为到达文件结尾，返回值 <code>err</code> 会是 <code>io.EOF</code>。它对应的系统调用是 <code>pread</code>。</p>\n<p><strong><code>Read</code> 和 <code>ReadAt</code> 的区别</strong>：前者从文件当前偏移量处读，且会改变文件当前的偏移量；而后者从 <code>off</code> 指定的位置开始读，且<strong>不会改变</strong>文件<br>当前偏移量。</p>\n<h3 id=\"Write\"><a href=\"#Write\" class=\"headerlink\" title=\"Write\"></a>Write</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(f *File)</span> <span class=\"title\">Write</span><span class=\"params\">(b []<span class=\"keyword\">byte</span>)</span> <span class=\"params\">(n <span class=\"keyword\">int</span>, err error)</span></span></span><br></pre></td></tr></table></figure>\n<p><code>Write</code> 向文件中写入 <code>len(b)</code> 字节数据。它返回写入的字节数和可能遇到的任何错误。如果返回值 <code>n != len(b)</code>，本方法会返回一个 <strong>非 nil</strong><br> 的错误。</p>\n<p><code>Write</code> 与 <code>WriteAt</code> 的区别同 <code>Read</code> 与 <code>ReadAt</code> 的区别一样。为了方便，还提供了 <code>WriteString</code> 方法，它实际是对 <code>Write</code> 的封装。</p>\n<p>注意：<code>Write</code> 调用成功并不能保证数据已经写入磁盘，因为内核会缓存磁盘的 I/O 操作。如果希望立刻将数据写入磁盘（一般场景不建议这么做，因为会<br>影响性能），有两种办法：</p>\n<ol>\n<li>打开文件时指定 <code>os.O_SYNC</code>；</li>\n<li>调用 <code>File.Sync()</code> 方法。</li>\n</ol>\n<p>说明：<code>File.Sync()</code> 底层调用的是 <code>fsync</code> 系统调用，这会将数据和元数据都刷到磁盘；如果只想刷数据到磁盘（比如，文件大小没变，只是变了文件<br>数据），需要自己封装，调用 <code>fdatasync</code> 系统调用。（<code>syscall.Fdatasync</code>）</p>\n<h3 id=\"Close\"><a href=\"#Close\" class=\"headerlink\" title=\"Close\"></a>Close</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(f *File)</span> <span class=\"title\">Close</span><span class=\"params\">()</span> <span class=\"title\">error</span></span></span><br></pre></td></tr></table></figure>\n<p><code>close()</code> 系统调用关闭一个打开的文件描述符，并将其释放回调用进程，供该进程继续使用。当进程终止时，将自动关闭其已打开的所有文件描述符。</p>\n<p><code>os.File.Close()</code> 是对 <code>close()</code> 的封装。文件描述符是资源，Go 的 gc 是针对内存的，并不会自动回收资源，如果不关闭文件描述符，<br>长期运行的服务可能会把文件描述符耗尽。</p>\n<p>所以，通常的写法如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">file, err := os.Open(<span class=\"string\">\"/tmp/studygolang.txt\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 错误处理，一般会阻止程序往下执行</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">defer</span> file.Close()</span><br></pre></td></tr></table></figure>\n<p><strong>关于返回值 <code>error</code></strong></p>\n<p>以下两种情况会导致 <code>Close</code> 返回错误：</p>\n<ol>\n<li>关闭一个未打开的文件；</li>\n<li>两次关闭同一个文件；</li>\n</ol>\n<p>通常，不会去检查 <code>Close</code> 的错误。</p>\n<h3 id=\"Seek\"><a href=\"#Seek\" class=\"headerlink\" title=\"Seek\"></a>Seek</h3><p>对于每个打开的文件，系统内核会记录其文件偏移量，有时也将文件偏移量称为读写偏移量或指针。文件偏移量是指执行下一个 <code>Read</code> 或 <code>Write</code> 操作<br>的文件真实位置，会以相对于文件头部起始点的文件当前位置来表示。文件第一个字节的偏移量为 0。</p>\n<p>文件打开时，会将文件偏移量设置为指向文件开始，以后每次 <code>Read</code> 或 <code>Write</code> 调用将自动对其进行调整，以指向已读或已写数据后的下一个字节。因<br>此，连续的 <code>Read</code> 和 <code>Write</code> 调用将按顺序递进，对文件进行操作。</p>\n<p><code>Seek</code> 可以调整文件偏移量：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(f *File)</span> <span class=\"title\">Seek</span><span class=\"params\">(offset <span class=\"keyword\">int64</span>, whence <span class=\"keyword\">int</span>)</span> <span class=\"params\">(ret <span class=\"keyword\">int64</span>, err error)</span></span></span><br></pre></td></tr></table></figure></p>\n<p><code>Seek</code> 设置下一次读/写的位置。<code>offset</code> 为相对偏移量，而 <code>whence</code> 决定相对位置：0 为相对文件开头，1 为相对当前位置，2 为相对文件结尾。它<br>返回新的偏移量（相对开头）和可能的错误。</p>\n<p>注意：<code>Seek</code> 只是调整内核中与文件描述符相关的文件偏移量记录，并没有访问任何物理设备。</p>\n<p>一些 <code>Seek</code> 的使用例子（file 为打开的文件对象），注释说明了将文件偏移量移动到的具体位置：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">file.Seek(<span class=\"number\">0</span>, os.SEEK_SET)\t<span class=\"comment\">// 文件开始处</span></span><br><span class=\"line\">file.Seek(<span class=\"number\">0</span>, SEEK_END)\t\t<span class=\"comment\">// 文件结尾处的下一个字节</span></span><br><span class=\"line\">file.Seek(<span class=\"number\">-1</span>, SEEK_END)\t\t<span class=\"comment\">// 文件最后一个字节</span></span><br><span class=\"line\">file.Seek(<span class=\"number\">-10</span>, SEEK_CUR) \t<span class=\"comment\">// 当前位置前 10 个字节</span></span><br><span class=\"line\">file.Seek(<span class=\"number\">1000</span>, SEEK_END)\t<span class=\"comment\">// 文件结尾处的下 1001 个字节</span></span><br></pre></td></tr></table></figure>\n<p>最后一个例子在文件中会产生“空洞”。</p>\n<p><code>Seek</code> 对应系统调用 <code>lseek</code>。该系统调用并不适用于所有类型，不允许将 <code>lseek</code> 应用于管道、FIFO、socket 或 终端。</p>\n<h2 id=\"截断文件\"><a href=\"#截断文件\" class=\"headerlink\" title=\"截断文件\"></a>截断文件</h2><p><code>trucate</code> 和 <code>ftruncate</code> 系统调用将文件大小设置为 <code>size</code> 参数指定的值；Go 语言中相应的包装函数是 <code>os.Truncate</code> 和<br><code>os.File.Truncate</code>。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Truncate</span><span class=\"params\">(name <span class=\"keyword\">string</span>, size <span class=\"keyword\">int64</span>)</span> <span class=\"title\">error</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"params\">(f *File)</span> <span class=\"title\">Truncate</span><span class=\"params\">(size <span class=\"keyword\">int64</span>)</span> <span class=\"title\">error</span></span></span><br></pre></td></tr></table></figure>\n<p>如果文件当前长度大于参数 <code>size</code>，调用将丢弃超出部分，若小于参数 <code>size</code>，调用将在文件尾部添加一系列空字节或是一个文件空洞。</p>\n<p>它们之间的区别在于如何指定操作文件：</p>\n<ol>\n<li><code>Truncate</code> 以路径名称字符串来指定文件，并要求可访问该文件（即对组成路径名的各目录拥有可执行 (x) 权限），且对文件拥有写权限。<br>若文件名为符号链接，那么调用将对其进行解引用。</li>\n<li>很明显，调用 <code>File.Truncate</code> 前，需要先以可写方式打开操作文件，该方法不会修改文件偏移量。</li>\n</ol>\n<h2 id=\"文件属性\"><a href=\"#文件属性\" class=\"headerlink\" title=\"文件属性\"></a>文件属性</h2><p>文件属性，也即文件元数据。在 Go 中，文件属性具体信息通过 <code>os.FileInfo</code> 接口获取。函数 <code>Stat</code>、<code>Lstat</code> 和 <code>File.Stat</code> 可以得到该接口<br>的实例。这三个函数对应三个系统调用：<code>stat</code>、<code>lstat</code> 和 <code>fstat</code>。</p>\n<p>这三个函数的区别：</p>\n<ol>\n<li><code>stat</code> 会返回所命名文件的相关信息。</li>\n<li><code>lstat</code> 与 <code>stat</code> 类似，区别在于如果文件是符号链接，那么所返回的信息针对的是符号链接自身（而非符号链接所指向的文件）。</li>\n<li><code>fstat</code> 则会返回由某个打开文件描述符（Go 中则是当前打开文件 File）所指代文件的相关信息。</li>\n</ol>\n<p><code>Stat</code> 和 <code>Lstat</code> 无需对其所操作的文件本身拥有任何权限，但针对指定 <code>name</code>的父目录要有执行（搜索）权限。而只要 <code>File</code> 对象 <code>ok</code>，<br><code>File.Stat</code> 总是成功。</p>\n<p><code>FileInfo</code> 接口如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> FileInfo <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">    Name() <span class=\"keyword\">string</span>       <span class=\"comment\">// 文件的名字（不含扩展名）</span></span><br><span class=\"line\">    Size() <span class=\"keyword\">int64</span>        <span class=\"comment\">// 普通文件返回值表示其大小；其他文件的返回值含义各系统不同</span></span><br><span class=\"line\">    Mode() FileMode     <span class=\"comment\">// 文件的模式位</span></span><br><span class=\"line\">    ModTime() time.Time <span class=\"comment\">// 文件的修改时间</span></span><br><span class=\"line\">    IsDir() <span class=\"keyword\">bool</span>        <span class=\"comment\">// 等价于 Mode().IsDir()</span></span><br><span class=\"line\">    Sys() <span class=\"keyword\">interface</span>&#123;&#125;   <span class=\"comment\">// 底层数据来源（可以返回 nil）</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>Sys()</code> 底层数据的 C 语言 结构 <code>statbuf</code> 格式如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> stat &#123;</span><br><span class=\"line\">\tdev_t\tst_dev;\t<span class=\"comment\">// 设备 ID</span></span><br><span class=\"line\">\tino_t\tst_ino;\t<span class=\"comment\">// 文件 i 节点号</span></span><br><span class=\"line\">\tmode_t\tst_mode;\t<span class=\"comment\">// 位掩码，文件类型和文件权限</span></span><br><span class=\"line\">\tnlink_t\tst_nlink;\t<span class=\"comment\">// 硬链接数</span></span><br><span class=\"line\">\tuid_t\tst_uid;\t<span class=\"comment\">// 文件属主，用户 ID</span></span><br><span class=\"line\">\tgid_t\tst_gid;\t<span class=\"comment\">// 文件属组，组 ID</span></span><br><span class=\"line\">\tdev_t\tst_rdev;\t<span class=\"comment\">// 如果针对设备 i 节点，则此字段包含主、辅 ID</span></span><br><span class=\"line\">\toff_t\tst_size;\t<span class=\"comment\">// 常规文件，则是文件字节数；符号链接，则是链接所指路径名的长度，字节为单位；对于共享内存对象，则是对象大小</span></span><br><span class=\"line\">\tblksize_t\tst_blsize;\t<span class=\"comment\">// 分配给文件的总块数，块大小为 512 字节</span></span><br><span class=\"line\">\tblkcnt_t\tst_blocks;\t<span class=\"comment\">// 实际分配给文件的磁盘块数量</span></span><br><span class=\"line\">\ttime_t\tst_atime;\t\t<span class=\"comment\">// 对文件上次访问时间</span></span><br><span class=\"line\">\ttime_t\tst_mtime;\t\t<span class=\"comment\">// 对文件上次修改时间</span></span><br><span class=\"line\">\ttime_t\tst_ctime;\t\t<span class=\"comment\">// 文件状态发生改变的上次时间</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Go 中 <code>syscal.Stat_t</code> 与该结构对应。</p>\n<p>如果我们要获取 <code>FileInfo</code> 接口没法直接返回的信息，比如想获取文件的上次访问时间，示例如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fileInfo, err := os.Stat(<span class=\"string\">\"test.log\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\tlog.Fatal(err)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">sys := fileInfo.Sys()</span><br><span class=\"line\">stat := sys.(*syscall.Stat_t)</span><br><span class=\"line\">fmt.Println(time.Unix(stat.Atimespec.Unix()))</span><br></pre></td></tr></table></figure>\n<h3 id=\"改变文件时间戳\"><a href=\"#改变文件时间戳\" class=\"headerlink\" title=\"改变文件时间戳\"></a>改变文件时间戳</h3><p>可以显式改变文件的访问时间和修改时间。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Chtimes</span><span class=\"params\">(name <span class=\"keyword\">string</span>, atime time.Time, mtime time.Time)</span> <span class=\"title\">error</span></span></span><br></pre></td></tr></table></figure></p>\n<p><code>Chtimes</code> 修改 <code>name</code> 指定的文件对象的访问时间和修改时间，类似 Unix 的 <code>utime()</code> 或 <code>utimes()</code> 函数。底层的文件系统可能会截断/舍入<br>时间单位到更低的精确度。如果出错，会返回 <code>*PathError</code> 类型的错误。在 Unix 中，底层实现会调用 <code>utimenstat()</code>，它提供纳秒级别的精度。</p>\n<h3 id=\"文件属主\"><a href=\"#文件属主\" class=\"headerlink\" title=\"文件属主\"></a>文件属主</h3><p>每个文件都有一个与之关联的用户 ID（UID）和组 ID（GID），籍此可以判定文件的属主和属组。系统调用 <code>chown</code>、<code>lchown</code> 和 <code>fchown</code> 可用来<br>改变文件的属主和属组，Go 中对应的函数或方法：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Chown</span><span class=\"params\">(name <span class=\"keyword\">string</span>, uid, gid <span class=\"keyword\">int</span>)</span> <span class=\"title\">error</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">Lchown</span><span class=\"params\">(name <span class=\"keyword\">string</span>, uid, gid <span class=\"keyword\">int</span>)</span> <span class=\"title\">error</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"params\">(f *File)</span> <span class=\"title\">Chown</span><span class=\"params\">(uid, gid <span class=\"keyword\">int</span>)</span> <span class=\"title\">error</span></span></span><br></pre></td></tr></table></figure>\n<p>它们的区别和上文提到的 <code>Stat</code> 相关函数类似。</p>\n<h3 id=\"文件权限\"><a href=\"#文件权限\" class=\"headerlink\" title=\"文件权限\"></a>文件权限</h3><p>这里介绍是应用于文件和目录的权限方案，尽管此处讨论的权限主要是针对普通文件和目录，但其规则可适用于所有文件类型，包括设备文件、FIFO 以<br>及 Unix 域套接字等。</p>\n<h4 id=\"相关函数或方法\"><a href=\"#相关函数或方法\" class=\"headerlink\" title=\"相关函数或方法\"></a>相关函数或方法</h4><p>在文件相关操作报错时，可以通过 <code>os.IsPermission</code> 检查是否是权限的问题。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">IsPermission</span><span class=\"params\">(err error)</span> <span class=\"title\">bool</span></span></span><br></pre></td></tr></table></figure></p>\n<p>返回一个布尔值说明该错误是否表示因权限不足要求被拒绝。<code>ErrPermission</code> 和一些系统调用错误会使它返回真。</p>\n<p>另外，<code>syscall.Access</code> 可以获取文件的权限。这对应系统调用 <code>access</code>。</p>\n<h4 id=\"Sticky-位\"><a href=\"#Sticky-位\" class=\"headerlink\" title=\"Sticky 位\"></a>Sticky 位</h4><p>除了 9 位用来表明属主、属组和其他用户的权限外，文件权限掩码还另设有 3 个附加位，分别是<br><code>set-user-ID</code>(bit 04000)、<code>set-group-ID</code>(bit 02000) 和 <code>sticky</code>(bit 01000) 位。</p>\n<p>Sticky 位一般用于目录，起限制删除位的作用，表明仅当非特权进程具有对目录的写权限，且为文件或目录的属主时，才能对目录下的文件进行删除和重命名操<br>作。根据这个机制来创建为多个用户共享的一个目录，各个用户可在其下创建或删除属于自己的文件，但不能删除隶属于其他用户的文件。<code>/tmp</code> 目录就设<br>置了 sticky 位，正是出于这个原因。</p>\n<p><code>chmod</code> 命令或系统调用可以设置文件的 sticky 位。若对某文件设置了 sticky 位，则 <code>ls -l</code> 显示文件时，会在其他用户执行权限字段上看到字<br>母 t（有执行权限时） 或 T（无执行权限时）。</p>\n<p><code>os.Chmod</code> 和 <code>os.File.Chmod</code> 可以修改文件权限（包括 sticky 位），分别对应系统调用 <code>chmod</code> 和 <code>fchmod</code>。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    file, err := os.Create(<span class=\"string\">\"studygolang.txt\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        log.Fatal(<span class=\"string\">\"error:\"</span>, err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">defer</span> file.Close()</span><br><span class=\"line\"></span><br><span class=\"line\">    fileMode := getFileMode(file)</span><br><span class=\"line\">    log.Println(<span class=\"string\">\"file mode:\"</span>, fileMode)</span><br><span class=\"line\">    file.Chmod(fileMode | os.ModeSticky)</span><br><span class=\"line\"></span><br><span class=\"line\">    log.Println(<span class=\"string\">\"change after, file mode:\"</span>, getFileMode(file))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">getFileMode</span><span class=\"params\">(file *os.File)</span> <span class=\"title\">os</span>.<span class=\"title\">FileMode</span></span> &#123;</span><br><span class=\"line\">    fileInfo, err := file.Stat()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        log.Fatal(<span class=\"string\">\"file stat error:\"</span>, err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> fileInfo.Mode()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Output:</span></span><br><span class=\"line\"><span class=\"comment\">// 2016/06/18 15:59:06 file mode: -rw-rw-r--</span></span><br><span class=\"line\"><span class=\"comment\">// 2016/06/18 15:59:06 change after, file mode: trw-rw-r--</span></span><br><span class=\"line\"><span class=\"comment\">// ls -l 看到的 studygolang.tx 是：-rw-rw-r-T</span></span><br><span class=\"line\"><span class=\"comment\">// 当然这里是给文件设置了 sticky 位，对权限不起作用。系统会忽略它。</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"目录与链接\"><a href=\"#目录与链接\" class=\"headerlink\" title=\"目录与链接\"></a>目录与链接</h2><p>在 Unix 文件系统中，目录的存储方式类似于普通文件。目录和普通文件的区别有二：</p>\n<ul>\n<li>在其 <code>i-node</code> 条目中，会将目录标记为一种不同的文件类型。</li>\n<li>目录是经特殊组织而成的文件。本质上说就是一个表格，包含文件名和 <code>i-node</code> 标号。</li>\n</ul>\n<h3 id=\"创建和移除（硬）链接\"><a href=\"#创建和移除（硬）链接\" class=\"headerlink\" title=\"创建和移除（硬）链接\"></a>创建和移除（硬）链接</h3><p>硬链接是针对文件而言的，目录不允许创建硬链接。</p>\n<p><code>link</code> 和 <code>unlink</code> 系统调用用于创建和移除（硬）链接。Go 中 <code>os.Link</code> 对应 <code>link</code> 系统调用；但 <code>os.Remove</code> 的实现会先执行 <code>unlink</code><br>系统调用，如果要移除的是目录，则 <code>unlink</code> 会失败，这时 <code>Remove</code> 会再调用 <code>rmdir</code> 系统调用。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Link</span><span class=\"params\">(oldname, newname <span class=\"keyword\">string</span>)</span> <span class=\"title\">error</span></span></span><br></pre></td></tr></table></figure></p>\n<p><code>Link</code> 创建一个名为 <code>newname</code> 指向 <code>oldname</code> 的硬链接。如果出错，会返回 <code>*LinkError</code> 类型的错误。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Remove</span><span class=\"params\">(name <span class=\"keyword\">string</span>)</span> <span class=\"title\">error</span></span></span><br></pre></td></tr></table></figure></p>\n<p><code>Remove</code> 删除 <code>name</code> 指定的文件或目录。如果出错，会返回 <code>*PathError</code> 类型的错误。如果目录不为空，<code>Remove</code> 会返回失败。</p>\n<h3 id=\"更改文件名\"><a href=\"#更改文件名\" class=\"headerlink\" title=\"更改文件名\"></a>更改文件名</h3><p>系统调用 <code>rename</code> 既可以重命名文件，又可以将文件移至同一个文件系统中的另一个目录。该系统调用既可以用于文件，也可以用于目录。相关细节，<br>请查阅相关资料。</p>\n<p>Go 中的 <code>os.Rename</code> 是对应的封装函数。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Rename</span><span class=\"params\">(oldpath, newpath <span class=\"keyword\">string</span>)</span> <span class=\"title\">error</span></span></span><br></pre></td></tr></table></figure></p>\n<p><code>Rename</code> 修改一个文件的名字或移动一个文件。如果 <code>newpath</code> 已经存在，则替换它。注意，可能会有一些个操作系统特定的限制。</p>\n<h3 id=\"使用符号链接\"><a href=\"#使用符号链接\" class=\"headerlink\" title=\"使用符号链接\"></a>使用符号链接</h3><p><code>symlink</code> 系统调用用于为指定路径名创建一个新的符号链接（想要移除符号链接，使用 <code>unlink</code>）。Go 中的 <code>os.Symlink</code> 是对应的封装函数。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Symlink</span><span class=\"params\">(oldname, newname <span class=\"keyword\">string</span>)</span> <span class=\"title\">error</span></span></span><br></pre></td></tr></table></figure></p>\n<p><code>Symlink</code> 创建一个名为 <code>newname</code> 指向 <code>oldname</code> 的符号链接。如果出错，会返回 <code>*LinkError</code> 类型的错误。</p>\n<p>由 <code>oldname</code> 所命名的文件或目录在调用时无需存在。因为即便当时存在，也无法阻止后来将其删除。这时，<code>newname</code> 成为“悬空链接”，其他系统<br>调用试图对其进行解引用操作都将错误（通常错误号是 <code>ENOENT</code>）。</p>\n<p>有时候，我们希望通过符号链接，能获取其所指向的路径名。系统调用 <code>readlink</code> 能做到，Go 的封装函数是 <code>os.Readlink</code>：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Readlink</span><span class=\"params\">(name <span class=\"keyword\">string</span>)</span> <span class=\"params\">(<span class=\"keyword\">string</span>, error)</span></span></span><br></pre></td></tr></table></figure></p>\n<p><code>Readlink</code> 获取 <code>name</code> 指定的符号链接指向的文件的路径。如果出错，会返回 <code>*PathError</code> 类型的错误。我们看看 <code>Readlink</code> 的实现。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Readlink</span><span class=\"params\">(name <span class=\"keyword\">string</span>)</span> <span class=\"params\">(<span class=\"keyword\">string</span>, error)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> <span class=\"built_in\">len</span> := <span class=\"number\">128</span>; ; <span class=\"built_in\">len</span> *= <span class=\"number\">2</span> &#123;</span><br><span class=\"line\">\t\tb := <span class=\"built_in\">make</span>([]<span class=\"keyword\">byte</span>, <span class=\"built_in\">len</span>)</span><br><span class=\"line\">\t\tn, e := fixCount(syscall.Readlink(name, b))</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> e != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"string\">\"\"</span>, &amp;PathError&#123;<span class=\"string\">\"readlink\"</span>, name, e&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> n &lt; <span class=\"built_in\">len</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">string</span>(b[<span class=\"number\">0</span>:n]), <span class=\"literal\">nil</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里之所以用循环，是因为我们没法知道文件的路径到底多长，如果 <code>b</code> 长度不够，文件名会被截断，而 <code>readlink</code> 系统调用无非分辨所返回的字<br>符串到底是经过截断处理，还是恰巧将 <code>b</code> 填满。这里采用的验证方法是分配一个更大的（两倍）<code>b</code> 并再次调用 <code>readlink</code>。</p>\n<h3 id=\"创建和移除目录\"><a href=\"#创建和移除目录\" class=\"headerlink\" title=\"创建和移除目录\"></a>创建和移除目录</h3><p><code>mkdir</code> 系统调用创建一个新目录，Go 中的 <code>os.Mkdir</code> 是对应的封装函数。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Mkdir</span><span class=\"params\">(name <span class=\"keyword\">string</span>, perm FileMode)</span> <span class=\"title\">error</span></span></span><br></pre></td></tr></table></figure></p>\n<p><code>Mkdir</code> 使用指定的权限和名称创建一个目录。如果出错，会返回 <code>*PathError</code> 类型的错误。</p>\n<p><code>name</code> 参数指定了新目录的路径名，可以是相对路径，也可以是绝对路径。如果已经存在，则调用失败并返回 <code>os.ErrExist</code> 错误。</p>\n<p><code>perm</code> 参数指定了新目录的权限。对该位掩码值的指定方式和 <code>os.OpenFile</code> 相同，也可以直接赋予八进制数值。注意，<code>perm</code> 值还将于进程掩码相<br>与（&amp;）。如果 <code>perm</code> 中设置了 sticky 位，那么将对新目录设置该权限。</p>\n<p>因为 <code>Mkdir</code> 所创建的只是路径名中的最后一部分，如果父目录不存在，创建会失败。<code>os.MkdirAll</code> 用于递归创建所有不存在的目录。</p>\n<p>建议读者阅读下 <code>os.MkdirAll</code> 的源码，了解其实现方式、技巧。</p>\n<p><code>rmdir</code> 系统调用移除一个指定的目录，目录可以是绝对路径或相对路径。在讲解 <code>unlink</code> 时，已经介绍了 Go 中的 <code>os.Remove</code>。注意，这里要求<br>目录必须为空。为了方便使用，Go 中封装了一个 <code>os.RemoveAll</code> 函数：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">RemoveAll</span><span class=\"params\">(path <span class=\"keyword\">string</span>)</span> <span class=\"title\">error</span></span></span><br></pre></td></tr></table></figure></p>\n<p><code>RemoveAll</code> 删除 <code>path</code> 指定的文件，或目录及它包含的任何下级对象。它会尝试删除所有东西，除非遇到错误并返回。如果 <code>path</code> 指定的对象不<br>存在，<code>RemoveAll</code> 会返回 <code>nil</code> 而不返回错误。</p>\n<p><code>RemoveAll</code> 的内部实现逻辑如下：</p>\n<ol>\n<li>调用 <code>Remove</code> 尝试进行删除，如果成功或返回 <code>path</code> 不存在，则直接返回 nil；</li>\n<li>调用 <code>Lstat</code> 获取 <code>path</code> 信息，以便判断是否是目录。注意，这里使用 <code>Lstat</code>，表示不对符号链接解引用；</li>\n<li>调用 <code>Open</code> 打开目录，递归读取目录中内容，执行删除操作。</li>\n</ol>\n<h3 id=\"读目录\"><a href=\"#读目录\" class=\"headerlink\" title=\"读目录\"></a>读目录</h3><p><code>POSIX</code> 与 <code>SUS</code> 定义了读取目录相关的 C 语言标准，各个操作系统提供的系统调用却不尽相同。Go 没有基于 C 语言，而是自己通过系统调用实现<br>了读目录功能。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(f *File)</span> <span class=\"title\">Readdirnames</span><span class=\"params\">(n <span class=\"keyword\">int</span>)</span> <span class=\"params\">(names []<span class=\"keyword\">string</span>, err error)</span></span></span><br></pre></td></tr></table></figure></p>\n<p><code>Readdirnames</code> 读取目录 <code>f</code> 的内容，返回一个最多有 <code>n</code> 个成员的 <code>[]string</code>，切片成员为目录中文件对象的名字，采用目录顺序。对本函数的下一<br>次调用会返回上一次调用未读取的内容的信息。</p>\n<p>如果 <code>n&gt;0</code>，<code>Readdirnames</code> 函数会返回一个最多 <code>n</code> 个成员的切片。这时，如果 <code>Readdirnames</code> 返回一个空切片，它会返回一个非 <code>nil</code> 的错<br>误说明原因。如果到达了目录 <code>f</code> 的结尾，返回值 <code>err</code> 会是 <code>io.EOF</code>。</p>\n<p>如果 <code>n&lt;=0</code>，<code>Readdirnames</code> 函数返回目录中剩余所有文件对象的名字构成的切片。此时，如果 <code>Readdirnames</code> 调用成功（读取所有内容直到结尾），<br>它会返回该切片和 <code>nil</code> 的错误值。如果在到达结尾前遇到错误，会返回之前成功读取的名字构成的切片和该错误。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(f *File)</span> <span class=\"title\">Readdir</span><span class=\"params\">(n <span class=\"keyword\">int</span>)</span> <span class=\"params\">(fi []FileInfo, err error)</span></span></span><br></pre></td></tr></table></figure></p>\n<p><code>Readdir</code> 内部会调用 <code>Readdirnames</code>，将得到的 <code>names</code> 构造路径，通过 <code>Lstat</code> 构造出 <code>[]FileInfo</code>。</p>\n<p><code>ioutil.ReadDir</code> 也可以实现类似的功能。</p>\n"},{"title":"同步和锁","_content":"\n# 同步和锁\n## 共享变量\n无论任何时候，只要有两个以上 `goroutine` 并发访问同一变量，且至少其中的一个是写操作的时候就会发生数据竞争。\n避免数据竞争的三种方式：\n1. 不去写变量。读取不可能出现数据竞争。\n2. 避免从多个 `goroutine` 访问变量，尽量把变量限定在了一个单独的 `goroutine` 中。(**不要使用共享数据来通信，使用通信\n来共享数据**)\n3. 互斥锁\n\n## 同步锁\nGo 语言包中的 `sync` 包提供了两种锁类型：`sync.Mutex` 和 `sync.RWMutex`，前者是互斥锁，后者是读写锁。\n### 互斥锁\n\n#### 使用 channel 实现互斥所\n我们可以使用容量只有 `1` 的 `channel` 来保证最多只有一个 `goroutine` 在同一时刻访问一个共享变量：\n```go\nvar (\n  sema = make(chan struct{}, 1) // a binary semaphore guarding balance\n  balance int\n)\n\nfunc Deposit(amount int) {\n  sema <- struct{}{} // acquire lock\n  balance = balance + amount\n  <-sema // release lock\n}\n\nfunc Balance() int {\n  sema <- struct{}{} // acquire lock\n  b := balance\n  <-sema // release lock\n  return b\n}\n```\n\n#### sync.Mutex\n使用 `sync.Mutex` 互斥锁：\n```go\nimport \"sync\"\n\nvar (\n  mu sync.Mutex // guards balance\n  balance int\n)\n\nfunc Deposit(amount int) {\n  mu.Lock()\n  balance = balance + amount\n  mu.Unlock()\n}\n\nfunc Balance() int {\n  mu.Lock()\n  b := balance\n  mu.Unlock()\n  return b\n}\n```\n\n`mutex` 会保护共享变量，当已经有 `goroutine` 获得这个锁，再有 `goroutine` 访问这个加锁的变量就会被阻塞，\n直到持有这个锁的 `goroutine` `unlock` 这个锁。\n\n我们可以**使用 `defer` 来 `unlock` 锁，保证在函数返回之后或者发生错误返回时一定会执行 `unlock`**。\n\n### 读写锁 `sync.RWMutex`\n如果有多个 `goroutine` 读取变量，那么是并发安全的，这个时候使用 `sync.Mutex` 加锁就没有必要。可以使\n用 `sync.RWMutex` 读写锁（多读单写锁）。\n\n**读写锁是把对共享资源的“读操作”和“写操作”区别对待了。它可以对这两种操作施加不同程度的保护**。\n\n一个读写锁中实际上包含了两个锁，即：读锁和写锁。`sync.RWMutex` 类型中的 `Lock` 方法和 `Unlock` 方法分别用于对写锁进行\n锁定和解锁，而它的 `RLock` 方法和 `RUnlock` 方法则分别用于对读锁进行锁定和解锁。\n\n**对于某个受到读写锁保护的共享资源，多个写操作不能同时进行，写操作和读操作也不能同时进行，但多个读操作却可以同时进行**。\n\n```go\nvar mu sync.RWMutex\nvar balance int\nfunc Balance() int {\n  mu.RLock() // readers lock\n  defer mu.RUnlock()\n  return balance\n}\n```\n**`RLock` 只能在共享变量没有任何写入操作时可用**。\n\n**为什么只读操作也需要加锁**？\n```go\nvar x, y int\ngo func() {\n  x = 1 // A1\n  fmt.Print(\"y:\", y, \" \") // A2\n}()\ngo func() {\n  y = 1                   // B1\n  fmt.Print(\"x:\", x, \" \") // B2\n}()\n```\n\n上面的代码打印的结果可能是：\n```bash\ny:0 x:1\nx:0 y:1\nx:1 y:1\ny:1 x:1\n\n# 还可能是\nx:0 y:0\ny:0 x:0\n```\n\n为什么会有 `x:0 y:0` 这种结果，在一个 `goroutine` 中，语句的执行顺序可以保证，在声明的例子，可以保证\n执行 `x = 1` 后打印 `y:`，但是不能保证打印 `y:` 时，另一个 `goroutine` 中 `y = 1` 是否已经执行。\n\n所以可能的话，将变量限定在 `goroutine` 内部；如果是多个 `goroutine` 都需要访问的变量，使用互斥条件来访问。\n\n### 注意事项\n- 不要重复锁定互斥锁；**对一个已经被锁定的互斥锁进行锁定，是会立即阻塞当前的 `goroutine` 的**。这个 `goroutine` 所执行的流程，\n会一直停滞在调用该互斥锁的 `Lock` 方法的那行代码上。直到该互斥锁的 `Unlock`方法被调用，并且这里的锁定操作成功完成，后续的代码\n（也就是临界区中的代码）才会开始执行。这也正是互斥锁能够保护临界区的原因所在。\n- 不要忘记解锁互斥锁，必要时使用 `defer` 语句；避免重复锁定。\n- 不要对尚未锁定或者已解锁的互斥锁解锁；**解锁“读写锁中未被锁定的写锁”，会立即引发 panic**，对于其中的读锁也是如此，并且同\n样是不可恢复的。\n- 不要在多个函数之间直接传递互斥锁。一旦，你把一个互斥锁同时用在了多个地方，就必然会有更多的 `goroutine` 争用这把锁。\n这不但会让你的程序变慢，还会大大增加死锁（`deadloc`k）的可能性。\n\n所谓的**死锁**，指的就是当前程序中的主 `goroutine`，以及我们启用的那些 `goroutine` 都已经被阻塞。这些 `goroutine` 可以被统\n称为用户级的 `goroutine`。这就相当于整个程序都已经停滞不前了。\n\nGo 语言运行时系统是不允许这种情况出现的，只要它发现所有的用户级 `goroutine` 都处于等待状态，就会自行抛出一个带有如下\n信息的 panic：`fatal error: all goroutines are asleep - deadlock!`\n\n**注意，这种由 Go 语言运行时系统自行抛出的 panic 都属于致命错误，都是无法被恢复的，调用 recover 函数对它们起不到任何作用。\n也就是说，一旦产生死锁，程序必然崩溃**。\n\n**最简单、有效的方式就是让每一个互斥锁都只保护一个临界区或一组相关临界区**。\n\n## 条件变量 sync.Cond\n条件变量是基于互斥锁的，它必须有互斥锁的支撑才能发挥作用。条件变量并不是被用来保护临界区和共享资源的，它是用于协调想要访问共享\n资源的那些线程的。**当共享资源的状态发生变化时，它可以被用来通知被互斥锁阻塞的线程**。\n\n条件变量在这里的最大优势就是在效率方面的提升。当共享资源的状态不满足条件的时候，想操作它的线程再也不用循环往复地做检查了，\n只要等待通知就好了。\n\n### 条件变量怎样与互斥锁配合使用\n条件变量的初始化离不开互斥锁，并且它的方法有的也是基于互斥锁的。\n\n条件变量提供的方法有三个：等待通知（wait）、单发通知（signal）和广播通知（broadcast）。我们在利用条件变量等待通知的时候，\n需要在它基于的那个互斥锁保护下进行。而在进行单发通知或广播通知的时候，却是恰恰相反的，也就是说，需要在对应的互斥锁解锁之后\n再做这两种操作。\n\n```go\nvar mailbox uint8\nvar lock sync.RWMutex\nsendCond := sync.NewCond(&lock)\nrecvCond := sync.NewCond(lock.RLocker())\n```\n\n`lock` 是一个类型为 `sync.RWMutex` 的变量，是一个读写锁。基于这把锁，我还创建了两个代表条件变量的变量，名字分别\n叫 `sendCond` 和 `recvCond`。\n\n**`sync.Cond` 类型并不是开箱即用的。只能利用 `sync.NewCond` 函数创建它的指针值**。\n\n`lock` 变量的 `Lock` 方法和 `Unlock` 方法分别用于对其中写锁的锁定和解锁，它们与 `sendCond` 变量的含义是对应的。\n被视为对共享资源的写操作。\n\n初始化 `recvCond`这 个条件变量，我们需要的是 `lock` 变量中的读锁，`sync.RWMutex` 类型的 `RLocker` 方法可以实现这一需求。\n`lock.RLocker()`，在其内部会分别调用 `lock` 变量的 `RLock` 方法和 `RUnlock` 方法。\n\n下面是一个例子：\n`mailbox` 是一个信箱，如果在放置的时候发现信箱里还有未被取走的情报，那就不再放置，而先返回。另一方面，如果你在获取的时候发现信\n箱里没有情报，那也只能先回去了。\n\n```go\nlock.Lock()\nfor mailbox == 1 {\n    sendCond.Wait()\n}\nmailbox = 1\nlock.Unlock()\nrecvCond.Signal()\n```\n\n先调用 `lock` 变量的 `Lock` 方法。注意，这个 `Lock` 方法在这里意味的是：持有信箱上的锁，并且有打开信箱的权利，\n而不是锁上这个锁。\n\n检查 `mailbox` 变量的值是否等于 1，也就是说，要看看信箱里是不是还存有情报。如果还有情报，那么我就回家去等通知。\n\n如果信箱里没有情报，那么我就把新情报放进去，关上信箱、锁上锁，然后离开。用代码表达出来就是 `mailbox = 1` 和 `lock.Unlock()`。\n然后发通知，“信箱里已经有新情报了”，我们调用 `recvCond` 的 `Signal` 方法就可以实现这一步骤。\n\n另一方面，你现在是另一个 `goroutine`，想要适时地从信箱中获取情报，然后通知我。\n```go\nlock.RLock()\nfor mailbox == 0 {\n    recvCond.Wait()\n}\nmailbox = 0\nlock.RUnlock()\nsendCond.Signal()\n```\n事情在流程上其实基本一致，只不过每一步操作的对象是不同的。\n\n**为什么先要锁定条件变量基于的互斥锁，才能调用它的 Wait 方法？**\n\n`Wait` 方法主要做了四件事。\n\n1. 把调用它的 `goroutine`（也就是当前的 `goroutine`）加入到当前条件变量的通知队列中。\n2. 解锁当前的条件变量基于的那个互斥锁。\n3. 让当前的 `goroutine` 处于等待状态，等到通知到来时再决定是否唤醒它。此时，这个 `goroutine` 就会阻塞在调用这\n个 `Wait` 方法的那行代码上。\n4. 如果通知到来并且决定唤醒这个 `goroutine`，那么就在唤醒它之后重新锁定当前条件变量基于的互斥锁。自此之后，当前\n的 `goroutine` 就会继续执行后面的代码了。\n\n因为条件变量的 `Wait` 方法在阻塞当前的 `goroutine` 之前会解锁它基于的互斥锁，所以在调用该 `Wait` 方法之前我们必须先\n锁定那个互斥锁，否则在调用这个 `Wait` 方法时，就会引发一个不可恢复的 panic。\n\n为什么条件变量的 `Wait` 方法要这么做呢？你可以想象一下，如果 `Wait` 方法在互斥锁已经锁定的情况下，阻塞了当前的 `goroutine`，\n那么又由谁来解锁呢？别的 `goroutine` 吗？\n\n先不说这违背了互斥锁的重要使用原则，即：成对的锁定和解锁，就算别的 `goroutine` 可以来解锁，那万一解锁重复了怎么办？\n由此引发的 panic 可是无法恢复的。\n\n如果当前的 `goroutine` 无法解锁，别的 `goroutine` 也都不来解锁，那么又由谁来进入临界区，并改变共享资源的状态呢？只要共享资源\n的状态不变，即使当前的 `goroutine` 因收到通知而被唤醒，也依然会再次执行这个 `Wait` 方法，并再次被阻塞。\n\n所以说，如果条件变量的 `Wait` 方法不先解锁互斥锁的话，那么就只会造成两种后果：不是当前的程序因 panic 而崩溃，就是相关的\n `goroutine` 全面阻塞。\n\n**为什么要用 `for` 语句来包裹调用其 `Wait` 方法的表达式，用 `if` 语句不行吗？**\n\n`if` 语句只会对共享资源的状态检查一次，而 `for` 语句却可以做多次检查，直到这个状态改变为止。\n\n那为什么要做多次检查呢？\n\n为了保险起见。如果一个 `goroutine` 因收到通知而被唤醒，但却发现共享资源的状态，依然不符合它的要求，那么就应该再次调用\n条件变量的 `Wait` 方法，并继续等待下次通知的到来。\n\n这种情况是很有可能发生的。\n\n### 条件变量的 `Signal` 方法和 `Broadcast` 方法有哪些异同\n条件变量的 `Signal` 方法和 `Broadcast` 方法都是被用来发送通知的，不同的是，前者的通知只会唤醒一个因此而等待的 `goroutine`，\n而后者的通知却会唤醒所有为此等待的 `goroutine`。\n\n条件变量的 `Wait` 方法总会把当前的 `goroutine` 添加到通知队列的队尾，而它的 `Signal` 方法总会从通知队列的队首开始查找可被\n唤醒的 `goroutine`。所以，因 `Signal` 方法的通知而被唤醒的 `goroutine` 一般都是最早等待的那一个。\n\n## 原子操作\nGo 语言的原子操作当然是基于 CPU 和操作系统的，所以它也只针对少数数据类型的值提供了原子操作函数。这些函数都存在于标准库代\n码包 `sync/atomic` 中。\n\n`sync/atomic` 包中的函数可以做的原子操作有：加法（add）、比较并交换（compare and swap，简称 CAS）、加载（load）、\n存储（store）和交换（swap）。\n\n这些函数针对的数据类型并不多。对这些类型中的每一个，`sync/atomic` 包都会有一套函数给予支持。这些数据类型有：\n`int32`、`int64`、`uint32`、`uint64`、`uintptr`，以及 `unsafe` 包中的 `Pointer`。不过，针对 \n`unsafe.Pointer` 类型，该包并未提供进行原子加法操作的函数。\n\n`sync/atomic` 包还提供了一个名为 `Value` 的类型，它可以被用来存储任意类型的值。\n\n`atomic.AddInt32` 函数的第一个参数，为什么不是 `int32` 而是 `*int32` 呢？\n因为**原子操作函数需要的是被操作值的指针，而不是这个值本身**；被传入函数的参数值都会被复制，像这种基本类型的值一旦被传入函数，\n就已经与函数外的那个值毫无关系了。\n\n所以，传入值本身没有任何意义。`unsafe.Pointer` 类型虽然是指针类型，但是那些原子操作函数要操作的是这个指针值，而不是它指向\n的那个值，所以需要的仍然是指向这个指针值的指针。\n\n只要原子操作函数拿到了被操作值的指针，就可以定位到存储该值的内存地址。只有这样，它们才能够通过底层的指令，准确地操作这个内\n存地址上的数据。\n\n## 比较并交换操作与交换操作相比有什么不同\n**比较并交换操作即 CAS 操作**，是有条件的交换操作，**只有在条件满足的情况下才会进行值的交换**。\n\n**所谓的交换指的是，把新值赋给变量，并返回变量的旧值**。\n\nCAS 操作用途要更广泛一些。例如，我们将它与 `for` 语句联用就可以实现一种简易的自旋锁（spinlock）。\n```go\nfor {\n    if atomic.CompareAndSwapInt32(&num2, 10, 0) {\n        fmt.Println(\"The second number has gone to zero.\")\n        break\n    }\n    time.Sleep(time.Millisecond * 500)\n}\n```\n在 `for` 语句中的 CAS 操作可以不停地检查某个需要满足的条件，一旦条件满足就退出 `for` 循环。这就相当于，只要条件未被满足，\n当前的流程就会被一直“阻塞”在这里。\n\n这在效果上与互斥锁有些类似。不过，它们的适用场景是不同的。我们在使用互斥锁的时候，总是假设共享资源的状态会被其他\n的 `goroutine` 频繁地改变。\n\n而 `for` 语句加 CAS 操作的假设往往是：共享资源状态的改变并不频繁，或者，它的状态总会变成期望的那样。这是一种更加乐观，\n或者说更加宽松的做法。\n\n**假设我已经保证了对一个变量的写操作都是原子操作，比如：加或减、存储、交换等等，那我对它进行读操作的时候，还有必要使用原\n子操作吗**？\n\n很有必要。其中的道理你可以对照一下读写锁。为什么在读写锁保护下的写操作和读操作之间是互斥的？这是为了防止读操作读到没有\n被修改完的值，对吗？\n\n如果写操作还没有进行完，读操作就来读了，那么就只能读到仅修改了一部分的值。这显然破坏了值的完整性，读出来的值也是完全错误的。\n\n所以，一旦你决定了要对一个共享资源进行保护，那就要做到完全的保护。不完全的保护基本上与不保护没有什么区别。\n\n## `sync/atomic.Value`\n此类型的值相当于一个容器，可以被用来“原子地”存储和加载任意的值。开箱即用。\n\n它只有两个指针方法—— `Store` 和 `Load`。不过，虽然简单，但还是有一些值得注意的地方的。\n\n1. 一旦 `atomic.Value` 类型的值（以下简称原子值）被真正使用，它就不应该再被复制了。只要用它来存储值了，就相当于开始真正使用了。\n`atomic.Value` 类型属于结构体类型，而结构体类型属于值类型。所以，复制该类型的值会产生一个完全分离的新值。这个新值相当于被\n复制的那个值的一个快照。之后，不论后者存储的值怎样改变，都不会影响到前者。\n2. 不能用原子值存储 `nil`。\n3. 我们向原子值存储的第一个值，决定了它今后能且只能存储哪一个类型的值。\n4. 尽量不要向原子值中存储引用类型的值。因为这很容易造成安全漏洞。\n\n```go\nvar box6 atomic.Value\nv6 := []int{1, 2, 3}\nbox6.Store(v6)\nv6[1] = 4 // 注意，此处的操作不是并发安全的！\n```\n切片类型属于引用类型。所以，我在外面改动这个切片值，就等于修改了 `box6` 中存储的那个值。这相当于绕过了原子值而进行了非并发\n安全的操作。怎样修补：\n```go\nstore := func(v []int) {\n    replica := make([]int, len(v))\n    copy(replica, v)\n    box6.Store(replica)\n}\nstore(v6)\nv6[2] = 5 // 此处的操作是安全的。\n```\n\n先为切片值 `v6` 创建了一个完全的副本。这个副本涉及的数据已经与原值毫不相干了。然后，我再把这个副本存入 `box6`。如此一来，\n无论我再对 `v6` 的值做怎样的修改，都不会破坏 `box6` 提供的安全保护。\n\n## sync.WaitGroup\n在一些场合下里，我们使用通道的方式看起来都似乎有些蹩脚。比如：声明一个通道，使它的容量与我们手动启用的 `goroutine` 的数量相同。\n之后利用这个通道，让主 `goroutine` 等待其他 `goroutine` 的运行结束。更具体地说就是：让其他的 `goroutine` 在运行结束之前，\n都向这个通道发送一个元素值，并且，让主 `goroutine` 在最后从这个通道中接收元素值，接收的次数需要与其他的 `goroutine` 的数量相同。\n\n```go\nfunc coordinateWithChan() {\n    sign := make(chan struct{}, 2)\n    num := int32(0)\n    fmt.Printf(\"The number: %d [with chan struct{}]\\n\", num)\n    max := int32(10)\n    go addNum(&num, 1, max, func() {\n        sign <- struct{}{}\n    })\n    go addNum(&num, 2, max, func() {\n        sign <- struct{}{}\n    })\n    <-sign\n    <-sign\n}\n```\n`coordinateWithChan` 函数中最后的那两行代码了吗？重复的两个接收表达式 `<-sign`，很丑陋。\n我们可以选用另外一个同步工具，即：`sync` 包的 `WaitGroup` 类型。它比通道更加适合实现这种一对多的 `goroutine` 协作流程。\n\n`sync.WaitGroup` 类型（以下简称 `WaitGroup` 类型）是开箱即用的，也是并发安全的。\n\n`WaitGroup` 类型拥有三个指针方法：`Add`、`Done` 和 `Wait`。**你可以想象该类型中有一个计数器，它的默认值是 `0`。我们可\n以通过调用该类型值的 `Add` 方法来增加，或者减少这个计数器的值**。\n\n**一般情况下，我会用这个方法来记录需要等待的 `goroutine` 的数量。相对应的，这个类型的 `Done` 方法，用于对其所属值中计数器\n的值进行减一操作**。我们可以在需要等待的 `goroutine` 中，通过 `defer` 语句调用它。\n\n而**此类型的 `Wait` 方法的功能是，阻塞当前的 `goroutine`，直到其所属值中的计数器归零**。\n\n改造版本：\n```go\nfunc coordinateWithWaitGroup() {\n\tvar wg sync.WaitGroup\n\twg.Add(2)\n\tnum := int32(0)\n\tfmt.Printf(\"The number: %d [with sync.WaitGroup]\\n\", num)\n\tmax := int32(10)\n\tgo addNum(&num, 3, max, wg.Done)\n\tgo addNum(&num, 4, max, wg.Done)\n\twg.Wait()\n}\n```\n\n**尽量不要在 `go` 函数内部调用 `Add`，以免 `Add` 还未执行，`Wait` 已经退出**：\n```go\nvar wg sync.WaitGroup\ngo func(){\n\twg.Add(1)\n\tfmt.Println(\"test\")\n}()\n\nwg.Wait()\nfmt.Println(\"exit.\")\n```\n\n### sync.WaitGroup 类型值中计数器的值可以小于 0 吗\n不可以。**小于 0，会引发一个 panic**。\n\n**`WaitGroup` 值是可以被复用的，但需要保证其计数周期的完整性**。这里的计数周期指的是这样一个过程：该值中的计数器值由 0 变为\n了某个正整数，而后又经过一系列的变化，最终由某个正整数又变回了 0。\n\n如果在一个此类值的 `Wait` 方法被执行期间，跨越了两个计数周期，那么就会引发一个 panic。\n\n### 使用注意\n- 不要把增加其计数器值的操作和调用其 `Wait` 方法的代码，放在不同的 `goroutine` 中执行。换句话说，要**杜绝对同一个 \n`WaitGroup` 值的两种操作的并发执行**。\n\n## sync.Once\n\n与 `sync.WaitGroup` 类型一样，`sync.Once` 类型（以下简称 `Once` 类型）也属于结构体类型，同样也是开箱即用和并发安全的。\n由于这个类型中包含了一个 `sync.Mutex` 类型的字段，所以，复制该类型的值也会导致功能的失效。\n\n```go\nvar loadIconsOnce sync.Once\nvar icons map[string]image.Image\n// Concurrency-safe.\nfunc Icon(name string) image.Image {\n  loadIconsOnce.Do(loadIcons)\n  return icons[name]\n}\n```\n`Once` 类型的 `Do` 方法只接受一个参数，这个参数的类型必须是 `func()`，即：无参数声明和结果声明的函数。该方法的功能并\n不是对每一种参数函数都只执行一次，而是只**执行“首次被调用时传入的”那个函数，并且之后不会再执行任何参数函数**。\n\n所以，**如果你有多个只需要执行一次的函数，那么就应该为它们中的每一个都分配一个 `sync.Once` 类型的值**（以下简称 `Once` 值）。\n\n`Once` 类型中还有一个名叫 `done` 的 `uint32` 类型的字段。**它的作用是记录其所属值的 `Do` 方法被调用的次数。不过，该字段的值\n只可能是 0 或者 1。一旦 `Do` 方法的首次调用完成，它的值就会从 0 变为 1**。\n\n**既然 `done` 字段的值不是 0 就是 1，那为什么还要使用需要四个字节的 `uint32` 类型呢**？\n\n原因很简单，因为对它的操作必须是“原子”的。`Do` 方法在一开始就会通过调用 `atomic.LoadUint32` 函数来获取该字段的值，并且一旦\n发现该值为 1 就会直接返回。这也初步保证了“`Do` 方法，只会执行首次被调用时传入的函数”。\n\n### Do 方法在功能方面的两个特点\n- 由于 `Do` 方法只会在参数函数执行结束之后把 `done` 字段的值变为 1，因此，如果参数函数的执行需要很长时间或者根本就不会结束\n（比如执行一些守护任务），那么就有可能会导致相关 `goroutine` 的同时阻塞\n- `Do` 方法在参数函数执行结束后，对 `done` 字段的赋值用的是原子操作，并且，这一操作是被挂在 `defer` 语句中的。因此，不论参数\n函数的执行会以怎样的方式结束，`done` 字段的值都会变为 1。\n\n## context.Context 类型\n使用 `WaitGroup` 值的时候，我们最好用**先统一 `Add`，再并发 `Done`，最后 `Wait`** 的标准模式来构建协作流程。如果在调用\n该值的 `Wait` 方法的同时，为了增大其计数器的值，而并发地调用该值的 `Add` 方法，那么就很可能会引发 panic。\n\n但是**如果，我们不能在一开始就确定执行子任务的 `goroutine` 的数量，那么使用 `WaitGroup` 值来协调它们和分发子任\n务的 `goroutine`，就是有一定风险的**。一个解决方案是：**分批地启用执行子任务的 `goroutine`**。\n\n只要我们在严格遵循上述规则的前提下，分批地启用执行子任务的 `goroutine`，就肯定不会有问题。\n```go\nfunc coordinateWithWaitGroup() {\n    total := 12\n    stride := 3\n    var num int32\n    fmt.Printf(\"The number: %d [with sync.WaitGroup]\\n\", num)\n    var wg sync.WaitGroup\n    for i := 1; i <= total; i = i + stride {\n        wg.Add(stride)\n        for j := 0; j < stride; j++ {\n            go addNum(&num, i+j, wg.Done)\n        }\n        wg.Wait()\n    }\n    fmt.Println(\"End.\")\n}\n```\n\n### 使用 `context` 包中的程序实体，实现一对多的 goroutine 协作流程\n用 `context` 包中的函数和 `Context` 类型作为实现工具，实现 `coordinateWithContext` 的函数。这个函数应该具有上\n面 `coordinateWithWaitGroup` 函数相同的功能。\n```go\nfunc coordinateWithContext() {\n\ttotal := 12\n\tvar num int32\n\tfmt.Printf(\"The number: %d [with context.Context]\\n\", num)\n\tcxt, cancelFunc := context.WithCancel(context.Background())\n\tfor i := 1; i <= total; i++ {\n\t\tgo addNum(&num, i, func() {\n\t\t\tif atomic.LoadInt32(&num) == int32(total) {\n\t\t\t\tcancelFunc()\n\t\t\t}\n\t\t})\n\t}\n\t<-cxt.Done()\n\tfmt.Println(\"End.\")\n}\n```\n先后调用了 `context.Background` 函数和 `context.WithCancel` 函数，并得到了一个可撤销的 `context.Context` 类型的值\n（由变量 `cxt` 代表），以及一个 `context.CancelFunc`类型的撤销函数（由变量 `cancelFunc` 代表）。\n\n注意我给予 `addNum` 函数的最后一个参数值。它是一个匿名函数，其中只包含了一条 `if` 语句。这条 `if` 语句会**原子地**加载\n `num` 变量的值，并判断它是否等于 `total` 变量的值。\n\n如果两个值相等，那么就调用 `cancelFunc` 函数。其含义是，如果所有的 `addNum` 函数都执行完毕，那么就立即通知分发子任务\n的 `goroutine`。\n\n**这里分发子任务的 `goroutine`，即为执行 `coordinateWithContext` 函数的 `goroutine`**。它在执行完 `for` 语句后，会\n立即调用 `cxt` 变量的 `Done` 函数，并试图针对该函数返回的通道，进行接收操作。\n\n一旦 `cancelFunc` 函数被调用，针对该通道的接收操作就会马上结束，所以，这样做就可以实现“等待所有的 `addNum` 函数都执\n行完毕”的功能。\n\n### context.Context 类型\n`Context` 类型的值（以下简称 `Context` 值）是可以繁衍的，这意味着我们可以通过一个 `Context` 值产生出任意个子值。这些子值\n可以携带其父值的属性和数据，也可以响应通过其父值传达的信号。\n\n正因为如此，所有的 `Context` 值共同构成了一颗代表了上下文全貌的树形结构。这棵树的**树根（或者称上下文根节点）是一个已经\n在 `context` 包中预定义好的 `Context` 值**，它是**全局唯一**的。通过调用 `context.Background` 函数，我们就可以获取到\n它（在 `coordinateWithContext` 函数中就是这么做的）。\n\n注意一下，这个**上下文根节点仅仅是一个最基本的支点，它不提供任何额外的功能**。也就是说，它既不可以被撤销（`cancel`），\n也不能携带任何数据。\n\n`context` 包中还包含了**四个用于繁衍 `Context` 值的函数，即：`WithCancel`、`WithDeadline`、`WithTimeout` 和 `WithValue`**。\n\n这些函数的第一个参数的类型都是 `context.Context`，而名称都为 `parent`。顾名思义，**这个位置上的参数对应的都是它们将会产生\n的 `Context` 值的父值**。\n\n**`WithCancel` 函数用于产生一个可撤销的 parent 的子值**。\n\n在 `coordinateWithContext` 函数中，通过调用该函数，获得了一个衍生自上下文根节点的 `Context` 值，和一个用于触发撤销信号的函数。\n\n`WithDeadline` 函数和 `WithTimeout` 函数则都可以被用来产生一个会**定时撤销**的 `parent` 的子值。至于 `WithValue` 函数，\n我们可以通过调用它，产生一个会携带额外数据的 `parent` 的子值。\n\n### “可撤销的”在 context 包中代表着什么？“撤销”一个 Context 值又意味着什么？\n\n这需要从 `Context` 类型的声明讲起。这个接口中有两个方法与“撤销”息息相关。`Done` 方法会返回一个元素类型为 `struct{}` 的接\n收通道。不过，这个接收通道的用途并不是传递元素值，而是**让调用方去感知“撤销”当前Context值的那个信号**。\n\n一旦当前的 `Context` 值被撤销，这里的接收通道就会被立即关闭。我们都知道，对于一个未包含任何元素值的通道来说，它的关闭会\n使任何针对它的接收操作立即结束。\n\n正因为如此，在 `coordinateWithContext` 函数中，基于调用表达式 `cxt.Done()` 的接收操作，才能够起到感知撤销信号的作用。\n\n### 撤销信号是如何在上下文树中传播的\n\n`context`包的 `WithCancel` 函数在被调用后会产生两个结果值。第一个结果值就是那个可撤销的 `Context` 值，而第二个结果值则是\n用于触发撤销信号的函数。\n\n在撤销函数被调用之后，对应的 `Context` 值会先关闭它内部的接收通道，也就是它的 `Done` 方法会返回的那个通道。\n\n然后，它会向它的所有子值（或者说子节点）传达撤销信号。这些子值会如法炮制，把撤销信号继续传播下去。最后，这个 `Context` 值会\n断开它与其父值之间的关联。\n\n**通过调用 `context.WithValue` 函数得到的 `Context` 值是不可撤销的**。\n\n### 怎样通过 Context 值携带数据\n\n**`WithValue` 函数在产生新的 `Context` 值（以下简称含数据的 `Context` 值）的时候需要三个参数，即：父值、键和值**。\n“字典对于键的约束”类似，这里**键的类型必须是可判等**的。\n\n原因很简单，当我们从中获取数据的时候，它需要根据给定的键来查找对应的值。不过，这种 `Context` 值并不是用字典来存储键和值的，\n后两者只是被简单地存储在前者的相应字段中而已。\n\n## 临时对象池 sync.Pool\n Go 语言标准库中最重要的那几个同步工具，这包括:\n - 互斥锁\n - 读写锁\n - 条件变量\n - 原子操作\n - `sync/atomic.Value`\n - `sync.Once`\n - `sync.WaitGroup`\n - `context.Context`\n\nGo 语言标准库中的还有另一个同步工具：`sync.Pool`。\n\n`sync.Pool` 类型可以被称为临时对象池，它的值可以被用来存储临时的对象。与 Go 语言的很多同步工具一样，`sync.Pool` 类型也属\n于结构体类型，它的值在被真正使用之后，就不应该再被复制了。\n\n**临时对象**的意思是：不需要持久使用的某一类值。这类值对于程序来说可有可无，但如果有的话会明显更好。它们的创建和销毁可以在\n任何时候发生，并且完全不会影响到程序的功能。\n\n**我们可以把临时对象池当作针对某种数据的缓存来用**。\n\n`sync.Pool` 类型只有两个方法——`Put` 和 `Get`。前者用于在当前的池中存放临时对象，它接受一个 `interface{}` 类型的参数；\n而后者则被用于从当前的池中获取临时对象，它会返回一个 `interface{}` 类型的值。\n\n更具体地说，**这个类型的 `Get` 方法可能会从当前的池中删除掉任何一个值，然后把这个值作为结果返回。如果此时当前的池中没有任何值，\n那么这个方法就会使用当前池的 `New` 字段创建一个新值，并直接将其返回**。\n\n`sync.Pool` 类型的 `New` 字段代表着创建临时对象的函数。它的类型是没有参数但有唯一结果的函数类型，即：`func() interface{}`。\n**初始化这个池的时候最好给定它**。\n\n这个函数是 `Get` 方法最后的临时对象获取手段。`Get` 方法如果到了最后，仍然无法获取到一个值，那么就会调用该函数。该函数的结\n值并不会被存入当前的临时对象池中，而是直接返回给 `Get` 方法的调用方。\n\n**临时对象池中存储的每一个值都应该是独立的、平等的和可重用的**。`sync.Pool` 的定位不是做类似连接池的东西，它的用途仅仅是增加\n对象重用的几率，减少 gc 的负担。因为 gc 带来了编程的方便但同时也增加了运行时开销，使用不当甚至会严重影响程序的性能。因此性能\n要求高的场景不能任意产生太多的垃圾。如何解决呢？那就是要重用对象了。\n\n一个比较好的例子是 `fmt` 包，`fmt` 包总是需要使用一些 `[]byte` 之类的对象，golang 建立了一个临时对象池，存放着这些对象，\n如果需要使用一个 `[]byte`，就去 `Pool` 里面拿，如果拿不到就分配一份。这比起不停生成新的 `[]byte`，用完了再等待 gc 回收\n来要高效得多。\n\n`sync.Pool` 缓存对象的期限是很诡异的，先看一下 `src/pkg/sync/pool.go` 里面的一段实现代码：\n```go\nfunc init() {\n    runtime_registerPoolCleanup(poolCleanup)\n}\n```\n\n可以看到 `pool` 包在 `init` 的时候注册了一个 `poolCleanup` 函数，它会清除所有的 `pool` 里面的所有缓存的对象，该函数注册进去\n之后会在每次 gc 之前都会调用，因此 **`sync.Pool` 缓存的期限只是两次gc之间这段时间**。\n\n## sync.Map\nGo 语言自带的字典类型 `map` 并不是并发安全的。换句话说，在同一时间段内，让不同 goroutine 中的代码，对同一个字典进行读写操\n作是不安全的。\n\nGo 语言官方终于在 2017 年发布的 Go 1.9 中正式加入了并发安全的字典类型 `sync.Map`。\n\n使用 `sync.Map` 可以显著地减少锁的争用。`sync.Map` 本身虽然也用到了锁，但是，它其实在尽可能地避免使用锁。\n\n**使用锁就意味着要把一些并发的操作强制串行化。这往往会降低程序的性能，尤其是在计算机拥有多个 CPU 核心的情况下**。\n\n由于**并发安全字典内部使用的存储介质正是原生字典，又因为它使用的原生字典键类型也是可以包罗万象的 `interface{}`，所以，\n我们绝对不能带着任何实际类型为函数类型、字典类型或切片类型的键值去操作并发安全字典**。\n\n因为**这些键值的实际类型只有在程序运行期间才能够确定，所以 Go 语言编译器是无法在编译期对它们进行检查的，不正确的键值实际类\n型肯定会引发 panic**。\n\n**因此，我们在这里首先要做的一件事就是：一定不要违反上述规则。我们应该在每次操作并发安全字典的时候，都去显式地检查键值的实际\n类型。无论是存、取还是删，都应该如此**。\n\n> **更好的做法是，把针对同一个并发安全字典的这几种操作都集中起来，然后统一地编写检查代码。除此之外，把并发安全字典封装在一\n个结构体类型中，往往是一个很好的选择**。如果你实在拿不准，那么可以先通过调用 `reflect.TypeOf` 函数得到一个键值对应的反射类\n型值（即：`reflect.Type` 类型的值），然后再调用这个值的 `Comparable` 方法，得到确切的判断结果。\n\n### 并发安全字典如何做到尽量避免使用锁\n`sync.Map` 类型在内部使用了**大量的原子操作来存取键和值，并使用了两个原生的 map 作为存储介质**。\n\n其中一个原生 map 被存在了 `sync.Map` 的 `read` 字段中，该字段是 `sync/atomic.Value` 类型的。简称它为**只读字典**。\n\n**只读字典虽然不会增减其中的键，但却允许变更其中的键所对应的值**。所以，它并不是传统意义上的快照，它的只读特性只是对于其中键\n的集合而言的。\n\n由 `read` 字段的类型可知，`sync.Map` 在替换只读字典的时候根本用不着锁。另外，这个只读字典在存储键值对的时候，还在值之上\n封装了一层。\n\n它先把值转换为了 `unsafe.Pointer` 类型的值，然后再把后者封装，并储存在其中的原生字典中。如此一来，在变更某个键所对应的值\n的时候，就也可以使用原子操作了。\n\n`sync.Map` 中的另一个原生字典由它的 `dirty` 字段代表。它存储键值对的方式与 `read` 字段中的原生字典一致，它的键类型\n也是 `interface{}`，并且同样是把值先做转换和封装后再进行储存的。称为**脏字典**。\n\n> 脏字典和只读字典如果都存有同一个键值对，那么这里的两个键指的肯定是同一个基本值，对于两个值来说也是如此。正如前文所述，\n这两个字典在存储键和值的时候都只会存入它们的某个指针，而不是基本值。\n\n`sync.Map` 在查找指定的键所对应的值的时候，总会先去只读字典中寻找，并不需要锁定互斥锁。只有当确定**只读字典中没有，但脏\n字典中可能会有这个键**的时候，它才会在锁的保护下去访问脏字典。\n\n相对应的，`sync.Map` 在存储键值对的时候，只要只读字典中已存有这个键，并且该键值对未被标记为“已删除”，就会把新值存到里面并\n直接返回，这种情况下也不需要用到锁。\n\n否则，它才会在锁的保护下把键值对存储到脏字典中。这个时候，该键值对的“已删除”标记会被抹去。\n\n只有当一个键值对应该被删除，但却仍然存在于只读字典中的时候，才会被用标记为“已删除”的方式进行逻辑删除，而不会直接被物理删除。\n这种情况会在重建脏字典以后的一段时间内出现。不过，过不了多久，它们就会被真正删除掉。在查找和遍历键值对的时候，已被逻\n辑删除的键值对永远会被无视。\n\n最后，`sync.Map` 会把该键值对中指向值的那个指针置为 `nil` ，这是另一种逻辑删除的方式。\n\n除此之外，还有一个细节需要注意，只读字典和脏字典之间是会互相转换的。在脏字典中查找键值对次数足够多的时候，`sync.Map` 会把\n脏字典直接作为只读字典，保存在它的 `read` 字段中，然后把代表脏字典的 `dirty` 字段的值置为 `nil`。\n\n在这之后，一旦再有新的键值对存入，它就会依据只读字典去重建脏字典。这个时候，它会把只读字典中已被逻辑删除的键值对过滤掉。\n理所当然，这些转换操作肯定都需要在锁的保护下进行。\n\n**`sync.Map` 的只读字典和脏字典中的键值对集合并不是实时同步的，它们在某些时间段内可能会有不同**。\n\n可以看出，在读操作有很多但写操作却很少的情况下，并发安全字典的性能往往会更好。在几个写操作当中，新增键值对的操作对并发安\n全字典的性能影响是最大的，其次是删除操作，最后才是修改操作。\n\n如果被操作的键值对已经存在于 `sync.Map` 的只读字典中，并且没有被逻辑删除，那么修改它并不会使用到锁，对其性能的影响就会很小。\n\n## 竞争检查器\n在 `go build`，`go run` 或者 `go test` 命令后面加上 `-race`，就会使编译器创建一个你的应用的“修改”版。\n\n会记录下每一个读或者写共享变量的 `goroutine` 的身份信息。记录下所有的同步事件，比如 `go` 语句，`channel` 操作，\n以及对 `(*sync.Mutex).Lock`，`(*sync.WaitGroup).Wait` 等等的调用。\n\n由于需要额外的记录，因此构建时加了竞争检测的程序跑起来会慢一些，且需要更大的内存，即使是这样，这些代价对于很多生产环境的\n工作来说还是可以接受的。","source":"concurrent/sync_lock.md","raw":"---\ntitle: 同步和锁\n---\n\n# 同步和锁\n## 共享变量\n无论任何时候，只要有两个以上 `goroutine` 并发访问同一变量，且至少其中的一个是写操作的时候就会发生数据竞争。\n避免数据竞争的三种方式：\n1. 不去写变量。读取不可能出现数据竞争。\n2. 避免从多个 `goroutine` 访问变量，尽量把变量限定在了一个单独的 `goroutine` 中。(**不要使用共享数据来通信，使用通信\n来共享数据**)\n3. 互斥锁\n\n## 同步锁\nGo 语言包中的 `sync` 包提供了两种锁类型：`sync.Mutex` 和 `sync.RWMutex`，前者是互斥锁，后者是读写锁。\n### 互斥锁\n\n#### 使用 channel 实现互斥所\n我们可以使用容量只有 `1` 的 `channel` 来保证最多只有一个 `goroutine` 在同一时刻访问一个共享变量：\n```go\nvar (\n  sema = make(chan struct{}, 1) // a binary semaphore guarding balance\n  balance int\n)\n\nfunc Deposit(amount int) {\n  sema <- struct{}{} // acquire lock\n  balance = balance + amount\n  <-sema // release lock\n}\n\nfunc Balance() int {\n  sema <- struct{}{} // acquire lock\n  b := balance\n  <-sema // release lock\n  return b\n}\n```\n\n#### sync.Mutex\n使用 `sync.Mutex` 互斥锁：\n```go\nimport \"sync\"\n\nvar (\n  mu sync.Mutex // guards balance\n  balance int\n)\n\nfunc Deposit(amount int) {\n  mu.Lock()\n  balance = balance + amount\n  mu.Unlock()\n}\n\nfunc Balance() int {\n  mu.Lock()\n  b := balance\n  mu.Unlock()\n  return b\n}\n```\n\n`mutex` 会保护共享变量，当已经有 `goroutine` 获得这个锁，再有 `goroutine` 访问这个加锁的变量就会被阻塞，\n直到持有这个锁的 `goroutine` `unlock` 这个锁。\n\n我们可以**使用 `defer` 来 `unlock` 锁，保证在函数返回之后或者发生错误返回时一定会执行 `unlock`**。\n\n### 读写锁 `sync.RWMutex`\n如果有多个 `goroutine` 读取变量，那么是并发安全的，这个时候使用 `sync.Mutex` 加锁就没有必要。可以使\n用 `sync.RWMutex` 读写锁（多读单写锁）。\n\n**读写锁是把对共享资源的“读操作”和“写操作”区别对待了。它可以对这两种操作施加不同程度的保护**。\n\n一个读写锁中实际上包含了两个锁，即：读锁和写锁。`sync.RWMutex` 类型中的 `Lock` 方法和 `Unlock` 方法分别用于对写锁进行\n锁定和解锁，而它的 `RLock` 方法和 `RUnlock` 方法则分别用于对读锁进行锁定和解锁。\n\n**对于某个受到读写锁保护的共享资源，多个写操作不能同时进行，写操作和读操作也不能同时进行，但多个读操作却可以同时进行**。\n\n```go\nvar mu sync.RWMutex\nvar balance int\nfunc Balance() int {\n  mu.RLock() // readers lock\n  defer mu.RUnlock()\n  return balance\n}\n```\n**`RLock` 只能在共享变量没有任何写入操作时可用**。\n\n**为什么只读操作也需要加锁**？\n```go\nvar x, y int\ngo func() {\n  x = 1 // A1\n  fmt.Print(\"y:\", y, \" \") // A2\n}()\ngo func() {\n  y = 1                   // B1\n  fmt.Print(\"x:\", x, \" \") // B2\n}()\n```\n\n上面的代码打印的结果可能是：\n```bash\ny:0 x:1\nx:0 y:1\nx:1 y:1\ny:1 x:1\n\n# 还可能是\nx:0 y:0\ny:0 x:0\n```\n\n为什么会有 `x:0 y:0` 这种结果，在一个 `goroutine` 中，语句的执行顺序可以保证，在声明的例子，可以保证\n执行 `x = 1` 后打印 `y:`，但是不能保证打印 `y:` 时，另一个 `goroutine` 中 `y = 1` 是否已经执行。\n\n所以可能的话，将变量限定在 `goroutine` 内部；如果是多个 `goroutine` 都需要访问的变量，使用互斥条件来访问。\n\n### 注意事项\n- 不要重复锁定互斥锁；**对一个已经被锁定的互斥锁进行锁定，是会立即阻塞当前的 `goroutine` 的**。这个 `goroutine` 所执行的流程，\n会一直停滞在调用该互斥锁的 `Lock` 方法的那行代码上。直到该互斥锁的 `Unlock`方法被调用，并且这里的锁定操作成功完成，后续的代码\n（也就是临界区中的代码）才会开始执行。这也正是互斥锁能够保护临界区的原因所在。\n- 不要忘记解锁互斥锁，必要时使用 `defer` 语句；避免重复锁定。\n- 不要对尚未锁定或者已解锁的互斥锁解锁；**解锁“读写锁中未被锁定的写锁”，会立即引发 panic**，对于其中的读锁也是如此，并且同\n样是不可恢复的。\n- 不要在多个函数之间直接传递互斥锁。一旦，你把一个互斥锁同时用在了多个地方，就必然会有更多的 `goroutine` 争用这把锁。\n这不但会让你的程序变慢，还会大大增加死锁（`deadloc`k）的可能性。\n\n所谓的**死锁**，指的就是当前程序中的主 `goroutine`，以及我们启用的那些 `goroutine` 都已经被阻塞。这些 `goroutine` 可以被统\n称为用户级的 `goroutine`。这就相当于整个程序都已经停滞不前了。\n\nGo 语言运行时系统是不允许这种情况出现的，只要它发现所有的用户级 `goroutine` 都处于等待状态，就会自行抛出一个带有如下\n信息的 panic：`fatal error: all goroutines are asleep - deadlock!`\n\n**注意，这种由 Go 语言运行时系统自行抛出的 panic 都属于致命错误，都是无法被恢复的，调用 recover 函数对它们起不到任何作用。\n也就是说，一旦产生死锁，程序必然崩溃**。\n\n**最简单、有效的方式就是让每一个互斥锁都只保护一个临界区或一组相关临界区**。\n\n## 条件变量 sync.Cond\n条件变量是基于互斥锁的，它必须有互斥锁的支撑才能发挥作用。条件变量并不是被用来保护临界区和共享资源的，它是用于协调想要访问共享\n资源的那些线程的。**当共享资源的状态发生变化时，它可以被用来通知被互斥锁阻塞的线程**。\n\n条件变量在这里的最大优势就是在效率方面的提升。当共享资源的状态不满足条件的时候，想操作它的线程再也不用循环往复地做检查了，\n只要等待通知就好了。\n\n### 条件变量怎样与互斥锁配合使用\n条件变量的初始化离不开互斥锁，并且它的方法有的也是基于互斥锁的。\n\n条件变量提供的方法有三个：等待通知（wait）、单发通知（signal）和广播通知（broadcast）。我们在利用条件变量等待通知的时候，\n需要在它基于的那个互斥锁保护下进行。而在进行单发通知或广播通知的时候，却是恰恰相反的，也就是说，需要在对应的互斥锁解锁之后\n再做这两种操作。\n\n```go\nvar mailbox uint8\nvar lock sync.RWMutex\nsendCond := sync.NewCond(&lock)\nrecvCond := sync.NewCond(lock.RLocker())\n```\n\n`lock` 是一个类型为 `sync.RWMutex` 的变量，是一个读写锁。基于这把锁，我还创建了两个代表条件变量的变量，名字分别\n叫 `sendCond` 和 `recvCond`。\n\n**`sync.Cond` 类型并不是开箱即用的。只能利用 `sync.NewCond` 函数创建它的指针值**。\n\n`lock` 变量的 `Lock` 方法和 `Unlock` 方法分别用于对其中写锁的锁定和解锁，它们与 `sendCond` 变量的含义是对应的。\n被视为对共享资源的写操作。\n\n初始化 `recvCond`这 个条件变量，我们需要的是 `lock` 变量中的读锁，`sync.RWMutex` 类型的 `RLocker` 方法可以实现这一需求。\n`lock.RLocker()`，在其内部会分别调用 `lock` 变量的 `RLock` 方法和 `RUnlock` 方法。\n\n下面是一个例子：\n`mailbox` 是一个信箱，如果在放置的时候发现信箱里还有未被取走的情报，那就不再放置，而先返回。另一方面，如果你在获取的时候发现信\n箱里没有情报，那也只能先回去了。\n\n```go\nlock.Lock()\nfor mailbox == 1 {\n    sendCond.Wait()\n}\nmailbox = 1\nlock.Unlock()\nrecvCond.Signal()\n```\n\n先调用 `lock` 变量的 `Lock` 方法。注意，这个 `Lock` 方法在这里意味的是：持有信箱上的锁，并且有打开信箱的权利，\n而不是锁上这个锁。\n\n检查 `mailbox` 变量的值是否等于 1，也就是说，要看看信箱里是不是还存有情报。如果还有情报，那么我就回家去等通知。\n\n如果信箱里没有情报，那么我就把新情报放进去，关上信箱、锁上锁，然后离开。用代码表达出来就是 `mailbox = 1` 和 `lock.Unlock()`。\n然后发通知，“信箱里已经有新情报了”，我们调用 `recvCond` 的 `Signal` 方法就可以实现这一步骤。\n\n另一方面，你现在是另一个 `goroutine`，想要适时地从信箱中获取情报，然后通知我。\n```go\nlock.RLock()\nfor mailbox == 0 {\n    recvCond.Wait()\n}\nmailbox = 0\nlock.RUnlock()\nsendCond.Signal()\n```\n事情在流程上其实基本一致，只不过每一步操作的对象是不同的。\n\n**为什么先要锁定条件变量基于的互斥锁，才能调用它的 Wait 方法？**\n\n`Wait` 方法主要做了四件事。\n\n1. 把调用它的 `goroutine`（也就是当前的 `goroutine`）加入到当前条件变量的通知队列中。\n2. 解锁当前的条件变量基于的那个互斥锁。\n3. 让当前的 `goroutine` 处于等待状态，等到通知到来时再决定是否唤醒它。此时，这个 `goroutine` 就会阻塞在调用这\n个 `Wait` 方法的那行代码上。\n4. 如果通知到来并且决定唤醒这个 `goroutine`，那么就在唤醒它之后重新锁定当前条件变量基于的互斥锁。自此之后，当前\n的 `goroutine` 就会继续执行后面的代码了。\n\n因为条件变量的 `Wait` 方法在阻塞当前的 `goroutine` 之前会解锁它基于的互斥锁，所以在调用该 `Wait` 方法之前我们必须先\n锁定那个互斥锁，否则在调用这个 `Wait` 方法时，就会引发一个不可恢复的 panic。\n\n为什么条件变量的 `Wait` 方法要这么做呢？你可以想象一下，如果 `Wait` 方法在互斥锁已经锁定的情况下，阻塞了当前的 `goroutine`，\n那么又由谁来解锁呢？别的 `goroutine` 吗？\n\n先不说这违背了互斥锁的重要使用原则，即：成对的锁定和解锁，就算别的 `goroutine` 可以来解锁，那万一解锁重复了怎么办？\n由此引发的 panic 可是无法恢复的。\n\n如果当前的 `goroutine` 无法解锁，别的 `goroutine` 也都不来解锁，那么又由谁来进入临界区，并改变共享资源的状态呢？只要共享资源\n的状态不变，即使当前的 `goroutine` 因收到通知而被唤醒，也依然会再次执行这个 `Wait` 方法，并再次被阻塞。\n\n所以说，如果条件变量的 `Wait` 方法不先解锁互斥锁的话，那么就只会造成两种后果：不是当前的程序因 panic 而崩溃，就是相关的\n `goroutine` 全面阻塞。\n\n**为什么要用 `for` 语句来包裹调用其 `Wait` 方法的表达式，用 `if` 语句不行吗？**\n\n`if` 语句只会对共享资源的状态检查一次，而 `for` 语句却可以做多次检查，直到这个状态改变为止。\n\n那为什么要做多次检查呢？\n\n为了保险起见。如果一个 `goroutine` 因收到通知而被唤醒，但却发现共享资源的状态，依然不符合它的要求，那么就应该再次调用\n条件变量的 `Wait` 方法，并继续等待下次通知的到来。\n\n这种情况是很有可能发生的。\n\n### 条件变量的 `Signal` 方法和 `Broadcast` 方法有哪些异同\n条件变量的 `Signal` 方法和 `Broadcast` 方法都是被用来发送通知的，不同的是，前者的通知只会唤醒一个因此而等待的 `goroutine`，\n而后者的通知却会唤醒所有为此等待的 `goroutine`。\n\n条件变量的 `Wait` 方法总会把当前的 `goroutine` 添加到通知队列的队尾，而它的 `Signal` 方法总会从通知队列的队首开始查找可被\n唤醒的 `goroutine`。所以，因 `Signal` 方法的通知而被唤醒的 `goroutine` 一般都是最早等待的那一个。\n\n## 原子操作\nGo 语言的原子操作当然是基于 CPU 和操作系统的，所以它也只针对少数数据类型的值提供了原子操作函数。这些函数都存在于标准库代\n码包 `sync/atomic` 中。\n\n`sync/atomic` 包中的函数可以做的原子操作有：加法（add）、比较并交换（compare and swap，简称 CAS）、加载（load）、\n存储（store）和交换（swap）。\n\n这些函数针对的数据类型并不多。对这些类型中的每一个，`sync/atomic` 包都会有一套函数给予支持。这些数据类型有：\n`int32`、`int64`、`uint32`、`uint64`、`uintptr`，以及 `unsafe` 包中的 `Pointer`。不过，针对 \n`unsafe.Pointer` 类型，该包并未提供进行原子加法操作的函数。\n\n`sync/atomic` 包还提供了一个名为 `Value` 的类型，它可以被用来存储任意类型的值。\n\n`atomic.AddInt32` 函数的第一个参数，为什么不是 `int32` 而是 `*int32` 呢？\n因为**原子操作函数需要的是被操作值的指针，而不是这个值本身**；被传入函数的参数值都会被复制，像这种基本类型的值一旦被传入函数，\n就已经与函数外的那个值毫无关系了。\n\n所以，传入值本身没有任何意义。`unsafe.Pointer` 类型虽然是指针类型，但是那些原子操作函数要操作的是这个指针值，而不是它指向\n的那个值，所以需要的仍然是指向这个指针值的指针。\n\n只要原子操作函数拿到了被操作值的指针，就可以定位到存储该值的内存地址。只有这样，它们才能够通过底层的指令，准确地操作这个内\n存地址上的数据。\n\n## 比较并交换操作与交换操作相比有什么不同\n**比较并交换操作即 CAS 操作**，是有条件的交换操作，**只有在条件满足的情况下才会进行值的交换**。\n\n**所谓的交换指的是，把新值赋给变量，并返回变量的旧值**。\n\nCAS 操作用途要更广泛一些。例如，我们将它与 `for` 语句联用就可以实现一种简易的自旋锁（spinlock）。\n```go\nfor {\n    if atomic.CompareAndSwapInt32(&num2, 10, 0) {\n        fmt.Println(\"The second number has gone to zero.\")\n        break\n    }\n    time.Sleep(time.Millisecond * 500)\n}\n```\n在 `for` 语句中的 CAS 操作可以不停地检查某个需要满足的条件，一旦条件满足就退出 `for` 循环。这就相当于，只要条件未被满足，\n当前的流程就会被一直“阻塞”在这里。\n\n这在效果上与互斥锁有些类似。不过，它们的适用场景是不同的。我们在使用互斥锁的时候，总是假设共享资源的状态会被其他\n的 `goroutine` 频繁地改变。\n\n而 `for` 语句加 CAS 操作的假设往往是：共享资源状态的改变并不频繁，或者，它的状态总会变成期望的那样。这是一种更加乐观，\n或者说更加宽松的做法。\n\n**假设我已经保证了对一个变量的写操作都是原子操作，比如：加或减、存储、交换等等，那我对它进行读操作的时候，还有必要使用原\n子操作吗**？\n\n很有必要。其中的道理你可以对照一下读写锁。为什么在读写锁保护下的写操作和读操作之间是互斥的？这是为了防止读操作读到没有\n被修改完的值，对吗？\n\n如果写操作还没有进行完，读操作就来读了，那么就只能读到仅修改了一部分的值。这显然破坏了值的完整性，读出来的值也是完全错误的。\n\n所以，一旦你决定了要对一个共享资源进行保护，那就要做到完全的保护。不完全的保护基本上与不保护没有什么区别。\n\n## `sync/atomic.Value`\n此类型的值相当于一个容器，可以被用来“原子地”存储和加载任意的值。开箱即用。\n\n它只有两个指针方法—— `Store` 和 `Load`。不过，虽然简单，但还是有一些值得注意的地方的。\n\n1. 一旦 `atomic.Value` 类型的值（以下简称原子值）被真正使用，它就不应该再被复制了。只要用它来存储值了，就相当于开始真正使用了。\n`atomic.Value` 类型属于结构体类型，而结构体类型属于值类型。所以，复制该类型的值会产生一个完全分离的新值。这个新值相当于被\n复制的那个值的一个快照。之后，不论后者存储的值怎样改变，都不会影响到前者。\n2. 不能用原子值存储 `nil`。\n3. 我们向原子值存储的第一个值，决定了它今后能且只能存储哪一个类型的值。\n4. 尽量不要向原子值中存储引用类型的值。因为这很容易造成安全漏洞。\n\n```go\nvar box6 atomic.Value\nv6 := []int{1, 2, 3}\nbox6.Store(v6)\nv6[1] = 4 // 注意，此处的操作不是并发安全的！\n```\n切片类型属于引用类型。所以，我在外面改动这个切片值，就等于修改了 `box6` 中存储的那个值。这相当于绕过了原子值而进行了非并发\n安全的操作。怎样修补：\n```go\nstore := func(v []int) {\n    replica := make([]int, len(v))\n    copy(replica, v)\n    box6.Store(replica)\n}\nstore(v6)\nv6[2] = 5 // 此处的操作是安全的。\n```\n\n先为切片值 `v6` 创建了一个完全的副本。这个副本涉及的数据已经与原值毫不相干了。然后，我再把这个副本存入 `box6`。如此一来，\n无论我再对 `v6` 的值做怎样的修改，都不会破坏 `box6` 提供的安全保护。\n\n## sync.WaitGroup\n在一些场合下里，我们使用通道的方式看起来都似乎有些蹩脚。比如：声明一个通道，使它的容量与我们手动启用的 `goroutine` 的数量相同。\n之后利用这个通道，让主 `goroutine` 等待其他 `goroutine` 的运行结束。更具体地说就是：让其他的 `goroutine` 在运行结束之前，\n都向这个通道发送一个元素值，并且，让主 `goroutine` 在最后从这个通道中接收元素值，接收的次数需要与其他的 `goroutine` 的数量相同。\n\n```go\nfunc coordinateWithChan() {\n    sign := make(chan struct{}, 2)\n    num := int32(0)\n    fmt.Printf(\"The number: %d [with chan struct{}]\\n\", num)\n    max := int32(10)\n    go addNum(&num, 1, max, func() {\n        sign <- struct{}{}\n    })\n    go addNum(&num, 2, max, func() {\n        sign <- struct{}{}\n    })\n    <-sign\n    <-sign\n}\n```\n`coordinateWithChan` 函数中最后的那两行代码了吗？重复的两个接收表达式 `<-sign`，很丑陋。\n我们可以选用另外一个同步工具，即：`sync` 包的 `WaitGroup` 类型。它比通道更加适合实现这种一对多的 `goroutine` 协作流程。\n\n`sync.WaitGroup` 类型（以下简称 `WaitGroup` 类型）是开箱即用的，也是并发安全的。\n\n`WaitGroup` 类型拥有三个指针方法：`Add`、`Done` 和 `Wait`。**你可以想象该类型中有一个计数器，它的默认值是 `0`。我们可\n以通过调用该类型值的 `Add` 方法来增加，或者减少这个计数器的值**。\n\n**一般情况下，我会用这个方法来记录需要等待的 `goroutine` 的数量。相对应的，这个类型的 `Done` 方法，用于对其所属值中计数器\n的值进行减一操作**。我们可以在需要等待的 `goroutine` 中，通过 `defer` 语句调用它。\n\n而**此类型的 `Wait` 方法的功能是，阻塞当前的 `goroutine`，直到其所属值中的计数器归零**。\n\n改造版本：\n```go\nfunc coordinateWithWaitGroup() {\n\tvar wg sync.WaitGroup\n\twg.Add(2)\n\tnum := int32(0)\n\tfmt.Printf(\"The number: %d [with sync.WaitGroup]\\n\", num)\n\tmax := int32(10)\n\tgo addNum(&num, 3, max, wg.Done)\n\tgo addNum(&num, 4, max, wg.Done)\n\twg.Wait()\n}\n```\n\n**尽量不要在 `go` 函数内部调用 `Add`，以免 `Add` 还未执行，`Wait` 已经退出**：\n```go\nvar wg sync.WaitGroup\ngo func(){\n\twg.Add(1)\n\tfmt.Println(\"test\")\n}()\n\nwg.Wait()\nfmt.Println(\"exit.\")\n```\n\n### sync.WaitGroup 类型值中计数器的值可以小于 0 吗\n不可以。**小于 0，会引发一个 panic**。\n\n**`WaitGroup` 值是可以被复用的，但需要保证其计数周期的完整性**。这里的计数周期指的是这样一个过程：该值中的计数器值由 0 变为\n了某个正整数，而后又经过一系列的变化，最终由某个正整数又变回了 0。\n\n如果在一个此类值的 `Wait` 方法被执行期间，跨越了两个计数周期，那么就会引发一个 panic。\n\n### 使用注意\n- 不要把增加其计数器值的操作和调用其 `Wait` 方法的代码，放在不同的 `goroutine` 中执行。换句话说，要**杜绝对同一个 \n`WaitGroup` 值的两种操作的并发执行**。\n\n## sync.Once\n\n与 `sync.WaitGroup` 类型一样，`sync.Once` 类型（以下简称 `Once` 类型）也属于结构体类型，同样也是开箱即用和并发安全的。\n由于这个类型中包含了一个 `sync.Mutex` 类型的字段，所以，复制该类型的值也会导致功能的失效。\n\n```go\nvar loadIconsOnce sync.Once\nvar icons map[string]image.Image\n// Concurrency-safe.\nfunc Icon(name string) image.Image {\n  loadIconsOnce.Do(loadIcons)\n  return icons[name]\n}\n```\n`Once` 类型的 `Do` 方法只接受一个参数，这个参数的类型必须是 `func()`，即：无参数声明和结果声明的函数。该方法的功能并\n不是对每一种参数函数都只执行一次，而是只**执行“首次被调用时传入的”那个函数，并且之后不会再执行任何参数函数**。\n\n所以，**如果你有多个只需要执行一次的函数，那么就应该为它们中的每一个都分配一个 `sync.Once` 类型的值**（以下简称 `Once` 值）。\n\n`Once` 类型中还有一个名叫 `done` 的 `uint32` 类型的字段。**它的作用是记录其所属值的 `Do` 方法被调用的次数。不过，该字段的值\n只可能是 0 或者 1。一旦 `Do` 方法的首次调用完成，它的值就会从 0 变为 1**。\n\n**既然 `done` 字段的值不是 0 就是 1，那为什么还要使用需要四个字节的 `uint32` 类型呢**？\n\n原因很简单，因为对它的操作必须是“原子”的。`Do` 方法在一开始就会通过调用 `atomic.LoadUint32` 函数来获取该字段的值，并且一旦\n发现该值为 1 就会直接返回。这也初步保证了“`Do` 方法，只会执行首次被调用时传入的函数”。\n\n### Do 方法在功能方面的两个特点\n- 由于 `Do` 方法只会在参数函数执行结束之后把 `done` 字段的值变为 1，因此，如果参数函数的执行需要很长时间或者根本就不会结束\n（比如执行一些守护任务），那么就有可能会导致相关 `goroutine` 的同时阻塞\n- `Do` 方法在参数函数执行结束后，对 `done` 字段的赋值用的是原子操作，并且，这一操作是被挂在 `defer` 语句中的。因此，不论参数\n函数的执行会以怎样的方式结束，`done` 字段的值都会变为 1。\n\n## context.Context 类型\n使用 `WaitGroup` 值的时候，我们最好用**先统一 `Add`，再并发 `Done`，最后 `Wait`** 的标准模式来构建协作流程。如果在调用\n该值的 `Wait` 方法的同时，为了增大其计数器的值，而并发地调用该值的 `Add` 方法，那么就很可能会引发 panic。\n\n但是**如果，我们不能在一开始就确定执行子任务的 `goroutine` 的数量，那么使用 `WaitGroup` 值来协调它们和分发子任\n务的 `goroutine`，就是有一定风险的**。一个解决方案是：**分批地启用执行子任务的 `goroutine`**。\n\n只要我们在严格遵循上述规则的前提下，分批地启用执行子任务的 `goroutine`，就肯定不会有问题。\n```go\nfunc coordinateWithWaitGroup() {\n    total := 12\n    stride := 3\n    var num int32\n    fmt.Printf(\"The number: %d [with sync.WaitGroup]\\n\", num)\n    var wg sync.WaitGroup\n    for i := 1; i <= total; i = i + stride {\n        wg.Add(stride)\n        for j := 0; j < stride; j++ {\n            go addNum(&num, i+j, wg.Done)\n        }\n        wg.Wait()\n    }\n    fmt.Println(\"End.\")\n}\n```\n\n### 使用 `context` 包中的程序实体，实现一对多的 goroutine 协作流程\n用 `context` 包中的函数和 `Context` 类型作为实现工具，实现 `coordinateWithContext` 的函数。这个函数应该具有上\n面 `coordinateWithWaitGroup` 函数相同的功能。\n```go\nfunc coordinateWithContext() {\n\ttotal := 12\n\tvar num int32\n\tfmt.Printf(\"The number: %d [with context.Context]\\n\", num)\n\tcxt, cancelFunc := context.WithCancel(context.Background())\n\tfor i := 1; i <= total; i++ {\n\t\tgo addNum(&num, i, func() {\n\t\t\tif atomic.LoadInt32(&num) == int32(total) {\n\t\t\t\tcancelFunc()\n\t\t\t}\n\t\t})\n\t}\n\t<-cxt.Done()\n\tfmt.Println(\"End.\")\n}\n```\n先后调用了 `context.Background` 函数和 `context.WithCancel` 函数，并得到了一个可撤销的 `context.Context` 类型的值\n（由变量 `cxt` 代表），以及一个 `context.CancelFunc`类型的撤销函数（由变量 `cancelFunc` 代表）。\n\n注意我给予 `addNum` 函数的最后一个参数值。它是一个匿名函数，其中只包含了一条 `if` 语句。这条 `if` 语句会**原子地**加载\n `num` 变量的值，并判断它是否等于 `total` 变量的值。\n\n如果两个值相等，那么就调用 `cancelFunc` 函数。其含义是，如果所有的 `addNum` 函数都执行完毕，那么就立即通知分发子任务\n的 `goroutine`。\n\n**这里分发子任务的 `goroutine`，即为执行 `coordinateWithContext` 函数的 `goroutine`**。它在执行完 `for` 语句后，会\n立即调用 `cxt` 变量的 `Done` 函数，并试图针对该函数返回的通道，进行接收操作。\n\n一旦 `cancelFunc` 函数被调用，针对该通道的接收操作就会马上结束，所以，这样做就可以实现“等待所有的 `addNum` 函数都执\n行完毕”的功能。\n\n### context.Context 类型\n`Context` 类型的值（以下简称 `Context` 值）是可以繁衍的，这意味着我们可以通过一个 `Context` 值产生出任意个子值。这些子值\n可以携带其父值的属性和数据，也可以响应通过其父值传达的信号。\n\n正因为如此，所有的 `Context` 值共同构成了一颗代表了上下文全貌的树形结构。这棵树的**树根（或者称上下文根节点）是一个已经\n在 `context` 包中预定义好的 `Context` 值**，它是**全局唯一**的。通过调用 `context.Background` 函数，我们就可以获取到\n它（在 `coordinateWithContext` 函数中就是这么做的）。\n\n注意一下，这个**上下文根节点仅仅是一个最基本的支点，它不提供任何额外的功能**。也就是说，它既不可以被撤销（`cancel`），\n也不能携带任何数据。\n\n`context` 包中还包含了**四个用于繁衍 `Context` 值的函数，即：`WithCancel`、`WithDeadline`、`WithTimeout` 和 `WithValue`**。\n\n这些函数的第一个参数的类型都是 `context.Context`，而名称都为 `parent`。顾名思义，**这个位置上的参数对应的都是它们将会产生\n的 `Context` 值的父值**。\n\n**`WithCancel` 函数用于产生一个可撤销的 parent 的子值**。\n\n在 `coordinateWithContext` 函数中，通过调用该函数，获得了一个衍生自上下文根节点的 `Context` 值，和一个用于触发撤销信号的函数。\n\n`WithDeadline` 函数和 `WithTimeout` 函数则都可以被用来产生一个会**定时撤销**的 `parent` 的子值。至于 `WithValue` 函数，\n我们可以通过调用它，产生一个会携带额外数据的 `parent` 的子值。\n\n### “可撤销的”在 context 包中代表着什么？“撤销”一个 Context 值又意味着什么？\n\n这需要从 `Context` 类型的声明讲起。这个接口中有两个方法与“撤销”息息相关。`Done` 方法会返回一个元素类型为 `struct{}` 的接\n收通道。不过，这个接收通道的用途并不是传递元素值，而是**让调用方去感知“撤销”当前Context值的那个信号**。\n\n一旦当前的 `Context` 值被撤销，这里的接收通道就会被立即关闭。我们都知道，对于一个未包含任何元素值的通道来说，它的关闭会\n使任何针对它的接收操作立即结束。\n\n正因为如此，在 `coordinateWithContext` 函数中，基于调用表达式 `cxt.Done()` 的接收操作，才能够起到感知撤销信号的作用。\n\n### 撤销信号是如何在上下文树中传播的\n\n`context`包的 `WithCancel` 函数在被调用后会产生两个结果值。第一个结果值就是那个可撤销的 `Context` 值，而第二个结果值则是\n用于触发撤销信号的函数。\n\n在撤销函数被调用之后，对应的 `Context` 值会先关闭它内部的接收通道，也就是它的 `Done` 方法会返回的那个通道。\n\n然后，它会向它的所有子值（或者说子节点）传达撤销信号。这些子值会如法炮制，把撤销信号继续传播下去。最后，这个 `Context` 值会\n断开它与其父值之间的关联。\n\n**通过调用 `context.WithValue` 函数得到的 `Context` 值是不可撤销的**。\n\n### 怎样通过 Context 值携带数据\n\n**`WithValue` 函数在产生新的 `Context` 值（以下简称含数据的 `Context` 值）的时候需要三个参数，即：父值、键和值**。\n“字典对于键的约束”类似，这里**键的类型必须是可判等**的。\n\n原因很简单，当我们从中获取数据的时候，它需要根据给定的键来查找对应的值。不过，这种 `Context` 值并不是用字典来存储键和值的，\n后两者只是被简单地存储在前者的相应字段中而已。\n\n## 临时对象池 sync.Pool\n Go 语言标准库中最重要的那几个同步工具，这包括:\n - 互斥锁\n - 读写锁\n - 条件变量\n - 原子操作\n - `sync/atomic.Value`\n - `sync.Once`\n - `sync.WaitGroup`\n - `context.Context`\n\nGo 语言标准库中的还有另一个同步工具：`sync.Pool`。\n\n`sync.Pool` 类型可以被称为临时对象池，它的值可以被用来存储临时的对象。与 Go 语言的很多同步工具一样，`sync.Pool` 类型也属\n于结构体类型，它的值在被真正使用之后，就不应该再被复制了。\n\n**临时对象**的意思是：不需要持久使用的某一类值。这类值对于程序来说可有可无，但如果有的话会明显更好。它们的创建和销毁可以在\n任何时候发生，并且完全不会影响到程序的功能。\n\n**我们可以把临时对象池当作针对某种数据的缓存来用**。\n\n`sync.Pool` 类型只有两个方法——`Put` 和 `Get`。前者用于在当前的池中存放临时对象，它接受一个 `interface{}` 类型的参数；\n而后者则被用于从当前的池中获取临时对象，它会返回一个 `interface{}` 类型的值。\n\n更具体地说，**这个类型的 `Get` 方法可能会从当前的池中删除掉任何一个值，然后把这个值作为结果返回。如果此时当前的池中没有任何值，\n那么这个方法就会使用当前池的 `New` 字段创建一个新值，并直接将其返回**。\n\n`sync.Pool` 类型的 `New` 字段代表着创建临时对象的函数。它的类型是没有参数但有唯一结果的函数类型，即：`func() interface{}`。\n**初始化这个池的时候最好给定它**。\n\n这个函数是 `Get` 方法最后的临时对象获取手段。`Get` 方法如果到了最后，仍然无法获取到一个值，那么就会调用该函数。该函数的结\n值并不会被存入当前的临时对象池中，而是直接返回给 `Get` 方法的调用方。\n\n**临时对象池中存储的每一个值都应该是独立的、平等的和可重用的**。`sync.Pool` 的定位不是做类似连接池的东西，它的用途仅仅是增加\n对象重用的几率，减少 gc 的负担。因为 gc 带来了编程的方便但同时也增加了运行时开销，使用不当甚至会严重影响程序的性能。因此性能\n要求高的场景不能任意产生太多的垃圾。如何解决呢？那就是要重用对象了。\n\n一个比较好的例子是 `fmt` 包，`fmt` 包总是需要使用一些 `[]byte` 之类的对象，golang 建立了一个临时对象池，存放着这些对象，\n如果需要使用一个 `[]byte`，就去 `Pool` 里面拿，如果拿不到就分配一份。这比起不停生成新的 `[]byte`，用完了再等待 gc 回收\n来要高效得多。\n\n`sync.Pool` 缓存对象的期限是很诡异的，先看一下 `src/pkg/sync/pool.go` 里面的一段实现代码：\n```go\nfunc init() {\n    runtime_registerPoolCleanup(poolCleanup)\n}\n```\n\n可以看到 `pool` 包在 `init` 的时候注册了一个 `poolCleanup` 函数，它会清除所有的 `pool` 里面的所有缓存的对象，该函数注册进去\n之后会在每次 gc 之前都会调用，因此 **`sync.Pool` 缓存的期限只是两次gc之间这段时间**。\n\n## sync.Map\nGo 语言自带的字典类型 `map` 并不是并发安全的。换句话说，在同一时间段内，让不同 goroutine 中的代码，对同一个字典进行读写操\n作是不安全的。\n\nGo 语言官方终于在 2017 年发布的 Go 1.9 中正式加入了并发安全的字典类型 `sync.Map`。\n\n使用 `sync.Map` 可以显著地减少锁的争用。`sync.Map` 本身虽然也用到了锁，但是，它其实在尽可能地避免使用锁。\n\n**使用锁就意味着要把一些并发的操作强制串行化。这往往会降低程序的性能，尤其是在计算机拥有多个 CPU 核心的情况下**。\n\n由于**并发安全字典内部使用的存储介质正是原生字典，又因为它使用的原生字典键类型也是可以包罗万象的 `interface{}`，所以，\n我们绝对不能带着任何实际类型为函数类型、字典类型或切片类型的键值去操作并发安全字典**。\n\n因为**这些键值的实际类型只有在程序运行期间才能够确定，所以 Go 语言编译器是无法在编译期对它们进行检查的，不正确的键值实际类\n型肯定会引发 panic**。\n\n**因此，我们在这里首先要做的一件事就是：一定不要违反上述规则。我们应该在每次操作并发安全字典的时候，都去显式地检查键值的实际\n类型。无论是存、取还是删，都应该如此**。\n\n> **更好的做法是，把针对同一个并发安全字典的这几种操作都集中起来，然后统一地编写检查代码。除此之外，把并发安全字典封装在一\n个结构体类型中，往往是一个很好的选择**。如果你实在拿不准，那么可以先通过调用 `reflect.TypeOf` 函数得到一个键值对应的反射类\n型值（即：`reflect.Type` 类型的值），然后再调用这个值的 `Comparable` 方法，得到确切的判断结果。\n\n### 并发安全字典如何做到尽量避免使用锁\n`sync.Map` 类型在内部使用了**大量的原子操作来存取键和值，并使用了两个原生的 map 作为存储介质**。\n\n其中一个原生 map 被存在了 `sync.Map` 的 `read` 字段中，该字段是 `sync/atomic.Value` 类型的。简称它为**只读字典**。\n\n**只读字典虽然不会增减其中的键，但却允许变更其中的键所对应的值**。所以，它并不是传统意义上的快照，它的只读特性只是对于其中键\n的集合而言的。\n\n由 `read` 字段的类型可知，`sync.Map` 在替换只读字典的时候根本用不着锁。另外，这个只读字典在存储键值对的时候，还在值之上\n封装了一层。\n\n它先把值转换为了 `unsafe.Pointer` 类型的值，然后再把后者封装，并储存在其中的原生字典中。如此一来，在变更某个键所对应的值\n的时候，就也可以使用原子操作了。\n\n`sync.Map` 中的另一个原生字典由它的 `dirty` 字段代表。它存储键值对的方式与 `read` 字段中的原生字典一致，它的键类型\n也是 `interface{}`，并且同样是把值先做转换和封装后再进行储存的。称为**脏字典**。\n\n> 脏字典和只读字典如果都存有同一个键值对，那么这里的两个键指的肯定是同一个基本值，对于两个值来说也是如此。正如前文所述，\n这两个字典在存储键和值的时候都只会存入它们的某个指针，而不是基本值。\n\n`sync.Map` 在查找指定的键所对应的值的时候，总会先去只读字典中寻找，并不需要锁定互斥锁。只有当确定**只读字典中没有，但脏\n字典中可能会有这个键**的时候，它才会在锁的保护下去访问脏字典。\n\n相对应的，`sync.Map` 在存储键值对的时候，只要只读字典中已存有这个键，并且该键值对未被标记为“已删除”，就会把新值存到里面并\n直接返回，这种情况下也不需要用到锁。\n\n否则，它才会在锁的保护下把键值对存储到脏字典中。这个时候，该键值对的“已删除”标记会被抹去。\n\n只有当一个键值对应该被删除，但却仍然存在于只读字典中的时候，才会被用标记为“已删除”的方式进行逻辑删除，而不会直接被物理删除。\n这种情况会在重建脏字典以后的一段时间内出现。不过，过不了多久，它们就会被真正删除掉。在查找和遍历键值对的时候，已被逻\n辑删除的键值对永远会被无视。\n\n最后，`sync.Map` 会把该键值对中指向值的那个指针置为 `nil` ，这是另一种逻辑删除的方式。\n\n除此之外，还有一个细节需要注意，只读字典和脏字典之间是会互相转换的。在脏字典中查找键值对次数足够多的时候，`sync.Map` 会把\n脏字典直接作为只读字典，保存在它的 `read` 字段中，然后把代表脏字典的 `dirty` 字段的值置为 `nil`。\n\n在这之后，一旦再有新的键值对存入，它就会依据只读字典去重建脏字典。这个时候，它会把只读字典中已被逻辑删除的键值对过滤掉。\n理所当然，这些转换操作肯定都需要在锁的保护下进行。\n\n**`sync.Map` 的只读字典和脏字典中的键值对集合并不是实时同步的，它们在某些时间段内可能会有不同**。\n\n可以看出，在读操作有很多但写操作却很少的情况下，并发安全字典的性能往往会更好。在几个写操作当中，新增键值对的操作对并发安\n全字典的性能影响是最大的，其次是删除操作，最后才是修改操作。\n\n如果被操作的键值对已经存在于 `sync.Map` 的只读字典中，并且没有被逻辑删除，那么修改它并不会使用到锁，对其性能的影响就会很小。\n\n## 竞争检查器\n在 `go build`，`go run` 或者 `go test` 命令后面加上 `-race`，就会使编译器创建一个你的应用的“修改”版。\n\n会记录下每一个读或者写共享变量的 `goroutine` 的身份信息。记录下所有的同步事件，比如 `go` 语句，`channel` 操作，\n以及对 `(*sync.Mutex).Lock`，`(*sync.WaitGroup).Wait` 等等的调用。\n\n由于需要额外的记录，因此构建时加了竞争检测的程序跑起来会慢一些，且需要更大的内存，即使是这样，这些代价对于很多生产环境的\n工作来说还是可以接受的。","date":"2019-08-28T00:15:07.515Z","updated":"2019-08-28T00:15:07.515Z","path":"concurrent/sync_lock.html","comments":1,"layout":"page","_id":"ck1xm14ln001dfcw29fs36srt","content":"<h1 id=\"同步和锁\"><a href=\"#同步和锁\" class=\"headerlink\" title=\"同步和锁\"></a>同步和锁</h1><h2 id=\"共享变量\"><a href=\"#共享变量\" class=\"headerlink\" title=\"共享变量\"></a>共享变量</h2><p>无论任何时候，只要有两个以上 <code>goroutine</code> 并发访问同一变量，且至少其中的一个是写操作的时候就会发生数据竞争。<br>避免数据竞争的三种方式：</p>\n<ol>\n<li>不去写变量。读取不可能出现数据竞争。</li>\n<li>避免从多个 <code>goroutine</code> 访问变量，尽量把变量限定在了一个单独的 <code>goroutine</code> 中。(<strong>不要使用共享数据来通信，使用通信<br>来共享数据</strong>)</li>\n<li>互斥锁</li>\n</ol>\n<h2 id=\"同步锁\"><a href=\"#同步锁\" class=\"headerlink\" title=\"同步锁\"></a>同步锁</h2><p>Go 语言包中的 <code>sync</code> 包提供了两种锁类型：<code>sync.Mutex</code> 和 <code>sync.RWMutex</code>，前者是互斥锁，后者是读写锁。</p>\n<h3 id=\"互斥锁\"><a href=\"#互斥锁\" class=\"headerlink\" title=\"互斥锁\"></a>互斥锁</h3><h4 id=\"使用-channel-实现互斥所\"><a href=\"#使用-channel-实现互斥所\" class=\"headerlink\" title=\"使用 channel 实现互斥所\"></a>使用 channel 实现互斥所</h4><p>我们可以使用容量只有 <code>1</code> 的 <code>channel</code> 来保证最多只有一个 <code>goroutine</code> 在同一时刻访问一个共享变量：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> (</span><br><span class=\"line\">  sema = <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">struct</span>&#123;&#125;, <span class=\"number\">1</span>) <span class=\"comment\">// a binary semaphore guarding balance</span></span><br><span class=\"line\">  balance <span class=\"keyword\">int</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Deposit</span><span class=\"params\">(amount <span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">  sema &lt;- <span class=\"keyword\">struct</span>&#123;&#125;&#123;&#125; <span class=\"comment\">// acquire lock</span></span><br><span class=\"line\">  balance = balance + amount</span><br><span class=\"line\">  &lt;-sema <span class=\"comment\">// release lock</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Balance</span><span class=\"params\">()</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">  sema &lt;- <span class=\"keyword\">struct</span>&#123;&#125;&#123;&#125; <span class=\"comment\">// acquire lock</span></span><br><span class=\"line\">  b := balance</span><br><span class=\"line\">  &lt;-sema <span class=\"comment\">// release lock</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> b</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"sync-Mutex\"><a href=\"#sync-Mutex\" class=\"headerlink\" title=\"sync.Mutex\"></a>sync.Mutex</h4><p>使用 <code>sync.Mutex</code> 互斥锁：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"sync\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> (</span><br><span class=\"line\">  mu sync.Mutex <span class=\"comment\">// guards balance</span></span><br><span class=\"line\">  balance <span class=\"keyword\">int</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Deposit</span><span class=\"params\">(amount <span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">  mu.Lock()</span><br><span class=\"line\">  balance = balance + amount</span><br><span class=\"line\">  mu.Unlock()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Balance</span><span class=\"params\">()</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">  mu.Lock()</span><br><span class=\"line\">  b := balance</span><br><span class=\"line\">  mu.Unlock()</span><br><span class=\"line\">  <span class=\"keyword\">return</span> b</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>mutex</code> 会保护共享变量，当已经有 <code>goroutine</code> 获得这个锁，再有 <code>goroutine</code> 访问这个加锁的变量就会被阻塞，<br>直到持有这个锁的 <code>goroutine</code> <code>unlock</code> 这个锁。</p>\n<p>我们可以<strong>使用 <code>defer</code> 来 <code>unlock</code> 锁，保证在函数返回之后或者发生错误返回时一定会执行 <code>unlock</code></strong>。</p>\n<h3 id=\"读写锁-sync-RWMutex\"><a href=\"#读写锁-sync-RWMutex\" class=\"headerlink\" title=\"读写锁 sync.RWMutex\"></a>读写锁 <code>sync.RWMutex</code></h3><p>如果有多个 <code>goroutine</code> 读取变量，那么是并发安全的，这个时候使用 <code>sync.Mutex</code> 加锁就没有必要。可以使<br>用 <code>sync.RWMutex</code> 读写锁（多读单写锁）。</p>\n<p><strong>读写锁是把对共享资源的“读操作”和“写操作”区别对待了。它可以对这两种操作施加不同程度的保护</strong>。</p>\n<p>一个读写锁中实际上包含了两个锁，即：读锁和写锁。<code>sync.RWMutex</code> 类型中的 <code>Lock</code> 方法和 <code>Unlock</code> 方法分别用于对写锁进行<br>锁定和解锁，而它的 <code>RLock</code> 方法和 <code>RUnlock</code> 方法则分别用于对读锁进行锁定和解锁。</p>\n<p><strong>对于某个受到读写锁保护的共享资源，多个写操作不能同时进行，写操作和读操作也不能同时进行，但多个读操作却可以同时进行</strong>。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> mu sync.RWMutex</span><br><span class=\"line\"><span class=\"keyword\">var</span> balance <span class=\"keyword\">int</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Balance</span><span class=\"params\">()</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">  mu.RLock() <span class=\"comment\">// readers lock</span></span><br><span class=\"line\">  <span class=\"keyword\">defer</span> mu.RUnlock()</span><br><span class=\"line\">  <span class=\"keyword\">return</span> balance</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong><code>RLock</code> 只能在共享变量没有任何写入操作时可用</strong>。</p>\n<p><strong>为什么只读操作也需要加锁</strong>？<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x, y <span class=\"keyword\">int</span></span><br><span class=\"line\"><span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  x = <span class=\"number\">1</span> <span class=\"comment\">// A1</span></span><br><span class=\"line\">  fmt.Print(<span class=\"string\">\"y:\"</span>, y, <span class=\"string\">\" \"</span>) <span class=\"comment\">// A2</span></span><br><span class=\"line\">&#125;()</span><br><span class=\"line\"><span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  y = <span class=\"number\">1</span>                   <span class=\"comment\">// B1</span></span><br><span class=\"line\">  fmt.Print(<span class=\"string\">\"x:\"</span>, x, <span class=\"string\">\" \"</span>) <span class=\"comment\">// B2</span></span><br><span class=\"line\">&#125;()</span><br></pre></td></tr></table></figure></p>\n<p>上面的代码打印的结果可能是：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">y:0 x:1</span><br><span class=\"line\">x:0 y:1</span><br><span class=\"line\">x:1 y:1</span><br><span class=\"line\">y:1 x:1</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 还可能是</span></span><br><span class=\"line\">x:0 y:0</span><br><span class=\"line\">y:0 x:0</span><br></pre></td></tr></table></figure></p>\n<p>为什么会有 <code>x:0 y:0</code> 这种结果，在一个 <code>goroutine</code> 中，语句的执行顺序可以保证，在声明的例子，可以保证<br>执行 <code>x = 1</code> 后打印 <code>y:</code>，但是不能保证打印 <code>y:</code> 时，另一个 <code>goroutine</code> 中 <code>y = 1</code> 是否已经执行。</p>\n<p>所以可能的话，将变量限定在 <code>goroutine</code> 内部；如果是多个 <code>goroutine</code> 都需要访问的变量，使用互斥条件来访问。</p>\n<h3 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h3><ul>\n<li>不要重复锁定互斥锁；<strong>对一个已经被锁定的互斥锁进行锁定，是会立即阻塞当前的 <code>goroutine</code> 的</strong>。这个 <code>goroutine</code> 所执行的流程，<br>会一直停滞在调用该互斥锁的 <code>Lock</code> 方法的那行代码上。直到该互斥锁的 <code>Unlock</code>方法被调用，并且这里的锁定操作成功完成，后续的代码<br>（也就是临界区中的代码）才会开始执行。这也正是互斥锁能够保护临界区的原因所在。</li>\n<li>不要忘记解锁互斥锁，必要时使用 <code>defer</code> 语句；避免重复锁定。</li>\n<li>不要对尚未锁定或者已解锁的互斥锁解锁；<strong>解锁“读写锁中未被锁定的写锁”，会立即引发 panic</strong>，对于其中的读锁也是如此，并且同<br>样是不可恢复的。</li>\n<li>不要在多个函数之间直接传递互斥锁。一旦，你把一个互斥锁同时用在了多个地方，就必然会有更多的 <code>goroutine</code> 争用这把锁。<br>这不但会让你的程序变慢，还会大大增加死锁（<code>deadloc</code>k）的可能性。</li>\n</ul>\n<p>所谓的<strong>死锁</strong>，指的就是当前程序中的主 <code>goroutine</code>，以及我们启用的那些 <code>goroutine</code> 都已经被阻塞。这些 <code>goroutine</code> 可以被统<br>称为用户级的 <code>goroutine</code>。这就相当于整个程序都已经停滞不前了。</p>\n<p>Go 语言运行时系统是不允许这种情况出现的，只要它发现所有的用户级 <code>goroutine</code> 都处于等待状态，就会自行抛出一个带有如下<br>信息的 panic：<code>fatal error: all goroutines are asleep - deadlock!</code></p>\n<p><strong>注意，这种由 Go 语言运行时系统自行抛出的 panic 都属于致命错误，都是无法被恢复的，调用 recover 函数对它们起不到任何作用。<br>也就是说，一旦产生死锁，程序必然崩溃</strong>。</p>\n<p><strong>最简单、有效的方式就是让每一个互斥锁都只保护一个临界区或一组相关临界区</strong>。</p>\n<h2 id=\"条件变量-sync-Cond\"><a href=\"#条件变量-sync-Cond\" class=\"headerlink\" title=\"条件变量 sync.Cond\"></a>条件变量 sync.Cond</h2><p>条件变量是基于互斥锁的，它必须有互斥锁的支撑才能发挥作用。条件变量并不是被用来保护临界区和共享资源的，它是用于协调想要访问共享<br>资源的那些线程的。<strong>当共享资源的状态发生变化时，它可以被用来通知被互斥锁阻塞的线程</strong>。</p>\n<p>条件变量在这里的最大优势就是在效率方面的提升。当共享资源的状态不满足条件的时候，想操作它的线程再也不用循环往复地做检查了，<br>只要等待通知就好了。</p>\n<h3 id=\"条件变量怎样与互斥锁配合使用\"><a href=\"#条件变量怎样与互斥锁配合使用\" class=\"headerlink\" title=\"条件变量怎样与互斥锁配合使用\"></a>条件变量怎样与互斥锁配合使用</h3><p>条件变量的初始化离不开互斥锁，并且它的方法有的也是基于互斥锁的。</p>\n<p>条件变量提供的方法有三个：等待通知（wait）、单发通知（signal）和广播通知（broadcast）。我们在利用条件变量等待通知的时候，<br>需要在它基于的那个互斥锁保护下进行。而在进行单发通知或广播通知的时候，却是恰恰相反的，也就是说，需要在对应的互斥锁解锁之后<br>再做这两种操作。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> mailbox <span class=\"keyword\">uint8</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> lock sync.RWMutex</span><br><span class=\"line\">sendCond := sync.NewCond(&amp;lock)</span><br><span class=\"line\">recvCond := sync.NewCond(lock.RLocker())</span><br></pre></td></tr></table></figure>\n<p><code>lock</code> 是一个类型为 <code>sync.RWMutex</code> 的变量，是一个读写锁。基于这把锁，我还创建了两个代表条件变量的变量，名字分别<br>叫 <code>sendCond</code> 和 <code>recvCond</code>。</p>\n<p><strong><code>sync.Cond</code> 类型并不是开箱即用的。只能利用 <code>sync.NewCond</code> 函数创建它的指针值</strong>。</p>\n<p><code>lock</code> 变量的 <code>Lock</code> 方法和 <code>Unlock</code> 方法分别用于对其中写锁的锁定和解锁，它们与 <code>sendCond</code> 变量的含义是对应的。<br>被视为对共享资源的写操作。</p>\n<p>初始化 <code>recvCond</code>这 个条件变量，我们需要的是 <code>lock</code> 变量中的读锁，<code>sync.RWMutex</code> 类型的 <code>RLocker</code> 方法可以实现这一需求。<br><code>lock.RLocker()</code>，在其内部会分别调用 <code>lock</code> 变量的 <code>RLock</code> 方法和 <code>RUnlock</code> 方法。</p>\n<p>下面是一个例子：<br><code>mailbox</code> 是一个信箱，如果在放置的时候发现信箱里还有未被取走的情报，那就不再放置，而先返回。另一方面，如果你在获取的时候发现信<br>箱里没有情报，那也只能先回去了。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lock.Lock()</span><br><span class=\"line\"><span class=\"keyword\">for</span> mailbox == <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">    sendCond.Wait()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">mailbox = <span class=\"number\">1</span></span><br><span class=\"line\">lock.Unlock()</span><br><span class=\"line\">recvCond.Signal()</span><br></pre></td></tr></table></figure>\n<p>先调用 <code>lock</code> 变量的 <code>Lock</code> 方法。注意，这个 <code>Lock</code> 方法在这里意味的是：持有信箱上的锁，并且有打开信箱的权利，<br>而不是锁上这个锁。</p>\n<p>检查 <code>mailbox</code> 变量的值是否等于 1，也就是说，要看看信箱里是不是还存有情报。如果还有情报，那么我就回家去等通知。</p>\n<p>如果信箱里没有情报，那么我就把新情报放进去，关上信箱、锁上锁，然后离开。用代码表达出来就是 <code>mailbox = 1</code> 和 <code>lock.Unlock()</code>。<br>然后发通知，“信箱里已经有新情报了”，我们调用 <code>recvCond</code> 的 <code>Signal</code> 方法就可以实现这一步骤。</p>\n<p>另一方面，你现在是另一个 <code>goroutine</code>，想要适时地从信箱中获取情报，然后通知我。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lock.RLock()</span><br><span class=\"line\"><span class=\"keyword\">for</span> mailbox == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">    recvCond.Wait()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">mailbox = <span class=\"number\">0</span></span><br><span class=\"line\">lock.RUnlock()</span><br><span class=\"line\">sendCond.Signal()</span><br></pre></td></tr></table></figure></p>\n<p>事情在流程上其实基本一致，只不过每一步操作的对象是不同的。</p>\n<p><strong>为什么先要锁定条件变量基于的互斥锁，才能调用它的 Wait 方法？</strong></p>\n<p><code>Wait</code> 方法主要做了四件事。</p>\n<ol>\n<li>把调用它的 <code>goroutine</code>（也就是当前的 <code>goroutine</code>）加入到当前条件变量的通知队列中。</li>\n<li>解锁当前的条件变量基于的那个互斥锁。</li>\n<li>让当前的 <code>goroutine</code> 处于等待状态，等到通知到来时再决定是否唤醒它。此时，这个 <code>goroutine</code> 就会阻塞在调用这<br>个 <code>Wait</code> 方法的那行代码上。</li>\n<li>如果通知到来并且决定唤醒这个 <code>goroutine</code>，那么就在唤醒它之后重新锁定当前条件变量基于的互斥锁。自此之后，当前<br>的 <code>goroutine</code> 就会继续执行后面的代码了。</li>\n</ol>\n<p>因为条件变量的 <code>Wait</code> 方法在阻塞当前的 <code>goroutine</code> 之前会解锁它基于的互斥锁，所以在调用该 <code>Wait</code> 方法之前我们必须先<br>锁定那个互斥锁，否则在调用这个 <code>Wait</code> 方法时，就会引发一个不可恢复的 panic。</p>\n<p>为什么条件变量的 <code>Wait</code> 方法要这么做呢？你可以想象一下，如果 <code>Wait</code> 方法在互斥锁已经锁定的情况下，阻塞了当前的 <code>goroutine</code>，<br>那么又由谁来解锁呢？别的 <code>goroutine</code> 吗？</p>\n<p>先不说这违背了互斥锁的重要使用原则，即：成对的锁定和解锁，就算别的 <code>goroutine</code> 可以来解锁，那万一解锁重复了怎么办？<br>由此引发的 panic 可是无法恢复的。</p>\n<p>如果当前的 <code>goroutine</code> 无法解锁，别的 <code>goroutine</code> 也都不来解锁，那么又由谁来进入临界区，并改变共享资源的状态呢？只要共享资源<br>的状态不变，即使当前的 <code>goroutine</code> 因收到通知而被唤醒，也依然会再次执行这个 <code>Wait</code> 方法，并再次被阻塞。</p>\n<p>所以说，如果条件变量的 <code>Wait</code> 方法不先解锁互斥锁的话，那么就只会造成两种后果：不是当前的程序因 panic 而崩溃，就是相关的<br> <code>goroutine</code> 全面阻塞。</p>\n<p><strong>为什么要用 <code>for</code> 语句来包裹调用其 <code>Wait</code> 方法的表达式，用 <code>if</code> 语句不行吗？</strong></p>\n<p><code>if</code> 语句只会对共享资源的状态检查一次，而 <code>for</code> 语句却可以做多次检查，直到这个状态改变为止。</p>\n<p>那为什么要做多次检查呢？</p>\n<p>为了保险起见。如果一个 <code>goroutine</code> 因收到通知而被唤醒，但却发现共享资源的状态，依然不符合它的要求，那么就应该再次调用<br>条件变量的 <code>Wait</code> 方法，并继续等待下次通知的到来。</p>\n<p>这种情况是很有可能发生的。</p>\n<h3 id=\"条件变量的-Signal-方法和-Broadcast-方法有哪些异同\"><a href=\"#条件变量的-Signal-方法和-Broadcast-方法有哪些异同\" class=\"headerlink\" title=\"条件变量的 Signal 方法和 Broadcast 方法有哪些异同\"></a>条件变量的 <code>Signal</code> 方法和 <code>Broadcast</code> 方法有哪些异同</h3><p>条件变量的 <code>Signal</code> 方法和 <code>Broadcast</code> 方法都是被用来发送通知的，不同的是，前者的通知只会唤醒一个因此而等待的 <code>goroutine</code>，<br>而后者的通知却会唤醒所有为此等待的 <code>goroutine</code>。</p>\n<p>条件变量的 <code>Wait</code> 方法总会把当前的 <code>goroutine</code> 添加到通知队列的队尾，而它的 <code>Signal</code> 方法总会从通知队列的队首开始查找可被<br>唤醒的 <code>goroutine</code>。所以，因 <code>Signal</code> 方法的通知而被唤醒的 <code>goroutine</code> 一般都是最早等待的那一个。</p>\n<h2 id=\"原子操作\"><a href=\"#原子操作\" class=\"headerlink\" title=\"原子操作\"></a>原子操作</h2><p>Go 语言的原子操作当然是基于 CPU 和操作系统的，所以它也只针对少数数据类型的值提供了原子操作函数。这些函数都存在于标准库代<br>码包 <code>sync/atomic</code> 中。</p>\n<p><code>sync/atomic</code> 包中的函数可以做的原子操作有：加法（add）、比较并交换（compare and swap，简称 CAS）、加载（load）、<br>存储（store）和交换（swap）。</p>\n<p>这些函数针对的数据类型并不多。对这些类型中的每一个，<code>sync/atomic</code> 包都会有一套函数给予支持。这些数据类型有：<br><code>int32</code>、<code>int64</code>、<code>uint32</code>、<code>uint64</code>、<code>uintptr</code>，以及 <code>unsafe</code> 包中的 <code>Pointer</code>。不过，针对<br><code>unsafe.Pointer</code> 类型，该包并未提供进行原子加法操作的函数。</p>\n<p><code>sync/atomic</code> 包还提供了一个名为 <code>Value</code> 的类型，它可以被用来存储任意类型的值。</p>\n<p><code>atomic.AddInt32</code> 函数的第一个参数，为什么不是 <code>int32</code> 而是 <code>*int32</code> 呢？<br>因为<strong>原子操作函数需要的是被操作值的指针，而不是这个值本身</strong>；被传入函数的参数值都会被复制，像这种基本类型的值一旦被传入函数，<br>就已经与函数外的那个值毫无关系了。</p>\n<p>所以，传入值本身没有任何意义。<code>unsafe.Pointer</code> 类型虽然是指针类型，但是那些原子操作函数要操作的是这个指针值，而不是它指向<br>的那个值，所以需要的仍然是指向这个指针值的指针。</p>\n<p>只要原子操作函数拿到了被操作值的指针，就可以定位到存储该值的内存地址。只有这样，它们才能够通过底层的指令，准确地操作这个内<br>存地址上的数据。</p>\n<h2 id=\"比较并交换操作与交换操作相比有什么不同\"><a href=\"#比较并交换操作与交换操作相比有什么不同\" class=\"headerlink\" title=\"比较并交换操作与交换操作相比有什么不同\"></a>比较并交换操作与交换操作相比有什么不同</h2><p><strong>比较并交换操作即 CAS 操作</strong>，是有条件的交换操作，<strong>只有在条件满足的情况下才会进行值的交换</strong>。</p>\n<p><strong>所谓的交换指的是，把新值赋给变量，并返回变量的旧值</strong>。</p>\n<p>CAS 操作用途要更广泛一些。例如，我们将它与 <code>for</code> 语句联用就可以实现一种简易的自旋锁（spinlock）。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> atomic.CompareAndSwapInt32(&amp;num2, <span class=\"number\">10</span>, <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        fmt.Println(<span class=\"string\">\"The second number has gone to zero.\"</span>)</span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    time.Sleep(time.Millisecond * <span class=\"number\">500</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在 <code>for</code> 语句中的 CAS 操作可以不停地检查某个需要满足的条件，一旦条件满足就退出 <code>for</code> 循环。这就相当于，只要条件未被满足，<br>当前的流程就会被一直“阻塞”在这里。</p>\n<p>这在效果上与互斥锁有些类似。不过，它们的适用场景是不同的。我们在使用互斥锁的时候，总是假设共享资源的状态会被其他<br>的 <code>goroutine</code> 频繁地改变。</p>\n<p>而 <code>for</code> 语句加 CAS 操作的假设往往是：共享资源状态的改变并不频繁，或者，它的状态总会变成期望的那样。这是一种更加乐观，<br>或者说更加宽松的做法。</p>\n<p><strong>假设我已经保证了对一个变量的写操作都是原子操作，比如：加或减、存储、交换等等，那我对它进行读操作的时候，还有必要使用原<br>子操作吗</strong>？</p>\n<p>很有必要。其中的道理你可以对照一下读写锁。为什么在读写锁保护下的写操作和读操作之间是互斥的？这是为了防止读操作读到没有<br>被修改完的值，对吗？</p>\n<p>如果写操作还没有进行完，读操作就来读了，那么就只能读到仅修改了一部分的值。这显然破坏了值的完整性，读出来的值也是完全错误的。</p>\n<p>所以，一旦你决定了要对一个共享资源进行保护，那就要做到完全的保护。不完全的保护基本上与不保护没有什么区别。</p>\n<h2 id=\"sync-atomic-Value\"><a href=\"#sync-atomic-Value\" class=\"headerlink\" title=\"sync/atomic.Value\"></a><code>sync/atomic.Value</code></h2><p>此类型的值相当于一个容器，可以被用来“原子地”存储和加载任意的值。开箱即用。</p>\n<p>它只有两个指针方法—— <code>Store</code> 和 <code>Load</code>。不过，虽然简单，但还是有一些值得注意的地方的。</p>\n<ol>\n<li>一旦 <code>atomic.Value</code> 类型的值（以下简称原子值）被真正使用，它就不应该再被复制了。只要用它来存储值了，就相当于开始真正使用了。<br><code>atomic.Value</code> 类型属于结构体类型，而结构体类型属于值类型。所以，复制该类型的值会产生一个完全分离的新值。这个新值相当于被<br>复制的那个值的一个快照。之后，不论后者存储的值怎样改变，都不会影响到前者。</li>\n<li>不能用原子值存储 <code>nil</code>。</li>\n<li>我们向原子值存储的第一个值，决定了它今后能且只能存储哪一个类型的值。</li>\n<li>尽量不要向原子值中存储引用类型的值。因为这很容易造成安全漏洞。</li>\n</ol>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> box6 atomic.Value</span><br><span class=\"line\">v6 := []<span class=\"keyword\">int</span>&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>&#125;</span><br><span class=\"line\">box6.Store(v6)</span><br><span class=\"line\">v6[<span class=\"number\">1</span>] = <span class=\"number\">4</span> <span class=\"comment\">// 注意，此处的操作不是并发安全的！</span></span><br></pre></td></tr></table></figure>\n<p>切片类型属于引用类型。所以，我在外面改动这个切片值，就等于修改了 <code>box6</code> 中存储的那个值。这相当于绕过了原子值而进行了非并发<br>安全的操作。怎样修补：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">store := <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(v []<span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">    replica := <span class=\"built_in\">make</span>([]<span class=\"keyword\">int</span>, <span class=\"built_in\">len</span>(v))</span><br><span class=\"line\">    <span class=\"built_in\">copy</span>(replica, v)</span><br><span class=\"line\">    box6.Store(replica)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">store(v6)</span><br><span class=\"line\">v6[<span class=\"number\">2</span>] = <span class=\"number\">5</span> <span class=\"comment\">// 此处的操作是安全的。</span></span><br></pre></td></tr></table></figure></p>\n<p>先为切片值 <code>v6</code> 创建了一个完全的副本。这个副本涉及的数据已经与原值毫不相干了。然后，我再把这个副本存入 <code>box6</code>。如此一来，<br>无论我再对 <code>v6</code> 的值做怎样的修改，都不会破坏 <code>box6</code> 提供的安全保护。</p>\n<h2 id=\"sync-WaitGroup\"><a href=\"#sync-WaitGroup\" class=\"headerlink\" title=\"sync.WaitGroup\"></a>sync.WaitGroup</h2><p>在一些场合下里，我们使用通道的方式看起来都似乎有些蹩脚。比如：声明一个通道，使它的容量与我们手动启用的 <code>goroutine</code> 的数量相同。<br>之后利用这个通道，让主 <code>goroutine</code> 等待其他 <code>goroutine</code> 的运行结束。更具体地说就是：让其他的 <code>goroutine</code> 在运行结束之前，<br>都向这个通道发送一个元素值，并且，让主 <code>goroutine</code> 在最后从这个通道中接收元素值，接收的次数需要与其他的 <code>goroutine</code> 的数量相同。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">coordinateWithChan</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    sign := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">struct</span>&#123;&#125;, <span class=\"number\">2</span>)</span><br><span class=\"line\">    num := <span class=\"keyword\">int32</span>(<span class=\"number\">0</span>)</span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">\"The number: %d [with chan struct&#123;&#125;]\\n\"</span>, num)</span><br><span class=\"line\">    max := <span class=\"keyword\">int32</span>(<span class=\"number\">10</span>)</span><br><span class=\"line\">    <span class=\"keyword\">go</span> addNum(&amp;num, <span class=\"number\">1</span>, max, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        sign &lt;- <span class=\"keyword\">struct</span>&#123;&#125;&#123;&#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    <span class=\"keyword\">go</span> addNum(&amp;num, <span class=\"number\">2</span>, max, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        sign &lt;- <span class=\"keyword\">struct</span>&#123;&#125;&#123;&#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    &lt;-sign</span><br><span class=\"line\">    &lt;-sign</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>coordinateWithChan</code> 函数中最后的那两行代码了吗？重复的两个接收表达式 <code>&lt;-sign</code>，很丑陋。<br>我们可以选用另外一个同步工具，即：<code>sync</code> 包的 <code>WaitGroup</code> 类型。它比通道更加适合实现这种一对多的 <code>goroutine</code> 协作流程。</p>\n<p><code>sync.WaitGroup</code> 类型（以下简称 <code>WaitGroup</code> 类型）是开箱即用的，也是并发安全的。</p>\n<p><code>WaitGroup</code> 类型拥有三个指针方法：<code>Add</code>、<code>Done</code> 和 <code>Wait</code>。<strong>你可以想象该类型中有一个计数器，它的默认值是 <code>0</code>。我们可<br>以通过调用该类型值的 <code>Add</code> 方法来增加，或者减少这个计数器的值</strong>。</p>\n<p><strong>一般情况下，我会用这个方法来记录需要等待的 <code>goroutine</code> 的数量。相对应的，这个类型的 <code>Done</code> 方法，用于对其所属值中计数器<br>的值进行减一操作</strong>。我们可以在需要等待的 <code>goroutine</code> 中，通过 <code>defer</code> 语句调用它。</p>\n<p>而<strong>此类型的 <code>Wait</code> 方法的功能是，阻塞当前的 <code>goroutine</code>，直到其所属值中的计数器归零</strong>。</p>\n<p>改造版本：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">coordinateWithWaitGroup</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> wg sync.WaitGroup</span><br><span class=\"line\">\twg.Add(<span class=\"number\">2</span>)</span><br><span class=\"line\">\tnum := <span class=\"keyword\">int32</span>(<span class=\"number\">0</span>)</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"The number: %d [with sync.WaitGroup]\\n\"</span>, num)</span><br><span class=\"line\">\tmax := <span class=\"keyword\">int32</span>(<span class=\"number\">10</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">go</span> addNum(&amp;num, <span class=\"number\">3</span>, max, wg.Done)</span><br><span class=\"line\">\t<span class=\"keyword\">go</span> addNum(&amp;num, <span class=\"number\">4</span>, max, wg.Done)</span><br><span class=\"line\">\twg.Wait()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>尽量不要在 <code>go</code> 函数内部调用 <code>Add</code>，以免 <code>Add</code> 还未执行，<code>Wait</code> 已经退出</strong>：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> wg sync.WaitGroup</span><br><span class=\"line\"><span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\twg.Add(<span class=\"number\">1</span>)</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">\"test\"</span>)</span><br><span class=\"line\">&#125;()</span><br><span class=\"line\"></span><br><span class=\"line\">wg.Wait()</span><br><span class=\"line\">fmt.Println(<span class=\"string\">\"exit.\"</span>)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"sync-WaitGroup-类型值中计数器的值可以小于-0-吗\"><a href=\"#sync-WaitGroup-类型值中计数器的值可以小于-0-吗\" class=\"headerlink\" title=\"sync.WaitGroup 类型值中计数器的值可以小于 0 吗\"></a>sync.WaitGroup 类型值中计数器的值可以小于 0 吗</h3><p>不可以。<strong>小于 0，会引发一个 panic</strong>。</p>\n<p><strong><code>WaitGroup</code> 值是可以被复用的，但需要保证其计数周期的完整性</strong>。这里的计数周期指的是这样一个过程：该值中的计数器值由 0 变为<br>了某个正整数，而后又经过一系列的变化，最终由某个正整数又变回了 0。</p>\n<p>如果在一个此类值的 <code>Wait</code> 方法被执行期间，跨越了两个计数周期，那么就会引发一个 panic。</p>\n<h3 id=\"使用注意\"><a href=\"#使用注意\" class=\"headerlink\" title=\"使用注意\"></a>使用注意</h3><ul>\n<li>不要把增加其计数器值的操作和调用其 <code>Wait</code> 方法的代码，放在不同的 <code>goroutine</code> 中执行。换句话说，要<strong>杜绝对同一个<br><code>WaitGroup</code> 值的两种操作的并发执行</strong>。</li>\n</ul>\n<h2 id=\"sync-Once\"><a href=\"#sync-Once\" class=\"headerlink\" title=\"sync.Once\"></a>sync.Once</h2><p>与 <code>sync.WaitGroup</code> 类型一样，<code>sync.Once</code> 类型（以下简称 <code>Once</code> 类型）也属于结构体类型，同样也是开箱即用和并发安全的。<br>由于这个类型中包含了一个 <code>sync.Mutex</code> 类型的字段，所以，复制该类型的值也会导致功能的失效。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> loadIconsOnce sync.Once</span><br><span class=\"line\"><span class=\"keyword\">var</span> icons <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]image.Image</span><br><span class=\"line\"><span class=\"comment\">// Concurrency-safe.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Icon</span><span class=\"params\">(name <span class=\"keyword\">string</span>)</span> <span class=\"title\">image</span>.<span class=\"title\">Image</span></span> &#123;</span><br><span class=\"line\">  loadIconsOnce.Do(loadIcons)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> icons[name]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>Once</code> 类型的 <code>Do</code> 方法只接受一个参数，这个参数的类型必须是 <code>func()</code>，即：无参数声明和结果声明的函数。该方法的功能并<br>不是对每一种参数函数都只执行一次，而是只<strong>执行“首次被调用时传入的”那个函数，并且之后不会再执行任何参数函数</strong>。</p>\n<p>所以，<strong>如果你有多个只需要执行一次的函数，那么就应该为它们中的每一个都分配一个 <code>sync.Once</code> 类型的值</strong>（以下简称 <code>Once</code> 值）。</p>\n<p><code>Once</code> 类型中还有一个名叫 <code>done</code> 的 <code>uint32</code> 类型的字段。<strong>它的作用是记录其所属值的 <code>Do</code> 方法被调用的次数。不过，该字段的值<br>只可能是 0 或者 1。一旦 <code>Do</code> 方法的首次调用完成，它的值就会从 0 变为 1</strong>。</p>\n<p><strong>既然 <code>done</code> 字段的值不是 0 就是 1，那为什么还要使用需要四个字节的 <code>uint32</code> 类型呢</strong>？</p>\n<p>原因很简单，因为对它的操作必须是“原子”的。<code>Do</code> 方法在一开始就会通过调用 <code>atomic.LoadUint32</code> 函数来获取该字段的值，并且一旦<br>发现该值为 1 就会直接返回。这也初步保证了“<code>Do</code> 方法，只会执行首次被调用时传入的函数”。</p>\n<h3 id=\"Do-方法在功能方面的两个特点\"><a href=\"#Do-方法在功能方面的两个特点\" class=\"headerlink\" title=\"Do 方法在功能方面的两个特点\"></a>Do 方法在功能方面的两个特点</h3><ul>\n<li>由于 <code>Do</code> 方法只会在参数函数执行结束之后把 <code>done</code> 字段的值变为 1，因此，如果参数函数的执行需要很长时间或者根本就不会结束<br>（比如执行一些守护任务），那么就有可能会导致相关 <code>goroutine</code> 的同时阻塞</li>\n<li><code>Do</code> 方法在参数函数执行结束后，对 <code>done</code> 字段的赋值用的是原子操作，并且，这一操作是被挂在 <code>defer</code> 语句中的。因此，不论参数<br>函数的执行会以怎样的方式结束，<code>done</code> 字段的值都会变为 1。</li>\n</ul>\n<h2 id=\"context-Context-类型\"><a href=\"#context-Context-类型\" class=\"headerlink\" title=\"context.Context 类型\"></a>context.Context 类型</h2><p>使用 <code>WaitGroup</code> 值的时候，我们最好用<strong>先统一 <code>Add</code>，再并发 <code>Done</code>，最后 <code>Wait</code></strong> 的标准模式来构建协作流程。如果在调用<br>该值的 <code>Wait</code> 方法的同时，为了增大其计数器的值，而并发地调用该值的 <code>Add</code> 方法，那么就很可能会引发 panic。</p>\n<p>但是<strong>如果，我们不能在一开始就确定执行子任务的 <code>goroutine</code> 的数量，那么使用 <code>WaitGroup</code> 值来协调它们和分发子任<br>务的 <code>goroutine</code>，就是有一定风险的</strong>。一个解决方案是：<strong>分批地启用执行子任务的 <code>goroutine</code></strong>。</p>\n<p>只要我们在严格遵循上述规则的前提下，分批地启用执行子任务的 <code>goroutine</code>，就肯定不会有问题。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">coordinateWithWaitGroup</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    total := <span class=\"number\">12</span></span><br><span class=\"line\">    stride := <span class=\"number\">3</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> num <span class=\"keyword\">int32</span></span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">\"The number: %d [with sync.WaitGroup]\\n\"</span>, num)</span><br><span class=\"line\">    <span class=\"keyword\">var</span> wg sync.WaitGroup</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">1</span>; i &lt;= total; i = i + stride &#123;</span><br><span class=\"line\">        wg.Add(stride)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j := <span class=\"number\">0</span>; j &lt; stride; j++ &#123;</span><br><span class=\"line\">            <span class=\"keyword\">go</span> addNum(&amp;num, i+j, wg.Done)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        wg.Wait()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    fmt.Println(<span class=\"string\">\"End.\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"使用-context-包中的程序实体，实现一对多的-goroutine-协作流程\"><a href=\"#使用-context-包中的程序实体，实现一对多的-goroutine-协作流程\" class=\"headerlink\" title=\"使用 context 包中的程序实体，实现一对多的 goroutine 协作流程\"></a>使用 <code>context</code> 包中的程序实体，实现一对多的 goroutine 协作流程</h3><p>用 <code>context</code> 包中的函数和 <code>Context</code> 类型作为实现工具，实现 <code>coordinateWithContext</code> 的函数。这个函数应该具有上<br>面 <code>coordinateWithWaitGroup</code> 函数相同的功能。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">coordinateWithContext</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\ttotal := <span class=\"number\">12</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> num <span class=\"keyword\">int32</span></span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"The number: %d [with context.Context]\\n\"</span>, num)</span><br><span class=\"line\">\tcxt, cancelFunc := context.WithCancel(context.Background())</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">1</span>; i &lt;= total; i++ &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">go</span> addNum(&amp;num, i, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> atomic.LoadInt32(&amp;num) == <span class=\"keyword\">int32</span>(total) &#123;</span><br><span class=\"line\">\t\t\t\tcancelFunc()</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t&lt;-cxt.Done()</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">\"End.\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>先后调用了 <code>context.Background</code> 函数和 <code>context.WithCancel</code> 函数，并得到了一个可撤销的 <code>context.Context</code> 类型的值<br>（由变量 <code>cxt</code> 代表），以及一个 <code>context.CancelFunc</code>类型的撤销函数（由变量 <code>cancelFunc</code> 代表）。</p>\n<p>注意我给予 <code>addNum</code> 函数的最后一个参数值。它是一个匿名函数，其中只包含了一条 <code>if</code> 语句。这条 <code>if</code> 语句会<strong>原子地</strong>加载<br> <code>num</code> 变量的值，并判断它是否等于 <code>total</code> 变量的值。</p>\n<p>如果两个值相等，那么就调用 <code>cancelFunc</code> 函数。其含义是，如果所有的 <code>addNum</code> 函数都执行完毕，那么就立即通知分发子任务<br>的 <code>goroutine</code>。</p>\n<p><strong>这里分发子任务的 <code>goroutine</code>，即为执行 <code>coordinateWithContext</code> 函数的 <code>goroutine</code></strong>。它在执行完 <code>for</code> 语句后，会<br>立即调用 <code>cxt</code> 变量的 <code>Done</code> 函数，并试图针对该函数返回的通道，进行接收操作。</p>\n<p>一旦 <code>cancelFunc</code> 函数被调用，针对该通道的接收操作就会马上结束，所以，这样做就可以实现“等待所有的 <code>addNum</code> 函数都执<br>行完毕”的功能。</p>\n<h3 id=\"context-Context-类型-1\"><a href=\"#context-Context-类型-1\" class=\"headerlink\" title=\"context.Context 类型\"></a>context.Context 类型</h3><p><code>Context</code> 类型的值（以下简称 <code>Context</code> 值）是可以繁衍的，这意味着我们可以通过一个 <code>Context</code> 值产生出任意个子值。这些子值<br>可以携带其父值的属性和数据，也可以响应通过其父值传达的信号。</p>\n<p>正因为如此，所有的 <code>Context</code> 值共同构成了一颗代表了上下文全貌的树形结构。这棵树的<strong>树根（或者称上下文根节点）是一个已经<br>在 <code>context</code> 包中预定义好的 <code>Context</code> 值</strong>，它是<strong>全局唯一</strong>的。通过调用 <code>context.Background</code> 函数，我们就可以获取到<br>它（在 <code>coordinateWithContext</code> 函数中就是这么做的）。</p>\n<p>注意一下，这个<strong>上下文根节点仅仅是一个最基本的支点，它不提供任何额外的功能</strong>。也就是说，它既不可以被撤销（<code>cancel</code>），<br>也不能携带任何数据。</p>\n<p><code>context</code> 包中还包含了<strong>四个用于繁衍 <code>Context</code> 值的函数，即：<code>WithCancel</code>、<code>WithDeadline</code>、<code>WithTimeout</code> 和 <code>WithValue</code></strong>。</p>\n<p>这些函数的第一个参数的类型都是 <code>context.Context</code>，而名称都为 <code>parent</code>。顾名思义，<strong>这个位置上的参数对应的都是它们将会产生<br>的 <code>Context</code> 值的父值</strong>。</p>\n<p><strong><code>WithCancel</code> 函数用于产生一个可撤销的 parent 的子值</strong>。</p>\n<p>在 <code>coordinateWithContext</code> 函数中，通过调用该函数，获得了一个衍生自上下文根节点的 <code>Context</code> 值，和一个用于触发撤销信号的函数。</p>\n<p><code>WithDeadline</code> 函数和 <code>WithTimeout</code> 函数则都可以被用来产生一个会<strong>定时撤销</strong>的 <code>parent</code> 的子值。至于 <code>WithValue</code> 函数，<br>我们可以通过调用它，产生一个会携带额外数据的 <code>parent</code> 的子值。</p>\n<h3 id=\"“可撤销的”在-context-包中代表着什么？“撤销”一个-Context-值又意味着什么？\"><a href=\"#“可撤销的”在-context-包中代表着什么？“撤销”一个-Context-值又意味着什么？\" class=\"headerlink\" title=\"“可撤销的”在 context 包中代表着什么？“撤销”一个 Context 值又意味着什么？\"></a>“可撤销的”在 context 包中代表着什么？“撤销”一个 Context 值又意味着什么？</h3><p>这需要从 <code>Context</code> 类型的声明讲起。这个接口中有两个方法与“撤销”息息相关。<code>Done</code> 方法会返回一个元素类型为 <code>struct{}</code> 的接<br>收通道。不过，这个接收通道的用途并不是传递元素值，而是<strong>让调用方去感知“撤销”当前Context值的那个信号</strong>。</p>\n<p>一旦当前的 <code>Context</code> 值被撤销，这里的接收通道就会被立即关闭。我们都知道，对于一个未包含任何元素值的通道来说，它的关闭会<br>使任何针对它的接收操作立即结束。</p>\n<p>正因为如此，在 <code>coordinateWithContext</code> 函数中，基于调用表达式 <code>cxt.Done()</code> 的接收操作，才能够起到感知撤销信号的作用。</p>\n<h3 id=\"撤销信号是如何在上下文树中传播的\"><a href=\"#撤销信号是如何在上下文树中传播的\" class=\"headerlink\" title=\"撤销信号是如何在上下文树中传播的\"></a>撤销信号是如何在上下文树中传播的</h3><p><code>context</code>包的 <code>WithCancel</code> 函数在被调用后会产生两个结果值。第一个结果值就是那个可撤销的 <code>Context</code> 值，而第二个结果值则是<br>用于触发撤销信号的函数。</p>\n<p>在撤销函数被调用之后，对应的 <code>Context</code> 值会先关闭它内部的接收通道，也就是它的 <code>Done</code> 方法会返回的那个通道。</p>\n<p>然后，它会向它的所有子值（或者说子节点）传达撤销信号。这些子值会如法炮制，把撤销信号继续传播下去。最后，这个 <code>Context</code> 值会<br>断开它与其父值之间的关联。</p>\n<p><strong>通过调用 <code>context.WithValue</code> 函数得到的 <code>Context</code> 值是不可撤销的</strong>。</p>\n<h3 id=\"怎样通过-Context-值携带数据\"><a href=\"#怎样通过-Context-值携带数据\" class=\"headerlink\" title=\"怎样通过 Context 值携带数据\"></a>怎样通过 Context 值携带数据</h3><p><strong><code>WithValue</code> 函数在产生新的 <code>Context</code> 值（以下简称含数据的 <code>Context</code> 值）的时候需要三个参数，即：父值、键和值</strong>。<br>“字典对于键的约束”类似，这里<strong>键的类型必须是可判等</strong>的。</p>\n<p>原因很简单，当我们从中获取数据的时候，它需要根据给定的键来查找对应的值。不过，这种 <code>Context</code> 值并不是用字典来存储键和值的，<br>后两者只是被简单地存储在前者的相应字段中而已。</p>\n<h2 id=\"临时对象池-sync-Pool\"><a href=\"#临时对象池-sync-Pool\" class=\"headerlink\" title=\"临时对象池 sync.Pool\"></a>临时对象池 sync.Pool</h2><p> Go 语言标准库中最重要的那几个同步工具，这包括:</p>\n<ul>\n<li>互斥锁</li>\n<li>读写锁</li>\n<li>条件变量</li>\n<li>原子操作</li>\n<li><code>sync/atomic.Value</code></li>\n<li><code>sync.Once</code></li>\n<li><code>sync.WaitGroup</code></li>\n<li><code>context.Context</code></li>\n</ul>\n<p>Go 语言标准库中的还有另一个同步工具：<code>sync.Pool</code>。</p>\n<p><code>sync.Pool</code> 类型可以被称为临时对象池，它的值可以被用来存储临时的对象。与 Go 语言的很多同步工具一样，<code>sync.Pool</code> 类型也属<br>于结构体类型，它的值在被真正使用之后，就不应该再被复制了。</p>\n<p><strong>临时对象</strong>的意思是：不需要持久使用的某一类值。这类值对于程序来说可有可无，但如果有的话会明显更好。它们的创建和销毁可以在<br>任何时候发生，并且完全不会影响到程序的功能。</p>\n<p><strong>我们可以把临时对象池当作针对某种数据的缓存来用</strong>。</p>\n<p><code>sync.Pool</code> 类型只有两个方法——<code>Put</code> 和 <code>Get</code>。前者用于在当前的池中存放临时对象，它接受一个 <code>interface{}</code> 类型的参数；<br>而后者则被用于从当前的池中获取临时对象，它会返回一个 <code>interface{}</code> 类型的值。</p>\n<p>更具体地说，<strong>这个类型的 <code>Get</code> 方法可能会从当前的池中删除掉任何一个值，然后把这个值作为结果返回。如果此时当前的池中没有任何值，<br>那么这个方法就会使用当前池的 <code>New</code> 字段创建一个新值，并直接将其返回</strong>。</p>\n<p><code>sync.Pool</code> 类型的 <code>New</code> 字段代表着创建临时对象的函数。它的类型是没有参数但有唯一结果的函数类型，即：<code>func() interface{}</code>。<br><strong>初始化这个池的时候最好给定它</strong>。</p>\n<p>这个函数是 <code>Get</code> 方法最后的临时对象获取手段。<code>Get</code> 方法如果到了最后，仍然无法获取到一个值，那么就会调用该函数。该函数的结<br>值并不会被存入当前的临时对象池中，而是直接返回给 <code>Get</code> 方法的调用方。</p>\n<p><strong>临时对象池中存储的每一个值都应该是独立的、平等的和可重用的</strong>。<code>sync.Pool</code> 的定位不是做类似连接池的东西，它的用途仅仅是增加<br>对象重用的几率，减少 gc 的负担。因为 gc 带来了编程的方便但同时也增加了运行时开销，使用不当甚至会严重影响程序的性能。因此性能<br>要求高的场景不能任意产生太多的垃圾。如何解决呢？那就是要重用对象了。</p>\n<p>一个比较好的例子是 <code>fmt</code> 包，<code>fmt</code> 包总是需要使用一些 <code>[]byte</code> 之类的对象，golang 建立了一个临时对象池，存放着这些对象，<br>如果需要使用一个 <code>[]byte</code>，就去 <code>Pool</code> 里面拿，如果拿不到就分配一份。这比起不停生成新的 <code>[]byte</code>，用完了再等待 gc 回收<br>来要高效得多。</p>\n<p><code>sync.Pool</code> 缓存对象的期限是很诡异的，先看一下 <code>src/pkg/sync/pool.go</code> 里面的一段实现代码：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">init</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    runtime_registerPoolCleanup(poolCleanup)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以看到 <code>pool</code> 包在 <code>init</code> 的时候注册了一个 <code>poolCleanup</code> 函数，它会清除所有的 <code>pool</code> 里面的所有缓存的对象，该函数注册进去<br>之后会在每次 gc 之前都会调用，因此 <strong><code>sync.Pool</code> 缓存的期限只是两次gc之间这段时间</strong>。</p>\n<h2 id=\"sync-Map\"><a href=\"#sync-Map\" class=\"headerlink\" title=\"sync.Map\"></a>sync.Map</h2><p>Go 语言自带的字典类型 <code>map</code> 并不是并发安全的。换句话说，在同一时间段内，让不同 goroutine 中的代码，对同一个字典进行读写操<br>作是不安全的。</p>\n<p>Go 语言官方终于在 2017 年发布的 Go 1.9 中正式加入了并发安全的字典类型 <code>sync.Map</code>。</p>\n<p>使用 <code>sync.Map</code> 可以显著地减少锁的争用。<code>sync.Map</code> 本身虽然也用到了锁，但是，它其实在尽可能地避免使用锁。</p>\n<p><strong>使用锁就意味着要把一些并发的操作强制串行化。这往往会降低程序的性能，尤其是在计算机拥有多个 CPU 核心的情况下</strong>。</p>\n<p>由于<strong>并发安全字典内部使用的存储介质正是原生字典，又因为它使用的原生字典键类型也是可以包罗万象的 <code>interface{}</code>，所以，<br>我们绝对不能带着任何实际类型为函数类型、字典类型或切片类型的键值去操作并发安全字典</strong>。</p>\n<p>因为<strong>这些键值的实际类型只有在程序运行期间才能够确定，所以 Go 语言编译器是无法在编译期对它们进行检查的，不正确的键值实际类<br>型肯定会引发 panic</strong>。</p>\n<p><strong>因此，我们在这里首先要做的一件事就是：一定不要违反上述规则。我们应该在每次操作并发安全字典的时候，都去显式地检查键值的实际<br>类型。无论是存、取还是删，都应该如此</strong>。</p>\n<blockquote>\n<p><strong>更好的做法是，把针对同一个并发安全字典的这几种操作都集中起来，然后统一地编写检查代码。除此之外，把并发安全字典封装在一<br>个结构体类型中，往往是一个很好的选择</strong>。如果你实在拿不准，那么可以先通过调用 <code>reflect.TypeOf</code> 函数得到一个键值对应的反射类<br>型值（即：<code>reflect.Type</code> 类型的值），然后再调用这个值的 <code>Comparable</code> 方法，得到确切的判断结果。</p>\n</blockquote>\n<h3 id=\"并发安全字典如何做到尽量避免使用锁\"><a href=\"#并发安全字典如何做到尽量避免使用锁\" class=\"headerlink\" title=\"并发安全字典如何做到尽量避免使用锁\"></a>并发安全字典如何做到尽量避免使用锁</h3><p><code>sync.Map</code> 类型在内部使用了<strong>大量的原子操作来存取键和值，并使用了两个原生的 map 作为存储介质</strong>。</p>\n<p>其中一个原生 map 被存在了 <code>sync.Map</code> 的 <code>read</code> 字段中，该字段是 <code>sync/atomic.Value</code> 类型的。简称它为<strong>只读字典</strong>。</p>\n<p><strong>只读字典虽然不会增减其中的键，但却允许变更其中的键所对应的值</strong>。所以，它并不是传统意义上的快照，它的只读特性只是对于其中键<br>的集合而言的。</p>\n<p>由 <code>read</code> 字段的类型可知，<code>sync.Map</code> 在替换只读字典的时候根本用不着锁。另外，这个只读字典在存储键值对的时候，还在值之上<br>封装了一层。</p>\n<p>它先把值转换为了 <code>unsafe.Pointer</code> 类型的值，然后再把后者封装，并储存在其中的原生字典中。如此一来，在变更某个键所对应的值<br>的时候，就也可以使用原子操作了。</p>\n<p><code>sync.Map</code> 中的另一个原生字典由它的 <code>dirty</code> 字段代表。它存储键值对的方式与 <code>read</code> 字段中的原生字典一致，它的键类型<br>也是 <code>interface{}</code>，并且同样是把值先做转换和封装后再进行储存的。称为<strong>脏字典</strong>。</p>\n<blockquote>\n<p>脏字典和只读字典如果都存有同一个键值对，那么这里的两个键指的肯定是同一个基本值，对于两个值来说也是如此。正如前文所述，<br>这两个字典在存储键和值的时候都只会存入它们的某个指针，而不是基本值。</p>\n</blockquote>\n<p><code>sync.Map</code> 在查找指定的键所对应的值的时候，总会先去只读字典中寻找，并不需要锁定互斥锁。只有当确定<strong>只读字典中没有，但脏<br>字典中可能会有这个键</strong>的时候，它才会在锁的保护下去访问脏字典。</p>\n<p>相对应的，<code>sync.Map</code> 在存储键值对的时候，只要只读字典中已存有这个键，并且该键值对未被标记为“已删除”，就会把新值存到里面并<br>直接返回，这种情况下也不需要用到锁。</p>\n<p>否则，它才会在锁的保护下把键值对存储到脏字典中。这个时候，该键值对的“已删除”标记会被抹去。</p>\n<p>只有当一个键值对应该被删除，但却仍然存在于只读字典中的时候，才会被用标记为“已删除”的方式进行逻辑删除，而不会直接被物理删除。<br>这种情况会在重建脏字典以后的一段时间内出现。不过，过不了多久，它们就会被真正删除掉。在查找和遍历键值对的时候，已被逻<br>辑删除的键值对永远会被无视。</p>\n<p>最后，<code>sync.Map</code> 会把该键值对中指向值的那个指针置为 <code>nil</code> ，这是另一种逻辑删除的方式。</p>\n<p>除此之外，还有一个细节需要注意，只读字典和脏字典之间是会互相转换的。在脏字典中查找键值对次数足够多的时候，<code>sync.Map</code> 会把<br>脏字典直接作为只读字典，保存在它的 <code>read</code> 字段中，然后把代表脏字典的 <code>dirty</code> 字段的值置为 <code>nil</code>。</p>\n<p>在这之后，一旦再有新的键值对存入，它就会依据只读字典去重建脏字典。这个时候，它会把只读字典中已被逻辑删除的键值对过滤掉。<br>理所当然，这些转换操作肯定都需要在锁的保护下进行。</p>\n<p><strong><code>sync.Map</code> 的只读字典和脏字典中的键值对集合并不是实时同步的，它们在某些时间段内可能会有不同</strong>。</p>\n<p>可以看出，在读操作有很多但写操作却很少的情况下，并发安全字典的性能往往会更好。在几个写操作当中，新增键值对的操作对并发安<br>全字典的性能影响是最大的，其次是删除操作，最后才是修改操作。</p>\n<p>如果被操作的键值对已经存在于 <code>sync.Map</code> 的只读字典中，并且没有被逻辑删除，那么修改它并不会使用到锁，对其性能的影响就会很小。</p>\n<h2 id=\"竞争检查器\"><a href=\"#竞争检查器\" class=\"headerlink\" title=\"竞争检查器\"></a>竞争检查器</h2><p>在 <code>go build</code>，<code>go run</code> 或者 <code>go test</code> 命令后面加上 <code>-race</code>，就会使编译器创建一个你的应用的“修改”版。</p>\n<p>会记录下每一个读或者写共享变量的 <code>goroutine</code> 的身份信息。记录下所有的同步事件，比如 <code>go</code> 语句，<code>channel</code> 操作，<br>以及对 <code>(*sync.Mutex).Lock</code>，<code>(*sync.WaitGroup).Wait</code> 等等的调用。</p>\n<p>由于需要额外的记录，因此构建时加了竞争检测的程序跑起来会慢一些，且需要更大的内存，即使是这样，这些代价对于很多生产环境的<br>工作来说还是可以接受的。</p>\n","site":{"data":{"navigation":{"logo":{"text":"Golang Learn","type":"link","path":"index.html"},"main":[{"text":"Golang 基础","type":"label"},{"text":"Go 环境配置","type":"link","path":"basic/env_config.html"},{"text":"包","type":"link","path":"basic/package.html"},{"text":"基础数据类型","type":"link","path":"basic/basic_data.html"},{"text":"变量","type":"link","path":"basic/var.html"},{"text":"常量","type":"link","path":"basic/constant.html"},{"text":"控制语句","type":"link","path":"basic/flow.html"},{"text":"运算符","type":"link","path":"basic/operator.html"},{"text":"作用域","type":"link","path":"basic/scope.html"},{"text":"指针","type":"link","path":"basic/pointer.html"},{"text":"数组","type":"link","path":"basic/array.html"},{"text":"切片","type":"link","path":"basic/slice.html"},{"text":"字典","type":"link","path":"basic/map.html"},{"text":"函数","type":"link","path":"basic/function.html"},{"text":"结构体","type":"link","path":"basic/struct.html"},{"text":"接口","type":"link","path":"basic/interface.html"},{"text":"面向对象","type":"link","path":"basic/oop.html"},{"text":"错误","type":"link","path":"basic/error.html"},{"text":"序列化","type":"link","path":"basic/json.html"},{"text":"反射","type":"link","path":"basic/reflect.html"},{"text":"测试","type":"link","path":"basic/test.html"},{"text":"并发编程","type":"label"},{"text":"goroutine","type":"link","path":"concurrent/goroutine.html"},{"text":"channel","type":"link","path":"concurrent/channel.html"},{"text":"同步和锁","type":"link","path":"concurrent/sync_lock.html"},{"text":"内存分配","type":"label"},{"text":"内存分配","type":"link","path":"advance/mm.html"},{"text":"垃圾回收","type":"label"},{"text":"垃圾回收","type":"link","path":"advance/gc.html"},{"text":"标准库","type":"label"},{"text":"fmt","type":"link","path":"standards/io/fmt.html"},{"text":"io","type":"link","path":"standards/io/io.html"},{"text":"ioutil","type":"link","path":"standards/io/ioutil.html"},{"text":"bufio","type":"link","path":"standards/io/bufio.html"},{"text":"os","type":"link","path":"standards/os/os.html"},{"text":"filepath","type":"link","path":"standards/os/filepath.html"},{"text":"strings","type":"link","path":"standards/text/strings.html"},{"text":"strconv","type":"link","path":"standards/text/strconv.html"},{"text":"unicode","type":"link","path":"standards/text/unicode.html"},{"text":"log","type":"link","path":"standards/log.html"},{"text":"time","type":"link","path":"standards/time.html"},{"text":"http","type":"link","path":"standards/net/http.html"},{"text":"math","type":"link","path":"standards/data/math.html"},{"text":"sort","type":"link","path":"standards/data/sort.html"},{"text":"big","type":"link","path":"standards/data/big.html"},{"text":"container","type":"link","path":"standards/data/container.html"},{"text":"sql","type":"link","path":"standards/database/sql.html"},{"text":"THEME","type":"label"},{"text":"使用文档主题","type":"link","path":"theme/theme-usage.html"},{"text":"SUPPORT AND FEEDBACK","type":"label"},{"text":"Raise an Issue on Github","type":"link","path":"https://github.com/shipengqi/golang-learn/issues/new"}]}}},"excerpt":"","more":"<h1 id=\"同步和锁\"><a href=\"#同步和锁\" class=\"headerlink\" title=\"同步和锁\"></a>同步和锁</h1><h2 id=\"共享变量\"><a href=\"#共享变量\" class=\"headerlink\" title=\"共享变量\"></a>共享变量</h2><p>无论任何时候，只要有两个以上 <code>goroutine</code> 并发访问同一变量，且至少其中的一个是写操作的时候就会发生数据竞争。<br>避免数据竞争的三种方式：</p>\n<ol>\n<li>不去写变量。读取不可能出现数据竞争。</li>\n<li>避免从多个 <code>goroutine</code> 访问变量，尽量把变量限定在了一个单独的 <code>goroutine</code> 中。(<strong>不要使用共享数据来通信，使用通信<br>来共享数据</strong>)</li>\n<li>互斥锁</li>\n</ol>\n<h2 id=\"同步锁\"><a href=\"#同步锁\" class=\"headerlink\" title=\"同步锁\"></a>同步锁</h2><p>Go 语言包中的 <code>sync</code> 包提供了两种锁类型：<code>sync.Mutex</code> 和 <code>sync.RWMutex</code>，前者是互斥锁，后者是读写锁。</p>\n<h3 id=\"互斥锁\"><a href=\"#互斥锁\" class=\"headerlink\" title=\"互斥锁\"></a>互斥锁</h3><h4 id=\"使用-channel-实现互斥所\"><a href=\"#使用-channel-实现互斥所\" class=\"headerlink\" title=\"使用 channel 实现互斥所\"></a>使用 channel 实现互斥所</h4><p>我们可以使用容量只有 <code>1</code> 的 <code>channel</code> 来保证最多只有一个 <code>goroutine</code> 在同一时刻访问一个共享变量：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> (</span><br><span class=\"line\">  sema = <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">struct</span>&#123;&#125;, <span class=\"number\">1</span>) <span class=\"comment\">// a binary semaphore guarding balance</span></span><br><span class=\"line\">  balance <span class=\"keyword\">int</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Deposit</span><span class=\"params\">(amount <span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">  sema &lt;- <span class=\"keyword\">struct</span>&#123;&#125;&#123;&#125; <span class=\"comment\">// acquire lock</span></span><br><span class=\"line\">  balance = balance + amount</span><br><span class=\"line\">  &lt;-sema <span class=\"comment\">// release lock</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Balance</span><span class=\"params\">()</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">  sema &lt;- <span class=\"keyword\">struct</span>&#123;&#125;&#123;&#125; <span class=\"comment\">// acquire lock</span></span><br><span class=\"line\">  b := balance</span><br><span class=\"line\">  &lt;-sema <span class=\"comment\">// release lock</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> b</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"sync-Mutex\"><a href=\"#sync-Mutex\" class=\"headerlink\" title=\"sync.Mutex\"></a>sync.Mutex</h4><p>使用 <code>sync.Mutex</code> 互斥锁：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"sync\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> (</span><br><span class=\"line\">  mu sync.Mutex <span class=\"comment\">// guards balance</span></span><br><span class=\"line\">  balance <span class=\"keyword\">int</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Deposit</span><span class=\"params\">(amount <span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">  mu.Lock()</span><br><span class=\"line\">  balance = balance + amount</span><br><span class=\"line\">  mu.Unlock()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Balance</span><span class=\"params\">()</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">  mu.Lock()</span><br><span class=\"line\">  b := balance</span><br><span class=\"line\">  mu.Unlock()</span><br><span class=\"line\">  <span class=\"keyword\">return</span> b</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>mutex</code> 会保护共享变量，当已经有 <code>goroutine</code> 获得这个锁，再有 <code>goroutine</code> 访问这个加锁的变量就会被阻塞，<br>直到持有这个锁的 <code>goroutine</code> <code>unlock</code> 这个锁。</p>\n<p>我们可以<strong>使用 <code>defer</code> 来 <code>unlock</code> 锁，保证在函数返回之后或者发生错误返回时一定会执行 <code>unlock</code></strong>。</p>\n<h3 id=\"读写锁-sync-RWMutex\"><a href=\"#读写锁-sync-RWMutex\" class=\"headerlink\" title=\"读写锁 sync.RWMutex\"></a>读写锁 <code>sync.RWMutex</code></h3><p>如果有多个 <code>goroutine</code> 读取变量，那么是并发安全的，这个时候使用 <code>sync.Mutex</code> 加锁就没有必要。可以使<br>用 <code>sync.RWMutex</code> 读写锁（多读单写锁）。</p>\n<p><strong>读写锁是把对共享资源的“读操作”和“写操作”区别对待了。它可以对这两种操作施加不同程度的保护</strong>。</p>\n<p>一个读写锁中实际上包含了两个锁，即：读锁和写锁。<code>sync.RWMutex</code> 类型中的 <code>Lock</code> 方法和 <code>Unlock</code> 方法分别用于对写锁进行<br>锁定和解锁，而它的 <code>RLock</code> 方法和 <code>RUnlock</code> 方法则分别用于对读锁进行锁定和解锁。</p>\n<p><strong>对于某个受到读写锁保护的共享资源，多个写操作不能同时进行，写操作和读操作也不能同时进行，但多个读操作却可以同时进行</strong>。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> mu sync.RWMutex</span><br><span class=\"line\"><span class=\"keyword\">var</span> balance <span class=\"keyword\">int</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Balance</span><span class=\"params\">()</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">  mu.RLock() <span class=\"comment\">// readers lock</span></span><br><span class=\"line\">  <span class=\"keyword\">defer</span> mu.RUnlock()</span><br><span class=\"line\">  <span class=\"keyword\">return</span> balance</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong><code>RLock</code> 只能在共享变量没有任何写入操作时可用</strong>。</p>\n<p><strong>为什么只读操作也需要加锁</strong>？<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x, y <span class=\"keyword\">int</span></span><br><span class=\"line\"><span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  x = <span class=\"number\">1</span> <span class=\"comment\">// A1</span></span><br><span class=\"line\">  fmt.Print(<span class=\"string\">\"y:\"</span>, y, <span class=\"string\">\" \"</span>) <span class=\"comment\">// A2</span></span><br><span class=\"line\">&#125;()</span><br><span class=\"line\"><span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  y = <span class=\"number\">1</span>                   <span class=\"comment\">// B1</span></span><br><span class=\"line\">  fmt.Print(<span class=\"string\">\"x:\"</span>, x, <span class=\"string\">\" \"</span>) <span class=\"comment\">// B2</span></span><br><span class=\"line\">&#125;()</span><br></pre></td></tr></table></figure></p>\n<p>上面的代码打印的结果可能是：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">y:0 x:1</span><br><span class=\"line\">x:0 y:1</span><br><span class=\"line\">x:1 y:1</span><br><span class=\"line\">y:1 x:1</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 还可能是</span></span><br><span class=\"line\">x:0 y:0</span><br><span class=\"line\">y:0 x:0</span><br></pre></td></tr></table></figure></p>\n<p>为什么会有 <code>x:0 y:0</code> 这种结果，在一个 <code>goroutine</code> 中，语句的执行顺序可以保证，在声明的例子，可以保证<br>执行 <code>x = 1</code> 后打印 <code>y:</code>，但是不能保证打印 <code>y:</code> 时，另一个 <code>goroutine</code> 中 <code>y = 1</code> 是否已经执行。</p>\n<p>所以可能的话，将变量限定在 <code>goroutine</code> 内部；如果是多个 <code>goroutine</code> 都需要访问的变量，使用互斥条件来访问。</p>\n<h3 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h3><ul>\n<li>不要重复锁定互斥锁；<strong>对一个已经被锁定的互斥锁进行锁定，是会立即阻塞当前的 <code>goroutine</code> 的</strong>。这个 <code>goroutine</code> 所执行的流程，<br>会一直停滞在调用该互斥锁的 <code>Lock</code> 方法的那行代码上。直到该互斥锁的 <code>Unlock</code>方法被调用，并且这里的锁定操作成功完成，后续的代码<br>（也就是临界区中的代码）才会开始执行。这也正是互斥锁能够保护临界区的原因所在。</li>\n<li>不要忘记解锁互斥锁，必要时使用 <code>defer</code> 语句；避免重复锁定。</li>\n<li>不要对尚未锁定或者已解锁的互斥锁解锁；<strong>解锁“读写锁中未被锁定的写锁”，会立即引发 panic</strong>，对于其中的读锁也是如此，并且同<br>样是不可恢复的。</li>\n<li>不要在多个函数之间直接传递互斥锁。一旦，你把一个互斥锁同时用在了多个地方，就必然会有更多的 <code>goroutine</code> 争用这把锁。<br>这不但会让你的程序变慢，还会大大增加死锁（<code>deadloc</code>k）的可能性。</li>\n</ul>\n<p>所谓的<strong>死锁</strong>，指的就是当前程序中的主 <code>goroutine</code>，以及我们启用的那些 <code>goroutine</code> 都已经被阻塞。这些 <code>goroutine</code> 可以被统<br>称为用户级的 <code>goroutine</code>。这就相当于整个程序都已经停滞不前了。</p>\n<p>Go 语言运行时系统是不允许这种情况出现的，只要它发现所有的用户级 <code>goroutine</code> 都处于等待状态，就会自行抛出一个带有如下<br>信息的 panic：<code>fatal error: all goroutines are asleep - deadlock!</code></p>\n<p><strong>注意，这种由 Go 语言运行时系统自行抛出的 panic 都属于致命错误，都是无法被恢复的，调用 recover 函数对它们起不到任何作用。<br>也就是说，一旦产生死锁，程序必然崩溃</strong>。</p>\n<p><strong>最简单、有效的方式就是让每一个互斥锁都只保护一个临界区或一组相关临界区</strong>。</p>\n<h2 id=\"条件变量-sync-Cond\"><a href=\"#条件变量-sync-Cond\" class=\"headerlink\" title=\"条件变量 sync.Cond\"></a>条件变量 sync.Cond</h2><p>条件变量是基于互斥锁的，它必须有互斥锁的支撑才能发挥作用。条件变量并不是被用来保护临界区和共享资源的，它是用于协调想要访问共享<br>资源的那些线程的。<strong>当共享资源的状态发生变化时，它可以被用来通知被互斥锁阻塞的线程</strong>。</p>\n<p>条件变量在这里的最大优势就是在效率方面的提升。当共享资源的状态不满足条件的时候，想操作它的线程再也不用循环往复地做检查了，<br>只要等待通知就好了。</p>\n<h3 id=\"条件变量怎样与互斥锁配合使用\"><a href=\"#条件变量怎样与互斥锁配合使用\" class=\"headerlink\" title=\"条件变量怎样与互斥锁配合使用\"></a>条件变量怎样与互斥锁配合使用</h3><p>条件变量的初始化离不开互斥锁，并且它的方法有的也是基于互斥锁的。</p>\n<p>条件变量提供的方法有三个：等待通知（wait）、单发通知（signal）和广播通知（broadcast）。我们在利用条件变量等待通知的时候，<br>需要在它基于的那个互斥锁保护下进行。而在进行单发通知或广播通知的时候，却是恰恰相反的，也就是说，需要在对应的互斥锁解锁之后<br>再做这两种操作。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> mailbox <span class=\"keyword\">uint8</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> lock sync.RWMutex</span><br><span class=\"line\">sendCond := sync.NewCond(&amp;lock)</span><br><span class=\"line\">recvCond := sync.NewCond(lock.RLocker())</span><br></pre></td></tr></table></figure>\n<p><code>lock</code> 是一个类型为 <code>sync.RWMutex</code> 的变量，是一个读写锁。基于这把锁，我还创建了两个代表条件变量的变量，名字分别<br>叫 <code>sendCond</code> 和 <code>recvCond</code>。</p>\n<p><strong><code>sync.Cond</code> 类型并不是开箱即用的。只能利用 <code>sync.NewCond</code> 函数创建它的指针值</strong>。</p>\n<p><code>lock</code> 变量的 <code>Lock</code> 方法和 <code>Unlock</code> 方法分别用于对其中写锁的锁定和解锁，它们与 <code>sendCond</code> 变量的含义是对应的。<br>被视为对共享资源的写操作。</p>\n<p>初始化 <code>recvCond</code>这 个条件变量，我们需要的是 <code>lock</code> 变量中的读锁，<code>sync.RWMutex</code> 类型的 <code>RLocker</code> 方法可以实现这一需求。<br><code>lock.RLocker()</code>，在其内部会分别调用 <code>lock</code> 变量的 <code>RLock</code> 方法和 <code>RUnlock</code> 方法。</p>\n<p>下面是一个例子：<br><code>mailbox</code> 是一个信箱，如果在放置的时候发现信箱里还有未被取走的情报，那就不再放置，而先返回。另一方面，如果你在获取的时候发现信<br>箱里没有情报，那也只能先回去了。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lock.Lock()</span><br><span class=\"line\"><span class=\"keyword\">for</span> mailbox == <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">    sendCond.Wait()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">mailbox = <span class=\"number\">1</span></span><br><span class=\"line\">lock.Unlock()</span><br><span class=\"line\">recvCond.Signal()</span><br></pre></td></tr></table></figure>\n<p>先调用 <code>lock</code> 变量的 <code>Lock</code> 方法。注意，这个 <code>Lock</code> 方法在这里意味的是：持有信箱上的锁，并且有打开信箱的权利，<br>而不是锁上这个锁。</p>\n<p>检查 <code>mailbox</code> 变量的值是否等于 1，也就是说，要看看信箱里是不是还存有情报。如果还有情报，那么我就回家去等通知。</p>\n<p>如果信箱里没有情报，那么我就把新情报放进去，关上信箱、锁上锁，然后离开。用代码表达出来就是 <code>mailbox = 1</code> 和 <code>lock.Unlock()</code>。<br>然后发通知，“信箱里已经有新情报了”，我们调用 <code>recvCond</code> 的 <code>Signal</code> 方法就可以实现这一步骤。</p>\n<p>另一方面，你现在是另一个 <code>goroutine</code>，想要适时地从信箱中获取情报，然后通知我。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lock.RLock()</span><br><span class=\"line\"><span class=\"keyword\">for</span> mailbox == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">    recvCond.Wait()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">mailbox = <span class=\"number\">0</span></span><br><span class=\"line\">lock.RUnlock()</span><br><span class=\"line\">sendCond.Signal()</span><br></pre></td></tr></table></figure></p>\n<p>事情在流程上其实基本一致，只不过每一步操作的对象是不同的。</p>\n<p><strong>为什么先要锁定条件变量基于的互斥锁，才能调用它的 Wait 方法？</strong></p>\n<p><code>Wait</code> 方法主要做了四件事。</p>\n<ol>\n<li>把调用它的 <code>goroutine</code>（也就是当前的 <code>goroutine</code>）加入到当前条件变量的通知队列中。</li>\n<li>解锁当前的条件变量基于的那个互斥锁。</li>\n<li>让当前的 <code>goroutine</code> 处于等待状态，等到通知到来时再决定是否唤醒它。此时，这个 <code>goroutine</code> 就会阻塞在调用这<br>个 <code>Wait</code> 方法的那行代码上。</li>\n<li>如果通知到来并且决定唤醒这个 <code>goroutine</code>，那么就在唤醒它之后重新锁定当前条件变量基于的互斥锁。自此之后，当前<br>的 <code>goroutine</code> 就会继续执行后面的代码了。</li>\n</ol>\n<p>因为条件变量的 <code>Wait</code> 方法在阻塞当前的 <code>goroutine</code> 之前会解锁它基于的互斥锁，所以在调用该 <code>Wait</code> 方法之前我们必须先<br>锁定那个互斥锁，否则在调用这个 <code>Wait</code> 方法时，就会引发一个不可恢复的 panic。</p>\n<p>为什么条件变量的 <code>Wait</code> 方法要这么做呢？你可以想象一下，如果 <code>Wait</code> 方法在互斥锁已经锁定的情况下，阻塞了当前的 <code>goroutine</code>，<br>那么又由谁来解锁呢？别的 <code>goroutine</code> 吗？</p>\n<p>先不说这违背了互斥锁的重要使用原则，即：成对的锁定和解锁，就算别的 <code>goroutine</code> 可以来解锁，那万一解锁重复了怎么办？<br>由此引发的 panic 可是无法恢复的。</p>\n<p>如果当前的 <code>goroutine</code> 无法解锁，别的 <code>goroutine</code> 也都不来解锁，那么又由谁来进入临界区，并改变共享资源的状态呢？只要共享资源<br>的状态不变，即使当前的 <code>goroutine</code> 因收到通知而被唤醒，也依然会再次执行这个 <code>Wait</code> 方法，并再次被阻塞。</p>\n<p>所以说，如果条件变量的 <code>Wait</code> 方法不先解锁互斥锁的话，那么就只会造成两种后果：不是当前的程序因 panic 而崩溃，就是相关的<br> <code>goroutine</code> 全面阻塞。</p>\n<p><strong>为什么要用 <code>for</code> 语句来包裹调用其 <code>Wait</code> 方法的表达式，用 <code>if</code> 语句不行吗？</strong></p>\n<p><code>if</code> 语句只会对共享资源的状态检查一次，而 <code>for</code> 语句却可以做多次检查，直到这个状态改变为止。</p>\n<p>那为什么要做多次检查呢？</p>\n<p>为了保险起见。如果一个 <code>goroutine</code> 因收到通知而被唤醒，但却发现共享资源的状态，依然不符合它的要求，那么就应该再次调用<br>条件变量的 <code>Wait</code> 方法，并继续等待下次通知的到来。</p>\n<p>这种情况是很有可能发生的。</p>\n<h3 id=\"条件变量的-Signal-方法和-Broadcast-方法有哪些异同\"><a href=\"#条件变量的-Signal-方法和-Broadcast-方法有哪些异同\" class=\"headerlink\" title=\"条件变量的 Signal 方法和 Broadcast 方法有哪些异同\"></a>条件变量的 <code>Signal</code> 方法和 <code>Broadcast</code> 方法有哪些异同</h3><p>条件变量的 <code>Signal</code> 方法和 <code>Broadcast</code> 方法都是被用来发送通知的，不同的是，前者的通知只会唤醒一个因此而等待的 <code>goroutine</code>，<br>而后者的通知却会唤醒所有为此等待的 <code>goroutine</code>。</p>\n<p>条件变量的 <code>Wait</code> 方法总会把当前的 <code>goroutine</code> 添加到通知队列的队尾，而它的 <code>Signal</code> 方法总会从通知队列的队首开始查找可被<br>唤醒的 <code>goroutine</code>。所以，因 <code>Signal</code> 方法的通知而被唤醒的 <code>goroutine</code> 一般都是最早等待的那一个。</p>\n<h2 id=\"原子操作\"><a href=\"#原子操作\" class=\"headerlink\" title=\"原子操作\"></a>原子操作</h2><p>Go 语言的原子操作当然是基于 CPU 和操作系统的，所以它也只针对少数数据类型的值提供了原子操作函数。这些函数都存在于标准库代<br>码包 <code>sync/atomic</code> 中。</p>\n<p><code>sync/atomic</code> 包中的函数可以做的原子操作有：加法（add）、比较并交换（compare and swap，简称 CAS）、加载（load）、<br>存储（store）和交换（swap）。</p>\n<p>这些函数针对的数据类型并不多。对这些类型中的每一个，<code>sync/atomic</code> 包都会有一套函数给予支持。这些数据类型有：<br><code>int32</code>、<code>int64</code>、<code>uint32</code>、<code>uint64</code>、<code>uintptr</code>，以及 <code>unsafe</code> 包中的 <code>Pointer</code>。不过，针对<br><code>unsafe.Pointer</code> 类型，该包并未提供进行原子加法操作的函数。</p>\n<p><code>sync/atomic</code> 包还提供了一个名为 <code>Value</code> 的类型，它可以被用来存储任意类型的值。</p>\n<p><code>atomic.AddInt32</code> 函数的第一个参数，为什么不是 <code>int32</code> 而是 <code>*int32</code> 呢？<br>因为<strong>原子操作函数需要的是被操作值的指针，而不是这个值本身</strong>；被传入函数的参数值都会被复制，像这种基本类型的值一旦被传入函数，<br>就已经与函数外的那个值毫无关系了。</p>\n<p>所以，传入值本身没有任何意义。<code>unsafe.Pointer</code> 类型虽然是指针类型，但是那些原子操作函数要操作的是这个指针值，而不是它指向<br>的那个值，所以需要的仍然是指向这个指针值的指针。</p>\n<p>只要原子操作函数拿到了被操作值的指针，就可以定位到存储该值的内存地址。只有这样，它们才能够通过底层的指令，准确地操作这个内<br>存地址上的数据。</p>\n<h2 id=\"比较并交换操作与交换操作相比有什么不同\"><a href=\"#比较并交换操作与交换操作相比有什么不同\" class=\"headerlink\" title=\"比较并交换操作与交换操作相比有什么不同\"></a>比较并交换操作与交换操作相比有什么不同</h2><p><strong>比较并交换操作即 CAS 操作</strong>，是有条件的交换操作，<strong>只有在条件满足的情况下才会进行值的交换</strong>。</p>\n<p><strong>所谓的交换指的是，把新值赋给变量，并返回变量的旧值</strong>。</p>\n<p>CAS 操作用途要更广泛一些。例如，我们将它与 <code>for</code> 语句联用就可以实现一种简易的自旋锁（spinlock）。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> atomic.CompareAndSwapInt32(&amp;num2, <span class=\"number\">10</span>, <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        fmt.Println(<span class=\"string\">\"The second number has gone to zero.\"</span>)</span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    time.Sleep(time.Millisecond * <span class=\"number\">500</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在 <code>for</code> 语句中的 CAS 操作可以不停地检查某个需要满足的条件，一旦条件满足就退出 <code>for</code> 循环。这就相当于，只要条件未被满足，<br>当前的流程就会被一直“阻塞”在这里。</p>\n<p>这在效果上与互斥锁有些类似。不过，它们的适用场景是不同的。我们在使用互斥锁的时候，总是假设共享资源的状态会被其他<br>的 <code>goroutine</code> 频繁地改变。</p>\n<p>而 <code>for</code> 语句加 CAS 操作的假设往往是：共享资源状态的改变并不频繁，或者，它的状态总会变成期望的那样。这是一种更加乐观，<br>或者说更加宽松的做法。</p>\n<p><strong>假设我已经保证了对一个变量的写操作都是原子操作，比如：加或减、存储、交换等等，那我对它进行读操作的时候，还有必要使用原<br>子操作吗</strong>？</p>\n<p>很有必要。其中的道理你可以对照一下读写锁。为什么在读写锁保护下的写操作和读操作之间是互斥的？这是为了防止读操作读到没有<br>被修改完的值，对吗？</p>\n<p>如果写操作还没有进行完，读操作就来读了，那么就只能读到仅修改了一部分的值。这显然破坏了值的完整性，读出来的值也是完全错误的。</p>\n<p>所以，一旦你决定了要对一个共享资源进行保护，那就要做到完全的保护。不完全的保护基本上与不保护没有什么区别。</p>\n<h2 id=\"sync-atomic-Value\"><a href=\"#sync-atomic-Value\" class=\"headerlink\" title=\"sync/atomic.Value\"></a><code>sync/atomic.Value</code></h2><p>此类型的值相当于一个容器，可以被用来“原子地”存储和加载任意的值。开箱即用。</p>\n<p>它只有两个指针方法—— <code>Store</code> 和 <code>Load</code>。不过，虽然简单，但还是有一些值得注意的地方的。</p>\n<ol>\n<li>一旦 <code>atomic.Value</code> 类型的值（以下简称原子值）被真正使用，它就不应该再被复制了。只要用它来存储值了，就相当于开始真正使用了。<br><code>atomic.Value</code> 类型属于结构体类型，而结构体类型属于值类型。所以，复制该类型的值会产生一个完全分离的新值。这个新值相当于被<br>复制的那个值的一个快照。之后，不论后者存储的值怎样改变，都不会影响到前者。</li>\n<li>不能用原子值存储 <code>nil</code>。</li>\n<li>我们向原子值存储的第一个值，决定了它今后能且只能存储哪一个类型的值。</li>\n<li>尽量不要向原子值中存储引用类型的值。因为这很容易造成安全漏洞。</li>\n</ol>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> box6 atomic.Value</span><br><span class=\"line\">v6 := []<span class=\"keyword\">int</span>&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>&#125;</span><br><span class=\"line\">box6.Store(v6)</span><br><span class=\"line\">v6[<span class=\"number\">1</span>] = <span class=\"number\">4</span> <span class=\"comment\">// 注意，此处的操作不是并发安全的！</span></span><br></pre></td></tr></table></figure>\n<p>切片类型属于引用类型。所以，我在外面改动这个切片值，就等于修改了 <code>box6</code> 中存储的那个值。这相当于绕过了原子值而进行了非并发<br>安全的操作。怎样修补：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">store := <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(v []<span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">    replica := <span class=\"built_in\">make</span>([]<span class=\"keyword\">int</span>, <span class=\"built_in\">len</span>(v))</span><br><span class=\"line\">    <span class=\"built_in\">copy</span>(replica, v)</span><br><span class=\"line\">    box6.Store(replica)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">store(v6)</span><br><span class=\"line\">v6[<span class=\"number\">2</span>] = <span class=\"number\">5</span> <span class=\"comment\">// 此处的操作是安全的。</span></span><br></pre></td></tr></table></figure></p>\n<p>先为切片值 <code>v6</code> 创建了一个完全的副本。这个副本涉及的数据已经与原值毫不相干了。然后，我再把这个副本存入 <code>box6</code>。如此一来，<br>无论我再对 <code>v6</code> 的值做怎样的修改，都不会破坏 <code>box6</code> 提供的安全保护。</p>\n<h2 id=\"sync-WaitGroup\"><a href=\"#sync-WaitGroup\" class=\"headerlink\" title=\"sync.WaitGroup\"></a>sync.WaitGroup</h2><p>在一些场合下里，我们使用通道的方式看起来都似乎有些蹩脚。比如：声明一个通道，使它的容量与我们手动启用的 <code>goroutine</code> 的数量相同。<br>之后利用这个通道，让主 <code>goroutine</code> 等待其他 <code>goroutine</code> 的运行结束。更具体地说就是：让其他的 <code>goroutine</code> 在运行结束之前，<br>都向这个通道发送一个元素值，并且，让主 <code>goroutine</code> 在最后从这个通道中接收元素值，接收的次数需要与其他的 <code>goroutine</code> 的数量相同。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">coordinateWithChan</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    sign := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">struct</span>&#123;&#125;, <span class=\"number\">2</span>)</span><br><span class=\"line\">    num := <span class=\"keyword\">int32</span>(<span class=\"number\">0</span>)</span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">\"The number: %d [with chan struct&#123;&#125;]\\n\"</span>, num)</span><br><span class=\"line\">    max := <span class=\"keyword\">int32</span>(<span class=\"number\">10</span>)</span><br><span class=\"line\">    <span class=\"keyword\">go</span> addNum(&amp;num, <span class=\"number\">1</span>, max, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        sign &lt;- <span class=\"keyword\">struct</span>&#123;&#125;&#123;&#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    <span class=\"keyword\">go</span> addNum(&amp;num, <span class=\"number\">2</span>, max, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        sign &lt;- <span class=\"keyword\">struct</span>&#123;&#125;&#123;&#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    &lt;-sign</span><br><span class=\"line\">    &lt;-sign</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>coordinateWithChan</code> 函数中最后的那两行代码了吗？重复的两个接收表达式 <code>&lt;-sign</code>，很丑陋。<br>我们可以选用另外一个同步工具，即：<code>sync</code> 包的 <code>WaitGroup</code> 类型。它比通道更加适合实现这种一对多的 <code>goroutine</code> 协作流程。</p>\n<p><code>sync.WaitGroup</code> 类型（以下简称 <code>WaitGroup</code> 类型）是开箱即用的，也是并发安全的。</p>\n<p><code>WaitGroup</code> 类型拥有三个指针方法：<code>Add</code>、<code>Done</code> 和 <code>Wait</code>。<strong>你可以想象该类型中有一个计数器，它的默认值是 <code>0</code>。我们可<br>以通过调用该类型值的 <code>Add</code> 方法来增加，或者减少这个计数器的值</strong>。</p>\n<p><strong>一般情况下，我会用这个方法来记录需要等待的 <code>goroutine</code> 的数量。相对应的，这个类型的 <code>Done</code> 方法，用于对其所属值中计数器<br>的值进行减一操作</strong>。我们可以在需要等待的 <code>goroutine</code> 中，通过 <code>defer</code> 语句调用它。</p>\n<p>而<strong>此类型的 <code>Wait</code> 方法的功能是，阻塞当前的 <code>goroutine</code>，直到其所属值中的计数器归零</strong>。</p>\n<p>改造版本：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">coordinateWithWaitGroup</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> wg sync.WaitGroup</span><br><span class=\"line\">\twg.Add(<span class=\"number\">2</span>)</span><br><span class=\"line\">\tnum := <span class=\"keyword\">int32</span>(<span class=\"number\">0</span>)</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"The number: %d [with sync.WaitGroup]\\n\"</span>, num)</span><br><span class=\"line\">\tmax := <span class=\"keyword\">int32</span>(<span class=\"number\">10</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">go</span> addNum(&amp;num, <span class=\"number\">3</span>, max, wg.Done)</span><br><span class=\"line\">\t<span class=\"keyword\">go</span> addNum(&amp;num, <span class=\"number\">4</span>, max, wg.Done)</span><br><span class=\"line\">\twg.Wait()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>尽量不要在 <code>go</code> 函数内部调用 <code>Add</code>，以免 <code>Add</code> 还未执行，<code>Wait</code> 已经退出</strong>：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> wg sync.WaitGroup</span><br><span class=\"line\"><span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\twg.Add(<span class=\"number\">1</span>)</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">\"test\"</span>)</span><br><span class=\"line\">&#125;()</span><br><span class=\"line\"></span><br><span class=\"line\">wg.Wait()</span><br><span class=\"line\">fmt.Println(<span class=\"string\">\"exit.\"</span>)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"sync-WaitGroup-类型值中计数器的值可以小于-0-吗\"><a href=\"#sync-WaitGroup-类型值中计数器的值可以小于-0-吗\" class=\"headerlink\" title=\"sync.WaitGroup 类型值中计数器的值可以小于 0 吗\"></a>sync.WaitGroup 类型值中计数器的值可以小于 0 吗</h3><p>不可以。<strong>小于 0，会引发一个 panic</strong>。</p>\n<p><strong><code>WaitGroup</code> 值是可以被复用的，但需要保证其计数周期的完整性</strong>。这里的计数周期指的是这样一个过程：该值中的计数器值由 0 变为<br>了某个正整数，而后又经过一系列的变化，最终由某个正整数又变回了 0。</p>\n<p>如果在一个此类值的 <code>Wait</code> 方法被执行期间，跨越了两个计数周期，那么就会引发一个 panic。</p>\n<h3 id=\"使用注意\"><a href=\"#使用注意\" class=\"headerlink\" title=\"使用注意\"></a>使用注意</h3><ul>\n<li>不要把增加其计数器值的操作和调用其 <code>Wait</code> 方法的代码，放在不同的 <code>goroutine</code> 中执行。换句话说，要<strong>杜绝对同一个<br><code>WaitGroup</code> 值的两种操作的并发执行</strong>。</li>\n</ul>\n<h2 id=\"sync-Once\"><a href=\"#sync-Once\" class=\"headerlink\" title=\"sync.Once\"></a>sync.Once</h2><p>与 <code>sync.WaitGroup</code> 类型一样，<code>sync.Once</code> 类型（以下简称 <code>Once</code> 类型）也属于结构体类型，同样也是开箱即用和并发安全的。<br>由于这个类型中包含了一个 <code>sync.Mutex</code> 类型的字段，所以，复制该类型的值也会导致功能的失效。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> loadIconsOnce sync.Once</span><br><span class=\"line\"><span class=\"keyword\">var</span> icons <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]image.Image</span><br><span class=\"line\"><span class=\"comment\">// Concurrency-safe.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Icon</span><span class=\"params\">(name <span class=\"keyword\">string</span>)</span> <span class=\"title\">image</span>.<span class=\"title\">Image</span></span> &#123;</span><br><span class=\"line\">  loadIconsOnce.Do(loadIcons)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> icons[name]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>Once</code> 类型的 <code>Do</code> 方法只接受一个参数，这个参数的类型必须是 <code>func()</code>，即：无参数声明和结果声明的函数。该方法的功能并<br>不是对每一种参数函数都只执行一次，而是只<strong>执行“首次被调用时传入的”那个函数，并且之后不会再执行任何参数函数</strong>。</p>\n<p>所以，<strong>如果你有多个只需要执行一次的函数，那么就应该为它们中的每一个都分配一个 <code>sync.Once</code> 类型的值</strong>（以下简称 <code>Once</code> 值）。</p>\n<p><code>Once</code> 类型中还有一个名叫 <code>done</code> 的 <code>uint32</code> 类型的字段。<strong>它的作用是记录其所属值的 <code>Do</code> 方法被调用的次数。不过，该字段的值<br>只可能是 0 或者 1。一旦 <code>Do</code> 方法的首次调用完成，它的值就会从 0 变为 1</strong>。</p>\n<p><strong>既然 <code>done</code> 字段的值不是 0 就是 1，那为什么还要使用需要四个字节的 <code>uint32</code> 类型呢</strong>？</p>\n<p>原因很简单，因为对它的操作必须是“原子”的。<code>Do</code> 方法在一开始就会通过调用 <code>atomic.LoadUint32</code> 函数来获取该字段的值，并且一旦<br>发现该值为 1 就会直接返回。这也初步保证了“<code>Do</code> 方法，只会执行首次被调用时传入的函数”。</p>\n<h3 id=\"Do-方法在功能方面的两个特点\"><a href=\"#Do-方法在功能方面的两个特点\" class=\"headerlink\" title=\"Do 方法在功能方面的两个特点\"></a>Do 方法在功能方面的两个特点</h3><ul>\n<li>由于 <code>Do</code> 方法只会在参数函数执行结束之后把 <code>done</code> 字段的值变为 1，因此，如果参数函数的执行需要很长时间或者根本就不会结束<br>（比如执行一些守护任务），那么就有可能会导致相关 <code>goroutine</code> 的同时阻塞</li>\n<li><code>Do</code> 方法在参数函数执行结束后，对 <code>done</code> 字段的赋值用的是原子操作，并且，这一操作是被挂在 <code>defer</code> 语句中的。因此，不论参数<br>函数的执行会以怎样的方式结束，<code>done</code> 字段的值都会变为 1。</li>\n</ul>\n<h2 id=\"context-Context-类型\"><a href=\"#context-Context-类型\" class=\"headerlink\" title=\"context.Context 类型\"></a>context.Context 类型</h2><p>使用 <code>WaitGroup</code> 值的时候，我们最好用<strong>先统一 <code>Add</code>，再并发 <code>Done</code>，最后 <code>Wait</code></strong> 的标准模式来构建协作流程。如果在调用<br>该值的 <code>Wait</code> 方法的同时，为了增大其计数器的值，而并发地调用该值的 <code>Add</code> 方法，那么就很可能会引发 panic。</p>\n<p>但是<strong>如果，我们不能在一开始就确定执行子任务的 <code>goroutine</code> 的数量，那么使用 <code>WaitGroup</code> 值来协调它们和分发子任<br>务的 <code>goroutine</code>，就是有一定风险的</strong>。一个解决方案是：<strong>分批地启用执行子任务的 <code>goroutine</code></strong>。</p>\n<p>只要我们在严格遵循上述规则的前提下，分批地启用执行子任务的 <code>goroutine</code>，就肯定不会有问题。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">coordinateWithWaitGroup</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    total := <span class=\"number\">12</span></span><br><span class=\"line\">    stride := <span class=\"number\">3</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> num <span class=\"keyword\">int32</span></span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">\"The number: %d [with sync.WaitGroup]\\n\"</span>, num)</span><br><span class=\"line\">    <span class=\"keyword\">var</span> wg sync.WaitGroup</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">1</span>; i &lt;= total; i = i + stride &#123;</span><br><span class=\"line\">        wg.Add(stride)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j := <span class=\"number\">0</span>; j &lt; stride; j++ &#123;</span><br><span class=\"line\">            <span class=\"keyword\">go</span> addNum(&amp;num, i+j, wg.Done)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        wg.Wait()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    fmt.Println(<span class=\"string\">\"End.\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"使用-context-包中的程序实体，实现一对多的-goroutine-协作流程\"><a href=\"#使用-context-包中的程序实体，实现一对多的-goroutine-协作流程\" class=\"headerlink\" title=\"使用 context 包中的程序实体，实现一对多的 goroutine 协作流程\"></a>使用 <code>context</code> 包中的程序实体，实现一对多的 goroutine 协作流程</h3><p>用 <code>context</code> 包中的函数和 <code>Context</code> 类型作为实现工具，实现 <code>coordinateWithContext</code> 的函数。这个函数应该具有上<br>面 <code>coordinateWithWaitGroup</code> 函数相同的功能。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">coordinateWithContext</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\ttotal := <span class=\"number\">12</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> num <span class=\"keyword\">int32</span></span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"The number: %d [with context.Context]\\n\"</span>, num)</span><br><span class=\"line\">\tcxt, cancelFunc := context.WithCancel(context.Background())</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">1</span>; i &lt;= total; i++ &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">go</span> addNum(&amp;num, i, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> atomic.LoadInt32(&amp;num) == <span class=\"keyword\">int32</span>(total) &#123;</span><br><span class=\"line\">\t\t\t\tcancelFunc()</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t&lt;-cxt.Done()</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">\"End.\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>先后调用了 <code>context.Background</code> 函数和 <code>context.WithCancel</code> 函数，并得到了一个可撤销的 <code>context.Context</code> 类型的值<br>（由变量 <code>cxt</code> 代表），以及一个 <code>context.CancelFunc</code>类型的撤销函数（由变量 <code>cancelFunc</code> 代表）。</p>\n<p>注意我给予 <code>addNum</code> 函数的最后一个参数值。它是一个匿名函数，其中只包含了一条 <code>if</code> 语句。这条 <code>if</code> 语句会<strong>原子地</strong>加载<br> <code>num</code> 变量的值，并判断它是否等于 <code>total</code> 变量的值。</p>\n<p>如果两个值相等，那么就调用 <code>cancelFunc</code> 函数。其含义是，如果所有的 <code>addNum</code> 函数都执行完毕，那么就立即通知分发子任务<br>的 <code>goroutine</code>。</p>\n<p><strong>这里分发子任务的 <code>goroutine</code>，即为执行 <code>coordinateWithContext</code> 函数的 <code>goroutine</code></strong>。它在执行完 <code>for</code> 语句后，会<br>立即调用 <code>cxt</code> 变量的 <code>Done</code> 函数，并试图针对该函数返回的通道，进行接收操作。</p>\n<p>一旦 <code>cancelFunc</code> 函数被调用，针对该通道的接收操作就会马上结束，所以，这样做就可以实现“等待所有的 <code>addNum</code> 函数都执<br>行完毕”的功能。</p>\n<h3 id=\"context-Context-类型-1\"><a href=\"#context-Context-类型-1\" class=\"headerlink\" title=\"context.Context 类型\"></a>context.Context 类型</h3><p><code>Context</code> 类型的值（以下简称 <code>Context</code> 值）是可以繁衍的，这意味着我们可以通过一个 <code>Context</code> 值产生出任意个子值。这些子值<br>可以携带其父值的属性和数据，也可以响应通过其父值传达的信号。</p>\n<p>正因为如此，所有的 <code>Context</code> 值共同构成了一颗代表了上下文全貌的树形结构。这棵树的<strong>树根（或者称上下文根节点）是一个已经<br>在 <code>context</code> 包中预定义好的 <code>Context</code> 值</strong>，它是<strong>全局唯一</strong>的。通过调用 <code>context.Background</code> 函数，我们就可以获取到<br>它（在 <code>coordinateWithContext</code> 函数中就是这么做的）。</p>\n<p>注意一下，这个<strong>上下文根节点仅仅是一个最基本的支点，它不提供任何额外的功能</strong>。也就是说，它既不可以被撤销（<code>cancel</code>），<br>也不能携带任何数据。</p>\n<p><code>context</code> 包中还包含了<strong>四个用于繁衍 <code>Context</code> 值的函数，即：<code>WithCancel</code>、<code>WithDeadline</code>、<code>WithTimeout</code> 和 <code>WithValue</code></strong>。</p>\n<p>这些函数的第一个参数的类型都是 <code>context.Context</code>，而名称都为 <code>parent</code>。顾名思义，<strong>这个位置上的参数对应的都是它们将会产生<br>的 <code>Context</code> 值的父值</strong>。</p>\n<p><strong><code>WithCancel</code> 函数用于产生一个可撤销的 parent 的子值</strong>。</p>\n<p>在 <code>coordinateWithContext</code> 函数中，通过调用该函数，获得了一个衍生自上下文根节点的 <code>Context</code> 值，和一个用于触发撤销信号的函数。</p>\n<p><code>WithDeadline</code> 函数和 <code>WithTimeout</code> 函数则都可以被用来产生一个会<strong>定时撤销</strong>的 <code>parent</code> 的子值。至于 <code>WithValue</code> 函数，<br>我们可以通过调用它，产生一个会携带额外数据的 <code>parent</code> 的子值。</p>\n<h3 id=\"“可撤销的”在-context-包中代表着什么？“撤销”一个-Context-值又意味着什么？\"><a href=\"#“可撤销的”在-context-包中代表着什么？“撤销”一个-Context-值又意味着什么？\" class=\"headerlink\" title=\"“可撤销的”在 context 包中代表着什么？“撤销”一个 Context 值又意味着什么？\"></a>“可撤销的”在 context 包中代表着什么？“撤销”一个 Context 值又意味着什么？</h3><p>这需要从 <code>Context</code> 类型的声明讲起。这个接口中有两个方法与“撤销”息息相关。<code>Done</code> 方法会返回一个元素类型为 <code>struct{}</code> 的接<br>收通道。不过，这个接收通道的用途并不是传递元素值，而是<strong>让调用方去感知“撤销”当前Context值的那个信号</strong>。</p>\n<p>一旦当前的 <code>Context</code> 值被撤销，这里的接收通道就会被立即关闭。我们都知道，对于一个未包含任何元素值的通道来说，它的关闭会<br>使任何针对它的接收操作立即结束。</p>\n<p>正因为如此，在 <code>coordinateWithContext</code> 函数中，基于调用表达式 <code>cxt.Done()</code> 的接收操作，才能够起到感知撤销信号的作用。</p>\n<h3 id=\"撤销信号是如何在上下文树中传播的\"><a href=\"#撤销信号是如何在上下文树中传播的\" class=\"headerlink\" title=\"撤销信号是如何在上下文树中传播的\"></a>撤销信号是如何在上下文树中传播的</h3><p><code>context</code>包的 <code>WithCancel</code> 函数在被调用后会产生两个结果值。第一个结果值就是那个可撤销的 <code>Context</code> 值，而第二个结果值则是<br>用于触发撤销信号的函数。</p>\n<p>在撤销函数被调用之后，对应的 <code>Context</code> 值会先关闭它内部的接收通道，也就是它的 <code>Done</code> 方法会返回的那个通道。</p>\n<p>然后，它会向它的所有子值（或者说子节点）传达撤销信号。这些子值会如法炮制，把撤销信号继续传播下去。最后，这个 <code>Context</code> 值会<br>断开它与其父值之间的关联。</p>\n<p><strong>通过调用 <code>context.WithValue</code> 函数得到的 <code>Context</code> 值是不可撤销的</strong>。</p>\n<h3 id=\"怎样通过-Context-值携带数据\"><a href=\"#怎样通过-Context-值携带数据\" class=\"headerlink\" title=\"怎样通过 Context 值携带数据\"></a>怎样通过 Context 值携带数据</h3><p><strong><code>WithValue</code> 函数在产生新的 <code>Context</code> 值（以下简称含数据的 <code>Context</code> 值）的时候需要三个参数，即：父值、键和值</strong>。<br>“字典对于键的约束”类似，这里<strong>键的类型必须是可判等</strong>的。</p>\n<p>原因很简单，当我们从中获取数据的时候，它需要根据给定的键来查找对应的值。不过，这种 <code>Context</code> 值并不是用字典来存储键和值的，<br>后两者只是被简单地存储在前者的相应字段中而已。</p>\n<h2 id=\"临时对象池-sync-Pool\"><a href=\"#临时对象池-sync-Pool\" class=\"headerlink\" title=\"临时对象池 sync.Pool\"></a>临时对象池 sync.Pool</h2><p> Go 语言标准库中最重要的那几个同步工具，这包括:</p>\n<ul>\n<li>互斥锁</li>\n<li>读写锁</li>\n<li>条件变量</li>\n<li>原子操作</li>\n<li><code>sync/atomic.Value</code></li>\n<li><code>sync.Once</code></li>\n<li><code>sync.WaitGroup</code></li>\n<li><code>context.Context</code></li>\n</ul>\n<p>Go 语言标准库中的还有另一个同步工具：<code>sync.Pool</code>。</p>\n<p><code>sync.Pool</code> 类型可以被称为临时对象池，它的值可以被用来存储临时的对象。与 Go 语言的很多同步工具一样，<code>sync.Pool</code> 类型也属<br>于结构体类型，它的值在被真正使用之后，就不应该再被复制了。</p>\n<p><strong>临时对象</strong>的意思是：不需要持久使用的某一类值。这类值对于程序来说可有可无，但如果有的话会明显更好。它们的创建和销毁可以在<br>任何时候发生，并且完全不会影响到程序的功能。</p>\n<p><strong>我们可以把临时对象池当作针对某种数据的缓存来用</strong>。</p>\n<p><code>sync.Pool</code> 类型只有两个方法——<code>Put</code> 和 <code>Get</code>。前者用于在当前的池中存放临时对象，它接受一个 <code>interface{}</code> 类型的参数；<br>而后者则被用于从当前的池中获取临时对象，它会返回一个 <code>interface{}</code> 类型的值。</p>\n<p>更具体地说，<strong>这个类型的 <code>Get</code> 方法可能会从当前的池中删除掉任何一个值，然后把这个值作为结果返回。如果此时当前的池中没有任何值，<br>那么这个方法就会使用当前池的 <code>New</code> 字段创建一个新值，并直接将其返回</strong>。</p>\n<p><code>sync.Pool</code> 类型的 <code>New</code> 字段代表着创建临时对象的函数。它的类型是没有参数但有唯一结果的函数类型，即：<code>func() interface{}</code>。<br><strong>初始化这个池的时候最好给定它</strong>。</p>\n<p>这个函数是 <code>Get</code> 方法最后的临时对象获取手段。<code>Get</code> 方法如果到了最后，仍然无法获取到一个值，那么就会调用该函数。该函数的结<br>值并不会被存入当前的临时对象池中，而是直接返回给 <code>Get</code> 方法的调用方。</p>\n<p><strong>临时对象池中存储的每一个值都应该是独立的、平等的和可重用的</strong>。<code>sync.Pool</code> 的定位不是做类似连接池的东西，它的用途仅仅是增加<br>对象重用的几率，减少 gc 的负担。因为 gc 带来了编程的方便但同时也增加了运行时开销，使用不当甚至会严重影响程序的性能。因此性能<br>要求高的场景不能任意产生太多的垃圾。如何解决呢？那就是要重用对象了。</p>\n<p>一个比较好的例子是 <code>fmt</code> 包，<code>fmt</code> 包总是需要使用一些 <code>[]byte</code> 之类的对象，golang 建立了一个临时对象池，存放着这些对象，<br>如果需要使用一个 <code>[]byte</code>，就去 <code>Pool</code> 里面拿，如果拿不到就分配一份。这比起不停生成新的 <code>[]byte</code>，用完了再等待 gc 回收<br>来要高效得多。</p>\n<p><code>sync.Pool</code> 缓存对象的期限是很诡异的，先看一下 <code>src/pkg/sync/pool.go</code> 里面的一段实现代码：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">init</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    runtime_registerPoolCleanup(poolCleanup)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以看到 <code>pool</code> 包在 <code>init</code> 的时候注册了一个 <code>poolCleanup</code> 函数，它会清除所有的 <code>pool</code> 里面的所有缓存的对象，该函数注册进去<br>之后会在每次 gc 之前都会调用，因此 <strong><code>sync.Pool</code> 缓存的期限只是两次gc之间这段时间</strong>。</p>\n<h2 id=\"sync-Map\"><a href=\"#sync-Map\" class=\"headerlink\" title=\"sync.Map\"></a>sync.Map</h2><p>Go 语言自带的字典类型 <code>map</code> 并不是并发安全的。换句话说，在同一时间段内，让不同 goroutine 中的代码，对同一个字典进行读写操<br>作是不安全的。</p>\n<p>Go 语言官方终于在 2017 年发布的 Go 1.9 中正式加入了并发安全的字典类型 <code>sync.Map</code>。</p>\n<p>使用 <code>sync.Map</code> 可以显著地减少锁的争用。<code>sync.Map</code> 本身虽然也用到了锁，但是，它其实在尽可能地避免使用锁。</p>\n<p><strong>使用锁就意味着要把一些并发的操作强制串行化。这往往会降低程序的性能，尤其是在计算机拥有多个 CPU 核心的情况下</strong>。</p>\n<p>由于<strong>并发安全字典内部使用的存储介质正是原生字典，又因为它使用的原生字典键类型也是可以包罗万象的 <code>interface{}</code>，所以，<br>我们绝对不能带着任何实际类型为函数类型、字典类型或切片类型的键值去操作并发安全字典</strong>。</p>\n<p>因为<strong>这些键值的实际类型只有在程序运行期间才能够确定，所以 Go 语言编译器是无法在编译期对它们进行检查的，不正确的键值实际类<br>型肯定会引发 panic</strong>。</p>\n<p><strong>因此，我们在这里首先要做的一件事就是：一定不要违反上述规则。我们应该在每次操作并发安全字典的时候，都去显式地检查键值的实际<br>类型。无论是存、取还是删，都应该如此</strong>。</p>\n<blockquote>\n<p><strong>更好的做法是，把针对同一个并发安全字典的这几种操作都集中起来，然后统一地编写检查代码。除此之外，把并发安全字典封装在一<br>个结构体类型中，往往是一个很好的选择</strong>。如果你实在拿不准，那么可以先通过调用 <code>reflect.TypeOf</code> 函数得到一个键值对应的反射类<br>型值（即：<code>reflect.Type</code> 类型的值），然后再调用这个值的 <code>Comparable</code> 方法，得到确切的判断结果。</p>\n</blockquote>\n<h3 id=\"并发安全字典如何做到尽量避免使用锁\"><a href=\"#并发安全字典如何做到尽量避免使用锁\" class=\"headerlink\" title=\"并发安全字典如何做到尽量避免使用锁\"></a>并发安全字典如何做到尽量避免使用锁</h3><p><code>sync.Map</code> 类型在内部使用了<strong>大量的原子操作来存取键和值，并使用了两个原生的 map 作为存储介质</strong>。</p>\n<p>其中一个原生 map 被存在了 <code>sync.Map</code> 的 <code>read</code> 字段中，该字段是 <code>sync/atomic.Value</code> 类型的。简称它为<strong>只读字典</strong>。</p>\n<p><strong>只读字典虽然不会增减其中的键，但却允许变更其中的键所对应的值</strong>。所以，它并不是传统意义上的快照，它的只读特性只是对于其中键<br>的集合而言的。</p>\n<p>由 <code>read</code> 字段的类型可知，<code>sync.Map</code> 在替换只读字典的时候根本用不着锁。另外，这个只读字典在存储键值对的时候，还在值之上<br>封装了一层。</p>\n<p>它先把值转换为了 <code>unsafe.Pointer</code> 类型的值，然后再把后者封装，并储存在其中的原生字典中。如此一来，在变更某个键所对应的值<br>的时候，就也可以使用原子操作了。</p>\n<p><code>sync.Map</code> 中的另一个原生字典由它的 <code>dirty</code> 字段代表。它存储键值对的方式与 <code>read</code> 字段中的原生字典一致，它的键类型<br>也是 <code>interface{}</code>，并且同样是把值先做转换和封装后再进行储存的。称为<strong>脏字典</strong>。</p>\n<blockquote>\n<p>脏字典和只读字典如果都存有同一个键值对，那么这里的两个键指的肯定是同一个基本值，对于两个值来说也是如此。正如前文所述，<br>这两个字典在存储键和值的时候都只会存入它们的某个指针，而不是基本值。</p>\n</blockquote>\n<p><code>sync.Map</code> 在查找指定的键所对应的值的时候，总会先去只读字典中寻找，并不需要锁定互斥锁。只有当确定<strong>只读字典中没有，但脏<br>字典中可能会有这个键</strong>的时候，它才会在锁的保护下去访问脏字典。</p>\n<p>相对应的，<code>sync.Map</code> 在存储键值对的时候，只要只读字典中已存有这个键，并且该键值对未被标记为“已删除”，就会把新值存到里面并<br>直接返回，这种情况下也不需要用到锁。</p>\n<p>否则，它才会在锁的保护下把键值对存储到脏字典中。这个时候，该键值对的“已删除”标记会被抹去。</p>\n<p>只有当一个键值对应该被删除，但却仍然存在于只读字典中的时候，才会被用标记为“已删除”的方式进行逻辑删除，而不会直接被物理删除。<br>这种情况会在重建脏字典以后的一段时间内出现。不过，过不了多久，它们就会被真正删除掉。在查找和遍历键值对的时候，已被逻<br>辑删除的键值对永远会被无视。</p>\n<p>最后，<code>sync.Map</code> 会把该键值对中指向值的那个指针置为 <code>nil</code> ，这是另一种逻辑删除的方式。</p>\n<p>除此之外，还有一个细节需要注意，只读字典和脏字典之间是会互相转换的。在脏字典中查找键值对次数足够多的时候，<code>sync.Map</code> 会把<br>脏字典直接作为只读字典，保存在它的 <code>read</code> 字段中，然后把代表脏字典的 <code>dirty</code> 字段的值置为 <code>nil</code>。</p>\n<p>在这之后，一旦再有新的键值对存入，它就会依据只读字典去重建脏字典。这个时候，它会把只读字典中已被逻辑删除的键值对过滤掉。<br>理所当然，这些转换操作肯定都需要在锁的保护下进行。</p>\n<p><strong><code>sync.Map</code> 的只读字典和脏字典中的键值对集合并不是实时同步的，它们在某些时间段内可能会有不同</strong>。</p>\n<p>可以看出，在读操作有很多但写操作却很少的情况下，并发安全字典的性能往往会更好。在几个写操作当中，新增键值对的操作对并发安<br>全字典的性能影响是最大的，其次是删除操作，最后才是修改操作。</p>\n<p>如果被操作的键值对已经存在于 <code>sync.Map</code> 的只读字典中，并且没有被逻辑删除，那么修改它并不会使用到锁，对其性能的影响就会很小。</p>\n<h2 id=\"竞争检查器\"><a href=\"#竞争检查器\" class=\"headerlink\" title=\"竞争检查器\"></a>竞争检查器</h2><p>在 <code>go build</code>，<code>go run</code> 或者 <code>go test</code> 命令后面加上 <code>-race</code>，就会使编译器创建一个你的应用的“修改”版。</p>\n<p>会记录下每一个读或者写共享变量的 <code>goroutine</code> 的身份信息。记录下所有的同步事件，比如 <code>go</code> 语句，<code>channel</code> 操作，<br>以及对 <code>(*sync.Mutex).Lock</code>，<code>(*sync.WaitGroup).Wait</code> 等等的调用。</p>\n<p>由于需要额外的记录，因此构建时加了竞争检测的程序跑起来会慢一些，且需要更大的内存，即使是这样，这些代价对于很多生产环境的<br>工作来说还是可以接受的。</p>\n"},{"title":"http","_content":"# http\n\n\n`net/http` 可以用来处理 HTTP 协议，包括 HTTP 服务器和 HTTP 客户端，主要组成：\n\n- Request，HTTP 请求对象\n- Response，HTTP 响应对象\n- Client，HTTP 客户端\n- Server，HTTP 服务端\n\n创建一个 server ：\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc MyHandler(w http.ResponseWriter, r *http.Request) {\n\t_, _ = fmt.Fprintf(w, \"hello\")\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/\", MyHandler)\n\t_ = http.ListenAndServe(\":8080\", nil)\n}\n```\n\n发送请求：\n```go\nresp, err := http.Get(\"http://example.com/\") // GET \n\nresp, err := http.Post(\"http://example.com/\") // POST\n\nresp, err := http.PostForm(\"http://example.com/\", url.Values{\"foo\": \"bar\"}) // 提交表单\n```\n\n## Request\n\n`Request` 对象是对 http 请求报文的抽象。包括起始行, `Headers`, `Body` 等。\n\n使用 `http.NewRequest` 函数创建一个 `Request` 请求对象：\n```go\nfunc NewRequest(method, url string, body io.Reader) (*Request, error)\n```\n\n`Request` 对象主要用于数据的存储，结构：\n```go\ntype Request struct {\n    Method string // HTTP方法\n    URL *url.URL // URL\n    \n    Proto      string // \"HTTP/1.0\"\n    ProtoMajor int    // 1\n    ProtoMinor int    // 0\n\n    Header Header // 报文头\n    Body io.ReadCloser // 报文体\n    GetBody func() (io.ReadCloser, error)\n    ContentLength int64 // 报文长度\n    TransferEncoding []string // 传输编码\n    Close bool // 关闭连接\n    Host string // 主机名\n    \n    Form url.Values // \n    PostForm url.Values // POST表单信息\n    MultipartForm *multipart.Form // multipart，\n\n    Trailer Header\n    RemoteAddr string\n    RequestURI string\n    TLS *tls.ConnectionState\n    Cancel <-chan struct{}\n    Response *Response\n}\n```\n\n```go\n// 从 b 中读取和解析一个请求. \nfunc ReadRequest(b *bufio.Reader) (req *Request, err error)\n\n// 给 request 添加 cookie, AddCookie 向请求中添加一个 cookie.按照RFC 6265 \n// section 5.4的规则, AddCookie 不会添加超过一个 Cookie 头字段.\n// 这表示所有的 cookie 都写在同一行, 用分号分隔（cookie 内部用逗号分隔属性） \nfunc (r *Request) AddCookie(c *Cookie)\n\n// 返回 request 中指定名 name 的 cookie，如果没有发现，返回 ErrNoCookie \nfunc (r *Request) Cookie(name string) (*Cookie, error)\n\n// 返回该请求的所有cookies \nfunc (r *Request) Cookies() []*Cookie\n\n// 利用提供的用户名和密码给 http 基本权限提供具有一定权限的 header。\n// 当使用 http 基本授权时，用户名和密码是不加密的 \nfunc (r *Request) SetBasicAuth(username, password string)\n\n// 如果在 request 中发送，该函数返回客户端的 user-Agent\nfunc (r *Request) UserAgent() string\n\n// 对于指定格式的 key，FormFile 返回符合条件的第一个文件，如果有必要的话，\n// 该函数会调用 ParseMultipartForm 和 ParseForm。 \nfunc (r *Request) FormFile(key string) (multipart.File, *multipart.FileHeader, error)\n\n// 返回 key 获取的队列中第一个值。在查询过程中 post 和 put 中的主题参数优先级\n// 高于 url 中的 value。为了访问相同 key 的多个值，调用 ParseForm 然后直接\n// 检查 RequestForm。 \nfunc (r *Request) FormValue(key string) string\n\n// 如果这是一个有多部分组成的 post 请求，该函数将会返回一个 MIME 多部分 reader，\n// 否则的话将会返回一个 nil 和 error。使用本函数代替 ParseMultipartForm\n// 可以将请求 body 当做流 stream 来处理。 \nfunc (r *Request) MultipartReader() (*multipart.Reader, error)\n\n// 解析URL中的查询字符串，并将解析结果更新到 r.Form 字段。对于POST 或 PUT\n// 请求，ParseForm 还会将 body 当作表单解析，并将结果既更新到 r.PostForm 也\n// 更新到 r.Form。解析结果中，POST 或 PUT 请求主体要优先于 URL 查询字符串\n// （同名变量，主体的值在查询字符串的值前面）。如果请求的主体的大小没有被\n// MaxBytesReader 函数设定限制，其大小默认限制为开头 10MB。\n// ParseMultipartForm 会自动调用 ParseForm。重复调用本方法是无意义的。\nfunc (r *Request) ParseForm() error \n\n// ParseMultipartForm 将请求的主体作为 multipart/form-data 解析。\n// 请求的整个主体都会被解析，得到的文件记录最多 maxMemery 字节保存在内存，\n// 其余部分保存在硬盘的 temp 文件里。如果必要，ParseMultipartForm 会\n// 自行调用 ParseForm。重复调用本方法是无意义的。\nfunc (r *Request) ParseMultipartForm(maxMemory int64) error \n\n// 返回 post 或者 put 请求 body 指定元素的第一个值，其中 url 中的参数被忽略。\nfunc (r *Request) PostFormValue(key string) string \n\n// 检测在 request 中使用的 http 协议是否至少是 major.minor \nfunc (r *Request) ProtoAtLeast(major, minor int) bool\n\n// 如果 request 中有 refer，那么 refer 返回相应的 url。Referer 在 request\n// 中是拼错的(Referrer)，这个错误从 http 初期就已经存在了。该值也可以从 Headermap 中\n// 利用 Header[\"Referer\"] 获取；在使用过程中利用 Referer 这个方法而\n// 不是 map 的形式的好处是在编译过程中可以检查方法的错误，而无法检查 map 中\n// key 的错误。\nfunc (r *Request) Referer() string \n\n// Write 方法以有线格式将 HTTP/1.1 请求写入 w（用于将请求写入下层 TCPConn 等）\n// 。本方法会考虑请求的如下字段：Host URL Method (defaults to \"GET\")\n//  Header ContentLength TransferEncoding Body如果存在Body，\n// ContentLength字段<= 0且TransferEncoding字段未显式设置为\n// [\"identity\"]，Write 方法会显式添加 ”Transfer-Encoding: chunked”\n// 到请求的头域。Body 字段会在发送完请求后关闭。\nfunc (r *Request) Write(w io.Writer) error \n\n// 该函数与 Write 方法类似，但是该方法写的 request 是按照 http 代理的格式去写。\n// 尤其是，按照 RFC 2616 Section 5.1.2，WriteProxy 会使用绝对 URI\n// （包括协议和主机名）来初始化请求的第1行（Request-URI行）。无论何种情况，\n// WriteProxy 都会使用 r.Host 或 r.URL.Host 设置 Host 头。\nfunc (r *Request) WriteProxy(w io.Writer) error \n```\n\n## Response\n\nResponse 也是一个数据对象，描述 HTTP 响应：\n```go\ntype Response struct {\n    Status     string // HTTP 状态码\n    StatusCode int    // 状态码 200\n    Proto      string // 版本号 \"HTTP/1.0\"\n    ProtoMajor int    // 主版本号 \n    ProtoMinor int    // 次版本号\n\n    Header Header // 响应报文头\n    Body io.ReadCloser // 响应报文体\n    ContentLength int64 // 报文长度\n    TransferEncoding []string // 报文编码\n    Close bool \n    Trailer Header\n    Request *Request // 请求对象\n    TLS *tls.ConnectionState\n}\n```\n\n```go\n// ReadResponse 从 r 读取并返回一个 HTTP 回复。req 参数是可选的，指定该回复\n// 对应的请求（即是对该请求的回复）。如果是 nil，将假设请 求是 GET 请求。\n// 客户端必须在结束 resp.Body 的读取后关闭它。读取完毕并关闭后，客户端可以\n// 检查 resp.Trailer 字段获取回复的 trailer 的键值对。\nfunc ReadResponse(r *bufio.Reader, req *Request) (*Response, error)\n\n// 解析 cookie 并返回在 header 中利用 set-Cookie 设定的 cookie 值。\nfunc (r *Response) Cookies() []*Cookie \n\n// 返回 response 中 Location 的 header 值的 url。如果该值存在的话，则对于\n// 请求问题可以解决相对重定向的问题，如果该值为nil，则返回ErrNOLocation。\nfunc (r *Response) Location() (*url.URL, error) \n\n// 判定在 response 中使用的 http 协议是否至少是 major.minor 的形式。\nfunc (r *Response) ProtoAtLeast(major, minor int) bool \n\n// 将 response 中信息按照线性格式写入 w 中。\nfunc (r *Response) Write(w io.Writer) error \n```\n\n\n## client\n\n前面以 `http.Get(\"http://example.com/\")` `Get` 或 `Post` 函数发送请求，就是通过绑定一个默认 `Client` 实现的。\n使用 `Client` 要先初始化一个 `Client` 对象。`Client` 具有 `Do`，`Get`，`Head`，`Post` 以及 `PostForm` 等方法。\n\n```go\npackage main\n\nimport \"net/http\"\n\nfunc main() {\n    client := http.Client()\n    res, err := client.Get(\"http://www.google.com\")\n}\n```\n对于常用 HTTP 动词，`Client` 对象对应的函数，下面的这些方法与 `http.Get` 等方法一致：\n```go\nfunc (c *Client) Get(url string) (resp *Response, err error)\n\nfunc (c *Client) Head(url string) (resp *Response, err error)\n\nfunc (c *Client) Post(url string, contentType string, body io.Reader) (resp *Response, err error)\n\nfunc (c *Client) PostForm(url string, data url.Values) (resp *Response, err error)\n```\n但是在很多情况下，需要支持对 headers，cookies 等的设定，上面提供的方法就不能满足需求了。就需要使用 `Do` 方法，\n```go\nfunc (c *Client) Do(req *Request) (resp *Response, err error)\n```\n\n`http.NewRequest` 可以灵活的对 `Request` 进行配置，然后再使用 `http.Client` 的 `Do` 方法发送这个 `Request` 请求。\n\n**模拟 HTTP Request**：\n\n```go\n// 简式声明一个 http.Client\nclient := &http.Client{}\n\n// 构建 Request\nrequest, err := http.NewRequest(\"GET\", \"http://www.baidu.com\", nil)\nif err != nil {\n    fmt.Println(err)\n}\n\n// 使用 http.Cookie 结构体初始化一个 cookie 键值对\ncookie := &http.Cookie{Name: \"userId\", Value: strconv.Itoa(12345)}\n\n// AddCookie\nrequest.AddCookie(cookie)\n\n// 设置 Header\nrequest.Header.Set(\"Accept\", \"text/html, application/xhtml+xml, application/xml;q=0.9, */*;q=0.8\")\nrequest.Header.Set(\"Accept-Charset\", \"GBK, utf-8;q=0.7, *;q=0.3\")\nrequest.Header.Set(\"Accept-Encoding\", \"gzip, deflate, sdch\")\nrequest.Header.Set(\"Accept-Language\", \"zh-CN, zh;q=0.8\")\nrequest.Header.Set(\"Cache-Control\", \"max-age=0\")\nrequest.Header.Set(\"Connection\", \"keep-alive\")\n\n// 使用 Do 方法发送请求\nresponse, err := client.Do(request)\nif err != nil {\n    fmt.Println(err)\n    return\n}\n\n// 程序结束时关闭 response.Body 响应流\ndefer response.Body.Close()\n\n// http Response 状态值\nfmt.Println(response.StatusCode)\nif response.StatusCode == 200 {\n\n    // gzip.NewReader对压缩的返回信息解压（考虑网络传输量，http Server\n    // 一般都会对响应压缩后再返回）\n    body, err := gzip.NewReader(response.Body)\n    if err != nil {\n        fmt.Println(err)\n    }\n\n    defer body.Close()\n\n    r, err := ioutil.ReadAll(body)\n    if err != nil {\n        fmt.Println(err)\n    }\n    // 打印出http Server返回的http Response信息\n    fmt.Println(string(r))\n}\n```\n\n\n**Ge请求**：\n\n```go\n// http.Get 实际上是 DefaultClient.Get(url)\nresponse, err := http.Get(\"http://www.baidu.com\")\nif err != nil {\n    fmt.Println(err)\n}\n\n// 程序在使用完回复后必须关闭回复的主体\ndefer response.Body.Close()\n\nbody, _ := ioutil.ReadAll(response.Body)\nfmt.Println(string(body))\n```\n\n**Post 请求**：\n\n```go\n// application/x-www-form-urlencoded：为 POST 的 contentType\nresp, err := http.Post(\"http://localhost:8080/login.do\",\n    \"application/x-www-form-urlencoded\", strings.NewReader(\"mobile=xxxxxxxxxx&isRemberPwd=1\"))\nif err != nil {\n    fmt.Println(err)\n    return\n}\ndefer resp.Body.Close()\nbody, err := ioutil.ReadAll(resp.Body)\nif err != nil {\n    fmt.Println(err)\n    return\n}\nfmt.Println(string(body))\n```\n\n**http.PostForm 请求**：\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/url\"\n)\n\nfunc main() {\n\tpostParam := url.Values{\n\t\t\"mobile\":      {\"xxxxxx\"},\n\t\t\"isRemberPwd\": {\"1\"},\n\t}\n\t// 数据的键值会经过 URL 编码后作为请求的 body 传递\n\tresp, err := http.PostForm(\"http://localhost：8080/login.do\", postParam)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\tdefer resp.Body.Close()\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\tfmt.Println(string(body))\n}\n```\n\n## HTTP Server\n\n`server.go` 文件中定义了一个非常重要的接口：`Handler`，另外还有一个结构体 `response`，这和 `http.Response` 结构体只有首字母大小\n写不一致，这个 `response` 也是响应，只不过是专门用在服务端，和 `http.Response` 结构体是完全两回事。\n\n```go\ntype Handler interface {\n\tServeHTTP(ResponseWriter, *Request)\n}\n\ntype Server struct\n\n// 监听 srv.Addr 然后调用 Serve 来处理接下来连接的请求\n// 如果 srv.Addr 是空的话，则使用 \":http\"\nfunc (srv *Server) ListenAndServe() error \n\n// 监听 srv.Addr ，调用 Serve 来处理接下来连接的请求\n// 必须提供证书文件和对应的私钥文件。如果证书是由\n// 权威机构签发的，certFile 参数必须是顺序串联的服务端证书和 CA 证书。\n\nfunc (srv *Server) ListenAndServeTLS(certFile, keyFile string) error \n\n// 接受 l Listener 的连接，创建一个新的服务协程。该服务协程读取请求然后调用\n// srv.Handler 来应答。实际上就是实现了对某个端口进行监听，然后创建相应的连接。 \nfunc (srv *Server) Serve(l net.Listener) error\n\n// 该函数控制是否 http 的 keep-alives 能够使用，默认情况下，keep-alives 总是可用的。\n// 只有资源非常紧张的环境或者服务端在关闭进程中时，才应该关闭该功能。 \nfunc (s *Server) SetKeepAlivesEnabled(v bool)\n\n// 是一个 http 请求多路复用器，它将每一个请求的 URL 和\n// 一个注册模式的列表进行匹配，然后调用和 URL 最匹配的模式的处理器进行后续操作。\ntype ServeMux\n\n// 初始化一个新的 ServeMux \nfunc NewServeMux() *ServeMux\n\n// 将 handler 注册为指定的模式，如果该模式已经有了 handler，则会出错 panic。\nfunc (mux *ServeMux) Handle(pattern string, handler Handler) \n\n// 将 handler 注册为指定的模式 \nfunc (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Request))\n\n// 根据指定的 r.Method, r.Host 以及 r.RUL.Path 返回一个用来处理给定请求的 handler。\n// 该函数总是返回一个 非 nil 的 handler，如果 path 不是一个规范格式，则 handler 会\n// 重定向到其规范 path。Handler 总是返回匹配该请求的的已注册模式；在内建重定向\n// 处理器的情况下，pattern 会在重定向后进行匹配。如果没有已注册模式可以应用于该请求，\n// 本方法将返回一个内建的 ”404 page not found” 处理器和一个空字符串模式。\nfunc (mux *ServeMux) Handler(r *Request) (h Handler, pattern string) \n\n// 该函数用于将最接近请求 url 模式的 handler 分配给指定的请求。 \nfunc (mux *ServeMux) ServeHTTP(w ResponseWriter, r *Request)\n```\n\n`Handler` 接口是 `server.go` 中最关键的接口，如果我们仔细看这个文件的源代码，将会发现很多结构体实现了这个接口的 `ServeHTTP` 方法。\n\n注意这个接口的注释：`Handler` 响应 HTTP 请求。没错，最终我们的 HTTP 服务是通过实现 `ServeHTTP(ResponseWriter, *Request)` 来达\n到服务端接收客户端请求并响应。\n\n```go\nfunc main() {\n\thttp.HandleFunc(\"/\", MyHandler)\n\t_ = http.ListenAndServe(\":8080\", nil)\n}\n```\n\n以上两行代码，就成功启动了一个 HTTP 服务器。我们通过 `net/http` 包源代码分析发现，调用 `Http.HandleFunc`，按顺序做了几件事：\n\n\n1. `Http.HandleFunc` 调用了 `DefaultServeMux` 的 `HandleFunc`\n\n```go\nfunc HandleFunc(pattern string, handler func(ResponseWriter, *Request)) {\n    DefaultServeMux.HandleFunc(pattern, handler)\n}\n```\n\n2. `DefaultServeMux.HandleFunc` 调用了 `DefaultServeMux` 的 `Handle`，`DefaultServeMux` 是一个 `ServeMux` 指针变量。\n而 `ServeMux` 是 Go 语言中的 `Multiplexer`（多路复用器），通过 `Handle` 匹配 `pattern` 和我们定义的 `handler`\n（其实就是 `http.HandlerFunc` 函数类型变量）。\n\n```go\ntype ServeMux struct {\n\tmu    sync.RWMutex\n\tm     map[string]muxEntry // 保存路由规则 和 handler\n\thosts bool // whether any patterns contain hostnames\n}\n\ntype muxEntry struct {\n\th       Handler\n\tpattern string\n}\n\nvar DefaultServeMux = &defaultServeMux\nvar defaultServeMux ServeMux\n\nfunc (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Request)) {\n\tif handler == nil {\n\t\tpanic(\"http: nil handler\")\n\t}\n\tmux.Handle(pattern, HandlerFunc(handler)) // 这个 handler 就是 MyHandler\n}\n```\n注意：\n上面的方法命名 `Handle`，`HandleFunc` 和 `HandlerFunc`，`Handler`（接口），他们很相似，容易混淆。记住 **`Handle` 和 `HandleFunc` \n和 `pattern` 匹配有关，也即往 `DefaultServeMux` 的 `map[string]muxEntry` 中增加对应的 `handler` 和路由规则**。\n\n接着我们看看 `MyHandler` 的声明和定义：\n\n```go\nfunc MyHandler(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprintf(w, \"hello\")\n}\n```\n而 `type HandlerFunc func(ResponseWriter, *Request)` 是一个函数类型，而我们定义的 `MyHandler` 的函数签名刚好符合这个函数类型。\n\n所以 `http.HandleFunc(\"/\", MyHandler)`，实际上是 `mux.Handle(\"/\", HandlerFunc(MyHandler))`。\n\n`HandlerFunc(MyHandler)` 让 `MyHandler` 成为了 `HandlerFunc` 类型，我们称 `MyHandler` 为 `handler`。而 `HandlerFunc` 类型是\n具有 `ServeHTTP` 方法的，而有了 `ServeHTTP` 方法也就是实现了 `Handler` 接口。\n\n```go\nfunc (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) {\n\tf(w, r) // 这相当于自身的调用\n}\n\n```\n现在 `ServeMux` 和 `Handler` 都和我们的 `MyHandler` 联系上了，`MyHandler` 是一个 `Handler` 接口变量也是 `HandlerFunc` 类型变量，\n接下来和结构体 `server` 有关了。\n\n从 `http.ListenAndServe` 的源码可以看出，它创建了一个 `server` 对象，并调用 `server` 对象的 `ListenAndServe` 方法：\n\n```go\nfunc ListenAndServe(addr string, handler Handler) error {\n    server := &Server{Addr: addr, Handler: handler}\n    return server.ListenAndServe()\n}\n```\n而我们 HTTP 服务器中第二行代码：\n\n```go\nhttp.ListenAndServe(\":8080\", nil)\n```\n\n创建了一个 `server` 对象，并调用 `server` 对象的 `ListenAndServe` 方法，这里没有直接传递 `Handler`，而是默认\n使用 `DefautServeMux` 作为 `multiplexer`。\n\n`Server` 的 `ListenAndServe` 方法中，会初始化监听地址 `Addr`，同时调用 `Listen` 方法设置监听。\n\n```go\nfor {\n    rw, e := l.Accept()\n    if e != nil {\n        select {\n        case <-srv.getDoneChan():\n            return ErrServerClosed\n        default:\n        }\n        if ne, ok := e.(net.Error); ok && ne.Temporary() {\n            if tempDelay == 0 {\n                tempDelay = 5 * time.Millisecond\n            } else {\n                tempDelay *= 2\n            }\n            if max := 1 * time.Second; tempDelay > max {\n                tempDelay = max\n            }\n            srv.logf(\"http: Accept error: %v; retrying in %v\", e, tempDelay)\n            time.Sleep(tempDelay)\n            continue\n        }\n        return e\n    }\n    tempDelay = 0\n    c := srv.newConn(rw)\n    c.setState(c.rwc, StateNew) // before Serve can return\n    go c.serve(ctx)\n}\n```\n监听开启之后，一旦客户端请求过来，Go 就开启一个协程 `go c.serve(ctx)` 处理请求，主要逻辑都在 `serve` 方法之中。\n\n`func (c *conn) serve(ctx context.Context)`，这个方法很长，里面主要的一句：`serverHandler{c.server}.ServeHTTP(w, w.req)`。\n其中 `w` 由 `w, err := c.readRequest(ctx)` 得到，因为有传递 `context`。\n\n还是来看源代码：\n\n```go\n// serverHandler delegates to either the server's Handler or\n// DefaultServeMux and also handles \"OPTIONS *\" requests.\ntype serverHandler struct {\n\tsrv *Server\n}\n\n\nfunc (sh serverHandler) ServeHTTP(rw ResponseWriter, req *Request) {\n    // 此 handler 即为 http.ListenAndServe 中的第二个参数\n    handler := sh.srv.Handler \n    if handler == nil {\n        // 如果 handler 为空则使用内部的 DefaultServeMux 进行处理\n        handler = DefaultServeMux\n    }\n    if req.RequestURI == \"*\" && req.Method == \"OPTIONS\" {\n        handler = globalOptionsHandler{}\n    }\n    // 这里就开始处理 http 请求\n    // 如果需要使用自定义的 mux，就需要实现 ServeHTTP 方法，即实现 Handler 接口。\n    // ServeHTTP(rw, req) 默认情况下是 func (mux *ServeMux) ServeHTTP(w ResponseWriter, r *Request)\n    handler.ServeHTTP(rw, req)\n}\n```\n从 `http.ListenAndServe(\":8080\", nil)` 开始，`handler` 是 `nil`，所以最后实际 `ServeHTTP` 方法\n是 `DefaultServeMux.ServeHTTP(rw, req)`。\n\n```go\nfunc (mux *ServeMux) ServeHTTP(w ResponseWriter, r *Request) {\n\tif r.RequestURI == \"*\" {\n\t\tif r.ProtoAtLeast(1, 1) {\n\t\t\tw.Header().Set(\"Connection\", \"close\")\n\t\t}\n\t\tw.WriteHeader(StatusBadRequest)\n\t\treturn\n\t}\n\th, _ := mux.Handler(r) // 会匹配路由，h 就是 MyHandler\n\th.ServeHTTP(w, r) // 调用自己\n}\n\nfunc (mux *ServeMux) Handler(r *Request) (h Handler, pattern string) {\n\n\t// CONNECT requests are not canonicalized.\n\tif r.Method == \"CONNECT\" {\n\t\t// If r.URL.Path is /tree and its handler is not registered,\n\t\t// the /tree -> /tree/ redirect applies to CONNECT requests\n\t\t// but the path canonicalization does not.\n\t\tif u, ok := mux.redirectToPathSlash(r.URL.Host, r.URL.Path, r.URL); ok {\n\t\t\treturn RedirectHandler(u.String(), StatusMovedPermanently), u.Path\n\t\t}\n\n\t\treturn mux.handler(r.Host, r.URL.Path)\n\t}\n\n\t// All other requests have any port stripped and path cleaned\n\t// before passing to mux.handler.\n\thost := stripHostPort(r.Host)\n\tpath := cleanPath(r.URL.Path)\n\n\t// If the given path is /tree and its handler is not registered,\n\t// redirect for /tree/.\n\tif u, ok := mux.redirectToPathSlash(host, path, r.URL); ok {\n\t\treturn RedirectHandler(u.String(), StatusMovedPermanently), u.Path\n\t}\n\n\tif path != r.URL.Path {\n\t\t_, pattern = mux.handler(host, path)\n\t\turl := *r.URL\n\t\turl.Path = path\n\t\treturn RedirectHandler(url.String(), StatusMovedPermanently), pattern\n\t}\n\n\treturn mux.handler(host, r.URL.Path)\n}\n\n// handler is the main implementation of Handler.\n// The path is known to be in canonical form, except for CONNECT methods.\nfunc (mux *ServeMux) handler(host, path string) (h Handler, pattern string) {\n\tmux.mu.RLock()\n\tdefer mux.mu.RUnlock()\n\n\t// Host-specific pattern takes precedence over generic ones\n\tif mux.hosts {\n\t\th, pattern = mux.match(host + path)\n\t}\n\tif h == nil {\n\t\th, pattern = mux.match(path)\n\t}\n\tif h == nil {\n\t\th, pattern = NotFoundHandler(), \"\"\n\t}\n\treturn\n}\n```\n\n通过 `func (mux *ServeMux) Handler(r *Request) (h Handler, pattern string)`，我们得到 `Handler h`，然后执\n行 `h.ServeHTTP(w, r)` 方法，也就是执行我们的 `MyHandler` 函数（别忘了 `MyHandler` 是HandlerFunc类型，而他的 `ServeHTTP(w, r)` \n方法这里其实就是自己调用自己），把 `response` 写到 `http.ResponseWriter` 对象返回给客户端，`fmt.Fprintf(w, \"hello\")`，我们在客\n户端会接收到 \"hello\" 。至此整个 HTTP 服务执行完成。\n\n\n总结下，HTTP 服务整个过程大概是这样：\n```go\nRequest -> ServeMux(Multiplexer) -> handler-> Response\n```\n\n我们再看下面代码：\n\n```go\nhttp.ListenAndServe(\":8080\", nil)\nfunc ListenAndServe(addr string, handler Handler) error {\n    server := &Server{Addr: addr, Handler: handler}\n    return server.ListenAndServe()\n}\n```\n\n上面代码实际上就是 `server.ListenAndServe()` 执行的实际效果，只不过简单声明了一个结构体 `Server{Addr: addr, Handler: handler}` 实例。\n如果我们声明一个 `Server` 实例，完全可以达到深度自定义 `http.Server` 的目的：\n\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc MyHandler(w http.ResponseWriter, r *http.Request) {\n\t_, _ = fmt.Fprintf(w, \"hi\")\n}\n\nfunc main() {\n\t// 更多http.Server的字段可以根据情况初始化\n\tserver := http.Server{\n\t\tAddr:         \":8080\",\n\t\tReadTimeout:  0,\n\t\tWriteTimeout: 0,\n\t}\n\thttp.HandleFunc(\"/\", MyHandler)\n\t_ = server.ListenAndServe()\n}\n```\n我们完全可以根据情况来自定义我们的 `Server`。\n\n还可以指定 `Servemux` 的用法:\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc MyHandler(w http.ResponseWriter, r *http.Request) {\n\t_, _ = fmt.Fprintf(w, \"hi\")\n}\n\nfunc main() {\n\tmux := http.NewServeMux()\n\n\tmux.HandleFunc(\"/\", MyHandler)\n\t_ = http.ListenAndServe(\":8080\", mux)\n}\n```\n\n如果既指定 `Servemux` 又自定义 `http.Server`，因为 `Server` 中有字段 `Handler`，所以我们可以直接把 `Servemux` 变量作\n为 `Server.Handler`：\n\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc MyHandler(w http.ResponseWriter, r *http.Request) {\n\t_, _ = fmt.Fprintf(w, \"hi\")\n}\n\nfunc main() {\n\tserver := http.Server{\n\t\tAddr:         \":8080\",\n\t\tReadTimeout:  0,\n\t\tWriteTimeout: 0,\n\t}\n\tmux := http.NewServeMux()\n\tserver.Handler = mux\n\n\tmux.HandleFunc(\"/\", MyHandler)\n\t_ = server.ListenAndServe()\n}\n```\n\n## 自定义处理器\n\n自定义的 `Handler`：\n\n标准库 http 提供了 `Handler` 接口，用于开发者实现自己的 `handler`。只要实现接口的 `ServeHTTP` 方法即可。\n\n```go\npackage main\n\nimport (\n\t\"log\"\n\t\"net/http\"\n\t\"time\"\n)\n\ntype timeHandler struct {\n\tformat string\n}\n\nfunc (th *timeHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\ttm := time.Now().Format(th.format)\n\t_, _ = w.Write([]byte(\"The time is: \" + tm))\n}\n\nfunc main() {\n\tmux := http.NewServeMux()\n\n\tth := &timeHandler{format: time.RFC1123}\n\tmux.Handle(\"/time\", th)\n\n\tlog.Println(\"Listening...\")\n\t_ = http.ListenAndServe(\":3000\", mux)\n}\n```\n我们知道，`NewServeMux` 可以创建一个 `ServeMux` 实例，`ServeMux` 同时也实现了 `ServeHTTP` 方法，因此代码中的 `mux` 也是\n一种 `handler`。把它当成参数传给 `http.ListenAndServe` 方法，后者会把 `mux` 传给 `Server` 实例。因为指定了 `handler`，\n因此整个 `http` 服务就不再是 `DefaultServeMux`，而是 `mux`，无论是在注册路由还是提供请求服务的时候。\n\n任何有 `func(http.ResponseWriter，*http.Request)` 签名的函数都能转化为一个 `HandlerFunc` 类型。这很有用，因为 `HandlerFunc` 对象\n内置了 `ServeHTTP` 方法，后者可以聪明又方便的调用我们最初提供的函数内容。\n\n## 中间件 Middleware\n\n所谓中间件，就是连接上下级不同功能的函数或者软件，通常进行一些包裹函数的行为，为被包裹函数提供添加一些功能或行为。前文的 `HandleFunc` 就\n能把签名为 `func(w http.ResponseWriter, r *http.Reqeust)` 的函数包裹成 `handler`。这个函数也算是中间件。\n\nGo 的 HTTP 中间件很简单，只要实现一个函数签名为 `func(http.Handler) http.Handler` 的函数即可。`http.Handler` 是一个接口，\n接口方法我们熟悉的为 `serveHTTP`。返回也是一个 `handler`。因为 Go 中的函数也可以当成变量传递或者或者返回，因此也可以在中间件函数\n中传递定义好的函数，只要这个函数是一个 `handler` 即可，即实现或者被 `handlerFunc` 包裹成为 `handler` 处理器。\n\n```go\nfunc index(w http.ResponseWriter, r *http.Request) {\n    w.Header().Set(\"Content-Type\", \"text/html\")\n\n    html := `<doctype html>\n        <html>\n        <head>\n          <title>Hello World</title>\n        </head>\n        <body>\n        <p>\n          Welcome\n        </p>\n        </body>\n</html>`\n    fmt.Fprintln(w, html)\n}\n\nfunc middlewareHandler(next http.Handler) http.Handler{\n    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request){\n        // 执行 handler 之前的逻辑\n        next.ServeHTTP(w, r)\n        // 执行完毕 handler 后的逻辑\n    })\n}\n\nfunc loggingHandler(next http.Handler) http.Handler {\n    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n        start := time.Now()\n        log.Printf(\"Started %s %s\", r.Method, r.URL.Path)\n        next.ServeHTTP(w, r)\n        log.Printf(\"Completed %s in %v\", r.URL.Path, time.Since(start))\n    })\n}\n\nfunc main() {\n    http.Handle(\"/\", loggingHandler(http.HandlerFunc(index)))\n\n    http.ListenAndServe(\":8000\", nil)\n}\n```\n\n## 静态站点\n\n下面代码通过指定目录，作为静态站点：\n```go\npackage main\n\nimport (\n\t\"net/http\"\n)\n\nfunc main() {\n\thttp.Handle(\"/\", http.FileServer(http.Dir(\"D:/html/static/\")))\n\t_ = http.ListenAndServe(\":8080\", nil)\n}\n```","source":"standards/net/http.md","raw":"---\ntitle: http\n---\n# http\n\n\n`net/http` 可以用来处理 HTTP 协议，包括 HTTP 服务器和 HTTP 客户端，主要组成：\n\n- Request，HTTP 请求对象\n- Response，HTTP 响应对象\n- Client，HTTP 客户端\n- Server，HTTP 服务端\n\n创建一个 server ：\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc MyHandler(w http.ResponseWriter, r *http.Request) {\n\t_, _ = fmt.Fprintf(w, \"hello\")\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/\", MyHandler)\n\t_ = http.ListenAndServe(\":8080\", nil)\n}\n```\n\n发送请求：\n```go\nresp, err := http.Get(\"http://example.com/\") // GET \n\nresp, err := http.Post(\"http://example.com/\") // POST\n\nresp, err := http.PostForm(\"http://example.com/\", url.Values{\"foo\": \"bar\"}) // 提交表单\n```\n\n## Request\n\n`Request` 对象是对 http 请求报文的抽象。包括起始行, `Headers`, `Body` 等。\n\n使用 `http.NewRequest` 函数创建一个 `Request` 请求对象：\n```go\nfunc NewRequest(method, url string, body io.Reader) (*Request, error)\n```\n\n`Request` 对象主要用于数据的存储，结构：\n```go\ntype Request struct {\n    Method string // HTTP方法\n    URL *url.URL // URL\n    \n    Proto      string // \"HTTP/1.0\"\n    ProtoMajor int    // 1\n    ProtoMinor int    // 0\n\n    Header Header // 报文头\n    Body io.ReadCloser // 报文体\n    GetBody func() (io.ReadCloser, error)\n    ContentLength int64 // 报文长度\n    TransferEncoding []string // 传输编码\n    Close bool // 关闭连接\n    Host string // 主机名\n    \n    Form url.Values // \n    PostForm url.Values // POST表单信息\n    MultipartForm *multipart.Form // multipart，\n\n    Trailer Header\n    RemoteAddr string\n    RequestURI string\n    TLS *tls.ConnectionState\n    Cancel <-chan struct{}\n    Response *Response\n}\n```\n\n```go\n// 从 b 中读取和解析一个请求. \nfunc ReadRequest(b *bufio.Reader) (req *Request, err error)\n\n// 给 request 添加 cookie, AddCookie 向请求中添加一个 cookie.按照RFC 6265 \n// section 5.4的规则, AddCookie 不会添加超过一个 Cookie 头字段.\n// 这表示所有的 cookie 都写在同一行, 用分号分隔（cookie 内部用逗号分隔属性） \nfunc (r *Request) AddCookie(c *Cookie)\n\n// 返回 request 中指定名 name 的 cookie，如果没有发现，返回 ErrNoCookie \nfunc (r *Request) Cookie(name string) (*Cookie, error)\n\n// 返回该请求的所有cookies \nfunc (r *Request) Cookies() []*Cookie\n\n// 利用提供的用户名和密码给 http 基本权限提供具有一定权限的 header。\n// 当使用 http 基本授权时，用户名和密码是不加密的 \nfunc (r *Request) SetBasicAuth(username, password string)\n\n// 如果在 request 中发送，该函数返回客户端的 user-Agent\nfunc (r *Request) UserAgent() string\n\n// 对于指定格式的 key，FormFile 返回符合条件的第一个文件，如果有必要的话，\n// 该函数会调用 ParseMultipartForm 和 ParseForm。 \nfunc (r *Request) FormFile(key string) (multipart.File, *multipart.FileHeader, error)\n\n// 返回 key 获取的队列中第一个值。在查询过程中 post 和 put 中的主题参数优先级\n// 高于 url 中的 value。为了访问相同 key 的多个值，调用 ParseForm 然后直接\n// 检查 RequestForm。 \nfunc (r *Request) FormValue(key string) string\n\n// 如果这是一个有多部分组成的 post 请求，该函数将会返回一个 MIME 多部分 reader，\n// 否则的话将会返回一个 nil 和 error。使用本函数代替 ParseMultipartForm\n// 可以将请求 body 当做流 stream 来处理。 \nfunc (r *Request) MultipartReader() (*multipart.Reader, error)\n\n// 解析URL中的查询字符串，并将解析结果更新到 r.Form 字段。对于POST 或 PUT\n// 请求，ParseForm 还会将 body 当作表单解析，并将结果既更新到 r.PostForm 也\n// 更新到 r.Form。解析结果中，POST 或 PUT 请求主体要优先于 URL 查询字符串\n// （同名变量，主体的值在查询字符串的值前面）。如果请求的主体的大小没有被\n// MaxBytesReader 函数设定限制，其大小默认限制为开头 10MB。\n// ParseMultipartForm 会自动调用 ParseForm。重复调用本方法是无意义的。\nfunc (r *Request) ParseForm() error \n\n// ParseMultipartForm 将请求的主体作为 multipart/form-data 解析。\n// 请求的整个主体都会被解析，得到的文件记录最多 maxMemery 字节保存在内存，\n// 其余部分保存在硬盘的 temp 文件里。如果必要，ParseMultipartForm 会\n// 自行调用 ParseForm。重复调用本方法是无意义的。\nfunc (r *Request) ParseMultipartForm(maxMemory int64) error \n\n// 返回 post 或者 put 请求 body 指定元素的第一个值，其中 url 中的参数被忽略。\nfunc (r *Request) PostFormValue(key string) string \n\n// 检测在 request 中使用的 http 协议是否至少是 major.minor \nfunc (r *Request) ProtoAtLeast(major, minor int) bool\n\n// 如果 request 中有 refer，那么 refer 返回相应的 url。Referer 在 request\n// 中是拼错的(Referrer)，这个错误从 http 初期就已经存在了。该值也可以从 Headermap 中\n// 利用 Header[\"Referer\"] 获取；在使用过程中利用 Referer 这个方法而\n// 不是 map 的形式的好处是在编译过程中可以检查方法的错误，而无法检查 map 中\n// key 的错误。\nfunc (r *Request) Referer() string \n\n// Write 方法以有线格式将 HTTP/1.1 请求写入 w（用于将请求写入下层 TCPConn 等）\n// 。本方法会考虑请求的如下字段：Host URL Method (defaults to \"GET\")\n//  Header ContentLength TransferEncoding Body如果存在Body，\n// ContentLength字段<= 0且TransferEncoding字段未显式设置为\n// [\"identity\"]，Write 方法会显式添加 ”Transfer-Encoding: chunked”\n// 到请求的头域。Body 字段会在发送完请求后关闭。\nfunc (r *Request) Write(w io.Writer) error \n\n// 该函数与 Write 方法类似，但是该方法写的 request 是按照 http 代理的格式去写。\n// 尤其是，按照 RFC 2616 Section 5.1.2，WriteProxy 会使用绝对 URI\n// （包括协议和主机名）来初始化请求的第1行（Request-URI行）。无论何种情况，\n// WriteProxy 都会使用 r.Host 或 r.URL.Host 设置 Host 头。\nfunc (r *Request) WriteProxy(w io.Writer) error \n```\n\n## Response\n\nResponse 也是一个数据对象，描述 HTTP 响应：\n```go\ntype Response struct {\n    Status     string // HTTP 状态码\n    StatusCode int    // 状态码 200\n    Proto      string // 版本号 \"HTTP/1.0\"\n    ProtoMajor int    // 主版本号 \n    ProtoMinor int    // 次版本号\n\n    Header Header // 响应报文头\n    Body io.ReadCloser // 响应报文体\n    ContentLength int64 // 报文长度\n    TransferEncoding []string // 报文编码\n    Close bool \n    Trailer Header\n    Request *Request // 请求对象\n    TLS *tls.ConnectionState\n}\n```\n\n```go\n// ReadResponse 从 r 读取并返回一个 HTTP 回复。req 参数是可选的，指定该回复\n// 对应的请求（即是对该请求的回复）。如果是 nil，将假设请 求是 GET 请求。\n// 客户端必须在结束 resp.Body 的读取后关闭它。读取完毕并关闭后，客户端可以\n// 检查 resp.Trailer 字段获取回复的 trailer 的键值对。\nfunc ReadResponse(r *bufio.Reader, req *Request) (*Response, error)\n\n// 解析 cookie 并返回在 header 中利用 set-Cookie 设定的 cookie 值。\nfunc (r *Response) Cookies() []*Cookie \n\n// 返回 response 中 Location 的 header 值的 url。如果该值存在的话，则对于\n// 请求问题可以解决相对重定向的问题，如果该值为nil，则返回ErrNOLocation。\nfunc (r *Response) Location() (*url.URL, error) \n\n// 判定在 response 中使用的 http 协议是否至少是 major.minor 的形式。\nfunc (r *Response) ProtoAtLeast(major, minor int) bool \n\n// 将 response 中信息按照线性格式写入 w 中。\nfunc (r *Response) Write(w io.Writer) error \n```\n\n\n## client\n\n前面以 `http.Get(\"http://example.com/\")` `Get` 或 `Post` 函数发送请求，就是通过绑定一个默认 `Client` 实现的。\n使用 `Client` 要先初始化一个 `Client` 对象。`Client` 具有 `Do`，`Get`，`Head`，`Post` 以及 `PostForm` 等方法。\n\n```go\npackage main\n\nimport \"net/http\"\n\nfunc main() {\n    client := http.Client()\n    res, err := client.Get(\"http://www.google.com\")\n}\n```\n对于常用 HTTP 动词，`Client` 对象对应的函数，下面的这些方法与 `http.Get` 等方法一致：\n```go\nfunc (c *Client) Get(url string) (resp *Response, err error)\n\nfunc (c *Client) Head(url string) (resp *Response, err error)\n\nfunc (c *Client) Post(url string, contentType string, body io.Reader) (resp *Response, err error)\n\nfunc (c *Client) PostForm(url string, data url.Values) (resp *Response, err error)\n```\n但是在很多情况下，需要支持对 headers，cookies 等的设定，上面提供的方法就不能满足需求了。就需要使用 `Do` 方法，\n```go\nfunc (c *Client) Do(req *Request) (resp *Response, err error)\n```\n\n`http.NewRequest` 可以灵活的对 `Request` 进行配置，然后再使用 `http.Client` 的 `Do` 方法发送这个 `Request` 请求。\n\n**模拟 HTTP Request**：\n\n```go\n// 简式声明一个 http.Client\nclient := &http.Client{}\n\n// 构建 Request\nrequest, err := http.NewRequest(\"GET\", \"http://www.baidu.com\", nil)\nif err != nil {\n    fmt.Println(err)\n}\n\n// 使用 http.Cookie 结构体初始化一个 cookie 键值对\ncookie := &http.Cookie{Name: \"userId\", Value: strconv.Itoa(12345)}\n\n// AddCookie\nrequest.AddCookie(cookie)\n\n// 设置 Header\nrequest.Header.Set(\"Accept\", \"text/html, application/xhtml+xml, application/xml;q=0.9, */*;q=0.8\")\nrequest.Header.Set(\"Accept-Charset\", \"GBK, utf-8;q=0.7, *;q=0.3\")\nrequest.Header.Set(\"Accept-Encoding\", \"gzip, deflate, sdch\")\nrequest.Header.Set(\"Accept-Language\", \"zh-CN, zh;q=0.8\")\nrequest.Header.Set(\"Cache-Control\", \"max-age=0\")\nrequest.Header.Set(\"Connection\", \"keep-alive\")\n\n// 使用 Do 方法发送请求\nresponse, err := client.Do(request)\nif err != nil {\n    fmt.Println(err)\n    return\n}\n\n// 程序结束时关闭 response.Body 响应流\ndefer response.Body.Close()\n\n// http Response 状态值\nfmt.Println(response.StatusCode)\nif response.StatusCode == 200 {\n\n    // gzip.NewReader对压缩的返回信息解压（考虑网络传输量，http Server\n    // 一般都会对响应压缩后再返回）\n    body, err := gzip.NewReader(response.Body)\n    if err != nil {\n        fmt.Println(err)\n    }\n\n    defer body.Close()\n\n    r, err := ioutil.ReadAll(body)\n    if err != nil {\n        fmt.Println(err)\n    }\n    // 打印出http Server返回的http Response信息\n    fmt.Println(string(r))\n}\n```\n\n\n**Ge请求**：\n\n```go\n// http.Get 实际上是 DefaultClient.Get(url)\nresponse, err := http.Get(\"http://www.baidu.com\")\nif err != nil {\n    fmt.Println(err)\n}\n\n// 程序在使用完回复后必须关闭回复的主体\ndefer response.Body.Close()\n\nbody, _ := ioutil.ReadAll(response.Body)\nfmt.Println(string(body))\n```\n\n**Post 请求**：\n\n```go\n// application/x-www-form-urlencoded：为 POST 的 contentType\nresp, err := http.Post(\"http://localhost:8080/login.do\",\n    \"application/x-www-form-urlencoded\", strings.NewReader(\"mobile=xxxxxxxxxx&isRemberPwd=1\"))\nif err != nil {\n    fmt.Println(err)\n    return\n}\ndefer resp.Body.Close()\nbody, err := ioutil.ReadAll(resp.Body)\nif err != nil {\n    fmt.Println(err)\n    return\n}\nfmt.Println(string(body))\n```\n\n**http.PostForm 请求**：\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/url\"\n)\n\nfunc main() {\n\tpostParam := url.Values{\n\t\t\"mobile\":      {\"xxxxxx\"},\n\t\t\"isRemberPwd\": {\"1\"},\n\t}\n\t// 数据的键值会经过 URL 编码后作为请求的 body 传递\n\tresp, err := http.PostForm(\"http://localhost：8080/login.do\", postParam)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\tdefer resp.Body.Close()\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\tfmt.Println(string(body))\n}\n```\n\n## HTTP Server\n\n`server.go` 文件中定义了一个非常重要的接口：`Handler`，另外还有一个结构体 `response`，这和 `http.Response` 结构体只有首字母大小\n写不一致，这个 `response` 也是响应，只不过是专门用在服务端，和 `http.Response` 结构体是完全两回事。\n\n```go\ntype Handler interface {\n\tServeHTTP(ResponseWriter, *Request)\n}\n\ntype Server struct\n\n// 监听 srv.Addr 然后调用 Serve 来处理接下来连接的请求\n// 如果 srv.Addr 是空的话，则使用 \":http\"\nfunc (srv *Server) ListenAndServe() error \n\n// 监听 srv.Addr ，调用 Serve 来处理接下来连接的请求\n// 必须提供证书文件和对应的私钥文件。如果证书是由\n// 权威机构签发的，certFile 参数必须是顺序串联的服务端证书和 CA 证书。\n\nfunc (srv *Server) ListenAndServeTLS(certFile, keyFile string) error \n\n// 接受 l Listener 的连接，创建一个新的服务协程。该服务协程读取请求然后调用\n// srv.Handler 来应答。实际上就是实现了对某个端口进行监听，然后创建相应的连接。 \nfunc (srv *Server) Serve(l net.Listener) error\n\n// 该函数控制是否 http 的 keep-alives 能够使用，默认情况下，keep-alives 总是可用的。\n// 只有资源非常紧张的环境或者服务端在关闭进程中时，才应该关闭该功能。 \nfunc (s *Server) SetKeepAlivesEnabled(v bool)\n\n// 是一个 http 请求多路复用器，它将每一个请求的 URL 和\n// 一个注册模式的列表进行匹配，然后调用和 URL 最匹配的模式的处理器进行后续操作。\ntype ServeMux\n\n// 初始化一个新的 ServeMux \nfunc NewServeMux() *ServeMux\n\n// 将 handler 注册为指定的模式，如果该模式已经有了 handler，则会出错 panic。\nfunc (mux *ServeMux) Handle(pattern string, handler Handler) \n\n// 将 handler 注册为指定的模式 \nfunc (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Request))\n\n// 根据指定的 r.Method, r.Host 以及 r.RUL.Path 返回一个用来处理给定请求的 handler。\n// 该函数总是返回一个 非 nil 的 handler，如果 path 不是一个规范格式，则 handler 会\n// 重定向到其规范 path。Handler 总是返回匹配该请求的的已注册模式；在内建重定向\n// 处理器的情况下，pattern 会在重定向后进行匹配。如果没有已注册模式可以应用于该请求，\n// 本方法将返回一个内建的 ”404 page not found” 处理器和一个空字符串模式。\nfunc (mux *ServeMux) Handler(r *Request) (h Handler, pattern string) \n\n// 该函数用于将最接近请求 url 模式的 handler 分配给指定的请求。 \nfunc (mux *ServeMux) ServeHTTP(w ResponseWriter, r *Request)\n```\n\n`Handler` 接口是 `server.go` 中最关键的接口，如果我们仔细看这个文件的源代码，将会发现很多结构体实现了这个接口的 `ServeHTTP` 方法。\n\n注意这个接口的注释：`Handler` 响应 HTTP 请求。没错，最终我们的 HTTP 服务是通过实现 `ServeHTTP(ResponseWriter, *Request)` 来达\n到服务端接收客户端请求并响应。\n\n```go\nfunc main() {\n\thttp.HandleFunc(\"/\", MyHandler)\n\t_ = http.ListenAndServe(\":8080\", nil)\n}\n```\n\n以上两行代码，就成功启动了一个 HTTP 服务器。我们通过 `net/http` 包源代码分析发现，调用 `Http.HandleFunc`，按顺序做了几件事：\n\n\n1. `Http.HandleFunc` 调用了 `DefaultServeMux` 的 `HandleFunc`\n\n```go\nfunc HandleFunc(pattern string, handler func(ResponseWriter, *Request)) {\n    DefaultServeMux.HandleFunc(pattern, handler)\n}\n```\n\n2. `DefaultServeMux.HandleFunc` 调用了 `DefaultServeMux` 的 `Handle`，`DefaultServeMux` 是一个 `ServeMux` 指针变量。\n而 `ServeMux` 是 Go 语言中的 `Multiplexer`（多路复用器），通过 `Handle` 匹配 `pattern` 和我们定义的 `handler`\n（其实就是 `http.HandlerFunc` 函数类型变量）。\n\n```go\ntype ServeMux struct {\n\tmu    sync.RWMutex\n\tm     map[string]muxEntry // 保存路由规则 和 handler\n\thosts bool // whether any patterns contain hostnames\n}\n\ntype muxEntry struct {\n\th       Handler\n\tpattern string\n}\n\nvar DefaultServeMux = &defaultServeMux\nvar defaultServeMux ServeMux\n\nfunc (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Request)) {\n\tif handler == nil {\n\t\tpanic(\"http: nil handler\")\n\t}\n\tmux.Handle(pattern, HandlerFunc(handler)) // 这个 handler 就是 MyHandler\n}\n```\n注意：\n上面的方法命名 `Handle`，`HandleFunc` 和 `HandlerFunc`，`Handler`（接口），他们很相似，容易混淆。记住 **`Handle` 和 `HandleFunc` \n和 `pattern` 匹配有关，也即往 `DefaultServeMux` 的 `map[string]muxEntry` 中增加对应的 `handler` 和路由规则**。\n\n接着我们看看 `MyHandler` 的声明和定义：\n\n```go\nfunc MyHandler(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprintf(w, \"hello\")\n}\n```\n而 `type HandlerFunc func(ResponseWriter, *Request)` 是一个函数类型，而我们定义的 `MyHandler` 的函数签名刚好符合这个函数类型。\n\n所以 `http.HandleFunc(\"/\", MyHandler)`，实际上是 `mux.Handle(\"/\", HandlerFunc(MyHandler))`。\n\n`HandlerFunc(MyHandler)` 让 `MyHandler` 成为了 `HandlerFunc` 类型，我们称 `MyHandler` 为 `handler`。而 `HandlerFunc` 类型是\n具有 `ServeHTTP` 方法的，而有了 `ServeHTTP` 方法也就是实现了 `Handler` 接口。\n\n```go\nfunc (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) {\n\tf(w, r) // 这相当于自身的调用\n}\n\n```\n现在 `ServeMux` 和 `Handler` 都和我们的 `MyHandler` 联系上了，`MyHandler` 是一个 `Handler` 接口变量也是 `HandlerFunc` 类型变量，\n接下来和结构体 `server` 有关了。\n\n从 `http.ListenAndServe` 的源码可以看出，它创建了一个 `server` 对象，并调用 `server` 对象的 `ListenAndServe` 方法：\n\n```go\nfunc ListenAndServe(addr string, handler Handler) error {\n    server := &Server{Addr: addr, Handler: handler}\n    return server.ListenAndServe()\n}\n```\n而我们 HTTP 服务器中第二行代码：\n\n```go\nhttp.ListenAndServe(\":8080\", nil)\n```\n\n创建了一个 `server` 对象，并调用 `server` 对象的 `ListenAndServe` 方法，这里没有直接传递 `Handler`，而是默认\n使用 `DefautServeMux` 作为 `multiplexer`。\n\n`Server` 的 `ListenAndServe` 方法中，会初始化监听地址 `Addr`，同时调用 `Listen` 方法设置监听。\n\n```go\nfor {\n    rw, e := l.Accept()\n    if e != nil {\n        select {\n        case <-srv.getDoneChan():\n            return ErrServerClosed\n        default:\n        }\n        if ne, ok := e.(net.Error); ok && ne.Temporary() {\n            if tempDelay == 0 {\n                tempDelay = 5 * time.Millisecond\n            } else {\n                tempDelay *= 2\n            }\n            if max := 1 * time.Second; tempDelay > max {\n                tempDelay = max\n            }\n            srv.logf(\"http: Accept error: %v; retrying in %v\", e, tempDelay)\n            time.Sleep(tempDelay)\n            continue\n        }\n        return e\n    }\n    tempDelay = 0\n    c := srv.newConn(rw)\n    c.setState(c.rwc, StateNew) // before Serve can return\n    go c.serve(ctx)\n}\n```\n监听开启之后，一旦客户端请求过来，Go 就开启一个协程 `go c.serve(ctx)` 处理请求，主要逻辑都在 `serve` 方法之中。\n\n`func (c *conn) serve(ctx context.Context)`，这个方法很长，里面主要的一句：`serverHandler{c.server}.ServeHTTP(w, w.req)`。\n其中 `w` 由 `w, err := c.readRequest(ctx)` 得到，因为有传递 `context`。\n\n还是来看源代码：\n\n```go\n// serverHandler delegates to either the server's Handler or\n// DefaultServeMux and also handles \"OPTIONS *\" requests.\ntype serverHandler struct {\n\tsrv *Server\n}\n\n\nfunc (sh serverHandler) ServeHTTP(rw ResponseWriter, req *Request) {\n    // 此 handler 即为 http.ListenAndServe 中的第二个参数\n    handler := sh.srv.Handler \n    if handler == nil {\n        // 如果 handler 为空则使用内部的 DefaultServeMux 进行处理\n        handler = DefaultServeMux\n    }\n    if req.RequestURI == \"*\" && req.Method == \"OPTIONS\" {\n        handler = globalOptionsHandler{}\n    }\n    // 这里就开始处理 http 请求\n    // 如果需要使用自定义的 mux，就需要实现 ServeHTTP 方法，即实现 Handler 接口。\n    // ServeHTTP(rw, req) 默认情况下是 func (mux *ServeMux) ServeHTTP(w ResponseWriter, r *Request)\n    handler.ServeHTTP(rw, req)\n}\n```\n从 `http.ListenAndServe(\":8080\", nil)` 开始，`handler` 是 `nil`，所以最后实际 `ServeHTTP` 方法\n是 `DefaultServeMux.ServeHTTP(rw, req)`。\n\n```go\nfunc (mux *ServeMux) ServeHTTP(w ResponseWriter, r *Request) {\n\tif r.RequestURI == \"*\" {\n\t\tif r.ProtoAtLeast(1, 1) {\n\t\t\tw.Header().Set(\"Connection\", \"close\")\n\t\t}\n\t\tw.WriteHeader(StatusBadRequest)\n\t\treturn\n\t}\n\th, _ := mux.Handler(r) // 会匹配路由，h 就是 MyHandler\n\th.ServeHTTP(w, r) // 调用自己\n}\n\nfunc (mux *ServeMux) Handler(r *Request) (h Handler, pattern string) {\n\n\t// CONNECT requests are not canonicalized.\n\tif r.Method == \"CONNECT\" {\n\t\t// If r.URL.Path is /tree and its handler is not registered,\n\t\t// the /tree -> /tree/ redirect applies to CONNECT requests\n\t\t// but the path canonicalization does not.\n\t\tif u, ok := mux.redirectToPathSlash(r.URL.Host, r.URL.Path, r.URL); ok {\n\t\t\treturn RedirectHandler(u.String(), StatusMovedPermanently), u.Path\n\t\t}\n\n\t\treturn mux.handler(r.Host, r.URL.Path)\n\t}\n\n\t// All other requests have any port stripped and path cleaned\n\t// before passing to mux.handler.\n\thost := stripHostPort(r.Host)\n\tpath := cleanPath(r.URL.Path)\n\n\t// If the given path is /tree and its handler is not registered,\n\t// redirect for /tree/.\n\tif u, ok := mux.redirectToPathSlash(host, path, r.URL); ok {\n\t\treturn RedirectHandler(u.String(), StatusMovedPermanently), u.Path\n\t}\n\n\tif path != r.URL.Path {\n\t\t_, pattern = mux.handler(host, path)\n\t\turl := *r.URL\n\t\turl.Path = path\n\t\treturn RedirectHandler(url.String(), StatusMovedPermanently), pattern\n\t}\n\n\treturn mux.handler(host, r.URL.Path)\n}\n\n// handler is the main implementation of Handler.\n// The path is known to be in canonical form, except for CONNECT methods.\nfunc (mux *ServeMux) handler(host, path string) (h Handler, pattern string) {\n\tmux.mu.RLock()\n\tdefer mux.mu.RUnlock()\n\n\t// Host-specific pattern takes precedence over generic ones\n\tif mux.hosts {\n\t\th, pattern = mux.match(host + path)\n\t}\n\tif h == nil {\n\t\th, pattern = mux.match(path)\n\t}\n\tif h == nil {\n\t\th, pattern = NotFoundHandler(), \"\"\n\t}\n\treturn\n}\n```\n\n通过 `func (mux *ServeMux) Handler(r *Request) (h Handler, pattern string)`，我们得到 `Handler h`，然后执\n行 `h.ServeHTTP(w, r)` 方法，也就是执行我们的 `MyHandler` 函数（别忘了 `MyHandler` 是HandlerFunc类型，而他的 `ServeHTTP(w, r)` \n方法这里其实就是自己调用自己），把 `response` 写到 `http.ResponseWriter` 对象返回给客户端，`fmt.Fprintf(w, \"hello\")`，我们在客\n户端会接收到 \"hello\" 。至此整个 HTTP 服务执行完成。\n\n\n总结下，HTTP 服务整个过程大概是这样：\n```go\nRequest -> ServeMux(Multiplexer) -> handler-> Response\n```\n\n我们再看下面代码：\n\n```go\nhttp.ListenAndServe(\":8080\", nil)\nfunc ListenAndServe(addr string, handler Handler) error {\n    server := &Server{Addr: addr, Handler: handler}\n    return server.ListenAndServe()\n}\n```\n\n上面代码实际上就是 `server.ListenAndServe()` 执行的实际效果，只不过简单声明了一个结构体 `Server{Addr: addr, Handler: handler}` 实例。\n如果我们声明一个 `Server` 实例，完全可以达到深度自定义 `http.Server` 的目的：\n\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc MyHandler(w http.ResponseWriter, r *http.Request) {\n\t_, _ = fmt.Fprintf(w, \"hi\")\n}\n\nfunc main() {\n\t// 更多http.Server的字段可以根据情况初始化\n\tserver := http.Server{\n\t\tAddr:         \":8080\",\n\t\tReadTimeout:  0,\n\t\tWriteTimeout: 0,\n\t}\n\thttp.HandleFunc(\"/\", MyHandler)\n\t_ = server.ListenAndServe()\n}\n```\n我们完全可以根据情况来自定义我们的 `Server`。\n\n还可以指定 `Servemux` 的用法:\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc MyHandler(w http.ResponseWriter, r *http.Request) {\n\t_, _ = fmt.Fprintf(w, \"hi\")\n}\n\nfunc main() {\n\tmux := http.NewServeMux()\n\n\tmux.HandleFunc(\"/\", MyHandler)\n\t_ = http.ListenAndServe(\":8080\", mux)\n}\n```\n\n如果既指定 `Servemux` 又自定义 `http.Server`，因为 `Server` 中有字段 `Handler`，所以我们可以直接把 `Servemux` 变量作\n为 `Server.Handler`：\n\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc MyHandler(w http.ResponseWriter, r *http.Request) {\n\t_, _ = fmt.Fprintf(w, \"hi\")\n}\n\nfunc main() {\n\tserver := http.Server{\n\t\tAddr:         \":8080\",\n\t\tReadTimeout:  0,\n\t\tWriteTimeout: 0,\n\t}\n\tmux := http.NewServeMux()\n\tserver.Handler = mux\n\n\tmux.HandleFunc(\"/\", MyHandler)\n\t_ = server.ListenAndServe()\n}\n```\n\n## 自定义处理器\n\n自定义的 `Handler`：\n\n标准库 http 提供了 `Handler` 接口，用于开发者实现自己的 `handler`。只要实现接口的 `ServeHTTP` 方法即可。\n\n```go\npackage main\n\nimport (\n\t\"log\"\n\t\"net/http\"\n\t\"time\"\n)\n\ntype timeHandler struct {\n\tformat string\n}\n\nfunc (th *timeHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\ttm := time.Now().Format(th.format)\n\t_, _ = w.Write([]byte(\"The time is: \" + tm))\n}\n\nfunc main() {\n\tmux := http.NewServeMux()\n\n\tth := &timeHandler{format: time.RFC1123}\n\tmux.Handle(\"/time\", th)\n\n\tlog.Println(\"Listening...\")\n\t_ = http.ListenAndServe(\":3000\", mux)\n}\n```\n我们知道，`NewServeMux` 可以创建一个 `ServeMux` 实例，`ServeMux` 同时也实现了 `ServeHTTP` 方法，因此代码中的 `mux` 也是\n一种 `handler`。把它当成参数传给 `http.ListenAndServe` 方法，后者会把 `mux` 传给 `Server` 实例。因为指定了 `handler`，\n因此整个 `http` 服务就不再是 `DefaultServeMux`，而是 `mux`，无论是在注册路由还是提供请求服务的时候。\n\n任何有 `func(http.ResponseWriter，*http.Request)` 签名的函数都能转化为一个 `HandlerFunc` 类型。这很有用，因为 `HandlerFunc` 对象\n内置了 `ServeHTTP` 方法，后者可以聪明又方便的调用我们最初提供的函数内容。\n\n## 中间件 Middleware\n\n所谓中间件，就是连接上下级不同功能的函数或者软件，通常进行一些包裹函数的行为，为被包裹函数提供添加一些功能或行为。前文的 `HandleFunc` 就\n能把签名为 `func(w http.ResponseWriter, r *http.Reqeust)` 的函数包裹成 `handler`。这个函数也算是中间件。\n\nGo 的 HTTP 中间件很简单，只要实现一个函数签名为 `func(http.Handler) http.Handler` 的函数即可。`http.Handler` 是一个接口，\n接口方法我们熟悉的为 `serveHTTP`。返回也是一个 `handler`。因为 Go 中的函数也可以当成变量传递或者或者返回，因此也可以在中间件函数\n中传递定义好的函数，只要这个函数是一个 `handler` 即可，即实现或者被 `handlerFunc` 包裹成为 `handler` 处理器。\n\n```go\nfunc index(w http.ResponseWriter, r *http.Request) {\n    w.Header().Set(\"Content-Type\", \"text/html\")\n\n    html := `<doctype html>\n        <html>\n        <head>\n          <title>Hello World</title>\n        </head>\n        <body>\n        <p>\n          Welcome\n        </p>\n        </body>\n</html>`\n    fmt.Fprintln(w, html)\n}\n\nfunc middlewareHandler(next http.Handler) http.Handler{\n    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request){\n        // 执行 handler 之前的逻辑\n        next.ServeHTTP(w, r)\n        // 执行完毕 handler 后的逻辑\n    })\n}\n\nfunc loggingHandler(next http.Handler) http.Handler {\n    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n        start := time.Now()\n        log.Printf(\"Started %s %s\", r.Method, r.URL.Path)\n        next.ServeHTTP(w, r)\n        log.Printf(\"Completed %s in %v\", r.URL.Path, time.Since(start))\n    })\n}\n\nfunc main() {\n    http.Handle(\"/\", loggingHandler(http.HandlerFunc(index)))\n\n    http.ListenAndServe(\":8000\", nil)\n}\n```\n\n## 静态站点\n\n下面代码通过指定目录，作为静态站点：\n```go\npackage main\n\nimport (\n\t\"net/http\"\n)\n\nfunc main() {\n\thttp.Handle(\"/\", http.FileServer(http.Dir(\"D:/html/static/\")))\n\t_ = http.ListenAndServe(\":8080\", nil)\n}\n```","date":"2019-10-19T13:40:15.181Z","updated":"2019-10-19T13:40:15.181Z","path":"standards/net/http.html","comments":1,"layout":"page","_id":"ck1xm14ls001efcw2gw8lnyiw","content":"<h1 id=\"http\"><a href=\"#http\" class=\"headerlink\" title=\"http\"></a>http</h1><p><code>net/http</code> 可以用来处理 HTTP 协议，包括 HTTP 服务器和 HTTP 客户端，主要组成：</p>\n<ul>\n<li>Request，HTTP 请求对象</li>\n<li>Response，HTTP 响应对象</li>\n<li>Client，HTTP 客户端</li>\n<li>Server，HTTP 服务端</li>\n</ul>\n<p>创建一个 server ：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">\"fmt\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"net/http\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">MyHandler</span><span class=\"params\">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class=\"line\">\t_, _ = fmt.Fprintf(w, <span class=\"string\">\"hello\"</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\thttp.HandleFunc(<span class=\"string\">\"/\"</span>, MyHandler)</span><br><span class=\"line\">\t_ = http.ListenAndServe(<span class=\"string\">\":8080\"</span>, <span class=\"literal\">nil</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>发送请求：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">resp, err := http.Get(<span class=\"string\">\"http://example.com/\"</span>) <span class=\"comment\">// GET </span></span><br><span class=\"line\"></span><br><span class=\"line\">resp, err := http.Post(<span class=\"string\">\"http://example.com/\"</span>) <span class=\"comment\">// POST</span></span><br><span class=\"line\"></span><br><span class=\"line\">resp, err := http.PostForm(<span class=\"string\">\"http://example.com/\"</span>, url.Values&#123;<span class=\"string\">\"foo\"</span>: <span class=\"string\">\"bar\"</span>&#125;) <span class=\"comment\">// 提交表单</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Request\"><a href=\"#Request\" class=\"headerlink\" title=\"Request\"></a>Request</h2><p><code>Request</code> 对象是对 http 请求报文的抽象。包括起始行, <code>Headers</code>, <code>Body</code> 等。</p>\n<p>使用 <code>http.NewRequest</code> 函数创建一个 <code>Request</code> 请求对象：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewRequest</span><span class=\"params\">(method, url <span class=\"keyword\">string</span>, body io.Reader)</span> <span class=\"params\">(*Request, error)</span></span></span><br></pre></td></tr></table></figure></p>\n<p><code>Request</code> 对象主要用于数据的存储，结构：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Request <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    Method <span class=\"keyword\">string</span> <span class=\"comment\">// HTTP方法</span></span><br><span class=\"line\">    URL *url.URL <span class=\"comment\">// URL</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    Proto      <span class=\"keyword\">string</span> <span class=\"comment\">// \"HTTP/1.0\"</span></span><br><span class=\"line\">    ProtoMajor <span class=\"keyword\">int</span>    <span class=\"comment\">// 1</span></span><br><span class=\"line\">    ProtoMinor <span class=\"keyword\">int</span>    <span class=\"comment\">// 0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    Header Header <span class=\"comment\">// 报文头</span></span><br><span class=\"line\">    Body io.ReadCloser <span class=\"comment\">// 报文体</span></span><br><span class=\"line\">    GetBody <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span> <span class=\"params\">(io.ReadCloser, error)</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">ContentLength</span> <span class=\"title\">int64</span> // 报文长度</span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">TransferEncoding</span> []<span class=\"title\">string</span> // 传输编码</span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">Close</span> <span class=\"title\">bool</span> // 关闭连接</span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">Host</span> <span class=\"title\">string</span> // 主机名</span></span><br><span class=\"line\"><span class=\"function\">    </span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">Form</span> <span class=\"title\">url</span>.<span class=\"title\">Values</span> // </span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">PostForm</span> <span class=\"title\">url</span>.<span class=\"title\">Values</span> // <span class=\"title\">POST</span>表单信息</span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">MultipartForm</span> *<span class=\"title\">multipart</span>.<span class=\"title\">Form</span> // <span class=\"title\">multipart</span>，</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">Trailer</span> <span class=\"title\">Header</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">RemoteAddr</span> <span class=\"title\">string</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">RequestURI</span> <span class=\"title\">string</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">TLS</span> *<span class=\"title\">tls</span>.<span class=\"title\">ConnectionState</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">Cancel</span> &lt;-<span class=\"title\">chan</span> <span class=\"title\">struct</span></span>&#123;&#125;</span><br><span class=\"line\">    Response *Response</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 从 b 中读取和解析一个请求. </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">ReadRequest</span><span class=\"params\">(b *bufio.Reader)</span> <span class=\"params\">(req *Request, err error)</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// 给 <span class=\"title\">request</span> 添加 <span class=\"title\">cookie</span>, <span class=\"title\">AddCookie</span> 向请求中添加一个 <span class=\"title\">cookie</span>.按照<span class=\"title\">RFC</span> 6265 </span></span><br><span class=\"line\"><span class=\"function\">// <span class=\"title\">section</span> 5.4的规则, <span class=\"title\">AddCookie</span> 不会添加超过一个 <span class=\"title\">Cookie</span> 头字段.</span></span><br><span class=\"line\"><span class=\"function\">// 这表示所有的 <span class=\"title\">cookie</span> 都写在同一行, 用分号分隔（<span class=\"title\">cookie</span> 内部用逗号分隔属性） </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"params\">(r *Request)</span> <span class=\"title\">AddCookie</span><span class=\"params\">(c *Cookie)</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// 返回 <span class=\"title\">request</span> 中指定名 <span class=\"title\">name</span> 的 <span class=\"title\">cookie</span>，如果没有发现，返回 <span class=\"title\">ErrNoCookie</span> </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"params\">(r *Request)</span> <span class=\"title\">Cookie</span><span class=\"params\">(name <span class=\"keyword\">string</span>)</span> <span class=\"params\">(*Cookie, error)</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// 返回该请求的所有<span class=\"title\">cookies</span> </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"params\">(r *Request)</span> <span class=\"title\">Cookies</span><span class=\"params\">()</span> []*<span class=\"title\">Cookie</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// 利用提供的用户名和密码给 <span class=\"title\">http</span> 基本权限提供具有一定权限的 <span class=\"title\">header</span>。</span></span><br><span class=\"line\"><span class=\"function\">// 当使用 <span class=\"title\">http</span> 基本授权时，用户名和密码是不加密的 </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"params\">(r *Request)</span> <span class=\"title\">SetBasicAuth</span><span class=\"params\">(username, password <span class=\"keyword\">string</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// 如果在 <span class=\"title\">request</span> 中发送，该函数返回客户端的 <span class=\"title\">user</span>-<span class=\"title\">Agent</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"params\">(r *Request)</span> <span class=\"title\">UserAgent</span><span class=\"params\">()</span> <span class=\"title\">string</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// 对于指定格式的 <span class=\"title\">key</span>，<span class=\"title\">FormFile</span> 返回符合条件的第一个文件，如果有必要的话，</span></span><br><span class=\"line\"><span class=\"function\">// 该函数会调用 <span class=\"title\">ParseMultipartForm</span> 和 <span class=\"title\">ParseForm</span>。 </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"params\">(r *Request)</span> <span class=\"title\">FormFile</span><span class=\"params\">(key <span class=\"keyword\">string</span>)</span> <span class=\"params\">(multipart.File, *multipart.FileHeader, error)</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// 返回 <span class=\"title\">key</span> 获取的队列中第一个值。在查询过程中 <span class=\"title\">post</span> 和 <span class=\"title\">put</span> 中的主题参数优先级</span></span><br><span class=\"line\"><span class=\"function\">// 高于 <span class=\"title\">url</span> 中的 <span class=\"title\">value</span>。为了访问相同 <span class=\"title\">key</span> 的多个值，调用 <span class=\"title\">ParseForm</span> 然后直接</span></span><br><span class=\"line\"><span class=\"function\">// 检查 <span class=\"title\">RequestForm</span>。 </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"params\">(r *Request)</span> <span class=\"title\">FormValue</span><span class=\"params\">(key <span class=\"keyword\">string</span>)</span> <span class=\"title\">string</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// 如果这是一个有多部分组成的 <span class=\"title\">post</span> 请求，该函数将会返回一个 <span class=\"title\">MIME</span> 多部分 <span class=\"title\">reader</span>，</span></span><br><span class=\"line\"><span class=\"function\">// 否则的话将会返回一个 <span class=\"title\">nil</span> 和 <span class=\"title\">error</span>。使用本函数代替 <span class=\"title\">ParseMultipartForm</span></span></span><br><span class=\"line\"><span class=\"function\">// 可以将请求 <span class=\"title\">body</span> 当做流 <span class=\"title\">stream</span> 来处理。 </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"params\">(r *Request)</span> <span class=\"title\">MultipartReader</span><span class=\"params\">()</span> <span class=\"params\">(*multipart.Reader, error)</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// 解析<span class=\"title\">URL</span>中的查询字符串，并将解析结果更新到 <span class=\"title\">r</span>.<span class=\"title\">Form</span> 字段。对于<span class=\"title\">POST</span> 或 <span class=\"title\">PUT</span></span></span><br><span class=\"line\"><span class=\"function\">// 请求，<span class=\"title\">ParseForm</span> 还会将 <span class=\"title\">body</span> 当作表单解析，并将结果既更新到 <span class=\"title\">r</span>.<span class=\"title\">PostForm</span> 也</span></span><br><span class=\"line\"><span class=\"function\">// 更新到 <span class=\"title\">r</span>.<span class=\"title\">Form</span>。解析结果中，<span class=\"title\">POST</span> 或 <span class=\"title\">PUT</span> 请求主体要优先于 <span class=\"title\">URL</span> 查询字符串</span></span><br><span class=\"line\"><span class=\"function\">// （同名变量，主体的值在查询字符串的值前面）。如果请求的主体的大小没有被</span></span><br><span class=\"line\"><span class=\"function\">// <span class=\"title\">MaxBytesReader</span> 函数设定限制，其大小默认限制为开头 10<span class=\"title\">MB</span>。</span></span><br><span class=\"line\"><span class=\"function\">// <span class=\"title\">ParseMultipartForm</span> 会自动调用 <span class=\"title\">ParseForm</span>。重复调用本方法是无意义的。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"params\">(r *Request)</span> <span class=\"title\">ParseForm</span><span class=\"params\">()</span> <span class=\"title\">error</span> </span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// <span class=\"title\">ParseMultipartForm</span> 将请求的主体作为 <span class=\"title\">multipart</span>/<span class=\"title\">form</span>-<span class=\"title\">data</span> 解析。</span></span><br><span class=\"line\"><span class=\"function\">// 请求的整个主体都会被解析，得到的文件记录最多 <span class=\"title\">maxMemery</span> 字节保存在内存，</span></span><br><span class=\"line\"><span class=\"function\">// 其余部分保存在硬盘的 <span class=\"title\">temp</span> 文件里。如果必要，<span class=\"title\">ParseMultipartForm</span> 会</span></span><br><span class=\"line\"><span class=\"function\">// 自行调用 <span class=\"title\">ParseForm</span>。重复调用本方法是无意义的。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"params\">(r *Request)</span> <span class=\"title\">ParseMultipartForm</span><span class=\"params\">(maxMemory <span class=\"keyword\">int64</span>)</span> <span class=\"title\">error</span> </span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// 返回 <span class=\"title\">post</span> 或者 <span class=\"title\">put</span> 请求 <span class=\"title\">body</span> 指定元素的第一个值，其中 <span class=\"title\">url</span> 中的参数被忽略。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"params\">(r *Request)</span> <span class=\"title\">PostFormValue</span><span class=\"params\">(key <span class=\"keyword\">string</span>)</span> <span class=\"title\">string</span> </span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// 检测在 <span class=\"title\">request</span> 中使用的 <span class=\"title\">http</span> 协议是否至少是 <span class=\"title\">major</span>.<span class=\"title\">minor</span> </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"params\">(r *Request)</span> <span class=\"title\">ProtoAtLeast</span><span class=\"params\">(major, minor <span class=\"keyword\">int</span>)</span> <span class=\"title\">bool</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// 如果 <span class=\"title\">request</span> 中有 <span class=\"title\">refer</span>，那么 <span class=\"title\">refer</span> 返回相应的 <span class=\"title\">url</span>。<span class=\"title\">Referer</span> 在 <span class=\"title\">request</span></span></span><br><span class=\"line\"><span class=\"function\">// 中是拼错的<span class=\"params\">(Referrer)</span>，这个错误从 <span class=\"title\">http</span> 初期就已经存在了。该值也可以从 <span class=\"title\">Headermap</span> 中</span></span><br><span class=\"line\"><span class=\"function\">// 利用 <span class=\"title\">Header</span>[\"<span class=\"title\">Referer</span>\"] 获取；在使用过程中利用 <span class=\"title\">Referer</span> 这个方法而</span></span><br><span class=\"line\"><span class=\"function\">// 不是 <span class=\"title\">map</span> 的形式的好处是在编译过程中可以检查方法的错误，而无法检查 <span class=\"title\">map</span> 中</span></span><br><span class=\"line\"><span class=\"function\">// <span class=\"title\">key</span> 的错误。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"params\">(r *Request)</span> <span class=\"title\">Referer</span><span class=\"params\">()</span> <span class=\"title\">string</span> </span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// <span class=\"title\">Write</span> 方法以有线格式将 <span class=\"title\">HTTP</span>/1.1 请求写入 <span class=\"title\">w</span>（用于将请求写入下层 <span class=\"title\">TCPConn</span> 等）</span></span><br><span class=\"line\">// 。本方法会考虑请求的如下字段：Host URL Method (defaults to \"GET\")</span><br><span class=\"line\"><span class=\"comment\">//  Header ContentLength TransferEncoding Body如果存在Body，</span></span><br><span class=\"line\"><span class=\"comment\">// ContentLength字段&lt;= 0且TransferEncoding字段未显式设置为</span></span><br><span class=\"line\"><span class=\"comment\">// [\"identity\"]，Write 方法会显式添加 ”Transfer-Encoding: chunked”</span></span><br><span class=\"line\"><span class=\"comment\">// 到请求的头域。Body 字段会在发送完请求后关闭。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(r *Request)</span> <span class=\"title\">Write</span><span class=\"params\">(w io.Writer)</span> <span class=\"title\">error</span> </span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// 该函数与 <span class=\"title\">Write</span> 方法类似，但是该方法写的 <span class=\"title\">request</span> 是按照 <span class=\"title\">http</span> 代理的格式去写。</span></span><br><span class=\"line\"><span class=\"function\">// 尤其是，按照 <span class=\"title\">RFC</span> 2616 <span class=\"title\">Section</span> 5.1.2，<span class=\"title\">WriteProxy</span> 会使用绝对 <span class=\"title\">URI</span></span></span><br><span class=\"line\"><span class=\"function\">// （包括协议和主机名）来初始化请求的第1行（<span class=\"title\">Request</span>-<span class=\"title\">URI</span>行）。无论何种情况，</span></span><br><span class=\"line\"><span class=\"function\">// <span class=\"title\">WriteProxy</span> 都会使用 <span class=\"title\">r</span>.<span class=\"title\">Host</span> 或 <span class=\"title\">r</span>.<span class=\"title\">URL</span>.<span class=\"title\">Host</span> 设置 <span class=\"title\">Host</span> 头。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"params\">(r *Request)</span> <span class=\"title\">WriteProxy</span><span class=\"params\">(w io.Writer)</span> <span class=\"title\">error</span></span></span><br></pre></td></tr></table></figure>\n<h2 id=\"Response\"><a href=\"#Response\" class=\"headerlink\" title=\"Response\"></a>Response</h2><p>Response 也是一个数据对象，描述 HTTP 响应：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Response <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    Status     <span class=\"keyword\">string</span> <span class=\"comment\">// HTTP 状态码</span></span><br><span class=\"line\">    StatusCode <span class=\"keyword\">int</span>    <span class=\"comment\">// 状态码 200</span></span><br><span class=\"line\">    Proto      <span class=\"keyword\">string</span> <span class=\"comment\">// 版本号 \"HTTP/1.0\"</span></span><br><span class=\"line\">    ProtoMajor <span class=\"keyword\">int</span>    <span class=\"comment\">// 主版本号 </span></span><br><span class=\"line\">    ProtoMinor <span class=\"keyword\">int</span>    <span class=\"comment\">// 次版本号</span></span><br><span class=\"line\"></span><br><span class=\"line\">    Header Header <span class=\"comment\">// 响应报文头</span></span><br><span class=\"line\">    Body io.ReadCloser <span class=\"comment\">// 响应报文体</span></span><br><span class=\"line\">    ContentLength <span class=\"keyword\">int64</span> <span class=\"comment\">// 报文长度</span></span><br><span class=\"line\">    TransferEncoding []<span class=\"keyword\">string</span> <span class=\"comment\">// 报文编码</span></span><br><span class=\"line\">    Close <span class=\"keyword\">bool</span> </span><br><span class=\"line\">    Trailer Header</span><br><span class=\"line\">    Request *Request <span class=\"comment\">// 请求对象</span></span><br><span class=\"line\">    TLS *tls.ConnectionState</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ReadResponse 从 r 读取并返回一个 HTTP 回复。req 参数是可选的，指定该回复</span></span><br><span class=\"line\"><span class=\"comment\">// 对应的请求（即是对该请求的回复）。如果是 nil，将假设请 求是 GET 请求。</span></span><br><span class=\"line\"><span class=\"comment\">// 客户端必须在结束 resp.Body 的读取后关闭它。读取完毕并关闭后，客户端可以</span></span><br><span class=\"line\"><span class=\"comment\">// 检查 resp.Trailer 字段获取回复的 trailer 的键值对。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">ReadResponse</span><span class=\"params\">(r *bufio.Reader, req *Request)</span> <span class=\"params\">(*Response, error)</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// 解析 <span class=\"title\">cookie</span> 并返回在 <span class=\"title\">header</span> 中利用 <span class=\"title\">set</span>-<span class=\"title\">Cookie</span> 设定的 <span class=\"title\">cookie</span> 值。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"params\">(r *Response)</span> <span class=\"title\">Cookies</span><span class=\"params\">()</span> []*<span class=\"title\">Cookie</span> </span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// 返回 <span class=\"title\">response</span> 中 <span class=\"title\">Location</span> 的 <span class=\"title\">header</span> 值的 <span class=\"title\">url</span>。如果该值存在的话，则对于</span></span><br><span class=\"line\"><span class=\"function\">// 请求问题可以解决相对重定向的问题，如果该值为<span class=\"title\">nil</span>，则返回<span class=\"title\">ErrNOLocation</span>。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"params\">(r *Response)</span> <span class=\"title\">Location</span><span class=\"params\">()</span> <span class=\"params\">(*url.URL, error)</span> </span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// 判定在 <span class=\"title\">response</span> 中使用的 <span class=\"title\">http</span> 协议是否至少是 <span class=\"title\">major</span>.<span class=\"title\">minor</span> 的形式。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"params\">(r *Response)</span> <span class=\"title\">ProtoAtLeast</span><span class=\"params\">(major, minor <span class=\"keyword\">int</span>)</span> <span class=\"title\">bool</span> </span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// 将 <span class=\"title\">response</span> 中信息按照线性格式写入 <span class=\"title\">w</span> 中。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"params\">(r *Response)</span> <span class=\"title\">Write</span><span class=\"params\">(w io.Writer)</span> <span class=\"title\">error</span></span></span><br></pre></td></tr></table></figure>\n<h2 id=\"client\"><a href=\"#client\" class=\"headerlink\" title=\"client\"></a>client</h2><p>前面以 <code>http.Get(&quot;http://example.com/&quot;)</code> <code>Get</code> 或 <code>Post</code> 函数发送请求，就是通过绑定一个默认 <code>Client</code> 实现的。<br>使用 <code>Client</code> 要先初始化一个 <code>Client</code> 对象。<code>Client</code> 具有 <code>Do</code>，<code>Get</code>，<code>Head</code>，<code>Post</code> 以及 <code>PostForm</code> 等方法。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"net/http\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    client := http.Client()</span><br><span class=\"line\">    res, err := client.Get(<span class=\"string\">\"http://www.google.com\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对于常用 HTTP 动词，<code>Client</code> 对象对应的函数，下面的这些方法与 <code>http.Get</code> 等方法一致：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *Client)</span> <span class=\"title\">Get</span><span class=\"params\">(url <span class=\"keyword\">string</span>)</span> <span class=\"params\">(resp *Response, err error)</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"params\">(c *Client)</span> <span class=\"title\">Head</span><span class=\"params\">(url <span class=\"keyword\">string</span>)</span> <span class=\"params\">(resp *Response, err error)</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"params\">(c *Client)</span> <span class=\"title\">Post</span><span class=\"params\">(url <span class=\"keyword\">string</span>, contentType <span class=\"keyword\">string</span>, body io.Reader)</span> <span class=\"params\">(resp *Response, err error)</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"params\">(c *Client)</span> <span class=\"title\">PostForm</span><span class=\"params\">(url <span class=\"keyword\">string</span>, data url.Values)</span> <span class=\"params\">(resp *Response, err error)</span></span></span><br></pre></td></tr></table></figure></p>\n<p>但是在很多情况下，需要支持对 headers，cookies 等的设定，上面提供的方法就不能满足需求了。就需要使用 <code>Do</code> 方法，<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *Client)</span> <span class=\"title\">Do</span><span class=\"params\">(req *Request)</span> <span class=\"params\">(resp *Response, err error)</span></span></span><br></pre></td></tr></table></figure></p>\n<p><code>http.NewRequest</code> 可以灵活的对 <code>Request</code> 进行配置，然后再使用 <code>http.Client</code> 的 <code>Do</code> 方法发送这个 <code>Request</code> 请求。</p>\n<p><strong>模拟 HTTP Request</strong>：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 简式声明一个 http.Client</span></span><br><span class=\"line\">client := &amp;http.Client&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 构建 Request</span></span><br><span class=\"line\">request, err := http.NewRequest(<span class=\"string\">\"GET\"</span>, <span class=\"string\">\"http://www.baidu.com\"</span>, <span class=\"literal\">nil</span>)</span><br><span class=\"line\"><span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    fmt.Println(err)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用 http.Cookie 结构体初始化一个 cookie 键值对</span></span><br><span class=\"line\">cookie := &amp;http.Cookie&#123;Name: <span class=\"string\">\"userId\"</span>, Value: strconv.Itoa(<span class=\"number\">12345</span>)&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// AddCookie</span></span><br><span class=\"line\">request.AddCookie(cookie)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 设置 Header</span></span><br><span class=\"line\">request.Header.Set(<span class=\"string\">\"Accept\"</span>, <span class=\"string\">\"text/html, application/xhtml+xml, application/xml;q=0.9, */*;q=0.8\"</span>)</span><br><span class=\"line\">request.Header.Set(<span class=\"string\">\"Accept-Charset\"</span>, <span class=\"string\">\"GBK, utf-8;q=0.7, *;q=0.3\"</span>)</span><br><span class=\"line\">request.Header.Set(<span class=\"string\">\"Accept-Encoding\"</span>, <span class=\"string\">\"gzip, deflate, sdch\"</span>)</span><br><span class=\"line\">request.Header.Set(<span class=\"string\">\"Accept-Language\"</span>, <span class=\"string\">\"zh-CN, zh;q=0.8\"</span>)</span><br><span class=\"line\">request.Header.Set(<span class=\"string\">\"Cache-Control\"</span>, <span class=\"string\">\"max-age=0\"</span>)</span><br><span class=\"line\">request.Header.Set(<span class=\"string\">\"Connection\"</span>, <span class=\"string\">\"keep-alive\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用 Do 方法发送请求</span></span><br><span class=\"line\">response, err := client.Do(request)</span><br><span class=\"line\"><span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    fmt.Println(err)</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 程序结束时关闭 response.Body 响应流</span></span><br><span class=\"line\"><span class=\"keyword\">defer</span> response.Body.Close()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// http Response 状态值</span></span><br><span class=\"line\">fmt.Println(response.StatusCode)</span><br><span class=\"line\"><span class=\"keyword\">if</span> response.StatusCode == <span class=\"number\">200</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// gzip.NewReader对压缩的返回信息解压（考虑网络传输量，http Server</span></span><br><span class=\"line\">    <span class=\"comment\">// 一般都会对响应压缩后再返回）</span></span><br><span class=\"line\">    body, err := gzip.NewReader(response.Body)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        fmt.Println(err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">defer</span> body.Close()</span><br><span class=\"line\"></span><br><span class=\"line\">    r, err := ioutil.ReadAll(body)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        fmt.Println(err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 打印出http Server返回的http Response信息</span></span><br><span class=\"line\">    fmt.Println(<span class=\"keyword\">string</span>(r))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>Ge请求</strong>：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// http.Get 实际上是 DefaultClient.Get(url)</span></span><br><span class=\"line\">response, err := http.Get(<span class=\"string\">\"http://www.baidu.com\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    fmt.Println(err)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 程序在使用完回复后必须关闭回复的主体</span></span><br><span class=\"line\"><span class=\"keyword\">defer</span> response.Body.Close()</span><br><span class=\"line\"></span><br><span class=\"line\">body, _ := ioutil.ReadAll(response.Body)</span><br><span class=\"line\">fmt.Println(<span class=\"keyword\">string</span>(body))</span><br></pre></td></tr></table></figure>\n<p><strong>Post 请求</strong>：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// application/x-www-form-urlencoded：为 POST 的 contentType</span></span><br><span class=\"line\">resp, err := http.Post(<span class=\"string\">\"http://localhost:8080/login.do\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"application/x-www-form-urlencoded\"</span>, strings.NewReader(<span class=\"string\">\"mobile=xxxxxxxxxx&amp;isRemberPwd=1\"</span>))</span><br><span class=\"line\"><span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    fmt.Println(err)</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">defer</span> resp.Body.Close()</span><br><span class=\"line\">body, err := ioutil.ReadAll(resp.Body)</span><br><span class=\"line\"><span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    fmt.Println(err)</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fmt.Println(<span class=\"keyword\">string</span>(body))</span><br></pre></td></tr></table></figure>\n<p><strong>http.PostForm 请求</strong>：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">\"fmt\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"io/ioutil\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"net/http\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"net/url\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tpostParam := url.Values&#123;</span><br><span class=\"line\">\t\t<span class=\"string\">\"mobile\"</span>:      &#123;<span class=\"string\">\"xxxxxx\"</span>&#125;,</span><br><span class=\"line\">\t\t<span class=\"string\">\"isRemberPwd\"</span>: &#123;<span class=\"string\">\"1\"</span>&#125;,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 数据的键值会经过 URL 编码后作为请求的 body 传递</span></span><br><span class=\"line\">\tresp, err := http.PostForm(<span class=\"string\">\"http://localhost：8080/login.do\"</span>, postParam)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tfmt.Println(err)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> resp.Body.Close()</span><br><span class=\"line\">\tbody, err := ioutil.ReadAll(resp.Body)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tfmt.Println(err)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tfmt.Println(<span class=\"keyword\">string</span>(body))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"HTTP-Server\"><a href=\"#HTTP-Server\" class=\"headerlink\" title=\"HTTP Server\"></a>HTTP Server</h2><p><code>server.go</code> 文件中定义了一个非常重要的接口：<code>Handler</code>，另外还有一个结构体 <code>response</code>，这和 <code>http.Response</code> 结构体只有首字母大小<br>写不一致，这个 <code>response</code> 也是响应，只不过是专门用在服务端，和 <code>http.Response</code> 结构体是完全两回事。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Handler <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">\tServeHTTP(ResponseWriter, *Request)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Server <span class=\"keyword\">struct</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 监听 srv.Addr 然后调用 Serve 来处理接下来连接的请求</span></span><br><span class=\"line\"><span class=\"comment\">// 如果 srv.Addr 是空的话，则使用 \":http\"</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(srv *Server)</span> <span class=\"title\">ListenAndServe</span><span class=\"params\">()</span> <span class=\"title\">error</span> </span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// 监听 <span class=\"title\">srv</span>.<span class=\"title\">Addr</span> ，调用 <span class=\"title\">Serve</span> 来处理接下来连接的请求</span></span><br><span class=\"line\"><span class=\"function\">// 必须提供证书文件和对应的私钥文件。如果证书是由</span></span><br><span class=\"line\"><span class=\"function\">// 权威机构签发的，<span class=\"title\">certFile</span> 参数必须是顺序串联的服务端证书和 <span class=\"title\">CA</span> 证书。</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"params\">(srv *Server)</span> <span class=\"title\">ListenAndServeTLS</span><span class=\"params\">(certFile, keyFile <span class=\"keyword\">string</span>)</span> <span class=\"title\">error</span> </span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// 接受 <span class=\"title\">l</span> <span class=\"title\">Listener</span> 的连接，创建一个新的服务协程。该服务协程读取请求然后调用</span></span><br><span class=\"line\"><span class=\"function\">// <span class=\"title\">srv</span>.<span class=\"title\">Handler</span> 来应答。实际上就是实现了对某个端口进行监听，然后创建相应的连接。 </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"params\">(srv *Server)</span> <span class=\"title\">Serve</span><span class=\"params\">(l net.Listener)</span> <span class=\"title\">error</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// 该函数控制是否 <span class=\"title\">http</span> 的 <span class=\"title\">keep</span>-<span class=\"title\">alives</span> 能够使用，默认情况下，<span class=\"title\">keep</span>-<span class=\"title\">alives</span> 总是可用的。</span></span><br><span class=\"line\"><span class=\"function\">// 只有资源非常紧张的环境或者服务端在关闭进程中时，才应该关闭该功能。 </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"params\">(s *Server)</span> <span class=\"title\">SetKeepAlivesEnabled</span><span class=\"params\">(v <span class=\"keyword\">bool</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// 是一个 <span class=\"title\">http</span> 请求多路复用器，它将每一个请求的 <span class=\"title\">URL</span> 和</span></span><br><span class=\"line\"><span class=\"function\">// 一个注册模式的列表进行匹配，然后调用和 <span class=\"title\">URL</span> 最匹配的模式的处理器进行后续操作。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">type</span> <span class=\"title\">ServeMux</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// 初始化一个新的 <span class=\"title\">ServeMux</span> </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">NewServeMux</span><span class=\"params\">()</span> *<span class=\"title\">ServeMux</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// 将 <span class=\"title\">handler</span> 注册为指定的模式，如果该模式已经有了 <span class=\"title\">handler</span>，则会出错 <span class=\"title\">panic</span>。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"params\">(mux *ServeMux)</span> <span class=\"title\">Handle</span><span class=\"params\">(pattern <span class=\"keyword\">string</span>, handler Handler)</span> </span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// 将 <span class=\"title\">handler</span> 注册为指定的模式 </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"params\">(mux *ServeMux)</span> <span class=\"title\">HandleFunc</span><span class=\"params\">(pattern <span class=\"keyword\">string</span>, handler <span class=\"keyword\">func</span>(ResponseWriter, *Request)</span>)</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// 根据指定的 <span class=\"title\">r</span>.<span class=\"title\">Method</span>, <span class=\"title\">r</span>.<span class=\"title\">Host</span> 以及 <span class=\"title\">r</span>.<span class=\"title\">RUL</span>.<span class=\"title\">Path</span> 返回一个用来处理给定请求的 <span class=\"title\">handler</span>。</span></span><br><span class=\"line\"><span class=\"function\">// 该函数总是返回一个 非 <span class=\"title\">nil</span> 的 <span class=\"title\">handler</span>，如果 <span class=\"title\">path</span> 不是一个规范格式，则 <span class=\"title\">handler</span> 会</span></span><br><span class=\"line\"><span class=\"function\">// 重定向到其规范 <span class=\"title\">path</span>。<span class=\"title\">Handler</span> 总是返回匹配该请求的的已注册模式；在内建重定向</span></span><br><span class=\"line\"><span class=\"function\">// 处理器的情况下，<span class=\"title\">pattern</span> 会在重定向后进行匹配。如果没有已注册模式可以应用于该请求，</span></span><br><span class=\"line\"><span class=\"function\">// 本方法将返回一个内建的 ”404 <span class=\"title\">page</span> <span class=\"title\">not</span> <span class=\"title\">found</span>” 处理器和一个空字符串模式。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"params\">(mux *ServeMux)</span> <span class=\"title\">Handler</span><span class=\"params\">(r *Request)</span> <span class=\"params\">(h Handler, pattern <span class=\"keyword\">string</span>)</span> </span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// 该函数用于将最接近请求 <span class=\"title\">url</span> 模式的 <span class=\"title\">handler</span> 分配给指定的请求。 </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"params\">(mux *ServeMux)</span> <span class=\"title\">ServeHTTP</span><span class=\"params\">(w ResponseWriter, r *Request)</span></span></span><br></pre></td></tr></table></figure>\n<p><code>Handler</code> 接口是 <code>server.go</code> 中最关键的接口，如果我们仔细看这个文件的源代码，将会发现很多结构体实现了这个接口的 <code>ServeHTTP</code> 方法。</p>\n<p>注意这个接口的注释：<code>Handler</code> 响应 HTTP 请求。没错，最终我们的 HTTP 服务是通过实现 <code>ServeHTTP(ResponseWriter, *Request)</code> 来达<br>到服务端接收客户端请求并响应。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\thttp.HandleFunc(<span class=\"string\">\"/\"</span>, MyHandler)</span><br><span class=\"line\">\t_ = http.ListenAndServe(<span class=\"string\">\":8080\"</span>, <span class=\"literal\">nil</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上两行代码，就成功启动了一个 HTTP 服务器。我们通过 <code>net/http</code> 包源代码分析发现，调用 <code>Http.HandleFunc</code>，按顺序做了几件事：</p>\n<ol>\n<li><code>Http.HandleFunc</code> 调用了 <code>DefaultServeMux</code> 的 <code>HandleFunc</code></li>\n</ol>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">HandleFunc</span><span class=\"params\">(pattern <span class=\"keyword\">string</span>, handler <span class=\"keyword\">func</span>(ResponseWriter, *Request)</span>)</span> &#123;</span><br><span class=\"line\">    DefaultServeMux.HandleFunc(pattern, handler)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li><code>DefaultServeMux.HandleFunc</code> 调用了 <code>DefaultServeMux</code> 的 <code>Handle</code>，<code>DefaultServeMux</code> 是一个 <code>ServeMux</code> 指针变量。<br>而 <code>ServeMux</code> 是 Go 语言中的 <code>Multiplexer</code>（多路复用器），通过 <code>Handle</code> 匹配 <code>pattern</code> 和我们定义的 <code>handler</code><br>（其实就是 <code>http.HandlerFunc</code> 函数类型变量）。</li>\n</ol>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> ServeMux <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tmu    sync.RWMutex</span><br><span class=\"line\">\tm     <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]muxEntry <span class=\"comment\">// 保存路由规则 和 handler</span></span><br><span class=\"line\">\thosts <span class=\"keyword\">bool</span> <span class=\"comment\">// whether any patterns contain hostnames</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> muxEntry <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\th       Handler</span><br><span class=\"line\">\tpattern <span class=\"keyword\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> DefaultServeMux = &amp;defaultServeMux</span><br><span class=\"line\"><span class=\"keyword\">var</span> defaultServeMux ServeMux</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(mux *ServeMux)</span> <span class=\"title\">HandleFunc</span><span class=\"params\">(pattern <span class=\"keyword\">string</span>, handler <span class=\"keyword\">func</span>(ResponseWriter, *Request)</span>)</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> handler == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">panic</span>(<span class=\"string\">\"http: nil handler\"</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tmux.Handle(pattern, HandlerFunc(handler)) <span class=\"comment\">// 这个 handler 就是 MyHandler</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意：<br>上面的方法命名 <code>Handle</code>，<code>HandleFunc</code> 和 <code>HandlerFunc</code>，<code>Handler</code>（接口），他们很相似，容易混淆。记住 <strong><code>Handle</code> 和 <code>HandleFunc</code><br>和 <code>pattern</code> 匹配有关，也即往 <code>DefaultServeMux</code> 的 <code>map[string]muxEntry</code> 中增加对应的 <code>handler</code> 和路由规则</strong>。</p>\n<p>接着我们看看 <code>MyHandler</code> 的声明和定义：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">MyHandler</span><span class=\"params\">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class=\"line\">\tfmt.Fprintf(w, <span class=\"string\">\"hello\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>而 <code>type HandlerFunc func(ResponseWriter, *Request)</code> 是一个函数类型，而我们定义的 <code>MyHandler</code> 的函数签名刚好符合这个函数类型。</p>\n<p>所以 <code>http.HandleFunc(&quot;/&quot;, MyHandler)</code>，实际上是 <code>mux.Handle(&quot;/&quot;, HandlerFunc(MyHandler))</code>。</p>\n<p><code>HandlerFunc(MyHandler)</code> 让 <code>MyHandler</code> 成为了 <code>HandlerFunc</code> 类型，我们称 <code>MyHandler</code> 为 <code>handler</code>。而 <code>HandlerFunc</code> 类型是<br>具有 <code>ServeHTTP</code> 方法的，而有了 <code>ServeHTTP</code> 方法也就是实现了 <code>Handler</code> 接口。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(f HandlerFunc)</span> <span class=\"title\">ServeHTTP</span><span class=\"params\">(w ResponseWriter, r *Request)</span></span> &#123;</span><br><span class=\"line\">\tf(w, r) <span class=\"comment\">// 这相当于自身的调用</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在 <code>ServeMux</code> 和 <code>Handler</code> 都和我们的 <code>MyHandler</code> 联系上了，<code>MyHandler</code> 是一个 <code>Handler</code> 接口变量也是 <code>HandlerFunc</code> 类型变量，<br>接下来和结构体 <code>server</code> 有关了。</p>\n<p>从 <code>http.ListenAndServe</code> 的源码可以看出，它创建了一个 <code>server</code> 对象，并调用 <code>server</code> 对象的 <code>ListenAndServe</code> 方法：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">ListenAndServe</span><span class=\"params\">(addr <span class=\"keyword\">string</span>, handler Handler)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">    server := &amp;Server&#123;Addr: addr, Handler: handler&#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> server.ListenAndServe()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>而我们 HTTP 服务器中第二行代码：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http.ListenAndServe(<span class=\"string\">\":8080\"</span>, <span class=\"literal\">nil</span>)</span><br></pre></td></tr></table></figure>\n<p>创建了一个 <code>server</code> 对象，并调用 <code>server</code> 对象的 <code>ListenAndServe</code> 方法，这里没有直接传递 <code>Handler</code>，而是默认<br>使用 <code>DefautServeMux</code> 作为 <code>multiplexer</code>。</p>\n<p><code>Server</code> 的 <code>ListenAndServe</code> 方法中，会初始化监听地址 <code>Addr</code>，同时调用 <code>Listen</code> 方法设置监听。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">    rw, e := l.Accept()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> e != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">select</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> &lt;-srv.getDoneChan():</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ErrServerClosed</span><br><span class=\"line\">        <span class=\"keyword\">default</span>:</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ne, ok := e.(net.Error); ok &amp;&amp; ne.Temporary() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> tempDelay == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">                tempDelay = <span class=\"number\">5</span> * time.Millisecond</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                tempDelay *= <span class=\"number\">2</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> max := <span class=\"number\">1</span> * time.Second; tempDelay &gt; max &#123;</span><br><span class=\"line\">                tempDelay = max</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            srv.logf(<span class=\"string\">\"http: Accept error: %v; retrying in %v\"</span>, e, tempDelay)</span><br><span class=\"line\">            time.Sleep(tempDelay)</span><br><span class=\"line\">            <span class=\"keyword\">continue</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> e</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    tempDelay = <span class=\"number\">0</span></span><br><span class=\"line\">    c := srv.newConn(rw)</span><br><span class=\"line\">    c.setState(c.rwc, StateNew) <span class=\"comment\">// before Serve can return</span></span><br><span class=\"line\">    <span class=\"keyword\">go</span> c.serve(ctx)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>监听开启之后，一旦客户端请求过来，Go 就开启一个协程 <code>go c.serve(ctx)</code> 处理请求，主要逻辑都在 <code>serve</code> 方法之中。</p>\n<p><code>func (c *conn) serve(ctx context.Context)</code>，这个方法很长，里面主要的一句：<code>serverHandler{c.server}.ServeHTTP(w, w.req)</code>。<br>其中 <code>w</code> 由 <code>w, err := c.readRequest(ctx)</code> 得到，因为有传递 <code>context</code>。</p>\n<p>还是来看源代码：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// serverHandler delegates to either the server's Handler or</span></span><br><span class=\"line\"><span class=\"comment\">// DefaultServeMux and also handles \"OPTIONS *\" requests.</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> serverHandler <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tsrv *Server</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(sh serverHandler)</span> <span class=\"title\">ServeHTTP</span><span class=\"params\">(rw ResponseWriter, req *Request)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 此 handler 即为 http.ListenAndServe 中的第二个参数</span></span><br><span class=\"line\">    handler := sh.srv.Handler </span><br><span class=\"line\">    <span class=\"keyword\">if</span> handler == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果 handler 为空则使用内部的 DefaultServeMux 进行处理</span></span><br><span class=\"line\">        handler = DefaultServeMux</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> req.RequestURI == <span class=\"string\">\"*\"</span> &amp;&amp; req.Method == <span class=\"string\">\"OPTIONS\"</span> &#123;</span><br><span class=\"line\">        handler = globalOptionsHandler&#123;&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 这里就开始处理 http 请求</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果需要使用自定义的 mux，就需要实现 ServeHTTP 方法，即实现 Handler 接口。</span></span><br><span class=\"line\">    <span class=\"comment\">// ServeHTTP(rw, req) 默认情况下是 func (mux *ServeMux) ServeHTTP(w ResponseWriter, r *Request)</span></span><br><span class=\"line\">    handler.ServeHTTP(rw, req)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从 <code>http.ListenAndServe(&quot;:8080&quot;, nil)</code> 开始，<code>handler</code> 是 <code>nil</code>，所以最后实际 <code>ServeHTTP</code> 方法<br>是 <code>DefaultServeMux.ServeHTTP(rw, req)</code>。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(mux *ServeMux)</span> <span class=\"title\">ServeHTTP</span><span class=\"params\">(w ResponseWriter, r *Request)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> r.RequestURI == <span class=\"string\">\"*\"</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> r.ProtoAtLeast(<span class=\"number\">1</span>, <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">\t\t\tw.Header().Set(<span class=\"string\">\"Connection\"</span>, <span class=\"string\">\"close\"</span>)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tw.WriteHeader(StatusBadRequest)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\th, _ := mux.Handler(r) <span class=\"comment\">// 会匹配路由，h 就是 MyHandler</span></span><br><span class=\"line\">\th.ServeHTTP(w, r) <span class=\"comment\">// 调用自己</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(mux *ServeMux)</span> <span class=\"title\">Handler</span><span class=\"params\">(r *Request)</span> <span class=\"params\">(h Handler, pattern <span class=\"keyword\">string</span>)</span></span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// CONNECT requests are not canonicalized.</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> r.Method == <span class=\"string\">\"CONNECT\"</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// If r.URL.Path is /tree and its handler is not registered,</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// the /tree -&gt; /tree/ redirect applies to CONNECT requests</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// but the path canonicalization does not.</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> u, ok := mux.redirectToPathSlash(r.URL.Host, r.URL.Path, r.URL); ok &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> RedirectHandler(u.String(), StatusMovedPermanently), u.Path</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> mux.handler(r.Host, r.URL.Path)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// All other requests have any port stripped and path cleaned</span></span><br><span class=\"line\">\t<span class=\"comment\">// before passing to mux.handler.</span></span><br><span class=\"line\">\thost := stripHostPort(r.Host)</span><br><span class=\"line\">\tpath := cleanPath(r.URL.Path)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// If the given path is /tree and its handler is not registered,</span></span><br><span class=\"line\">\t<span class=\"comment\">// redirect for /tree/.</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> u, ok := mux.redirectToPathSlash(host, path, r.URL); ok &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> RedirectHandler(u.String(), StatusMovedPermanently), u.Path</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> path != r.URL.Path &#123;</span><br><span class=\"line\">\t\t_, pattern = mux.handler(host, path)</span><br><span class=\"line\">\t\turl := *r.URL</span><br><span class=\"line\">\t\turl.Path = path</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> RedirectHandler(url.String(), StatusMovedPermanently), pattern</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> mux.handler(host, r.URL.Path)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// handler is the main implementation of Handler.</span></span><br><span class=\"line\"><span class=\"comment\">// The path is known to be in canonical form, except for CONNECT methods.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(mux *ServeMux)</span> <span class=\"title\">handler</span><span class=\"params\">(host, path <span class=\"keyword\">string</span>)</span> <span class=\"params\">(h Handler, pattern <span class=\"keyword\">string</span>)</span></span> &#123;</span><br><span class=\"line\">\tmux.mu.RLock()</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> mux.mu.RUnlock()</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// Host-specific pattern takes precedence over generic ones</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> mux.hosts &#123;</span><br><span class=\"line\">\t\th, pattern = mux.match(host + path)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> h == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\th, pattern = mux.match(path)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> h == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\th, pattern = NotFoundHandler(), <span class=\"string\">\"\"</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过 <code>func (mux *ServeMux) Handler(r *Request) (h Handler, pattern string)</code>，我们得到 <code>Handler h</code>，然后执<br>行 <code>h.ServeHTTP(w, r)</code> 方法，也就是执行我们的 <code>MyHandler</code> 函数（别忘了 <code>MyHandler</code> 是HandlerFunc类型，而他的 <code>ServeHTTP(w, r)</code><br>方法这里其实就是自己调用自己），把 <code>response</code> 写到 <code>http.ResponseWriter</code> 对象返回给客户端，<code>fmt.Fprintf(w, &quot;hello&quot;)</code>，我们在客<br>户端会接收到 “hello” 。至此整个 HTTP 服务执行完成。</p>\n<p>总结下，HTTP 服务整个过程大概是这样：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Request -&gt; ServeMux(Multiplexer) -&gt; handler-&gt; Response</span><br></pre></td></tr></table></figure></p>\n<p>我们再看下面代码：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http.ListenAndServe(<span class=\"string\">\":8080\"</span>, <span class=\"literal\">nil</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">ListenAndServe</span><span class=\"params\">(addr <span class=\"keyword\">string</span>, handler Handler)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">    server := &amp;Server&#123;Addr: addr, Handler: handler&#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> server.ListenAndServe()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面代码实际上就是 <code>server.ListenAndServe()</code> 执行的实际效果，只不过简单声明了一个结构体 <code>Server{Addr: addr, Handler: handler}</code> 实例。<br>如果我们声明一个 <code>Server</code> 实例，完全可以达到深度自定义 <code>http.Server</code> 的目的：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">\"fmt\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"net/http\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">MyHandler</span><span class=\"params\">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class=\"line\">\t_, _ = fmt.Fprintf(w, <span class=\"string\">\"hi\"</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 更多http.Server的字段可以根据情况初始化</span></span><br><span class=\"line\">\tserver := http.Server&#123;</span><br><span class=\"line\">\t\tAddr:         <span class=\"string\">\":8080\"</span>,</span><br><span class=\"line\">\t\tReadTimeout:  <span class=\"number\">0</span>,</span><br><span class=\"line\">\t\tWriteTimeout: <span class=\"number\">0</span>,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\thttp.HandleFunc(<span class=\"string\">\"/\"</span>, MyHandler)</span><br><span class=\"line\">\t_ = server.ListenAndServe()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们完全可以根据情况来自定义我们的 <code>Server</code>。</p>\n<p>还可以指定 <code>Servemux</code> 的用法:</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">\"fmt\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"net/http\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">MyHandler</span><span class=\"params\">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class=\"line\">\t_, _ = fmt.Fprintf(w, <span class=\"string\">\"hi\"</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tmux := http.NewServeMux()</span><br><span class=\"line\"></span><br><span class=\"line\">\tmux.HandleFunc(<span class=\"string\">\"/\"</span>, MyHandler)</span><br><span class=\"line\">\t_ = http.ListenAndServe(<span class=\"string\">\":8080\"</span>, mux)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果既指定 <code>Servemux</code> 又自定义 <code>http.Server</code>，因为 <code>Server</code> 中有字段 <code>Handler</code>，所以我们可以直接把 <code>Servemux</code> 变量作<br>为 <code>Server.Handler</code>：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">\"fmt\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"net/http\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">MyHandler</span><span class=\"params\">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class=\"line\">\t_, _ = fmt.Fprintf(w, <span class=\"string\">\"hi\"</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tserver := http.Server&#123;</span><br><span class=\"line\">\t\tAddr:         <span class=\"string\">\":8080\"</span>,</span><br><span class=\"line\">\t\tReadTimeout:  <span class=\"number\">0</span>,</span><br><span class=\"line\">\t\tWriteTimeout: <span class=\"number\">0</span>,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tmux := http.NewServeMux()</span><br><span class=\"line\">\tserver.Handler = mux</span><br><span class=\"line\"></span><br><span class=\"line\">\tmux.HandleFunc(<span class=\"string\">\"/\"</span>, MyHandler)</span><br><span class=\"line\">\t_ = server.ListenAndServe()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"自定义处理器\"><a href=\"#自定义处理器\" class=\"headerlink\" title=\"自定义处理器\"></a>自定义处理器</h2><p>自定义的 <code>Handler</code>：</p>\n<p>标准库 http 提供了 <code>Handler</code> 接口，用于开发者实现自己的 <code>handler</code>。只要实现接口的 <code>ServeHTTP</code> 方法即可。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">\"log\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"net/http\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"time\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> timeHandler <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tformat <span class=\"keyword\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(th *timeHandler)</span> <span class=\"title\">ServeHTTP</span><span class=\"params\">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class=\"line\">\ttm := time.Now().Format(th.format)</span><br><span class=\"line\">\t_, _ = w.Write([]<span class=\"keyword\">byte</span>(<span class=\"string\">\"The time is: \"</span> + tm))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tmux := http.NewServeMux()</span><br><span class=\"line\"></span><br><span class=\"line\">\tth := &amp;timeHandler&#123;format: time.RFC1123&#125;</span><br><span class=\"line\">\tmux.Handle(<span class=\"string\">\"/time\"</span>, th)</span><br><span class=\"line\"></span><br><span class=\"line\">\tlog.Println(<span class=\"string\">\"Listening...\"</span>)</span><br><span class=\"line\">\t_ = http.ListenAndServe(<span class=\"string\">\":3000\"</span>, mux)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们知道，<code>NewServeMux</code> 可以创建一个 <code>ServeMux</code> 实例，<code>ServeMux</code> 同时也实现了 <code>ServeHTTP</code> 方法，因此代码中的 <code>mux</code> 也是<br>一种 <code>handler</code>。把它当成参数传给 <code>http.ListenAndServe</code> 方法，后者会把 <code>mux</code> 传给 <code>Server</code> 实例。因为指定了 <code>handler</code>，<br>因此整个 <code>http</code> 服务就不再是 <code>DefaultServeMux</code>，而是 <code>mux</code>，无论是在注册路由还是提供请求服务的时候。</p>\n<p>任何有 <code>func(http.ResponseWriter，*http.Request)</code> 签名的函数都能转化为一个 <code>HandlerFunc</code> 类型。这很有用，因为 <code>HandlerFunc</code> 对象<br>内置了 <code>ServeHTTP</code> 方法，后者可以聪明又方便的调用我们最初提供的函数内容。</p>\n<h2 id=\"中间件-Middleware\"><a href=\"#中间件-Middleware\" class=\"headerlink\" title=\"中间件 Middleware\"></a>中间件 Middleware</h2><p>所谓中间件，就是连接上下级不同功能的函数或者软件，通常进行一些包裹函数的行为，为被包裹函数提供添加一些功能或行为。前文的 <code>HandleFunc</code> 就<br>能把签名为 <code>func(w http.ResponseWriter, r *http.Reqeust)</code> 的函数包裹成 <code>handler</code>。这个函数也算是中间件。</p>\n<p>Go 的 HTTP 中间件很简单，只要实现一个函数签名为 <code>func(http.Handler) http.Handler</code> 的函数即可。<code>http.Handler</code> 是一个接口，<br>接口方法我们熟悉的为 <code>serveHTTP</code>。返回也是一个 <code>handler</code>。因为 Go 中的函数也可以当成变量传递或者或者返回，因此也可以在中间件函数<br>中传递定义好的函数，只要这个函数是一个 <code>handler</code> 即可，即实现或者被 <code>handlerFunc</code> 包裹成为 <code>handler</code> 处理器。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">index</span><span class=\"params\">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class=\"line\">    w.Header().Set(<span class=\"string\">\"Content-Type\"</span>, <span class=\"string\">\"text/html\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    html := <span class=\"string\">`&lt;doctype html&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;html&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;head&gt;</span></span><br><span class=\"line\"><span class=\"string\">          &lt;title&gt;Hello World&lt;/title&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;/head&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;body&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"string\">          Welcome</span></span><br><span class=\"line\"><span class=\"string\">        &lt;/p&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;/body&gt;</span></span><br><span class=\"line\"><span class=\"string\">&lt;/html&gt;`</span></span><br><span class=\"line\">    fmt.Fprintln(w, html)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">middlewareHandler</span><span class=\"params\">(next http.Handler)</span> <span class=\"title\">http</span>.<span class=\"title\">Handler</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> http.HandlerFunc(<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(w http.ResponseWriter, r *http.Request)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 执行 handler 之前的逻辑</span></span><br><span class=\"line\">        next.ServeHTTP(w, r)</span><br><span class=\"line\">        <span class=\"comment\">// 执行完毕 handler 后的逻辑</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">loggingHandler</span><span class=\"params\">(next http.Handler)</span> <span class=\"title\">http</span>.<span class=\"title\">Handler</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> http.HandlerFunc(<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class=\"line\">        start := time.Now()</span><br><span class=\"line\">        log.Printf(<span class=\"string\">\"Started %s %s\"</span>, r.Method, r.URL.Path)</span><br><span class=\"line\">        next.ServeHTTP(w, r)</span><br><span class=\"line\">        log.Printf(<span class=\"string\">\"Completed %s in %v\"</span>, r.URL.Path, time.Since(start))</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    http.Handle(<span class=\"string\">\"/\"</span>, loggingHandler(http.HandlerFunc(index)))</span><br><span class=\"line\"></span><br><span class=\"line\">    http.ListenAndServe(<span class=\"string\">\":8000\"</span>, <span class=\"literal\">nil</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"静态站点\"><a href=\"#静态站点\" class=\"headerlink\" title=\"静态站点\"></a>静态站点</h2><p>下面代码通过指定目录，作为静态站点：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">\"net/http\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\thttp.Handle(<span class=\"string\">\"/\"</span>, http.FileServer(http.Dir(<span class=\"string\">\"D:/html/static/\"</span>)))</span><br><span class=\"line\">\t_ = http.ListenAndServe(<span class=\"string\">\":8080\"</span>, <span class=\"literal\">nil</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{"navigation":{"logo":{"text":"Golang Learn","type":"link","path":"index.html"},"main":[{"text":"Golang 基础","type":"label"},{"text":"Go 环境配置","type":"link","path":"basic/env_config.html"},{"text":"包","type":"link","path":"basic/package.html"},{"text":"基础数据类型","type":"link","path":"basic/basic_data.html"},{"text":"变量","type":"link","path":"basic/var.html"},{"text":"常量","type":"link","path":"basic/constant.html"},{"text":"控制语句","type":"link","path":"basic/flow.html"},{"text":"运算符","type":"link","path":"basic/operator.html"},{"text":"作用域","type":"link","path":"basic/scope.html"},{"text":"指针","type":"link","path":"basic/pointer.html"},{"text":"数组","type":"link","path":"basic/array.html"},{"text":"切片","type":"link","path":"basic/slice.html"},{"text":"字典","type":"link","path":"basic/map.html"},{"text":"函数","type":"link","path":"basic/function.html"},{"text":"结构体","type":"link","path":"basic/struct.html"},{"text":"接口","type":"link","path":"basic/interface.html"},{"text":"面向对象","type":"link","path":"basic/oop.html"},{"text":"错误","type":"link","path":"basic/error.html"},{"text":"序列化","type":"link","path":"basic/json.html"},{"text":"反射","type":"link","path":"basic/reflect.html"},{"text":"测试","type":"link","path":"basic/test.html"},{"text":"并发编程","type":"label"},{"text":"goroutine","type":"link","path":"concurrent/goroutine.html"},{"text":"channel","type":"link","path":"concurrent/channel.html"},{"text":"同步和锁","type":"link","path":"concurrent/sync_lock.html"},{"text":"内存分配","type":"label"},{"text":"内存分配","type":"link","path":"advance/mm.html"},{"text":"垃圾回收","type":"label"},{"text":"垃圾回收","type":"link","path":"advance/gc.html"},{"text":"标准库","type":"label"},{"text":"fmt","type":"link","path":"standards/io/fmt.html"},{"text":"io","type":"link","path":"standards/io/io.html"},{"text":"ioutil","type":"link","path":"standards/io/ioutil.html"},{"text":"bufio","type":"link","path":"standards/io/bufio.html"},{"text":"os","type":"link","path":"standards/os/os.html"},{"text":"filepath","type":"link","path":"standards/os/filepath.html"},{"text":"strings","type":"link","path":"standards/text/strings.html"},{"text":"strconv","type":"link","path":"standards/text/strconv.html"},{"text":"unicode","type":"link","path":"standards/text/unicode.html"},{"text":"log","type":"link","path":"standards/log.html"},{"text":"time","type":"link","path":"standards/time.html"},{"text":"http","type":"link","path":"standards/net/http.html"},{"text":"math","type":"link","path":"standards/data/math.html"},{"text":"sort","type":"link","path":"standards/data/sort.html"},{"text":"big","type":"link","path":"standards/data/big.html"},{"text":"container","type":"link","path":"standards/data/container.html"},{"text":"sql","type":"link","path":"standards/database/sql.html"},{"text":"THEME","type":"label"},{"text":"使用文档主题","type":"link","path":"theme/theme-usage.html"},{"text":"SUPPORT AND FEEDBACK","type":"label"},{"text":"Raise an Issue on Github","type":"link","path":"https://github.com/shipengqi/golang-learn/issues/new"}]}}},"excerpt":"","more":"<h1 id=\"http\"><a href=\"#http\" class=\"headerlink\" title=\"http\"></a>http</h1><p><code>net/http</code> 可以用来处理 HTTP 协议，包括 HTTP 服务器和 HTTP 客户端，主要组成：</p>\n<ul>\n<li>Request，HTTP 请求对象</li>\n<li>Response，HTTP 响应对象</li>\n<li>Client，HTTP 客户端</li>\n<li>Server，HTTP 服务端</li>\n</ul>\n<p>创建一个 server ：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">\"fmt\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"net/http\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">MyHandler</span><span class=\"params\">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class=\"line\">\t_, _ = fmt.Fprintf(w, <span class=\"string\">\"hello\"</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\thttp.HandleFunc(<span class=\"string\">\"/\"</span>, MyHandler)</span><br><span class=\"line\">\t_ = http.ListenAndServe(<span class=\"string\">\":8080\"</span>, <span class=\"literal\">nil</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>发送请求：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">resp, err := http.Get(<span class=\"string\">\"http://example.com/\"</span>) <span class=\"comment\">// GET </span></span><br><span class=\"line\"></span><br><span class=\"line\">resp, err := http.Post(<span class=\"string\">\"http://example.com/\"</span>) <span class=\"comment\">// POST</span></span><br><span class=\"line\"></span><br><span class=\"line\">resp, err := http.PostForm(<span class=\"string\">\"http://example.com/\"</span>, url.Values&#123;<span class=\"string\">\"foo\"</span>: <span class=\"string\">\"bar\"</span>&#125;) <span class=\"comment\">// 提交表单</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Request\"><a href=\"#Request\" class=\"headerlink\" title=\"Request\"></a>Request</h2><p><code>Request</code> 对象是对 http 请求报文的抽象。包括起始行, <code>Headers</code>, <code>Body</code> 等。</p>\n<p>使用 <code>http.NewRequest</code> 函数创建一个 <code>Request</code> 请求对象：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewRequest</span><span class=\"params\">(method, url <span class=\"keyword\">string</span>, body io.Reader)</span> <span class=\"params\">(*Request, error)</span></span></span><br></pre></td></tr></table></figure></p>\n<p><code>Request</code> 对象主要用于数据的存储，结构：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Request <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    Method <span class=\"keyword\">string</span> <span class=\"comment\">// HTTP方法</span></span><br><span class=\"line\">    URL *url.URL <span class=\"comment\">// URL</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    Proto      <span class=\"keyword\">string</span> <span class=\"comment\">// \"HTTP/1.0\"</span></span><br><span class=\"line\">    ProtoMajor <span class=\"keyword\">int</span>    <span class=\"comment\">// 1</span></span><br><span class=\"line\">    ProtoMinor <span class=\"keyword\">int</span>    <span class=\"comment\">// 0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    Header Header <span class=\"comment\">// 报文头</span></span><br><span class=\"line\">    Body io.ReadCloser <span class=\"comment\">// 报文体</span></span><br><span class=\"line\">    GetBody <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span> <span class=\"params\">(io.ReadCloser, error)</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">ContentLength</span> <span class=\"title\">int64</span> // 报文长度</span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">TransferEncoding</span> []<span class=\"title\">string</span> // 传输编码</span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">Close</span> <span class=\"title\">bool</span> // 关闭连接</span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">Host</span> <span class=\"title\">string</span> // 主机名</span></span><br><span class=\"line\"><span class=\"function\">    </span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">Form</span> <span class=\"title\">url</span>.<span class=\"title\">Values</span> // </span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">PostForm</span> <span class=\"title\">url</span>.<span class=\"title\">Values</span> // <span class=\"title\">POST</span>表单信息</span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">MultipartForm</span> *<span class=\"title\">multipart</span>.<span class=\"title\">Form</span> // <span class=\"title\">multipart</span>，</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">Trailer</span> <span class=\"title\">Header</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">RemoteAddr</span> <span class=\"title\">string</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">RequestURI</span> <span class=\"title\">string</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">TLS</span> *<span class=\"title\">tls</span>.<span class=\"title\">ConnectionState</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">Cancel</span> &lt;-<span class=\"title\">chan</span> <span class=\"title\">struct</span></span>&#123;&#125;</span><br><span class=\"line\">    Response *Response</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 从 b 中读取和解析一个请求. </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">ReadRequest</span><span class=\"params\">(b *bufio.Reader)</span> <span class=\"params\">(req *Request, err error)</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// 给 <span class=\"title\">request</span> 添加 <span class=\"title\">cookie</span>, <span class=\"title\">AddCookie</span> 向请求中添加一个 <span class=\"title\">cookie</span>.按照<span class=\"title\">RFC</span> 6265 </span></span><br><span class=\"line\"><span class=\"function\">// <span class=\"title\">section</span> 5.4的规则, <span class=\"title\">AddCookie</span> 不会添加超过一个 <span class=\"title\">Cookie</span> 头字段.</span></span><br><span class=\"line\"><span class=\"function\">// 这表示所有的 <span class=\"title\">cookie</span> 都写在同一行, 用分号分隔（<span class=\"title\">cookie</span> 内部用逗号分隔属性） </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"params\">(r *Request)</span> <span class=\"title\">AddCookie</span><span class=\"params\">(c *Cookie)</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// 返回 <span class=\"title\">request</span> 中指定名 <span class=\"title\">name</span> 的 <span class=\"title\">cookie</span>，如果没有发现，返回 <span class=\"title\">ErrNoCookie</span> </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"params\">(r *Request)</span> <span class=\"title\">Cookie</span><span class=\"params\">(name <span class=\"keyword\">string</span>)</span> <span class=\"params\">(*Cookie, error)</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// 返回该请求的所有<span class=\"title\">cookies</span> </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"params\">(r *Request)</span> <span class=\"title\">Cookies</span><span class=\"params\">()</span> []*<span class=\"title\">Cookie</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// 利用提供的用户名和密码给 <span class=\"title\">http</span> 基本权限提供具有一定权限的 <span class=\"title\">header</span>。</span></span><br><span class=\"line\"><span class=\"function\">// 当使用 <span class=\"title\">http</span> 基本授权时，用户名和密码是不加密的 </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"params\">(r *Request)</span> <span class=\"title\">SetBasicAuth</span><span class=\"params\">(username, password <span class=\"keyword\">string</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// 如果在 <span class=\"title\">request</span> 中发送，该函数返回客户端的 <span class=\"title\">user</span>-<span class=\"title\">Agent</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"params\">(r *Request)</span> <span class=\"title\">UserAgent</span><span class=\"params\">()</span> <span class=\"title\">string</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// 对于指定格式的 <span class=\"title\">key</span>，<span class=\"title\">FormFile</span> 返回符合条件的第一个文件，如果有必要的话，</span></span><br><span class=\"line\"><span class=\"function\">// 该函数会调用 <span class=\"title\">ParseMultipartForm</span> 和 <span class=\"title\">ParseForm</span>。 </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"params\">(r *Request)</span> <span class=\"title\">FormFile</span><span class=\"params\">(key <span class=\"keyword\">string</span>)</span> <span class=\"params\">(multipart.File, *multipart.FileHeader, error)</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// 返回 <span class=\"title\">key</span> 获取的队列中第一个值。在查询过程中 <span class=\"title\">post</span> 和 <span class=\"title\">put</span> 中的主题参数优先级</span></span><br><span class=\"line\"><span class=\"function\">// 高于 <span class=\"title\">url</span> 中的 <span class=\"title\">value</span>。为了访问相同 <span class=\"title\">key</span> 的多个值，调用 <span class=\"title\">ParseForm</span> 然后直接</span></span><br><span class=\"line\"><span class=\"function\">// 检查 <span class=\"title\">RequestForm</span>。 </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"params\">(r *Request)</span> <span class=\"title\">FormValue</span><span class=\"params\">(key <span class=\"keyword\">string</span>)</span> <span class=\"title\">string</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// 如果这是一个有多部分组成的 <span class=\"title\">post</span> 请求，该函数将会返回一个 <span class=\"title\">MIME</span> 多部分 <span class=\"title\">reader</span>，</span></span><br><span class=\"line\"><span class=\"function\">// 否则的话将会返回一个 <span class=\"title\">nil</span> 和 <span class=\"title\">error</span>。使用本函数代替 <span class=\"title\">ParseMultipartForm</span></span></span><br><span class=\"line\"><span class=\"function\">// 可以将请求 <span class=\"title\">body</span> 当做流 <span class=\"title\">stream</span> 来处理。 </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"params\">(r *Request)</span> <span class=\"title\">MultipartReader</span><span class=\"params\">()</span> <span class=\"params\">(*multipart.Reader, error)</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// 解析<span class=\"title\">URL</span>中的查询字符串，并将解析结果更新到 <span class=\"title\">r</span>.<span class=\"title\">Form</span> 字段。对于<span class=\"title\">POST</span> 或 <span class=\"title\">PUT</span></span></span><br><span class=\"line\"><span class=\"function\">// 请求，<span class=\"title\">ParseForm</span> 还会将 <span class=\"title\">body</span> 当作表单解析，并将结果既更新到 <span class=\"title\">r</span>.<span class=\"title\">PostForm</span> 也</span></span><br><span class=\"line\"><span class=\"function\">// 更新到 <span class=\"title\">r</span>.<span class=\"title\">Form</span>。解析结果中，<span class=\"title\">POST</span> 或 <span class=\"title\">PUT</span> 请求主体要优先于 <span class=\"title\">URL</span> 查询字符串</span></span><br><span class=\"line\"><span class=\"function\">// （同名变量，主体的值在查询字符串的值前面）。如果请求的主体的大小没有被</span></span><br><span class=\"line\"><span class=\"function\">// <span class=\"title\">MaxBytesReader</span> 函数设定限制，其大小默认限制为开头 10<span class=\"title\">MB</span>。</span></span><br><span class=\"line\"><span class=\"function\">// <span class=\"title\">ParseMultipartForm</span> 会自动调用 <span class=\"title\">ParseForm</span>。重复调用本方法是无意义的。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"params\">(r *Request)</span> <span class=\"title\">ParseForm</span><span class=\"params\">()</span> <span class=\"title\">error</span> </span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// <span class=\"title\">ParseMultipartForm</span> 将请求的主体作为 <span class=\"title\">multipart</span>/<span class=\"title\">form</span>-<span class=\"title\">data</span> 解析。</span></span><br><span class=\"line\"><span class=\"function\">// 请求的整个主体都会被解析，得到的文件记录最多 <span class=\"title\">maxMemery</span> 字节保存在内存，</span></span><br><span class=\"line\"><span class=\"function\">// 其余部分保存在硬盘的 <span class=\"title\">temp</span> 文件里。如果必要，<span class=\"title\">ParseMultipartForm</span> 会</span></span><br><span class=\"line\"><span class=\"function\">// 自行调用 <span class=\"title\">ParseForm</span>。重复调用本方法是无意义的。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"params\">(r *Request)</span> <span class=\"title\">ParseMultipartForm</span><span class=\"params\">(maxMemory <span class=\"keyword\">int64</span>)</span> <span class=\"title\">error</span> </span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// 返回 <span class=\"title\">post</span> 或者 <span class=\"title\">put</span> 请求 <span class=\"title\">body</span> 指定元素的第一个值，其中 <span class=\"title\">url</span> 中的参数被忽略。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"params\">(r *Request)</span> <span class=\"title\">PostFormValue</span><span class=\"params\">(key <span class=\"keyword\">string</span>)</span> <span class=\"title\">string</span> </span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// 检测在 <span class=\"title\">request</span> 中使用的 <span class=\"title\">http</span> 协议是否至少是 <span class=\"title\">major</span>.<span class=\"title\">minor</span> </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"params\">(r *Request)</span> <span class=\"title\">ProtoAtLeast</span><span class=\"params\">(major, minor <span class=\"keyword\">int</span>)</span> <span class=\"title\">bool</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// 如果 <span class=\"title\">request</span> 中有 <span class=\"title\">refer</span>，那么 <span class=\"title\">refer</span> 返回相应的 <span class=\"title\">url</span>。<span class=\"title\">Referer</span> 在 <span class=\"title\">request</span></span></span><br><span class=\"line\"><span class=\"function\">// 中是拼错的<span class=\"params\">(Referrer)</span>，这个错误从 <span class=\"title\">http</span> 初期就已经存在了。该值也可以从 <span class=\"title\">Headermap</span> 中</span></span><br><span class=\"line\"><span class=\"function\">// 利用 <span class=\"title\">Header</span>[\"<span class=\"title\">Referer</span>\"] 获取；在使用过程中利用 <span class=\"title\">Referer</span> 这个方法而</span></span><br><span class=\"line\"><span class=\"function\">// 不是 <span class=\"title\">map</span> 的形式的好处是在编译过程中可以检查方法的错误，而无法检查 <span class=\"title\">map</span> 中</span></span><br><span class=\"line\"><span class=\"function\">// <span class=\"title\">key</span> 的错误。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"params\">(r *Request)</span> <span class=\"title\">Referer</span><span class=\"params\">()</span> <span class=\"title\">string</span> </span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// <span class=\"title\">Write</span> 方法以有线格式将 <span class=\"title\">HTTP</span>/1.1 请求写入 <span class=\"title\">w</span>（用于将请求写入下层 <span class=\"title\">TCPConn</span> 等）</span></span><br><span class=\"line\">// 。本方法会考虑请求的如下字段：Host URL Method (defaults to \"GET\")</span><br><span class=\"line\"><span class=\"comment\">//  Header ContentLength TransferEncoding Body如果存在Body，</span></span><br><span class=\"line\"><span class=\"comment\">// ContentLength字段&lt;= 0且TransferEncoding字段未显式设置为</span></span><br><span class=\"line\"><span class=\"comment\">// [\"identity\"]，Write 方法会显式添加 ”Transfer-Encoding: chunked”</span></span><br><span class=\"line\"><span class=\"comment\">// 到请求的头域。Body 字段会在发送完请求后关闭。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(r *Request)</span> <span class=\"title\">Write</span><span class=\"params\">(w io.Writer)</span> <span class=\"title\">error</span> </span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// 该函数与 <span class=\"title\">Write</span> 方法类似，但是该方法写的 <span class=\"title\">request</span> 是按照 <span class=\"title\">http</span> 代理的格式去写。</span></span><br><span class=\"line\"><span class=\"function\">// 尤其是，按照 <span class=\"title\">RFC</span> 2616 <span class=\"title\">Section</span> 5.1.2，<span class=\"title\">WriteProxy</span> 会使用绝对 <span class=\"title\">URI</span></span></span><br><span class=\"line\"><span class=\"function\">// （包括协议和主机名）来初始化请求的第1行（<span class=\"title\">Request</span>-<span class=\"title\">URI</span>行）。无论何种情况，</span></span><br><span class=\"line\"><span class=\"function\">// <span class=\"title\">WriteProxy</span> 都会使用 <span class=\"title\">r</span>.<span class=\"title\">Host</span> 或 <span class=\"title\">r</span>.<span class=\"title\">URL</span>.<span class=\"title\">Host</span> 设置 <span class=\"title\">Host</span> 头。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"params\">(r *Request)</span> <span class=\"title\">WriteProxy</span><span class=\"params\">(w io.Writer)</span> <span class=\"title\">error</span></span></span><br></pre></td></tr></table></figure>\n<h2 id=\"Response\"><a href=\"#Response\" class=\"headerlink\" title=\"Response\"></a>Response</h2><p>Response 也是一个数据对象，描述 HTTP 响应：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Response <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    Status     <span class=\"keyword\">string</span> <span class=\"comment\">// HTTP 状态码</span></span><br><span class=\"line\">    StatusCode <span class=\"keyword\">int</span>    <span class=\"comment\">// 状态码 200</span></span><br><span class=\"line\">    Proto      <span class=\"keyword\">string</span> <span class=\"comment\">// 版本号 \"HTTP/1.0\"</span></span><br><span class=\"line\">    ProtoMajor <span class=\"keyword\">int</span>    <span class=\"comment\">// 主版本号 </span></span><br><span class=\"line\">    ProtoMinor <span class=\"keyword\">int</span>    <span class=\"comment\">// 次版本号</span></span><br><span class=\"line\"></span><br><span class=\"line\">    Header Header <span class=\"comment\">// 响应报文头</span></span><br><span class=\"line\">    Body io.ReadCloser <span class=\"comment\">// 响应报文体</span></span><br><span class=\"line\">    ContentLength <span class=\"keyword\">int64</span> <span class=\"comment\">// 报文长度</span></span><br><span class=\"line\">    TransferEncoding []<span class=\"keyword\">string</span> <span class=\"comment\">// 报文编码</span></span><br><span class=\"line\">    Close <span class=\"keyword\">bool</span> </span><br><span class=\"line\">    Trailer Header</span><br><span class=\"line\">    Request *Request <span class=\"comment\">// 请求对象</span></span><br><span class=\"line\">    TLS *tls.ConnectionState</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ReadResponse 从 r 读取并返回一个 HTTP 回复。req 参数是可选的，指定该回复</span></span><br><span class=\"line\"><span class=\"comment\">// 对应的请求（即是对该请求的回复）。如果是 nil，将假设请 求是 GET 请求。</span></span><br><span class=\"line\"><span class=\"comment\">// 客户端必须在结束 resp.Body 的读取后关闭它。读取完毕并关闭后，客户端可以</span></span><br><span class=\"line\"><span class=\"comment\">// 检查 resp.Trailer 字段获取回复的 trailer 的键值对。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">ReadResponse</span><span class=\"params\">(r *bufio.Reader, req *Request)</span> <span class=\"params\">(*Response, error)</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// 解析 <span class=\"title\">cookie</span> 并返回在 <span class=\"title\">header</span> 中利用 <span class=\"title\">set</span>-<span class=\"title\">Cookie</span> 设定的 <span class=\"title\">cookie</span> 值。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"params\">(r *Response)</span> <span class=\"title\">Cookies</span><span class=\"params\">()</span> []*<span class=\"title\">Cookie</span> </span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// 返回 <span class=\"title\">response</span> 中 <span class=\"title\">Location</span> 的 <span class=\"title\">header</span> 值的 <span class=\"title\">url</span>。如果该值存在的话，则对于</span></span><br><span class=\"line\"><span class=\"function\">// 请求问题可以解决相对重定向的问题，如果该值为<span class=\"title\">nil</span>，则返回<span class=\"title\">ErrNOLocation</span>。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"params\">(r *Response)</span> <span class=\"title\">Location</span><span class=\"params\">()</span> <span class=\"params\">(*url.URL, error)</span> </span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// 判定在 <span class=\"title\">response</span> 中使用的 <span class=\"title\">http</span> 协议是否至少是 <span class=\"title\">major</span>.<span class=\"title\">minor</span> 的形式。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"params\">(r *Response)</span> <span class=\"title\">ProtoAtLeast</span><span class=\"params\">(major, minor <span class=\"keyword\">int</span>)</span> <span class=\"title\">bool</span> </span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// 将 <span class=\"title\">response</span> 中信息按照线性格式写入 <span class=\"title\">w</span> 中。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"params\">(r *Response)</span> <span class=\"title\">Write</span><span class=\"params\">(w io.Writer)</span> <span class=\"title\">error</span></span></span><br></pre></td></tr></table></figure>\n<h2 id=\"client\"><a href=\"#client\" class=\"headerlink\" title=\"client\"></a>client</h2><p>前面以 <code>http.Get(&quot;http://example.com/&quot;)</code> <code>Get</code> 或 <code>Post</code> 函数发送请求，就是通过绑定一个默认 <code>Client</code> 实现的。<br>使用 <code>Client</code> 要先初始化一个 <code>Client</code> 对象。<code>Client</code> 具有 <code>Do</code>，<code>Get</code>，<code>Head</code>，<code>Post</code> 以及 <code>PostForm</code> 等方法。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"net/http\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    client := http.Client()</span><br><span class=\"line\">    res, err := client.Get(<span class=\"string\">\"http://www.google.com\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对于常用 HTTP 动词，<code>Client</code> 对象对应的函数，下面的这些方法与 <code>http.Get</code> 等方法一致：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *Client)</span> <span class=\"title\">Get</span><span class=\"params\">(url <span class=\"keyword\">string</span>)</span> <span class=\"params\">(resp *Response, err error)</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"params\">(c *Client)</span> <span class=\"title\">Head</span><span class=\"params\">(url <span class=\"keyword\">string</span>)</span> <span class=\"params\">(resp *Response, err error)</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"params\">(c *Client)</span> <span class=\"title\">Post</span><span class=\"params\">(url <span class=\"keyword\">string</span>, contentType <span class=\"keyword\">string</span>, body io.Reader)</span> <span class=\"params\">(resp *Response, err error)</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"params\">(c *Client)</span> <span class=\"title\">PostForm</span><span class=\"params\">(url <span class=\"keyword\">string</span>, data url.Values)</span> <span class=\"params\">(resp *Response, err error)</span></span></span><br></pre></td></tr></table></figure></p>\n<p>但是在很多情况下，需要支持对 headers，cookies 等的设定，上面提供的方法就不能满足需求了。就需要使用 <code>Do</code> 方法，<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *Client)</span> <span class=\"title\">Do</span><span class=\"params\">(req *Request)</span> <span class=\"params\">(resp *Response, err error)</span></span></span><br></pre></td></tr></table></figure></p>\n<p><code>http.NewRequest</code> 可以灵活的对 <code>Request</code> 进行配置，然后再使用 <code>http.Client</code> 的 <code>Do</code> 方法发送这个 <code>Request</code> 请求。</p>\n<p><strong>模拟 HTTP Request</strong>：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 简式声明一个 http.Client</span></span><br><span class=\"line\">client := &amp;http.Client&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 构建 Request</span></span><br><span class=\"line\">request, err := http.NewRequest(<span class=\"string\">\"GET\"</span>, <span class=\"string\">\"http://www.baidu.com\"</span>, <span class=\"literal\">nil</span>)</span><br><span class=\"line\"><span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    fmt.Println(err)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用 http.Cookie 结构体初始化一个 cookie 键值对</span></span><br><span class=\"line\">cookie := &amp;http.Cookie&#123;Name: <span class=\"string\">\"userId\"</span>, Value: strconv.Itoa(<span class=\"number\">12345</span>)&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// AddCookie</span></span><br><span class=\"line\">request.AddCookie(cookie)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 设置 Header</span></span><br><span class=\"line\">request.Header.Set(<span class=\"string\">\"Accept\"</span>, <span class=\"string\">\"text/html, application/xhtml+xml, application/xml;q=0.9, */*;q=0.8\"</span>)</span><br><span class=\"line\">request.Header.Set(<span class=\"string\">\"Accept-Charset\"</span>, <span class=\"string\">\"GBK, utf-8;q=0.7, *;q=0.3\"</span>)</span><br><span class=\"line\">request.Header.Set(<span class=\"string\">\"Accept-Encoding\"</span>, <span class=\"string\">\"gzip, deflate, sdch\"</span>)</span><br><span class=\"line\">request.Header.Set(<span class=\"string\">\"Accept-Language\"</span>, <span class=\"string\">\"zh-CN, zh;q=0.8\"</span>)</span><br><span class=\"line\">request.Header.Set(<span class=\"string\">\"Cache-Control\"</span>, <span class=\"string\">\"max-age=0\"</span>)</span><br><span class=\"line\">request.Header.Set(<span class=\"string\">\"Connection\"</span>, <span class=\"string\">\"keep-alive\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用 Do 方法发送请求</span></span><br><span class=\"line\">response, err := client.Do(request)</span><br><span class=\"line\"><span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    fmt.Println(err)</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 程序结束时关闭 response.Body 响应流</span></span><br><span class=\"line\"><span class=\"keyword\">defer</span> response.Body.Close()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// http Response 状态值</span></span><br><span class=\"line\">fmt.Println(response.StatusCode)</span><br><span class=\"line\"><span class=\"keyword\">if</span> response.StatusCode == <span class=\"number\">200</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// gzip.NewReader对压缩的返回信息解压（考虑网络传输量，http Server</span></span><br><span class=\"line\">    <span class=\"comment\">// 一般都会对响应压缩后再返回）</span></span><br><span class=\"line\">    body, err := gzip.NewReader(response.Body)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        fmt.Println(err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">defer</span> body.Close()</span><br><span class=\"line\"></span><br><span class=\"line\">    r, err := ioutil.ReadAll(body)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        fmt.Println(err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 打印出http Server返回的http Response信息</span></span><br><span class=\"line\">    fmt.Println(<span class=\"keyword\">string</span>(r))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>Ge请求</strong>：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// http.Get 实际上是 DefaultClient.Get(url)</span></span><br><span class=\"line\">response, err := http.Get(<span class=\"string\">\"http://www.baidu.com\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    fmt.Println(err)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 程序在使用完回复后必须关闭回复的主体</span></span><br><span class=\"line\"><span class=\"keyword\">defer</span> response.Body.Close()</span><br><span class=\"line\"></span><br><span class=\"line\">body, _ := ioutil.ReadAll(response.Body)</span><br><span class=\"line\">fmt.Println(<span class=\"keyword\">string</span>(body))</span><br></pre></td></tr></table></figure>\n<p><strong>Post 请求</strong>：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// application/x-www-form-urlencoded：为 POST 的 contentType</span></span><br><span class=\"line\">resp, err := http.Post(<span class=\"string\">\"http://localhost:8080/login.do\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"application/x-www-form-urlencoded\"</span>, strings.NewReader(<span class=\"string\">\"mobile=xxxxxxxxxx&amp;isRemberPwd=1\"</span>))</span><br><span class=\"line\"><span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    fmt.Println(err)</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">defer</span> resp.Body.Close()</span><br><span class=\"line\">body, err := ioutil.ReadAll(resp.Body)</span><br><span class=\"line\"><span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    fmt.Println(err)</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fmt.Println(<span class=\"keyword\">string</span>(body))</span><br></pre></td></tr></table></figure>\n<p><strong>http.PostForm 请求</strong>：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">\"fmt\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"io/ioutil\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"net/http\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"net/url\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tpostParam := url.Values&#123;</span><br><span class=\"line\">\t\t<span class=\"string\">\"mobile\"</span>:      &#123;<span class=\"string\">\"xxxxxx\"</span>&#125;,</span><br><span class=\"line\">\t\t<span class=\"string\">\"isRemberPwd\"</span>: &#123;<span class=\"string\">\"1\"</span>&#125;,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 数据的键值会经过 URL 编码后作为请求的 body 传递</span></span><br><span class=\"line\">\tresp, err := http.PostForm(<span class=\"string\">\"http://localhost：8080/login.do\"</span>, postParam)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tfmt.Println(err)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> resp.Body.Close()</span><br><span class=\"line\">\tbody, err := ioutil.ReadAll(resp.Body)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tfmt.Println(err)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tfmt.Println(<span class=\"keyword\">string</span>(body))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"HTTP-Server\"><a href=\"#HTTP-Server\" class=\"headerlink\" title=\"HTTP Server\"></a>HTTP Server</h2><p><code>server.go</code> 文件中定义了一个非常重要的接口：<code>Handler</code>，另外还有一个结构体 <code>response</code>，这和 <code>http.Response</code> 结构体只有首字母大小<br>写不一致，这个 <code>response</code> 也是响应，只不过是专门用在服务端，和 <code>http.Response</code> 结构体是完全两回事。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Handler <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">\tServeHTTP(ResponseWriter, *Request)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Server <span class=\"keyword\">struct</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 监听 srv.Addr 然后调用 Serve 来处理接下来连接的请求</span></span><br><span class=\"line\"><span class=\"comment\">// 如果 srv.Addr 是空的话，则使用 \":http\"</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(srv *Server)</span> <span class=\"title\">ListenAndServe</span><span class=\"params\">()</span> <span class=\"title\">error</span> </span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// 监听 <span class=\"title\">srv</span>.<span class=\"title\">Addr</span> ，调用 <span class=\"title\">Serve</span> 来处理接下来连接的请求</span></span><br><span class=\"line\"><span class=\"function\">// 必须提供证书文件和对应的私钥文件。如果证书是由</span></span><br><span class=\"line\"><span class=\"function\">// 权威机构签发的，<span class=\"title\">certFile</span> 参数必须是顺序串联的服务端证书和 <span class=\"title\">CA</span> 证书。</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"params\">(srv *Server)</span> <span class=\"title\">ListenAndServeTLS</span><span class=\"params\">(certFile, keyFile <span class=\"keyword\">string</span>)</span> <span class=\"title\">error</span> </span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// 接受 <span class=\"title\">l</span> <span class=\"title\">Listener</span> 的连接，创建一个新的服务协程。该服务协程读取请求然后调用</span></span><br><span class=\"line\"><span class=\"function\">// <span class=\"title\">srv</span>.<span class=\"title\">Handler</span> 来应答。实际上就是实现了对某个端口进行监听，然后创建相应的连接。 </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"params\">(srv *Server)</span> <span class=\"title\">Serve</span><span class=\"params\">(l net.Listener)</span> <span class=\"title\">error</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// 该函数控制是否 <span class=\"title\">http</span> 的 <span class=\"title\">keep</span>-<span class=\"title\">alives</span> 能够使用，默认情况下，<span class=\"title\">keep</span>-<span class=\"title\">alives</span> 总是可用的。</span></span><br><span class=\"line\"><span class=\"function\">// 只有资源非常紧张的环境或者服务端在关闭进程中时，才应该关闭该功能。 </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"params\">(s *Server)</span> <span class=\"title\">SetKeepAlivesEnabled</span><span class=\"params\">(v <span class=\"keyword\">bool</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// 是一个 <span class=\"title\">http</span> 请求多路复用器，它将每一个请求的 <span class=\"title\">URL</span> 和</span></span><br><span class=\"line\"><span class=\"function\">// 一个注册模式的列表进行匹配，然后调用和 <span class=\"title\">URL</span> 最匹配的模式的处理器进行后续操作。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">type</span> <span class=\"title\">ServeMux</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// 初始化一个新的 <span class=\"title\">ServeMux</span> </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">NewServeMux</span><span class=\"params\">()</span> *<span class=\"title\">ServeMux</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// 将 <span class=\"title\">handler</span> 注册为指定的模式，如果该模式已经有了 <span class=\"title\">handler</span>，则会出错 <span class=\"title\">panic</span>。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"params\">(mux *ServeMux)</span> <span class=\"title\">Handle</span><span class=\"params\">(pattern <span class=\"keyword\">string</span>, handler Handler)</span> </span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// 将 <span class=\"title\">handler</span> 注册为指定的模式 </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"params\">(mux *ServeMux)</span> <span class=\"title\">HandleFunc</span><span class=\"params\">(pattern <span class=\"keyword\">string</span>, handler <span class=\"keyword\">func</span>(ResponseWriter, *Request)</span>)</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// 根据指定的 <span class=\"title\">r</span>.<span class=\"title\">Method</span>, <span class=\"title\">r</span>.<span class=\"title\">Host</span> 以及 <span class=\"title\">r</span>.<span class=\"title\">RUL</span>.<span class=\"title\">Path</span> 返回一个用来处理给定请求的 <span class=\"title\">handler</span>。</span></span><br><span class=\"line\"><span class=\"function\">// 该函数总是返回一个 非 <span class=\"title\">nil</span> 的 <span class=\"title\">handler</span>，如果 <span class=\"title\">path</span> 不是一个规范格式，则 <span class=\"title\">handler</span> 会</span></span><br><span class=\"line\"><span class=\"function\">// 重定向到其规范 <span class=\"title\">path</span>。<span class=\"title\">Handler</span> 总是返回匹配该请求的的已注册模式；在内建重定向</span></span><br><span class=\"line\"><span class=\"function\">// 处理器的情况下，<span class=\"title\">pattern</span> 会在重定向后进行匹配。如果没有已注册模式可以应用于该请求，</span></span><br><span class=\"line\"><span class=\"function\">// 本方法将返回一个内建的 ”404 <span class=\"title\">page</span> <span class=\"title\">not</span> <span class=\"title\">found</span>” 处理器和一个空字符串模式。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"params\">(mux *ServeMux)</span> <span class=\"title\">Handler</span><span class=\"params\">(r *Request)</span> <span class=\"params\">(h Handler, pattern <span class=\"keyword\">string</span>)</span> </span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// 该函数用于将最接近请求 <span class=\"title\">url</span> 模式的 <span class=\"title\">handler</span> 分配给指定的请求。 </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"params\">(mux *ServeMux)</span> <span class=\"title\">ServeHTTP</span><span class=\"params\">(w ResponseWriter, r *Request)</span></span></span><br></pre></td></tr></table></figure>\n<p><code>Handler</code> 接口是 <code>server.go</code> 中最关键的接口，如果我们仔细看这个文件的源代码，将会发现很多结构体实现了这个接口的 <code>ServeHTTP</code> 方法。</p>\n<p>注意这个接口的注释：<code>Handler</code> 响应 HTTP 请求。没错，最终我们的 HTTP 服务是通过实现 <code>ServeHTTP(ResponseWriter, *Request)</code> 来达<br>到服务端接收客户端请求并响应。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\thttp.HandleFunc(<span class=\"string\">\"/\"</span>, MyHandler)</span><br><span class=\"line\">\t_ = http.ListenAndServe(<span class=\"string\">\":8080\"</span>, <span class=\"literal\">nil</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上两行代码，就成功启动了一个 HTTP 服务器。我们通过 <code>net/http</code> 包源代码分析发现，调用 <code>Http.HandleFunc</code>，按顺序做了几件事：</p>\n<ol>\n<li><code>Http.HandleFunc</code> 调用了 <code>DefaultServeMux</code> 的 <code>HandleFunc</code></li>\n</ol>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">HandleFunc</span><span class=\"params\">(pattern <span class=\"keyword\">string</span>, handler <span class=\"keyword\">func</span>(ResponseWriter, *Request)</span>)</span> &#123;</span><br><span class=\"line\">    DefaultServeMux.HandleFunc(pattern, handler)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li><code>DefaultServeMux.HandleFunc</code> 调用了 <code>DefaultServeMux</code> 的 <code>Handle</code>，<code>DefaultServeMux</code> 是一个 <code>ServeMux</code> 指针变量。<br>而 <code>ServeMux</code> 是 Go 语言中的 <code>Multiplexer</code>（多路复用器），通过 <code>Handle</code> 匹配 <code>pattern</code> 和我们定义的 <code>handler</code><br>（其实就是 <code>http.HandlerFunc</code> 函数类型变量）。</li>\n</ol>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> ServeMux <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tmu    sync.RWMutex</span><br><span class=\"line\">\tm     <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]muxEntry <span class=\"comment\">// 保存路由规则 和 handler</span></span><br><span class=\"line\">\thosts <span class=\"keyword\">bool</span> <span class=\"comment\">// whether any patterns contain hostnames</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> muxEntry <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\th       Handler</span><br><span class=\"line\">\tpattern <span class=\"keyword\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> DefaultServeMux = &amp;defaultServeMux</span><br><span class=\"line\"><span class=\"keyword\">var</span> defaultServeMux ServeMux</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(mux *ServeMux)</span> <span class=\"title\">HandleFunc</span><span class=\"params\">(pattern <span class=\"keyword\">string</span>, handler <span class=\"keyword\">func</span>(ResponseWriter, *Request)</span>)</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> handler == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">panic</span>(<span class=\"string\">\"http: nil handler\"</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tmux.Handle(pattern, HandlerFunc(handler)) <span class=\"comment\">// 这个 handler 就是 MyHandler</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意：<br>上面的方法命名 <code>Handle</code>，<code>HandleFunc</code> 和 <code>HandlerFunc</code>，<code>Handler</code>（接口），他们很相似，容易混淆。记住 <strong><code>Handle</code> 和 <code>HandleFunc</code><br>和 <code>pattern</code> 匹配有关，也即往 <code>DefaultServeMux</code> 的 <code>map[string]muxEntry</code> 中增加对应的 <code>handler</code> 和路由规则</strong>。</p>\n<p>接着我们看看 <code>MyHandler</code> 的声明和定义：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">MyHandler</span><span class=\"params\">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class=\"line\">\tfmt.Fprintf(w, <span class=\"string\">\"hello\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>而 <code>type HandlerFunc func(ResponseWriter, *Request)</code> 是一个函数类型，而我们定义的 <code>MyHandler</code> 的函数签名刚好符合这个函数类型。</p>\n<p>所以 <code>http.HandleFunc(&quot;/&quot;, MyHandler)</code>，实际上是 <code>mux.Handle(&quot;/&quot;, HandlerFunc(MyHandler))</code>。</p>\n<p><code>HandlerFunc(MyHandler)</code> 让 <code>MyHandler</code> 成为了 <code>HandlerFunc</code> 类型，我们称 <code>MyHandler</code> 为 <code>handler</code>。而 <code>HandlerFunc</code> 类型是<br>具有 <code>ServeHTTP</code> 方法的，而有了 <code>ServeHTTP</code> 方法也就是实现了 <code>Handler</code> 接口。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(f HandlerFunc)</span> <span class=\"title\">ServeHTTP</span><span class=\"params\">(w ResponseWriter, r *Request)</span></span> &#123;</span><br><span class=\"line\">\tf(w, r) <span class=\"comment\">// 这相当于自身的调用</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在 <code>ServeMux</code> 和 <code>Handler</code> 都和我们的 <code>MyHandler</code> 联系上了，<code>MyHandler</code> 是一个 <code>Handler</code> 接口变量也是 <code>HandlerFunc</code> 类型变量，<br>接下来和结构体 <code>server</code> 有关了。</p>\n<p>从 <code>http.ListenAndServe</code> 的源码可以看出，它创建了一个 <code>server</code> 对象，并调用 <code>server</code> 对象的 <code>ListenAndServe</code> 方法：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">ListenAndServe</span><span class=\"params\">(addr <span class=\"keyword\">string</span>, handler Handler)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">    server := &amp;Server&#123;Addr: addr, Handler: handler&#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> server.ListenAndServe()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>而我们 HTTP 服务器中第二行代码：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http.ListenAndServe(<span class=\"string\">\":8080\"</span>, <span class=\"literal\">nil</span>)</span><br></pre></td></tr></table></figure>\n<p>创建了一个 <code>server</code> 对象，并调用 <code>server</code> 对象的 <code>ListenAndServe</code> 方法，这里没有直接传递 <code>Handler</code>，而是默认<br>使用 <code>DefautServeMux</code> 作为 <code>multiplexer</code>。</p>\n<p><code>Server</code> 的 <code>ListenAndServe</code> 方法中，会初始化监听地址 <code>Addr</code>，同时调用 <code>Listen</code> 方法设置监听。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">    rw, e := l.Accept()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> e != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">select</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> &lt;-srv.getDoneChan():</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ErrServerClosed</span><br><span class=\"line\">        <span class=\"keyword\">default</span>:</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ne, ok := e.(net.Error); ok &amp;&amp; ne.Temporary() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> tempDelay == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">                tempDelay = <span class=\"number\">5</span> * time.Millisecond</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                tempDelay *= <span class=\"number\">2</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> max := <span class=\"number\">1</span> * time.Second; tempDelay &gt; max &#123;</span><br><span class=\"line\">                tempDelay = max</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            srv.logf(<span class=\"string\">\"http: Accept error: %v; retrying in %v\"</span>, e, tempDelay)</span><br><span class=\"line\">            time.Sleep(tempDelay)</span><br><span class=\"line\">            <span class=\"keyword\">continue</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> e</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    tempDelay = <span class=\"number\">0</span></span><br><span class=\"line\">    c := srv.newConn(rw)</span><br><span class=\"line\">    c.setState(c.rwc, StateNew) <span class=\"comment\">// before Serve can return</span></span><br><span class=\"line\">    <span class=\"keyword\">go</span> c.serve(ctx)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>监听开启之后，一旦客户端请求过来，Go 就开启一个协程 <code>go c.serve(ctx)</code> 处理请求，主要逻辑都在 <code>serve</code> 方法之中。</p>\n<p><code>func (c *conn) serve(ctx context.Context)</code>，这个方法很长，里面主要的一句：<code>serverHandler{c.server}.ServeHTTP(w, w.req)</code>。<br>其中 <code>w</code> 由 <code>w, err := c.readRequest(ctx)</code> 得到，因为有传递 <code>context</code>。</p>\n<p>还是来看源代码：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// serverHandler delegates to either the server's Handler or</span></span><br><span class=\"line\"><span class=\"comment\">// DefaultServeMux and also handles \"OPTIONS *\" requests.</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> serverHandler <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tsrv *Server</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(sh serverHandler)</span> <span class=\"title\">ServeHTTP</span><span class=\"params\">(rw ResponseWriter, req *Request)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 此 handler 即为 http.ListenAndServe 中的第二个参数</span></span><br><span class=\"line\">    handler := sh.srv.Handler </span><br><span class=\"line\">    <span class=\"keyword\">if</span> handler == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果 handler 为空则使用内部的 DefaultServeMux 进行处理</span></span><br><span class=\"line\">        handler = DefaultServeMux</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> req.RequestURI == <span class=\"string\">\"*\"</span> &amp;&amp; req.Method == <span class=\"string\">\"OPTIONS\"</span> &#123;</span><br><span class=\"line\">        handler = globalOptionsHandler&#123;&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 这里就开始处理 http 请求</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果需要使用自定义的 mux，就需要实现 ServeHTTP 方法，即实现 Handler 接口。</span></span><br><span class=\"line\">    <span class=\"comment\">// ServeHTTP(rw, req) 默认情况下是 func (mux *ServeMux) ServeHTTP(w ResponseWriter, r *Request)</span></span><br><span class=\"line\">    handler.ServeHTTP(rw, req)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从 <code>http.ListenAndServe(&quot;:8080&quot;, nil)</code> 开始，<code>handler</code> 是 <code>nil</code>，所以最后实际 <code>ServeHTTP</code> 方法<br>是 <code>DefaultServeMux.ServeHTTP(rw, req)</code>。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(mux *ServeMux)</span> <span class=\"title\">ServeHTTP</span><span class=\"params\">(w ResponseWriter, r *Request)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> r.RequestURI == <span class=\"string\">\"*\"</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> r.ProtoAtLeast(<span class=\"number\">1</span>, <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">\t\t\tw.Header().Set(<span class=\"string\">\"Connection\"</span>, <span class=\"string\">\"close\"</span>)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tw.WriteHeader(StatusBadRequest)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\th, _ := mux.Handler(r) <span class=\"comment\">// 会匹配路由，h 就是 MyHandler</span></span><br><span class=\"line\">\th.ServeHTTP(w, r) <span class=\"comment\">// 调用自己</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(mux *ServeMux)</span> <span class=\"title\">Handler</span><span class=\"params\">(r *Request)</span> <span class=\"params\">(h Handler, pattern <span class=\"keyword\">string</span>)</span></span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// CONNECT requests are not canonicalized.</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> r.Method == <span class=\"string\">\"CONNECT\"</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// If r.URL.Path is /tree and its handler is not registered,</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// the /tree -&gt; /tree/ redirect applies to CONNECT requests</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// but the path canonicalization does not.</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> u, ok := mux.redirectToPathSlash(r.URL.Host, r.URL.Path, r.URL); ok &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> RedirectHandler(u.String(), StatusMovedPermanently), u.Path</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> mux.handler(r.Host, r.URL.Path)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// All other requests have any port stripped and path cleaned</span></span><br><span class=\"line\">\t<span class=\"comment\">// before passing to mux.handler.</span></span><br><span class=\"line\">\thost := stripHostPort(r.Host)</span><br><span class=\"line\">\tpath := cleanPath(r.URL.Path)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// If the given path is /tree and its handler is not registered,</span></span><br><span class=\"line\">\t<span class=\"comment\">// redirect for /tree/.</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> u, ok := mux.redirectToPathSlash(host, path, r.URL); ok &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> RedirectHandler(u.String(), StatusMovedPermanently), u.Path</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> path != r.URL.Path &#123;</span><br><span class=\"line\">\t\t_, pattern = mux.handler(host, path)</span><br><span class=\"line\">\t\turl := *r.URL</span><br><span class=\"line\">\t\turl.Path = path</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> RedirectHandler(url.String(), StatusMovedPermanently), pattern</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> mux.handler(host, r.URL.Path)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// handler is the main implementation of Handler.</span></span><br><span class=\"line\"><span class=\"comment\">// The path is known to be in canonical form, except for CONNECT methods.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(mux *ServeMux)</span> <span class=\"title\">handler</span><span class=\"params\">(host, path <span class=\"keyword\">string</span>)</span> <span class=\"params\">(h Handler, pattern <span class=\"keyword\">string</span>)</span></span> &#123;</span><br><span class=\"line\">\tmux.mu.RLock()</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> mux.mu.RUnlock()</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// Host-specific pattern takes precedence over generic ones</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> mux.hosts &#123;</span><br><span class=\"line\">\t\th, pattern = mux.match(host + path)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> h == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\th, pattern = mux.match(path)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> h == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\th, pattern = NotFoundHandler(), <span class=\"string\">\"\"</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过 <code>func (mux *ServeMux) Handler(r *Request) (h Handler, pattern string)</code>，我们得到 <code>Handler h</code>，然后执<br>行 <code>h.ServeHTTP(w, r)</code> 方法，也就是执行我们的 <code>MyHandler</code> 函数（别忘了 <code>MyHandler</code> 是HandlerFunc类型，而他的 <code>ServeHTTP(w, r)</code><br>方法这里其实就是自己调用自己），把 <code>response</code> 写到 <code>http.ResponseWriter</code> 对象返回给客户端，<code>fmt.Fprintf(w, &quot;hello&quot;)</code>，我们在客<br>户端会接收到 “hello” 。至此整个 HTTP 服务执行完成。</p>\n<p>总结下，HTTP 服务整个过程大概是这样：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Request -&gt; ServeMux(Multiplexer) -&gt; handler-&gt; Response</span><br></pre></td></tr></table></figure></p>\n<p>我们再看下面代码：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http.ListenAndServe(<span class=\"string\">\":8080\"</span>, <span class=\"literal\">nil</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">ListenAndServe</span><span class=\"params\">(addr <span class=\"keyword\">string</span>, handler Handler)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">    server := &amp;Server&#123;Addr: addr, Handler: handler&#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> server.ListenAndServe()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面代码实际上就是 <code>server.ListenAndServe()</code> 执行的实际效果，只不过简单声明了一个结构体 <code>Server{Addr: addr, Handler: handler}</code> 实例。<br>如果我们声明一个 <code>Server</code> 实例，完全可以达到深度自定义 <code>http.Server</code> 的目的：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">\"fmt\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"net/http\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">MyHandler</span><span class=\"params\">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class=\"line\">\t_, _ = fmt.Fprintf(w, <span class=\"string\">\"hi\"</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 更多http.Server的字段可以根据情况初始化</span></span><br><span class=\"line\">\tserver := http.Server&#123;</span><br><span class=\"line\">\t\tAddr:         <span class=\"string\">\":8080\"</span>,</span><br><span class=\"line\">\t\tReadTimeout:  <span class=\"number\">0</span>,</span><br><span class=\"line\">\t\tWriteTimeout: <span class=\"number\">0</span>,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\thttp.HandleFunc(<span class=\"string\">\"/\"</span>, MyHandler)</span><br><span class=\"line\">\t_ = server.ListenAndServe()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们完全可以根据情况来自定义我们的 <code>Server</code>。</p>\n<p>还可以指定 <code>Servemux</code> 的用法:</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">\"fmt\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"net/http\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">MyHandler</span><span class=\"params\">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class=\"line\">\t_, _ = fmt.Fprintf(w, <span class=\"string\">\"hi\"</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tmux := http.NewServeMux()</span><br><span class=\"line\"></span><br><span class=\"line\">\tmux.HandleFunc(<span class=\"string\">\"/\"</span>, MyHandler)</span><br><span class=\"line\">\t_ = http.ListenAndServe(<span class=\"string\">\":8080\"</span>, mux)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果既指定 <code>Servemux</code> 又自定义 <code>http.Server</code>，因为 <code>Server</code> 中有字段 <code>Handler</code>，所以我们可以直接把 <code>Servemux</code> 变量作<br>为 <code>Server.Handler</code>：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">\"fmt\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"net/http\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">MyHandler</span><span class=\"params\">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class=\"line\">\t_, _ = fmt.Fprintf(w, <span class=\"string\">\"hi\"</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tserver := http.Server&#123;</span><br><span class=\"line\">\t\tAddr:         <span class=\"string\">\":8080\"</span>,</span><br><span class=\"line\">\t\tReadTimeout:  <span class=\"number\">0</span>,</span><br><span class=\"line\">\t\tWriteTimeout: <span class=\"number\">0</span>,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tmux := http.NewServeMux()</span><br><span class=\"line\">\tserver.Handler = mux</span><br><span class=\"line\"></span><br><span class=\"line\">\tmux.HandleFunc(<span class=\"string\">\"/\"</span>, MyHandler)</span><br><span class=\"line\">\t_ = server.ListenAndServe()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"自定义处理器\"><a href=\"#自定义处理器\" class=\"headerlink\" title=\"自定义处理器\"></a>自定义处理器</h2><p>自定义的 <code>Handler</code>：</p>\n<p>标准库 http 提供了 <code>Handler</code> 接口，用于开发者实现自己的 <code>handler</code>。只要实现接口的 <code>ServeHTTP</code> 方法即可。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">\"log\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"net/http\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"time\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> timeHandler <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tformat <span class=\"keyword\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(th *timeHandler)</span> <span class=\"title\">ServeHTTP</span><span class=\"params\">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class=\"line\">\ttm := time.Now().Format(th.format)</span><br><span class=\"line\">\t_, _ = w.Write([]<span class=\"keyword\">byte</span>(<span class=\"string\">\"The time is: \"</span> + tm))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tmux := http.NewServeMux()</span><br><span class=\"line\"></span><br><span class=\"line\">\tth := &amp;timeHandler&#123;format: time.RFC1123&#125;</span><br><span class=\"line\">\tmux.Handle(<span class=\"string\">\"/time\"</span>, th)</span><br><span class=\"line\"></span><br><span class=\"line\">\tlog.Println(<span class=\"string\">\"Listening...\"</span>)</span><br><span class=\"line\">\t_ = http.ListenAndServe(<span class=\"string\">\":3000\"</span>, mux)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们知道，<code>NewServeMux</code> 可以创建一个 <code>ServeMux</code> 实例，<code>ServeMux</code> 同时也实现了 <code>ServeHTTP</code> 方法，因此代码中的 <code>mux</code> 也是<br>一种 <code>handler</code>。把它当成参数传给 <code>http.ListenAndServe</code> 方法，后者会把 <code>mux</code> 传给 <code>Server</code> 实例。因为指定了 <code>handler</code>，<br>因此整个 <code>http</code> 服务就不再是 <code>DefaultServeMux</code>，而是 <code>mux</code>，无论是在注册路由还是提供请求服务的时候。</p>\n<p>任何有 <code>func(http.ResponseWriter，*http.Request)</code> 签名的函数都能转化为一个 <code>HandlerFunc</code> 类型。这很有用，因为 <code>HandlerFunc</code> 对象<br>内置了 <code>ServeHTTP</code> 方法，后者可以聪明又方便的调用我们最初提供的函数内容。</p>\n<h2 id=\"中间件-Middleware\"><a href=\"#中间件-Middleware\" class=\"headerlink\" title=\"中间件 Middleware\"></a>中间件 Middleware</h2><p>所谓中间件，就是连接上下级不同功能的函数或者软件，通常进行一些包裹函数的行为，为被包裹函数提供添加一些功能或行为。前文的 <code>HandleFunc</code> 就<br>能把签名为 <code>func(w http.ResponseWriter, r *http.Reqeust)</code> 的函数包裹成 <code>handler</code>。这个函数也算是中间件。</p>\n<p>Go 的 HTTP 中间件很简单，只要实现一个函数签名为 <code>func(http.Handler) http.Handler</code> 的函数即可。<code>http.Handler</code> 是一个接口，<br>接口方法我们熟悉的为 <code>serveHTTP</code>。返回也是一个 <code>handler</code>。因为 Go 中的函数也可以当成变量传递或者或者返回，因此也可以在中间件函数<br>中传递定义好的函数，只要这个函数是一个 <code>handler</code> 即可，即实现或者被 <code>handlerFunc</code> 包裹成为 <code>handler</code> 处理器。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">index</span><span class=\"params\">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class=\"line\">    w.Header().Set(<span class=\"string\">\"Content-Type\"</span>, <span class=\"string\">\"text/html\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    html := <span class=\"string\">`&lt;doctype html&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;html&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;head&gt;</span></span><br><span class=\"line\"><span class=\"string\">          &lt;title&gt;Hello World&lt;/title&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;/head&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;body&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"string\">          Welcome</span></span><br><span class=\"line\"><span class=\"string\">        &lt;/p&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;/body&gt;</span></span><br><span class=\"line\"><span class=\"string\">&lt;/html&gt;`</span></span><br><span class=\"line\">    fmt.Fprintln(w, html)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">middlewareHandler</span><span class=\"params\">(next http.Handler)</span> <span class=\"title\">http</span>.<span class=\"title\">Handler</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> http.HandlerFunc(<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(w http.ResponseWriter, r *http.Request)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 执行 handler 之前的逻辑</span></span><br><span class=\"line\">        next.ServeHTTP(w, r)</span><br><span class=\"line\">        <span class=\"comment\">// 执行完毕 handler 后的逻辑</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">loggingHandler</span><span class=\"params\">(next http.Handler)</span> <span class=\"title\">http</span>.<span class=\"title\">Handler</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> http.HandlerFunc(<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class=\"line\">        start := time.Now()</span><br><span class=\"line\">        log.Printf(<span class=\"string\">\"Started %s %s\"</span>, r.Method, r.URL.Path)</span><br><span class=\"line\">        next.ServeHTTP(w, r)</span><br><span class=\"line\">        log.Printf(<span class=\"string\">\"Completed %s in %v\"</span>, r.URL.Path, time.Since(start))</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    http.Handle(<span class=\"string\">\"/\"</span>, loggingHandler(http.HandlerFunc(index)))</span><br><span class=\"line\"></span><br><span class=\"line\">    http.ListenAndServe(<span class=\"string\">\":8000\"</span>, <span class=\"literal\">nil</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"静态站点\"><a href=\"#静态站点\" class=\"headerlink\" title=\"静态站点\"></a>静态站点</h2><p>下面代码通过指定目录，作为静态站点：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">\"net/http\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\thttp.Handle(<span class=\"string\">\"/\"</span>, http.FileServer(http.Dir(<span class=\"string\">\"D:/html/static/\"</span>)))</span><br><span class=\"line\">\t_ = http.ListenAndServe(<span class=\"string\">\":8080\"</span>, <span class=\"literal\">nil</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n"},{"title":"sort","_content":"\n# sort\n`sort` 包中实现了几种基本的排序算法：插入排序、归并排序、堆排序和快速排序。但是这四种排序方法是不公开的，只用于 `sort` 包\n内部使用。所以在对数据集合排序时不必考虑应当选择哪一种排序方法，只要实现了 `sort.Interface` 定义的三个方法就可以对数据集合进\n行排序。`sort` 包会根据实际数据自动选择高效的排序算法。\n\n```go\ntype Interface interface {\n\t// Len 为集合内元素的总数\n\tLen() int\n\t// 如果 index 为 i 的元素小于 index 为 j 的元素，则返回 true，否则 false\n\tLess(i, j int) bool\n\t// Swap 交换索引为 i 和 j 的元素\n\tSwap(i, j int)\n}\n```\n\n\n为了方便对常用数据类型的操作，`sort` 包原生支持 `[]int`、`[]float64` 和 `[]string` 三种内建数据类型切片的排序操作。\n即不必实现 `sort.Interface` 接口的三个方法。\n\n## 数据集合排序\n\n对数据集合（包括自定义数据类型的集合）排序需要实现 `sort.Interface` 接口的三个方法：\n\n数据集合实现了这三个方法后，即可调用该包的 `Sort()` 方法进行排序。\n`Sort()` 方法定义如下：\n```go\nfunc Sort(data Interface)\n```\n`Sort()` 方法惟一的参数就是待排序的数据集合。\n\n该包还提供了一个方法可以判断数据集合是否已经排好顺序，该方法的内部实现依赖于我们自己实现的 `Len()` 和 `Less()` 方法：\n```go\nfunc IsSorted(data Interface) bool {\n    n := data.Len()\n    for i := n - 1; i > 0; i-- {\n        if data.Less(i, i-1) {\n            return false\n        }\n    }\n    return true\n}\n```\n使用 `sort` 包对学生成绩排序的示例：\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"sort\"\n)\n\n// 学生成绩结构体\ntype StuScore struct {\n    name  string    // 姓名\n    score int   // 成绩\n}\n\ntype StuScores []StuScore\n\nfunc (s StuScores) Len() int {\n\treturn len(s)\n}\n\nfunc (s StuScores) Less(i, j int) bool {\n\treturn s[i].score < s[j].score\n}\n\nfunc (s StuScores) Swap(i, j int) {\n\ts[i], s[j] = s[j], s[i]\n}\n\nfunc main() {\n    students := StuScores{\n        {\"alan\", 95},\n        {\"hikerell\", 91},\n        {\"acmfly\", 96},\n        {\"leao\", 90},\n\t}\n\n\t// 打印未排序的 students 数据\n    fmt.Println(\"Default:\\n\\t\", students)\n    // StuScores 已经实现了 sort.Interface 接口 , 所以可以调用 Sort 函数进行排序\n\tsort.Sort(students)\n\t// 判断是否已经排好顺序\n\tfmt.Println(\"IS Sorted?\\n\\t\", sort.IsSorted(students))\n\t// 打印排序后的 students 数据\n    fmt.Println(\"Sorted:\\n\\t\",students)\n}\n```\n输出：\n```sh\nDefault:\n     [{alan 95} {hikerell 91} {acmfly 96} {leao 90}]\nIS Sorted?\n     true\nSorted:\n     [{leao 90} {hikerell 91} {alan 95} {acmfly 96}]\n```\n\n## Reverse\n\n上面的代码实现的是升序排序，如果要实现降序排序修改 `Less()` 函数：\n```go\n// 将小于号修改为大于号\nfunc (s StuScores) Less(i, j int) bool {\n\treturn s[i].score > s[j].score\n}\n```\n此外，`sort`包提供了 `Reverse()` 方法，可以允许将数据按 `Less()` 定义的排序方式逆序排序，而不必修改 `Less()` 代码。\n```go\nfunc Reverse(data Interface) Interface\n```\n\n`Reverse()` 返回的一个 `sort.Interface` 接口类型，整个 `Reverse()` 的内部实现比较有趣：\n```go\n// 定义了一个 reverse 结构类型，嵌入 Interface 接口\ntype reverse struct {\n    Interface\n}\n\n// reverse 结构类型的 Less() 方法拥有嵌入的 Less() 方法相反的行为\nfunc (r reverse) Less(i, j int) bool {\n    return r.Interface.Less(j, i)\n}\n\n// 返回新的实现 Interface 接口的数据类型\nfunc Reverse(data Interface) Interface {\n    return &reverse{data}\n}\n```\n了解内部原理后，可以在学生成绩排序示例中使用 `Reverse()` 来实现成绩升序排序：\n```go\nsort.Sort(sort.Reverse(students))\nfmt.Println(students)\n```\n\n## Search\n```go\nfunc Search(n int, f func(int) bool) int\n```\n\n`Search()` 函数一个常用的使用方式是搜索元素 x 是否在已经升序排好的切片 s 中：\n\n```go\nx := 11\ns := []int{3, 6, 8, 11, 45} // 已经升序排序的集合\npos := sort.Search(len(s), func(i int) bool { return s[i] >= x })\nif pos < len(s) && s[pos] == x {\n    fmt.Println(x, \" 在 s 中的位置为：\", pos)\n} else {\n    fmt.Println(\"s 不包含元素 \", x)\n}\n```\n\n官方文档给出的小程序：\n\n```go\nfunc GuessingGame() {\n\tvar s string\n\tfmt.Printf(\"Pick an integer from 0 to 100.\\n\")\n\tanswer := sort.Search(100, func(i int) bool {\n\t\tfmt.Printf(\"Is your number <= %d? \", i)\n\t\tfmt.Scanf(\"%s\", &s)\n\t\treturn s != \"\" && s[0] == 'y'\n\t})\n\tfmt.Printf(\"Your number is %d.\\n\", answer)\n}\n```\n\n## 已经支持的内部数据类型排序\n`sort`包原生支持 `[]int`、`[]float64` 和 `[]string` 三种内建数据类型切片的排序操作。\n\n### IntSlice 类型和 []int\n\n`[]int` 切片排序内部实现及使用方法与 `[]float64` 和 `[]string` 类似。\n\n`sort`包定义了一个 `IntSlice` 类型，并且实现了 `sort.Interface` 接口：\n\n```go\n    type IntSlice []int\n    func (p IntSlice) Len() int           { return len(p) }\n    func (p IntSlice) Less(i, j int) bool { return p[i] < p[j] }\n    func (p IntSlice) Swap(i, j int)      { p[i], p[j] = p[j], p[i] }\n    // IntSlice 类型定义了 Sort() 方法，包装了 sort.Sort() 函数\n    func (p IntSlice) Sort() { Sort(p) }\n    // IntSlice 类型定义了 Search() 方法，包装了 SearchInts() 函数\n    func (p IntSlice) Search(x int) int { return SearchInts(p, x) }\n```\n并且提供的 `sort.Ints()` 方法使用了该 `IntSlice` 类型：\n```go\n    func Ints(a []int) { Sort(IntSlice(a)) }\n```\n\n所以，对 `[]int` 切片排序更常使用 `sort.Ints()`，而不是直接使用 `IntSlice` 类型：\n\n```go\ns := []int{5, 2, 6, 3, 1, 4} // 未排序的切片数据\nsort.Ints(s)\nfmt.Println(s) // 将会输出[1 2 3 4 5 6]\n```\n如果要使用降序排序，显然要用前面提到的 Reverse() 方法：\n\n```go\ns := []int{5, 2, 6, 3, 1, 4} // 未排序的切片数据\nsort.Sort(sort.Reverse(sort.IntSlice(s)))\nfmt.Println(s) // 将会输出[6 5 4 3 2 1]\n```\n\n如果要查找整数 `x` 在切片 `a` 中的位置，相对于前面提到的 `Search()` 方法，`sort` 包提供了 `SearchInts()`:\n\n```go\nfunc SearchInts(a []int, x int) int\n```\n注意，`SearchInts()` 的使用条件为：**切片 `a` 已经升序排序**\n以下是一个错误使用的例子：\n\n```go\ns := []int{5, 2, 6, 3, 1, 4} // 未排序的切片数据\nfmt.Println(sort.SearchInts(s, 2)) // 将会输出 0 而不是 1\n```\n\n### Float64Slice 类型及 []float64\n\n实现与 Ints 类似：\n\n```go\ntype Float64Slice []float64\n\nfunc (p Float64Slice) Len() int           { return len(p) }\nfunc (p Float64Slice) Less(i, j int) bool { return p[i] < p[j] || isNaN(p[i]) && !isNaN(p[j]) }\nfunc (p Float64Slice) Swap(i, j int)      { p[i], p[j] = p[j], p[i] }\nfunc (p Float64Slice) Sort() { Sort(p) }\nfunc (p Float64Slice) Search(x float64) int { return SearchFloat64s(p, x) }\n```\n与 `Sort()`、`IsSorted()`、`Search()` 相对应的三个方法：\n\n```go\nfunc Float64s(a []float64)\nfunc Float64sAreSorted(a []float64) bool\nfunc SearchFloat64s(a []float64, x float64) int\n```\n\n在上面 `Float64Slice` 类型定义的 `Less` 方法中，有一个内部函数 `isNaN()`。\n`isNaN()` 与 `math` 包中 `IsNaN()` 实现完全相同，`sort` 包之所以不使用 `math.IsNaN()`，完全是基于包依赖性的考虑，\n`sort` 包的实现不依赖与其他任何包。\n\n### StringSlice 类型及 []string\n\n两个 `string` 对象之间的大小比较是基于“字典序”的。\n\n```go\ntype StringSlice []string\n\nfunc (p StringSlice) Len() int           { return len(p) }\nfunc (p StringSlice) Less(i, j int) bool { return p[i] < p[j] }\nfunc (p StringSlice) Swap(i, j int)      { p[i], p[j] = p[j], p[i] }\nfunc (p StringSlice) Sort() { Sort(p) }\nfunc (p StringSlice) Search(x string) int { return SearchStrings(p, x) }\n```\n\n## []interface 排序与查找\n\n只要实现了 `sort.Interface` 接口，即可通过 `sort` 包内的函数完成排序，查找等操作。但是这种用法对于其它数据类型的 `slice`\n不友好，可能我们需要为大量的 `struct` 定义一个单独的 `[]struct` 类型，再为其实现 `sort.Interface` 接口，例如：\n```go\ntype Person struct {\n    Name string\n    Age  int\n}\ntype Persons []Person\n\nfunc (p Persons) Len() int {\n    panic(\"implement me\")\n}\n\nfunc (p Persons) Less(i, j int) bool {\n    panic(\"implement me\")\n}\n\nfunc (p Persons) Swap(i, j int) {\n    panic(\"implement me\")\n}\n```\n\n`sort` 包提供了以下函数：\n\n```go\nfunc Slice(slice interface{}, less func(i, j int) bool)\nfunc SliceStable(slice interface{}, less func(i, j int) bool)\nfunc SliceIsSorted(slice interface{}, less func(i, j int) bool) bool\nfunc Search(n int, f func(int) bool) int\n```\n排序相关的三个函数都接收 `[]interface`，并且需要传入一个比较函数，用于为程序比较两个变量的大小，因为\n函数签名和作用域的原因，这个函数只能是 `匿名函数`。\n\n### sort.Slice\n利用 `sort.Slice` 函数，而不用提供一个特定的 `sort.Interface` 的实现，而是 `Less(i，j int)` 作为一个比较回调函数，可以简单\n地传递给 `sort.Slice` 进行排序。**不建议使用，因为在 `sort.Slice` 中使用了 `reflect`**。\n\n```go\npeople := []struct {\n    Name string\n    Age  int\n}{\n    {\"Gopher\", 7},\n    {\"Alice\", 55},\n    {\"Vera\", 24},\n    {\"Bob\", 75},\n}\n\nsort.Slice(people, func(i, j int) bool { return people[i].Age < people[j].Age }) // 按年龄升序排序\nfmt.Println(\"Sort by age:\", people)\n\n// Output:\n// Sort by age: [{Gopher 7} {Vera 24} {Alice 55} {Bob 75}]\n```\n\n### sort.Search\n\n该函数判断 `[]interface` 是否存在指定元素，举个栗子：\n\n- 升序 slice\n\n> sort 包为 `[]int`,`[]float64`,`[]string` 提供的 Search 函数其实也是调用的该函数，因为该函数是使用的二分查找法，所以要\n求 slice 为升序排序状态。并且判断条件必须为 `>=`，这也是官方库提供的三个查找相关函数的的写法。\n\n```go\na := []int{2, 3, 4, 200, 100, 21, 234, 56}\nx := 21\n\nsort.Slice(a, func(i, j int) bool { return a[i] < a[j] })   // 升序排序\nindex := sort.Search(len(a), func(i int) bool { return a[i] >= x }) // 查找元素\n\nif index < len(a) && a[index] == x {\n    fmt.Printf(\"found %d at index %d in %v\\n\", x, index, a)\n} else {\n    fmt.Printf(\"%d not found in %v,index:%d\\n\", x, a, index)\n}\n\n// Output:\n// found 21 at index 3 in [2 3 4 21 56 100 200 234]\n```\n\n","source":"standards/data/sort.md","raw":"---\ntitle: sort\n---\n\n# sort\n`sort` 包中实现了几种基本的排序算法：插入排序、归并排序、堆排序和快速排序。但是这四种排序方法是不公开的，只用于 `sort` 包\n内部使用。所以在对数据集合排序时不必考虑应当选择哪一种排序方法，只要实现了 `sort.Interface` 定义的三个方法就可以对数据集合进\n行排序。`sort` 包会根据实际数据自动选择高效的排序算法。\n\n```go\ntype Interface interface {\n\t// Len 为集合内元素的总数\n\tLen() int\n\t// 如果 index 为 i 的元素小于 index 为 j 的元素，则返回 true，否则 false\n\tLess(i, j int) bool\n\t// Swap 交换索引为 i 和 j 的元素\n\tSwap(i, j int)\n}\n```\n\n\n为了方便对常用数据类型的操作，`sort` 包原生支持 `[]int`、`[]float64` 和 `[]string` 三种内建数据类型切片的排序操作。\n即不必实现 `sort.Interface` 接口的三个方法。\n\n## 数据集合排序\n\n对数据集合（包括自定义数据类型的集合）排序需要实现 `sort.Interface` 接口的三个方法：\n\n数据集合实现了这三个方法后，即可调用该包的 `Sort()` 方法进行排序。\n`Sort()` 方法定义如下：\n```go\nfunc Sort(data Interface)\n```\n`Sort()` 方法惟一的参数就是待排序的数据集合。\n\n该包还提供了一个方法可以判断数据集合是否已经排好顺序，该方法的内部实现依赖于我们自己实现的 `Len()` 和 `Less()` 方法：\n```go\nfunc IsSorted(data Interface) bool {\n    n := data.Len()\n    for i := n - 1; i > 0; i-- {\n        if data.Less(i, i-1) {\n            return false\n        }\n    }\n    return true\n}\n```\n使用 `sort` 包对学生成绩排序的示例：\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"sort\"\n)\n\n// 学生成绩结构体\ntype StuScore struct {\n    name  string    // 姓名\n    score int   // 成绩\n}\n\ntype StuScores []StuScore\n\nfunc (s StuScores) Len() int {\n\treturn len(s)\n}\n\nfunc (s StuScores) Less(i, j int) bool {\n\treturn s[i].score < s[j].score\n}\n\nfunc (s StuScores) Swap(i, j int) {\n\ts[i], s[j] = s[j], s[i]\n}\n\nfunc main() {\n    students := StuScores{\n        {\"alan\", 95},\n        {\"hikerell\", 91},\n        {\"acmfly\", 96},\n        {\"leao\", 90},\n\t}\n\n\t// 打印未排序的 students 数据\n    fmt.Println(\"Default:\\n\\t\", students)\n    // StuScores 已经实现了 sort.Interface 接口 , 所以可以调用 Sort 函数进行排序\n\tsort.Sort(students)\n\t// 判断是否已经排好顺序\n\tfmt.Println(\"IS Sorted?\\n\\t\", sort.IsSorted(students))\n\t// 打印排序后的 students 数据\n    fmt.Println(\"Sorted:\\n\\t\",students)\n}\n```\n输出：\n```sh\nDefault:\n     [{alan 95} {hikerell 91} {acmfly 96} {leao 90}]\nIS Sorted?\n     true\nSorted:\n     [{leao 90} {hikerell 91} {alan 95} {acmfly 96}]\n```\n\n## Reverse\n\n上面的代码实现的是升序排序，如果要实现降序排序修改 `Less()` 函数：\n```go\n// 将小于号修改为大于号\nfunc (s StuScores) Less(i, j int) bool {\n\treturn s[i].score > s[j].score\n}\n```\n此外，`sort`包提供了 `Reverse()` 方法，可以允许将数据按 `Less()` 定义的排序方式逆序排序，而不必修改 `Less()` 代码。\n```go\nfunc Reverse(data Interface) Interface\n```\n\n`Reverse()` 返回的一个 `sort.Interface` 接口类型，整个 `Reverse()` 的内部实现比较有趣：\n```go\n// 定义了一个 reverse 结构类型，嵌入 Interface 接口\ntype reverse struct {\n    Interface\n}\n\n// reverse 结构类型的 Less() 方法拥有嵌入的 Less() 方法相反的行为\nfunc (r reverse) Less(i, j int) bool {\n    return r.Interface.Less(j, i)\n}\n\n// 返回新的实现 Interface 接口的数据类型\nfunc Reverse(data Interface) Interface {\n    return &reverse{data}\n}\n```\n了解内部原理后，可以在学生成绩排序示例中使用 `Reverse()` 来实现成绩升序排序：\n```go\nsort.Sort(sort.Reverse(students))\nfmt.Println(students)\n```\n\n## Search\n```go\nfunc Search(n int, f func(int) bool) int\n```\n\n`Search()` 函数一个常用的使用方式是搜索元素 x 是否在已经升序排好的切片 s 中：\n\n```go\nx := 11\ns := []int{3, 6, 8, 11, 45} // 已经升序排序的集合\npos := sort.Search(len(s), func(i int) bool { return s[i] >= x })\nif pos < len(s) && s[pos] == x {\n    fmt.Println(x, \" 在 s 中的位置为：\", pos)\n} else {\n    fmt.Println(\"s 不包含元素 \", x)\n}\n```\n\n官方文档给出的小程序：\n\n```go\nfunc GuessingGame() {\n\tvar s string\n\tfmt.Printf(\"Pick an integer from 0 to 100.\\n\")\n\tanswer := sort.Search(100, func(i int) bool {\n\t\tfmt.Printf(\"Is your number <= %d? \", i)\n\t\tfmt.Scanf(\"%s\", &s)\n\t\treturn s != \"\" && s[0] == 'y'\n\t})\n\tfmt.Printf(\"Your number is %d.\\n\", answer)\n}\n```\n\n## 已经支持的内部数据类型排序\n`sort`包原生支持 `[]int`、`[]float64` 和 `[]string` 三种内建数据类型切片的排序操作。\n\n### IntSlice 类型和 []int\n\n`[]int` 切片排序内部实现及使用方法与 `[]float64` 和 `[]string` 类似。\n\n`sort`包定义了一个 `IntSlice` 类型，并且实现了 `sort.Interface` 接口：\n\n```go\n    type IntSlice []int\n    func (p IntSlice) Len() int           { return len(p) }\n    func (p IntSlice) Less(i, j int) bool { return p[i] < p[j] }\n    func (p IntSlice) Swap(i, j int)      { p[i], p[j] = p[j], p[i] }\n    // IntSlice 类型定义了 Sort() 方法，包装了 sort.Sort() 函数\n    func (p IntSlice) Sort() { Sort(p) }\n    // IntSlice 类型定义了 Search() 方法，包装了 SearchInts() 函数\n    func (p IntSlice) Search(x int) int { return SearchInts(p, x) }\n```\n并且提供的 `sort.Ints()` 方法使用了该 `IntSlice` 类型：\n```go\n    func Ints(a []int) { Sort(IntSlice(a)) }\n```\n\n所以，对 `[]int` 切片排序更常使用 `sort.Ints()`，而不是直接使用 `IntSlice` 类型：\n\n```go\ns := []int{5, 2, 6, 3, 1, 4} // 未排序的切片数据\nsort.Ints(s)\nfmt.Println(s) // 将会输出[1 2 3 4 5 6]\n```\n如果要使用降序排序，显然要用前面提到的 Reverse() 方法：\n\n```go\ns := []int{5, 2, 6, 3, 1, 4} // 未排序的切片数据\nsort.Sort(sort.Reverse(sort.IntSlice(s)))\nfmt.Println(s) // 将会输出[6 5 4 3 2 1]\n```\n\n如果要查找整数 `x` 在切片 `a` 中的位置，相对于前面提到的 `Search()` 方法，`sort` 包提供了 `SearchInts()`:\n\n```go\nfunc SearchInts(a []int, x int) int\n```\n注意，`SearchInts()` 的使用条件为：**切片 `a` 已经升序排序**\n以下是一个错误使用的例子：\n\n```go\ns := []int{5, 2, 6, 3, 1, 4} // 未排序的切片数据\nfmt.Println(sort.SearchInts(s, 2)) // 将会输出 0 而不是 1\n```\n\n### Float64Slice 类型及 []float64\n\n实现与 Ints 类似：\n\n```go\ntype Float64Slice []float64\n\nfunc (p Float64Slice) Len() int           { return len(p) }\nfunc (p Float64Slice) Less(i, j int) bool { return p[i] < p[j] || isNaN(p[i]) && !isNaN(p[j]) }\nfunc (p Float64Slice) Swap(i, j int)      { p[i], p[j] = p[j], p[i] }\nfunc (p Float64Slice) Sort() { Sort(p) }\nfunc (p Float64Slice) Search(x float64) int { return SearchFloat64s(p, x) }\n```\n与 `Sort()`、`IsSorted()`、`Search()` 相对应的三个方法：\n\n```go\nfunc Float64s(a []float64)\nfunc Float64sAreSorted(a []float64) bool\nfunc SearchFloat64s(a []float64, x float64) int\n```\n\n在上面 `Float64Slice` 类型定义的 `Less` 方法中，有一个内部函数 `isNaN()`。\n`isNaN()` 与 `math` 包中 `IsNaN()` 实现完全相同，`sort` 包之所以不使用 `math.IsNaN()`，完全是基于包依赖性的考虑，\n`sort` 包的实现不依赖与其他任何包。\n\n### StringSlice 类型及 []string\n\n两个 `string` 对象之间的大小比较是基于“字典序”的。\n\n```go\ntype StringSlice []string\n\nfunc (p StringSlice) Len() int           { return len(p) }\nfunc (p StringSlice) Less(i, j int) bool { return p[i] < p[j] }\nfunc (p StringSlice) Swap(i, j int)      { p[i], p[j] = p[j], p[i] }\nfunc (p StringSlice) Sort() { Sort(p) }\nfunc (p StringSlice) Search(x string) int { return SearchStrings(p, x) }\n```\n\n## []interface 排序与查找\n\n只要实现了 `sort.Interface` 接口，即可通过 `sort` 包内的函数完成排序，查找等操作。但是这种用法对于其它数据类型的 `slice`\n不友好，可能我们需要为大量的 `struct` 定义一个单独的 `[]struct` 类型，再为其实现 `sort.Interface` 接口，例如：\n```go\ntype Person struct {\n    Name string\n    Age  int\n}\ntype Persons []Person\n\nfunc (p Persons) Len() int {\n    panic(\"implement me\")\n}\n\nfunc (p Persons) Less(i, j int) bool {\n    panic(\"implement me\")\n}\n\nfunc (p Persons) Swap(i, j int) {\n    panic(\"implement me\")\n}\n```\n\n`sort` 包提供了以下函数：\n\n```go\nfunc Slice(slice interface{}, less func(i, j int) bool)\nfunc SliceStable(slice interface{}, less func(i, j int) bool)\nfunc SliceIsSorted(slice interface{}, less func(i, j int) bool) bool\nfunc Search(n int, f func(int) bool) int\n```\n排序相关的三个函数都接收 `[]interface`，并且需要传入一个比较函数，用于为程序比较两个变量的大小，因为\n函数签名和作用域的原因，这个函数只能是 `匿名函数`。\n\n### sort.Slice\n利用 `sort.Slice` 函数，而不用提供一个特定的 `sort.Interface` 的实现，而是 `Less(i，j int)` 作为一个比较回调函数，可以简单\n地传递给 `sort.Slice` 进行排序。**不建议使用，因为在 `sort.Slice` 中使用了 `reflect`**。\n\n```go\npeople := []struct {\n    Name string\n    Age  int\n}{\n    {\"Gopher\", 7},\n    {\"Alice\", 55},\n    {\"Vera\", 24},\n    {\"Bob\", 75},\n}\n\nsort.Slice(people, func(i, j int) bool { return people[i].Age < people[j].Age }) // 按年龄升序排序\nfmt.Println(\"Sort by age:\", people)\n\n// Output:\n// Sort by age: [{Gopher 7} {Vera 24} {Alice 55} {Bob 75}]\n```\n\n### sort.Search\n\n该函数判断 `[]interface` 是否存在指定元素，举个栗子：\n\n- 升序 slice\n\n> sort 包为 `[]int`,`[]float64`,`[]string` 提供的 Search 函数其实也是调用的该函数，因为该函数是使用的二分查找法，所以要\n求 slice 为升序排序状态。并且判断条件必须为 `>=`，这也是官方库提供的三个查找相关函数的的写法。\n\n```go\na := []int{2, 3, 4, 200, 100, 21, 234, 56}\nx := 21\n\nsort.Slice(a, func(i, j int) bool { return a[i] < a[j] })   // 升序排序\nindex := sort.Search(len(a), func(i int) bool { return a[i] >= x }) // 查找元素\n\nif index < len(a) && a[index] == x {\n    fmt.Printf(\"found %d at index %d in %v\\n\", x, index, a)\n} else {\n    fmt.Printf(\"%d not found in %v,index:%d\\n\", x, a, index)\n}\n\n// Output:\n// found 21 at index 3 in [2 3 4 21 56 100 200 234]\n```\n\n","date":"2019-09-01T10:04:56.992Z","updated":"2019-09-01T10:04:56.939Z","path":"standards/data/sort.html","comments":1,"layout":"page","_id":"ck1xm14lu001ffcw2y5gn7ygt","content":"<h1 id=\"sort\"><a href=\"#sort\" class=\"headerlink\" title=\"sort\"></a>sort</h1><p><code>sort</code> 包中实现了几种基本的排序算法：插入排序、归并排序、堆排序和快速排序。但是这四种排序方法是不公开的，只用于 <code>sort</code> 包<br>内部使用。所以在对数据集合排序时不必考虑应当选择哪一种排序方法，只要实现了 <code>sort.Interface</code> 定义的三个方法就可以对数据集合进<br>行排序。<code>sort</code> 包会根据实际数据自动选择高效的排序算法。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Interface <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// Len 为集合内元素的总数</span></span><br><span class=\"line\">\tLen() <span class=\"keyword\">int</span></span><br><span class=\"line\">\t<span class=\"comment\">// 如果 index 为 i 的元素小于 index 为 j 的元素，则返回 true，否则 false</span></span><br><span class=\"line\">\tLess(i, j <span class=\"keyword\">int</span>) <span class=\"keyword\">bool</span></span><br><span class=\"line\">\t<span class=\"comment\">// Swap 交换索引为 i 和 j 的元素</span></span><br><span class=\"line\">\tSwap(i, j <span class=\"keyword\">int</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>为了方便对常用数据类型的操作，<code>sort</code> 包原生支持 <code>[]int</code>、<code>[]float64</code> 和 <code>[]string</code> 三种内建数据类型切片的排序操作。<br>即不必实现 <code>sort.Interface</code> 接口的三个方法。</p>\n<h2 id=\"数据集合排序\"><a href=\"#数据集合排序\" class=\"headerlink\" title=\"数据集合排序\"></a>数据集合排序</h2><p>对数据集合（包括自定义数据类型的集合）排序需要实现 <code>sort.Interface</code> 接口的三个方法：</p>\n<p>数据集合实现了这三个方法后，即可调用该包的 <code>Sort()</code> 方法进行排序。<br><code>Sort()</code> 方法定义如下：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Sort</span><span class=\"params\">(data Interface)</span></span></span><br></pre></td></tr></table></figure></p>\n<p><code>Sort()</code> 方法惟一的参数就是待排序的数据集合。</p>\n<p>该包还提供了一个方法可以判断数据集合是否已经排好顺序，该方法的内部实现依赖于我们自己实现的 <code>Len()</code> 和 <code>Less()</code> 方法：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">IsSorted</span><span class=\"params\">(data Interface)</span> <span class=\"title\">bool</span></span> &#123;</span><br><span class=\"line\">    n := data.Len()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := n - <span class=\"number\">1</span>; i &gt; <span class=\"number\">0</span>; i-- &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> data.Less(i, i<span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>使用 <code>sort</code> 包对学生成绩排序的示例：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">\"fmt\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"sort\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 学生成绩结构体</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> StuScore <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    name  <span class=\"keyword\">string</span>    <span class=\"comment\">// 姓名</span></span><br><span class=\"line\">    score <span class=\"keyword\">int</span>   <span class=\"comment\">// 成绩</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> StuScores []StuScore</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(s StuScores)</span> <span class=\"title\">Len</span><span class=\"params\">()</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"built_in\">len</span>(s)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(s StuScores)</span> <span class=\"title\">Less</span><span class=\"params\">(i, j <span class=\"keyword\">int</span>)</span> <span class=\"title\">bool</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> s[i].score &lt; s[j].score</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(s StuScores)</span> <span class=\"title\">Swap</span><span class=\"params\">(i, j <span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">\ts[i], s[j] = s[j], s[i]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    students := StuScores&#123;</span><br><span class=\"line\">        &#123;<span class=\"string\">\"alan\"</span>, <span class=\"number\">95</span>&#125;,</span><br><span class=\"line\">        &#123;<span class=\"string\">\"hikerell\"</span>, <span class=\"number\">91</span>&#125;,</span><br><span class=\"line\">        &#123;<span class=\"string\">\"acmfly\"</span>, <span class=\"number\">96</span>&#125;,</span><br><span class=\"line\">        &#123;<span class=\"string\">\"leao\"</span>, <span class=\"number\">90</span>&#125;,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 打印未排序的 students 数据</span></span><br><span class=\"line\">    fmt.Println(<span class=\"string\">\"Default:\\n\\t\"</span>, students)</span><br><span class=\"line\">    <span class=\"comment\">// StuScores 已经实现了 sort.Interface 接口 , 所以可以调用 Sort 函数进行排序</span></span><br><span class=\"line\">\tsort.Sort(students)</span><br><span class=\"line\">\t<span class=\"comment\">// 判断是否已经排好顺序</span></span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">\"IS Sorted?\\n\\t\"</span>, sort.IsSorted(students))</span><br><span class=\"line\">\t<span class=\"comment\">// 打印排序后的 students 数据</span></span><br><span class=\"line\">    fmt.Println(<span class=\"string\">\"Sorted:\\n\\t\"</span>,students)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出：<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Default:</span><br><span class=\"line\">     [&#123;alan 95&#125; &#123;hikerell 91&#125; &#123;acmfly 96&#125; &#123;leao 90&#125;]</span><br><span class=\"line\">IS Sorted?</span><br><span class=\"line\">     <span class=\"literal\">true</span></span><br><span class=\"line\">Sorted:</span><br><span class=\"line\">     [&#123;leao 90&#125; &#123;hikerell 91&#125; &#123;alan 95&#125; &#123;acmfly 96&#125;]</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Reverse\"><a href=\"#Reverse\" class=\"headerlink\" title=\"Reverse\"></a>Reverse</h2><p>上面的代码实现的是升序排序，如果要实现降序排序修改 <code>Less()</code> 函数：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 将小于号修改为大于号</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(s StuScores)</span> <span class=\"title\">Less</span><span class=\"params\">(i, j <span class=\"keyword\">int</span>)</span> <span class=\"title\">bool</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> s[i].score &gt; s[j].score</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>此外，<code>sort</code>包提供了 <code>Reverse()</code> 方法，可以允许将数据按 <code>Less()</code> 定义的排序方式逆序排序，而不必修改 <code>Less()</code> 代码。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Reverse</span><span class=\"params\">(data Interface)</span> <span class=\"title\">Interface</span></span></span><br></pre></td></tr></table></figure></p>\n<p><code>Reverse()</code> 返回的一个 <code>sort.Interface</code> 接口类型，整个 <code>Reverse()</code> 的内部实现比较有趣：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义了一个 reverse 结构类型，嵌入 Interface 接口</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> reverse <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    Interface</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// reverse 结构类型的 Less() 方法拥有嵌入的 Less() 方法相反的行为</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(r reverse)</span> <span class=\"title\">Less</span><span class=\"params\">(i, j <span class=\"keyword\">int</span>)</span> <span class=\"title\">bool</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> r.Interface.Less(j, i)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 返回新的实现 Interface 接口的数据类型</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Reverse</span><span class=\"params\">(data Interface)</span> <span class=\"title\">Interface</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &amp;reverse&#123;data&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>了解内部原理后，可以在学生成绩排序示例中使用 <code>Reverse()</code> 来实现成绩升序排序：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sort.Sort(sort.Reverse(students))</span><br><span class=\"line\">fmt.Println(students)</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Search\"><a href=\"#Search\" class=\"headerlink\" title=\"Search\"></a>Search</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Search</span><span class=\"params\">(n <span class=\"keyword\">int</span>, f <span class=\"keyword\">func</span>(<span class=\"keyword\">int</span>)</span> <span class=\"title\">bool</span>) <span class=\"title\">int</span></span></span><br></pre></td></tr></table></figure>\n<p><code>Search()</code> 函数一个常用的使用方式是搜索元素 x 是否在已经升序排好的切片 s 中：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x := <span class=\"number\">11</span></span><br><span class=\"line\">s := []<span class=\"keyword\">int</span>&#123;<span class=\"number\">3</span>, <span class=\"number\">6</span>, <span class=\"number\">8</span>, <span class=\"number\">11</span>, <span class=\"number\">45</span>&#125; <span class=\"comment\">// 已经升序排序的集合</span></span><br><span class=\"line\">pos := sort.Search(<span class=\"built_in\">len</span>(s), <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(i <span class=\"keyword\">int</span>)</span> <span class=\"title\">bool</span></span> &#123; <span class=\"keyword\">return</span> s[i] &gt;= x &#125;)</span><br><span class=\"line\"><span class=\"keyword\">if</span> pos &lt; <span class=\"built_in\">len</span>(s) &amp;&amp; s[pos] == x &#123;</span><br><span class=\"line\">    fmt.Println(x, <span class=\"string\">\" 在 s 中的位置为：\"</span>, pos)</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    fmt.Println(<span class=\"string\">\"s 不包含元素 \"</span>, x)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>官方文档给出的小程序：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">GuessingGame</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> s <span class=\"keyword\">string</span></span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"Pick an integer from 0 to 100.\\n\"</span>)</span><br><span class=\"line\">\tanswer := sort.Search(<span class=\"number\">100</span>, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(i <span class=\"keyword\">int</span>)</span> <span class=\"title\">bool</span></span> &#123;</span><br><span class=\"line\">\t\tfmt.Printf(<span class=\"string\">\"Is your number &lt;= %d? \"</span>, i)</span><br><span class=\"line\">\t\tfmt.Scanf(<span class=\"string\">\"%s\"</span>, &amp;s)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> s != <span class=\"string\">\"\"</span> &amp;&amp; s[<span class=\"number\">0</span>] == <span class=\"string\">'y'</span></span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"Your number is %d.\\n\"</span>, answer)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"已经支持的内部数据类型排序\"><a href=\"#已经支持的内部数据类型排序\" class=\"headerlink\" title=\"已经支持的内部数据类型排序\"></a>已经支持的内部数据类型排序</h2><p><code>sort</code>包原生支持 <code>[]int</code>、<code>[]float64</code> 和 <code>[]string</code> 三种内建数据类型切片的排序操作。</p>\n<h3 id=\"IntSlice-类型和-int\"><a href=\"#IntSlice-类型和-int\" class=\"headerlink\" title=\"IntSlice 类型和 []int\"></a>IntSlice 类型和 []int</h3><p><code>[]int</code> 切片排序内部实现及使用方法与 <code>[]float64</code> 和 <code>[]string</code> 类似。</p>\n<p><code>sort</code>包定义了一个 <code>IntSlice</code> 类型，并且实现了 <code>sort.Interface</code> 接口：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> IntSlice []<span class=\"keyword\">int</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p IntSlice)</span> <span class=\"title\">Len</span><span class=\"params\">()</span> <span class=\"title\">int</span></span>           &#123; <span class=\"keyword\">return</span> <span class=\"built_in\">len</span>(p) &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p IntSlice)</span> <span class=\"title\">Less</span><span class=\"params\">(i, j <span class=\"keyword\">int</span>)</span> <span class=\"title\">bool</span></span> &#123; <span class=\"keyword\">return</span> p[i] &lt; p[j] &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p IntSlice)</span> <span class=\"title\">Swap</span><span class=\"params\">(i, j <span class=\"keyword\">int</span>)</span></span>      &#123; p[i], p[j] = p[j], p[i] &#125;</span><br><span class=\"line\"><span class=\"comment\">// IntSlice 类型定义了 Sort() 方法，包装了 sort.Sort() 函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p IntSlice)</span> <span class=\"title\">Sort</span><span class=\"params\">()</span></span> &#123; Sort(p) &#125;</span><br><span class=\"line\"><span class=\"comment\">// IntSlice 类型定义了 Search() 方法，包装了 SearchInts() 函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p IntSlice)</span> <span class=\"title\">Search</span><span class=\"params\">(x <span class=\"keyword\">int</span>)</span> <span class=\"title\">int</span></span> &#123; <span class=\"keyword\">return</span> SearchInts(p, x) &#125;</span><br></pre></td></tr></table></figure>\n<p>并且提供的 <code>sort.Ints()</code> 方法使用了该 <code>IntSlice</code> 类型：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Ints</span><span class=\"params\">(a []<span class=\"keyword\">int</span>)</span></span> &#123; Sort(IntSlice(a)) &#125;</span><br></pre></td></tr></table></figure></p>\n<p>所以，对 <code>[]int</code> 切片排序更常使用 <code>sort.Ints()</code>，而不是直接使用 <code>IntSlice</code> 类型：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s := []<span class=\"keyword\">int</span>&#123;<span class=\"number\">5</span>, <span class=\"number\">2</span>, <span class=\"number\">6</span>, <span class=\"number\">3</span>, <span class=\"number\">1</span>, <span class=\"number\">4</span>&#125; <span class=\"comment\">// 未排序的切片数据</span></span><br><span class=\"line\">sort.Ints(s)</span><br><span class=\"line\">fmt.Println(s) <span class=\"comment\">// 将会输出[1 2 3 4 5 6]</span></span><br></pre></td></tr></table></figure>\n<p>如果要使用降序排序，显然要用前面提到的 Reverse() 方法：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s := []<span class=\"keyword\">int</span>&#123;<span class=\"number\">5</span>, <span class=\"number\">2</span>, <span class=\"number\">6</span>, <span class=\"number\">3</span>, <span class=\"number\">1</span>, <span class=\"number\">4</span>&#125; <span class=\"comment\">// 未排序的切片数据</span></span><br><span class=\"line\">sort.Sort(sort.Reverse(sort.IntSlice(s)))</span><br><span class=\"line\">fmt.Println(s) <span class=\"comment\">// 将会输出[6 5 4 3 2 1]</span></span><br></pre></td></tr></table></figure>\n<p>如果要查找整数 <code>x</code> 在切片 <code>a</code> 中的位置，相对于前面提到的 <code>Search()</code> 方法，<code>sort</code> 包提供了 <code>SearchInts()</code>:</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">SearchInts</span><span class=\"params\">(a []<span class=\"keyword\">int</span>, x <span class=\"keyword\">int</span>)</span> <span class=\"title\">int</span></span></span><br></pre></td></tr></table></figure>\n<p>注意，<code>SearchInts()</code> 的使用条件为：<strong>切片 <code>a</code> 已经升序排序</strong><br>以下是一个错误使用的例子：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s := []<span class=\"keyword\">int</span>&#123;<span class=\"number\">5</span>, <span class=\"number\">2</span>, <span class=\"number\">6</span>, <span class=\"number\">3</span>, <span class=\"number\">1</span>, <span class=\"number\">4</span>&#125; <span class=\"comment\">// 未排序的切片数据</span></span><br><span class=\"line\">fmt.Println(sort.SearchInts(s, <span class=\"number\">2</span>)) <span class=\"comment\">// 将会输出 0 而不是 1</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"Float64Slice-类型及-float64\"><a href=\"#Float64Slice-类型及-float64\" class=\"headerlink\" title=\"Float64Slice 类型及 []float64\"></a>Float64Slice 类型及 []float64</h3><p>实现与 Ints 类似：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Float64Slice []<span class=\"keyword\">float64</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p Float64Slice)</span> <span class=\"title\">Len</span><span class=\"params\">()</span> <span class=\"title\">int</span></span>           &#123; <span class=\"keyword\">return</span> <span class=\"built_in\">len</span>(p) &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p Float64Slice)</span> <span class=\"title\">Less</span><span class=\"params\">(i, j <span class=\"keyword\">int</span>)</span> <span class=\"title\">bool</span></span> &#123; <span class=\"keyword\">return</span> p[i] &lt; p[j] || isNaN(p[i]) &amp;&amp; !isNaN(p[j]) &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p Float64Slice)</span> <span class=\"title\">Swap</span><span class=\"params\">(i, j <span class=\"keyword\">int</span>)</span></span>      &#123; p[i], p[j] = p[j], p[i] &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p Float64Slice)</span> <span class=\"title\">Sort</span><span class=\"params\">()</span></span> &#123; Sort(p) &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p Float64Slice)</span> <span class=\"title\">Search</span><span class=\"params\">(x <span class=\"keyword\">float64</span>)</span> <span class=\"title\">int</span></span> &#123; <span class=\"keyword\">return</span> SearchFloat64s(p, x) &#125;</span><br></pre></td></tr></table></figure>\n<p>与 <code>Sort()</code>、<code>IsSorted()</code>、<code>Search()</code> 相对应的三个方法：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Float64s</span><span class=\"params\">(a []<span class=\"keyword\">float64</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">Float64sAreSorted</span><span class=\"params\">(a []<span class=\"keyword\">float64</span>)</span> <span class=\"title\">bool</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">SearchFloat64s</span><span class=\"params\">(a []<span class=\"keyword\">float64</span>, x <span class=\"keyword\">float64</span>)</span> <span class=\"title\">int</span></span></span><br></pre></td></tr></table></figure>\n<p>在上面 <code>Float64Slice</code> 类型定义的 <code>Less</code> 方法中，有一个内部函数 <code>isNaN()</code>。<br><code>isNaN()</code> 与 <code>math</code> 包中 <code>IsNaN()</code> 实现完全相同，<code>sort</code> 包之所以不使用 <code>math.IsNaN()</code>，完全是基于包依赖性的考虑，<br><code>sort</code> 包的实现不依赖与其他任何包。</p>\n<h3 id=\"StringSlice-类型及-string\"><a href=\"#StringSlice-类型及-string\" class=\"headerlink\" title=\"StringSlice 类型及 []string\"></a>StringSlice 类型及 []string</h3><p>两个 <code>string</code> 对象之间的大小比较是基于“字典序”的。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> StringSlice []<span class=\"keyword\">string</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p StringSlice)</span> <span class=\"title\">Len</span><span class=\"params\">()</span> <span class=\"title\">int</span></span>           &#123; <span class=\"keyword\">return</span> <span class=\"built_in\">len</span>(p) &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p StringSlice)</span> <span class=\"title\">Less</span><span class=\"params\">(i, j <span class=\"keyword\">int</span>)</span> <span class=\"title\">bool</span></span> &#123; <span class=\"keyword\">return</span> p[i] &lt; p[j] &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p StringSlice)</span> <span class=\"title\">Swap</span><span class=\"params\">(i, j <span class=\"keyword\">int</span>)</span></span>      &#123; p[i], p[j] = p[j], p[i] &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p StringSlice)</span> <span class=\"title\">Sort</span><span class=\"params\">()</span></span> &#123; Sort(p) &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p StringSlice)</span> <span class=\"title\">Search</span><span class=\"params\">(x <span class=\"keyword\">string</span>)</span> <span class=\"title\">int</span></span> &#123; <span class=\"keyword\">return</span> SearchStrings(p, x) &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"interface-排序与查找\"><a href=\"#interface-排序与查找\" class=\"headerlink\" title=\"[]interface 排序与查找\"></a>[]interface 排序与查找</h2><p>只要实现了 <code>sort.Interface</code> 接口，即可通过 <code>sort</code> 包内的函数完成排序，查找等操作。但是这种用法对于其它数据类型的 <code>slice</code><br>不友好，可能我们需要为大量的 <code>struct</code> 定义一个单独的 <code>[]struct</code> 类型，再为其实现 <code>sort.Interface</code> 接口，例如：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Person <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    Name <span class=\"keyword\">string</span></span><br><span class=\"line\">    Age  <span class=\"keyword\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">type</span> Persons []Person</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p Persons)</span> <span class=\"title\">Len</span><span class=\"params\">()</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">panic</span>(<span class=\"string\">\"implement me\"</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p Persons)</span> <span class=\"title\">Less</span><span class=\"params\">(i, j <span class=\"keyword\">int</span>)</span> <span class=\"title\">bool</span></span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">panic</span>(<span class=\"string\">\"implement me\"</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p Persons)</span> <span class=\"title\">Swap</span><span class=\"params\">(i, j <span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">panic</span>(<span class=\"string\">\"implement me\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>sort</code> 包提供了以下函数：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Slice</span><span class=\"params\">(slice <span class=\"keyword\">interface</span>&#123;&#125;, less <span class=\"keyword\">func</span>(i, j <span class=\"keyword\">int</span>)</span> <span class=\"title\">bool</span>)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">SliceStable</span><span class=\"params\">(slice <span class=\"keyword\">interface</span>&#123;&#125;, less <span class=\"keyword\">func</span>(i, j <span class=\"keyword\">int</span>)</span> <span class=\"title\">bool</span>)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">SliceIsSorted</span><span class=\"params\">(slice <span class=\"keyword\">interface</span>&#123;&#125;, less <span class=\"keyword\">func</span>(i, j <span class=\"keyword\">int</span>)</span> <span class=\"title\">bool</span>) <span class=\"title\">bool</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">Search</span><span class=\"params\">(n <span class=\"keyword\">int</span>, f <span class=\"keyword\">func</span>(<span class=\"keyword\">int</span>)</span> <span class=\"title\">bool</span>) <span class=\"title\">int</span></span></span><br></pre></td></tr></table></figure>\n<p>排序相关的三个函数都接收 <code>[]interface</code>，并且需要传入一个比较函数，用于为程序比较两个变量的大小，因为<br>函数签名和作用域的原因，这个函数只能是 <code>匿名函数</code>。</p>\n<h3 id=\"sort-Slice\"><a href=\"#sort-Slice\" class=\"headerlink\" title=\"sort.Slice\"></a>sort.Slice</h3><p>利用 <code>sort.Slice</code> 函数，而不用提供一个特定的 <code>sort.Interface</code> 的实现，而是 <code>Less(i，j int)</code> 作为一个比较回调函数，可以简单<br>地传递给 <code>sort.Slice</code> 进行排序。<strong>不建议使用，因为在 <code>sort.Slice</code> 中使用了 <code>reflect</code></strong>。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">people := []<span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    Name <span class=\"keyword\">string</span></span><br><span class=\"line\">    Age  <span class=\"keyword\">int</span></span><br><span class=\"line\">&#125;&#123;</span><br><span class=\"line\">    &#123;<span class=\"string\">\"Gopher\"</span>, <span class=\"number\">7</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"string\">\"Alice\"</span>, <span class=\"number\">55</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"string\">\"Vera\"</span>, <span class=\"number\">24</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"string\">\"Bob\"</span>, <span class=\"number\">75</span>&#125;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">sort.Slice(people, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(i, j <span class=\"keyword\">int</span>)</span> <span class=\"title\">bool</span></span> &#123; <span class=\"keyword\">return</span> people[i].Age &lt; people[j].Age &#125;) <span class=\"comment\">// 按年龄升序排序</span></span><br><span class=\"line\">fmt.Println(<span class=\"string\">\"Sort by age:\"</span>, people)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Output:</span></span><br><span class=\"line\"><span class=\"comment\">// Sort by age: [&#123;Gopher 7&#125; &#123;Vera 24&#125; &#123;Alice 55&#125; &#123;Bob 75&#125;]</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"sort-Search\"><a href=\"#sort-Search\" class=\"headerlink\" title=\"sort.Search\"></a>sort.Search</h3><p>该函数判断 <code>[]interface</code> 是否存在指定元素，举个栗子：</p>\n<ul>\n<li>升序 slice</li>\n</ul>\n<blockquote>\n<p>sort 包为 <code>[]int</code>,<code>[]float64</code>,<code>[]string</code> 提供的 Search 函数其实也是调用的该函数，因为该函数是使用的二分查找法，所以要<br>求 slice 为升序排序状态。并且判断条件必须为 <code>&gt;=</code>，这也是官方库提供的三个查找相关函数的的写法。</p>\n</blockquote>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a := []<span class=\"keyword\">int</span>&#123;<span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">200</span>, <span class=\"number\">100</span>, <span class=\"number\">21</span>, <span class=\"number\">234</span>, <span class=\"number\">56</span>&#125;</span><br><span class=\"line\">x := <span class=\"number\">21</span></span><br><span class=\"line\"></span><br><span class=\"line\">sort.Slice(a, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(i, j <span class=\"keyword\">int</span>)</span> <span class=\"title\">bool</span></span> &#123; <span class=\"keyword\">return</span> a[i] &lt; a[j] &#125;)   <span class=\"comment\">// 升序排序</span></span><br><span class=\"line\">index := sort.Search(<span class=\"built_in\">len</span>(a), <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(i <span class=\"keyword\">int</span>)</span> <span class=\"title\">bool</span></span> &#123; <span class=\"keyword\">return</span> a[i] &gt;= x &#125;) <span class=\"comment\">// 查找元素</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> index &lt; <span class=\"built_in\">len</span>(a) &amp;&amp; a[index] == x &#123;</span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">\"found %d at index %d in %v\\n\"</span>, x, index, a)</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">\"%d not found in %v,index:%d\\n\"</span>, x, a, index)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Output:</span></span><br><span class=\"line\"><span class=\"comment\">// found 21 at index 3 in [2 3 4 21 56 100 200 234]</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{"navigation":{"logo":{"text":"Golang Learn","type":"link","path":"index.html"},"main":[{"text":"Golang 基础","type":"label"},{"text":"Go 环境配置","type":"link","path":"basic/env_config.html"},{"text":"包","type":"link","path":"basic/package.html"},{"text":"基础数据类型","type":"link","path":"basic/basic_data.html"},{"text":"变量","type":"link","path":"basic/var.html"},{"text":"常量","type":"link","path":"basic/constant.html"},{"text":"控制语句","type":"link","path":"basic/flow.html"},{"text":"运算符","type":"link","path":"basic/operator.html"},{"text":"作用域","type":"link","path":"basic/scope.html"},{"text":"指针","type":"link","path":"basic/pointer.html"},{"text":"数组","type":"link","path":"basic/array.html"},{"text":"切片","type":"link","path":"basic/slice.html"},{"text":"字典","type":"link","path":"basic/map.html"},{"text":"函数","type":"link","path":"basic/function.html"},{"text":"结构体","type":"link","path":"basic/struct.html"},{"text":"接口","type":"link","path":"basic/interface.html"},{"text":"面向对象","type":"link","path":"basic/oop.html"},{"text":"错误","type":"link","path":"basic/error.html"},{"text":"序列化","type":"link","path":"basic/json.html"},{"text":"反射","type":"link","path":"basic/reflect.html"},{"text":"测试","type":"link","path":"basic/test.html"},{"text":"并发编程","type":"label"},{"text":"goroutine","type":"link","path":"concurrent/goroutine.html"},{"text":"channel","type":"link","path":"concurrent/channel.html"},{"text":"同步和锁","type":"link","path":"concurrent/sync_lock.html"},{"text":"内存分配","type":"label"},{"text":"内存分配","type":"link","path":"advance/mm.html"},{"text":"垃圾回收","type":"label"},{"text":"垃圾回收","type":"link","path":"advance/gc.html"},{"text":"标准库","type":"label"},{"text":"fmt","type":"link","path":"standards/io/fmt.html"},{"text":"io","type":"link","path":"standards/io/io.html"},{"text":"ioutil","type":"link","path":"standards/io/ioutil.html"},{"text":"bufio","type":"link","path":"standards/io/bufio.html"},{"text":"os","type":"link","path":"standards/os/os.html"},{"text":"filepath","type":"link","path":"standards/os/filepath.html"},{"text":"strings","type":"link","path":"standards/text/strings.html"},{"text":"strconv","type":"link","path":"standards/text/strconv.html"},{"text":"unicode","type":"link","path":"standards/text/unicode.html"},{"text":"log","type":"link","path":"standards/log.html"},{"text":"time","type":"link","path":"standards/time.html"},{"text":"http","type":"link","path":"standards/net/http.html"},{"text":"math","type":"link","path":"standards/data/math.html"},{"text":"sort","type":"link","path":"standards/data/sort.html"},{"text":"big","type":"link","path":"standards/data/big.html"},{"text":"container","type":"link","path":"standards/data/container.html"},{"text":"sql","type":"link","path":"standards/database/sql.html"},{"text":"THEME","type":"label"},{"text":"使用文档主题","type":"link","path":"theme/theme-usage.html"},{"text":"SUPPORT AND FEEDBACK","type":"label"},{"text":"Raise an Issue on Github","type":"link","path":"https://github.com/shipengqi/golang-learn/issues/new"}]}}},"excerpt":"","more":"<h1 id=\"sort\"><a href=\"#sort\" class=\"headerlink\" title=\"sort\"></a>sort</h1><p><code>sort</code> 包中实现了几种基本的排序算法：插入排序、归并排序、堆排序和快速排序。但是这四种排序方法是不公开的，只用于 <code>sort</code> 包<br>内部使用。所以在对数据集合排序时不必考虑应当选择哪一种排序方法，只要实现了 <code>sort.Interface</code> 定义的三个方法就可以对数据集合进<br>行排序。<code>sort</code> 包会根据实际数据自动选择高效的排序算法。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Interface <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// Len 为集合内元素的总数</span></span><br><span class=\"line\">\tLen() <span class=\"keyword\">int</span></span><br><span class=\"line\">\t<span class=\"comment\">// 如果 index 为 i 的元素小于 index 为 j 的元素，则返回 true，否则 false</span></span><br><span class=\"line\">\tLess(i, j <span class=\"keyword\">int</span>) <span class=\"keyword\">bool</span></span><br><span class=\"line\">\t<span class=\"comment\">// Swap 交换索引为 i 和 j 的元素</span></span><br><span class=\"line\">\tSwap(i, j <span class=\"keyword\">int</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>为了方便对常用数据类型的操作，<code>sort</code> 包原生支持 <code>[]int</code>、<code>[]float64</code> 和 <code>[]string</code> 三种内建数据类型切片的排序操作。<br>即不必实现 <code>sort.Interface</code> 接口的三个方法。</p>\n<h2 id=\"数据集合排序\"><a href=\"#数据集合排序\" class=\"headerlink\" title=\"数据集合排序\"></a>数据集合排序</h2><p>对数据集合（包括自定义数据类型的集合）排序需要实现 <code>sort.Interface</code> 接口的三个方法：</p>\n<p>数据集合实现了这三个方法后，即可调用该包的 <code>Sort()</code> 方法进行排序。<br><code>Sort()</code> 方法定义如下：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Sort</span><span class=\"params\">(data Interface)</span></span></span><br></pre></td></tr></table></figure></p>\n<p><code>Sort()</code> 方法惟一的参数就是待排序的数据集合。</p>\n<p>该包还提供了一个方法可以判断数据集合是否已经排好顺序，该方法的内部实现依赖于我们自己实现的 <code>Len()</code> 和 <code>Less()</code> 方法：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">IsSorted</span><span class=\"params\">(data Interface)</span> <span class=\"title\">bool</span></span> &#123;</span><br><span class=\"line\">    n := data.Len()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := n - <span class=\"number\">1</span>; i &gt; <span class=\"number\">0</span>; i-- &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> data.Less(i, i<span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>使用 <code>sort</code> 包对学生成绩排序的示例：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">\"fmt\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"sort\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 学生成绩结构体</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> StuScore <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    name  <span class=\"keyword\">string</span>    <span class=\"comment\">// 姓名</span></span><br><span class=\"line\">    score <span class=\"keyword\">int</span>   <span class=\"comment\">// 成绩</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> StuScores []StuScore</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(s StuScores)</span> <span class=\"title\">Len</span><span class=\"params\">()</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"built_in\">len</span>(s)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(s StuScores)</span> <span class=\"title\">Less</span><span class=\"params\">(i, j <span class=\"keyword\">int</span>)</span> <span class=\"title\">bool</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> s[i].score &lt; s[j].score</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(s StuScores)</span> <span class=\"title\">Swap</span><span class=\"params\">(i, j <span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">\ts[i], s[j] = s[j], s[i]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    students := StuScores&#123;</span><br><span class=\"line\">        &#123;<span class=\"string\">\"alan\"</span>, <span class=\"number\">95</span>&#125;,</span><br><span class=\"line\">        &#123;<span class=\"string\">\"hikerell\"</span>, <span class=\"number\">91</span>&#125;,</span><br><span class=\"line\">        &#123;<span class=\"string\">\"acmfly\"</span>, <span class=\"number\">96</span>&#125;,</span><br><span class=\"line\">        &#123;<span class=\"string\">\"leao\"</span>, <span class=\"number\">90</span>&#125;,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 打印未排序的 students 数据</span></span><br><span class=\"line\">    fmt.Println(<span class=\"string\">\"Default:\\n\\t\"</span>, students)</span><br><span class=\"line\">    <span class=\"comment\">// StuScores 已经实现了 sort.Interface 接口 , 所以可以调用 Sort 函数进行排序</span></span><br><span class=\"line\">\tsort.Sort(students)</span><br><span class=\"line\">\t<span class=\"comment\">// 判断是否已经排好顺序</span></span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">\"IS Sorted?\\n\\t\"</span>, sort.IsSorted(students))</span><br><span class=\"line\">\t<span class=\"comment\">// 打印排序后的 students 数据</span></span><br><span class=\"line\">    fmt.Println(<span class=\"string\">\"Sorted:\\n\\t\"</span>,students)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出：<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Default:</span><br><span class=\"line\">     [&#123;alan 95&#125; &#123;hikerell 91&#125; &#123;acmfly 96&#125; &#123;leao 90&#125;]</span><br><span class=\"line\">IS Sorted?</span><br><span class=\"line\">     <span class=\"literal\">true</span></span><br><span class=\"line\">Sorted:</span><br><span class=\"line\">     [&#123;leao 90&#125; &#123;hikerell 91&#125; &#123;alan 95&#125; &#123;acmfly 96&#125;]</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Reverse\"><a href=\"#Reverse\" class=\"headerlink\" title=\"Reverse\"></a>Reverse</h2><p>上面的代码实现的是升序排序，如果要实现降序排序修改 <code>Less()</code> 函数：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 将小于号修改为大于号</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(s StuScores)</span> <span class=\"title\">Less</span><span class=\"params\">(i, j <span class=\"keyword\">int</span>)</span> <span class=\"title\">bool</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> s[i].score &gt; s[j].score</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>此外，<code>sort</code>包提供了 <code>Reverse()</code> 方法，可以允许将数据按 <code>Less()</code> 定义的排序方式逆序排序，而不必修改 <code>Less()</code> 代码。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Reverse</span><span class=\"params\">(data Interface)</span> <span class=\"title\">Interface</span></span></span><br></pre></td></tr></table></figure></p>\n<p><code>Reverse()</code> 返回的一个 <code>sort.Interface</code> 接口类型，整个 <code>Reverse()</code> 的内部实现比较有趣：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义了一个 reverse 结构类型，嵌入 Interface 接口</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> reverse <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    Interface</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// reverse 结构类型的 Less() 方法拥有嵌入的 Less() 方法相反的行为</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(r reverse)</span> <span class=\"title\">Less</span><span class=\"params\">(i, j <span class=\"keyword\">int</span>)</span> <span class=\"title\">bool</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> r.Interface.Less(j, i)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 返回新的实现 Interface 接口的数据类型</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Reverse</span><span class=\"params\">(data Interface)</span> <span class=\"title\">Interface</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &amp;reverse&#123;data&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>了解内部原理后，可以在学生成绩排序示例中使用 <code>Reverse()</code> 来实现成绩升序排序：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sort.Sort(sort.Reverse(students))</span><br><span class=\"line\">fmt.Println(students)</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Search\"><a href=\"#Search\" class=\"headerlink\" title=\"Search\"></a>Search</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Search</span><span class=\"params\">(n <span class=\"keyword\">int</span>, f <span class=\"keyword\">func</span>(<span class=\"keyword\">int</span>)</span> <span class=\"title\">bool</span>) <span class=\"title\">int</span></span></span><br></pre></td></tr></table></figure>\n<p><code>Search()</code> 函数一个常用的使用方式是搜索元素 x 是否在已经升序排好的切片 s 中：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x := <span class=\"number\">11</span></span><br><span class=\"line\">s := []<span class=\"keyword\">int</span>&#123;<span class=\"number\">3</span>, <span class=\"number\">6</span>, <span class=\"number\">8</span>, <span class=\"number\">11</span>, <span class=\"number\">45</span>&#125; <span class=\"comment\">// 已经升序排序的集合</span></span><br><span class=\"line\">pos := sort.Search(<span class=\"built_in\">len</span>(s), <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(i <span class=\"keyword\">int</span>)</span> <span class=\"title\">bool</span></span> &#123; <span class=\"keyword\">return</span> s[i] &gt;= x &#125;)</span><br><span class=\"line\"><span class=\"keyword\">if</span> pos &lt; <span class=\"built_in\">len</span>(s) &amp;&amp; s[pos] == x &#123;</span><br><span class=\"line\">    fmt.Println(x, <span class=\"string\">\" 在 s 中的位置为：\"</span>, pos)</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    fmt.Println(<span class=\"string\">\"s 不包含元素 \"</span>, x)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>官方文档给出的小程序：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">GuessingGame</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> s <span class=\"keyword\">string</span></span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"Pick an integer from 0 to 100.\\n\"</span>)</span><br><span class=\"line\">\tanswer := sort.Search(<span class=\"number\">100</span>, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(i <span class=\"keyword\">int</span>)</span> <span class=\"title\">bool</span></span> &#123;</span><br><span class=\"line\">\t\tfmt.Printf(<span class=\"string\">\"Is your number &lt;= %d? \"</span>, i)</span><br><span class=\"line\">\t\tfmt.Scanf(<span class=\"string\">\"%s\"</span>, &amp;s)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> s != <span class=\"string\">\"\"</span> &amp;&amp; s[<span class=\"number\">0</span>] == <span class=\"string\">'y'</span></span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"Your number is %d.\\n\"</span>, answer)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"已经支持的内部数据类型排序\"><a href=\"#已经支持的内部数据类型排序\" class=\"headerlink\" title=\"已经支持的内部数据类型排序\"></a>已经支持的内部数据类型排序</h2><p><code>sort</code>包原生支持 <code>[]int</code>、<code>[]float64</code> 和 <code>[]string</code> 三种内建数据类型切片的排序操作。</p>\n<h3 id=\"IntSlice-类型和-int\"><a href=\"#IntSlice-类型和-int\" class=\"headerlink\" title=\"IntSlice 类型和 []int\"></a>IntSlice 类型和 []int</h3><p><code>[]int</code> 切片排序内部实现及使用方法与 <code>[]float64</code> 和 <code>[]string</code> 类似。</p>\n<p><code>sort</code>包定义了一个 <code>IntSlice</code> 类型，并且实现了 <code>sort.Interface</code> 接口：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> IntSlice []<span class=\"keyword\">int</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p IntSlice)</span> <span class=\"title\">Len</span><span class=\"params\">()</span> <span class=\"title\">int</span></span>           &#123; <span class=\"keyword\">return</span> <span class=\"built_in\">len</span>(p) &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p IntSlice)</span> <span class=\"title\">Less</span><span class=\"params\">(i, j <span class=\"keyword\">int</span>)</span> <span class=\"title\">bool</span></span> &#123; <span class=\"keyword\">return</span> p[i] &lt; p[j] &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p IntSlice)</span> <span class=\"title\">Swap</span><span class=\"params\">(i, j <span class=\"keyword\">int</span>)</span></span>      &#123; p[i], p[j] = p[j], p[i] &#125;</span><br><span class=\"line\"><span class=\"comment\">// IntSlice 类型定义了 Sort() 方法，包装了 sort.Sort() 函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p IntSlice)</span> <span class=\"title\">Sort</span><span class=\"params\">()</span></span> &#123; Sort(p) &#125;</span><br><span class=\"line\"><span class=\"comment\">// IntSlice 类型定义了 Search() 方法，包装了 SearchInts() 函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p IntSlice)</span> <span class=\"title\">Search</span><span class=\"params\">(x <span class=\"keyword\">int</span>)</span> <span class=\"title\">int</span></span> &#123; <span class=\"keyword\">return</span> SearchInts(p, x) &#125;</span><br></pre></td></tr></table></figure>\n<p>并且提供的 <code>sort.Ints()</code> 方法使用了该 <code>IntSlice</code> 类型：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Ints</span><span class=\"params\">(a []<span class=\"keyword\">int</span>)</span></span> &#123; Sort(IntSlice(a)) &#125;</span><br></pre></td></tr></table></figure></p>\n<p>所以，对 <code>[]int</code> 切片排序更常使用 <code>sort.Ints()</code>，而不是直接使用 <code>IntSlice</code> 类型：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s := []<span class=\"keyword\">int</span>&#123;<span class=\"number\">5</span>, <span class=\"number\">2</span>, <span class=\"number\">6</span>, <span class=\"number\">3</span>, <span class=\"number\">1</span>, <span class=\"number\">4</span>&#125; <span class=\"comment\">// 未排序的切片数据</span></span><br><span class=\"line\">sort.Ints(s)</span><br><span class=\"line\">fmt.Println(s) <span class=\"comment\">// 将会输出[1 2 3 4 5 6]</span></span><br></pre></td></tr></table></figure>\n<p>如果要使用降序排序，显然要用前面提到的 Reverse() 方法：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s := []<span class=\"keyword\">int</span>&#123;<span class=\"number\">5</span>, <span class=\"number\">2</span>, <span class=\"number\">6</span>, <span class=\"number\">3</span>, <span class=\"number\">1</span>, <span class=\"number\">4</span>&#125; <span class=\"comment\">// 未排序的切片数据</span></span><br><span class=\"line\">sort.Sort(sort.Reverse(sort.IntSlice(s)))</span><br><span class=\"line\">fmt.Println(s) <span class=\"comment\">// 将会输出[6 5 4 3 2 1]</span></span><br></pre></td></tr></table></figure>\n<p>如果要查找整数 <code>x</code> 在切片 <code>a</code> 中的位置，相对于前面提到的 <code>Search()</code> 方法，<code>sort</code> 包提供了 <code>SearchInts()</code>:</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">SearchInts</span><span class=\"params\">(a []<span class=\"keyword\">int</span>, x <span class=\"keyword\">int</span>)</span> <span class=\"title\">int</span></span></span><br></pre></td></tr></table></figure>\n<p>注意，<code>SearchInts()</code> 的使用条件为：<strong>切片 <code>a</code> 已经升序排序</strong><br>以下是一个错误使用的例子：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s := []<span class=\"keyword\">int</span>&#123;<span class=\"number\">5</span>, <span class=\"number\">2</span>, <span class=\"number\">6</span>, <span class=\"number\">3</span>, <span class=\"number\">1</span>, <span class=\"number\">4</span>&#125; <span class=\"comment\">// 未排序的切片数据</span></span><br><span class=\"line\">fmt.Println(sort.SearchInts(s, <span class=\"number\">2</span>)) <span class=\"comment\">// 将会输出 0 而不是 1</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"Float64Slice-类型及-float64\"><a href=\"#Float64Slice-类型及-float64\" class=\"headerlink\" title=\"Float64Slice 类型及 []float64\"></a>Float64Slice 类型及 []float64</h3><p>实现与 Ints 类似：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Float64Slice []<span class=\"keyword\">float64</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p Float64Slice)</span> <span class=\"title\">Len</span><span class=\"params\">()</span> <span class=\"title\">int</span></span>           &#123; <span class=\"keyword\">return</span> <span class=\"built_in\">len</span>(p) &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p Float64Slice)</span> <span class=\"title\">Less</span><span class=\"params\">(i, j <span class=\"keyword\">int</span>)</span> <span class=\"title\">bool</span></span> &#123; <span class=\"keyword\">return</span> p[i] &lt; p[j] || isNaN(p[i]) &amp;&amp; !isNaN(p[j]) &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p Float64Slice)</span> <span class=\"title\">Swap</span><span class=\"params\">(i, j <span class=\"keyword\">int</span>)</span></span>      &#123; p[i], p[j] = p[j], p[i] &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p Float64Slice)</span> <span class=\"title\">Sort</span><span class=\"params\">()</span></span> &#123; Sort(p) &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p Float64Slice)</span> <span class=\"title\">Search</span><span class=\"params\">(x <span class=\"keyword\">float64</span>)</span> <span class=\"title\">int</span></span> &#123; <span class=\"keyword\">return</span> SearchFloat64s(p, x) &#125;</span><br></pre></td></tr></table></figure>\n<p>与 <code>Sort()</code>、<code>IsSorted()</code>、<code>Search()</code> 相对应的三个方法：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Float64s</span><span class=\"params\">(a []<span class=\"keyword\">float64</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">Float64sAreSorted</span><span class=\"params\">(a []<span class=\"keyword\">float64</span>)</span> <span class=\"title\">bool</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">SearchFloat64s</span><span class=\"params\">(a []<span class=\"keyword\">float64</span>, x <span class=\"keyword\">float64</span>)</span> <span class=\"title\">int</span></span></span><br></pre></td></tr></table></figure>\n<p>在上面 <code>Float64Slice</code> 类型定义的 <code>Less</code> 方法中，有一个内部函数 <code>isNaN()</code>。<br><code>isNaN()</code> 与 <code>math</code> 包中 <code>IsNaN()</code> 实现完全相同，<code>sort</code> 包之所以不使用 <code>math.IsNaN()</code>，完全是基于包依赖性的考虑，<br><code>sort</code> 包的实现不依赖与其他任何包。</p>\n<h3 id=\"StringSlice-类型及-string\"><a href=\"#StringSlice-类型及-string\" class=\"headerlink\" title=\"StringSlice 类型及 []string\"></a>StringSlice 类型及 []string</h3><p>两个 <code>string</code> 对象之间的大小比较是基于“字典序”的。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> StringSlice []<span class=\"keyword\">string</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p StringSlice)</span> <span class=\"title\">Len</span><span class=\"params\">()</span> <span class=\"title\">int</span></span>           &#123; <span class=\"keyword\">return</span> <span class=\"built_in\">len</span>(p) &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p StringSlice)</span> <span class=\"title\">Less</span><span class=\"params\">(i, j <span class=\"keyword\">int</span>)</span> <span class=\"title\">bool</span></span> &#123; <span class=\"keyword\">return</span> p[i] &lt; p[j] &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p StringSlice)</span> <span class=\"title\">Swap</span><span class=\"params\">(i, j <span class=\"keyword\">int</span>)</span></span>      &#123; p[i], p[j] = p[j], p[i] &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p StringSlice)</span> <span class=\"title\">Sort</span><span class=\"params\">()</span></span> &#123; Sort(p) &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p StringSlice)</span> <span class=\"title\">Search</span><span class=\"params\">(x <span class=\"keyword\">string</span>)</span> <span class=\"title\">int</span></span> &#123; <span class=\"keyword\">return</span> SearchStrings(p, x) &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"interface-排序与查找\"><a href=\"#interface-排序与查找\" class=\"headerlink\" title=\"[]interface 排序与查找\"></a>[]interface 排序与查找</h2><p>只要实现了 <code>sort.Interface</code> 接口，即可通过 <code>sort</code> 包内的函数完成排序，查找等操作。但是这种用法对于其它数据类型的 <code>slice</code><br>不友好，可能我们需要为大量的 <code>struct</code> 定义一个单独的 <code>[]struct</code> 类型，再为其实现 <code>sort.Interface</code> 接口，例如：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Person <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    Name <span class=\"keyword\">string</span></span><br><span class=\"line\">    Age  <span class=\"keyword\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">type</span> Persons []Person</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p Persons)</span> <span class=\"title\">Len</span><span class=\"params\">()</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">panic</span>(<span class=\"string\">\"implement me\"</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p Persons)</span> <span class=\"title\">Less</span><span class=\"params\">(i, j <span class=\"keyword\">int</span>)</span> <span class=\"title\">bool</span></span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">panic</span>(<span class=\"string\">\"implement me\"</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p Persons)</span> <span class=\"title\">Swap</span><span class=\"params\">(i, j <span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">panic</span>(<span class=\"string\">\"implement me\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>sort</code> 包提供了以下函数：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Slice</span><span class=\"params\">(slice <span class=\"keyword\">interface</span>&#123;&#125;, less <span class=\"keyword\">func</span>(i, j <span class=\"keyword\">int</span>)</span> <span class=\"title\">bool</span>)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">SliceStable</span><span class=\"params\">(slice <span class=\"keyword\">interface</span>&#123;&#125;, less <span class=\"keyword\">func</span>(i, j <span class=\"keyword\">int</span>)</span> <span class=\"title\">bool</span>)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">SliceIsSorted</span><span class=\"params\">(slice <span class=\"keyword\">interface</span>&#123;&#125;, less <span class=\"keyword\">func</span>(i, j <span class=\"keyword\">int</span>)</span> <span class=\"title\">bool</span>) <span class=\"title\">bool</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">Search</span><span class=\"params\">(n <span class=\"keyword\">int</span>, f <span class=\"keyword\">func</span>(<span class=\"keyword\">int</span>)</span> <span class=\"title\">bool</span>) <span class=\"title\">int</span></span></span><br></pre></td></tr></table></figure>\n<p>排序相关的三个函数都接收 <code>[]interface</code>，并且需要传入一个比较函数，用于为程序比较两个变量的大小，因为<br>函数签名和作用域的原因，这个函数只能是 <code>匿名函数</code>。</p>\n<h3 id=\"sort-Slice\"><a href=\"#sort-Slice\" class=\"headerlink\" title=\"sort.Slice\"></a>sort.Slice</h3><p>利用 <code>sort.Slice</code> 函数，而不用提供一个特定的 <code>sort.Interface</code> 的实现，而是 <code>Less(i，j int)</code> 作为一个比较回调函数，可以简单<br>地传递给 <code>sort.Slice</code> 进行排序。<strong>不建议使用，因为在 <code>sort.Slice</code> 中使用了 <code>reflect</code></strong>。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">people := []<span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    Name <span class=\"keyword\">string</span></span><br><span class=\"line\">    Age  <span class=\"keyword\">int</span></span><br><span class=\"line\">&#125;&#123;</span><br><span class=\"line\">    &#123;<span class=\"string\">\"Gopher\"</span>, <span class=\"number\">7</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"string\">\"Alice\"</span>, <span class=\"number\">55</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"string\">\"Vera\"</span>, <span class=\"number\">24</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"string\">\"Bob\"</span>, <span class=\"number\">75</span>&#125;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">sort.Slice(people, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(i, j <span class=\"keyword\">int</span>)</span> <span class=\"title\">bool</span></span> &#123; <span class=\"keyword\">return</span> people[i].Age &lt; people[j].Age &#125;) <span class=\"comment\">// 按年龄升序排序</span></span><br><span class=\"line\">fmt.Println(<span class=\"string\">\"Sort by age:\"</span>, people)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Output:</span></span><br><span class=\"line\"><span class=\"comment\">// Sort by age: [&#123;Gopher 7&#125; &#123;Vera 24&#125; &#123;Alice 55&#125; &#123;Bob 75&#125;]</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"sort-Search\"><a href=\"#sort-Search\" class=\"headerlink\" title=\"sort.Search\"></a>sort.Search</h3><p>该函数判断 <code>[]interface</code> 是否存在指定元素，举个栗子：</p>\n<ul>\n<li>升序 slice</li>\n</ul>\n<blockquote>\n<p>sort 包为 <code>[]int</code>,<code>[]float64</code>,<code>[]string</code> 提供的 Search 函数其实也是调用的该函数，因为该函数是使用的二分查找法，所以要<br>求 slice 为升序排序状态。并且判断条件必须为 <code>&gt;=</code>，这也是官方库提供的三个查找相关函数的的写法。</p>\n</blockquote>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a := []<span class=\"keyword\">int</span>&#123;<span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">200</span>, <span class=\"number\">100</span>, <span class=\"number\">21</span>, <span class=\"number\">234</span>, <span class=\"number\">56</span>&#125;</span><br><span class=\"line\">x := <span class=\"number\">21</span></span><br><span class=\"line\"></span><br><span class=\"line\">sort.Slice(a, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(i, j <span class=\"keyword\">int</span>)</span> <span class=\"title\">bool</span></span> &#123; <span class=\"keyword\">return</span> a[i] &lt; a[j] &#125;)   <span class=\"comment\">// 升序排序</span></span><br><span class=\"line\">index := sort.Search(<span class=\"built_in\">len</span>(a), <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(i <span class=\"keyword\">int</span>)</span> <span class=\"title\">bool</span></span> &#123; <span class=\"keyword\">return</span> a[i] &gt;= x &#125;) <span class=\"comment\">// 查找元素</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> index &lt; <span class=\"built_in\">len</span>(a) &amp;&amp; a[index] == x &#123;</span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">\"found %d at index %d in %v\\n\"</span>, x, index, a)</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">\"%d not found in %v,index:%d\\n\"</span>, x, a, index)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Output:</span></span><br><span class=\"line\"><span class=\"comment\">// found 21 at index 3 in [2 3 4 21 56 100 200 234]</span></span><br></pre></td></tr></table></figure>\n"}],"Post":[],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}