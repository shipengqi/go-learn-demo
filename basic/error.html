<!DOCTYPE html>
<html lang="en">
  <head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">

    <title>Golang learning | 错误 </title>
    <meta name="description" content>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    

    <!-- fonts -->
    <link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700" rel="stylesheet">
    <link href="//fonts.googleapis.com/css?family=Ubuntu:300,400,500,600,700" rel="stylesheet">

    <!-- stylesheets -->
    <link rel="stylesheet" href="/golang-learn/style/doc.css">

    <!-- favicon -->
    <link rel="icon" href="/golang-learn/images/favicon.ico">

    

  </head>
  <body>

   <script>window.__INITIAL_STATE__ = {"page":{"title":"错误","path":"basic/error.html"},"data":{"navigation":{"logo":{"text":"Golang Learn","type":"link","path":"index.html"},"main":[{"text":"Golang 基础","type":"label"},{"text":"Go 环境配置","type":"link","path":"basic/env_config.html"},{"text":"包","type":"link","path":"basic/package.html"},{"text":"基础数据类型","type":"link","path":"basic/basic_data.html"},{"text":"变量","type":"link","path":"basic/var.html"},{"text":"常量","type":"link","path":"basic/constant.html"},{"text":"控制语句","type":"link","path":"basic/flow.html"},{"text":"运算符","type":"link","path":"basic/operator.html"},{"text":"作用域","type":"link","path":"basic/scope.html"},{"text":"指针","type":"link","path":"basic/pointer.html"},{"text":"数组","type":"link","path":"basic/array.html"},{"text":"切片","type":"link","path":"basic/slice.html"},{"text":"字典","type":"link","path":"basic/map.html"},{"text":"函数","type":"link","path":"basic/function.html"},{"text":"结构体","type":"link","path":"basic/struct.html"},{"text":"接口","type":"link","path":"basic/interface.html"},{"text":"面向对象","type":"link","path":"basic/oop.html"},{"text":"错误","type":"link","path":"basic/error.html"},{"text":"序列化","type":"link","path":"basic/json.html"},{"text":"反射","type":"link","path":"basic/reflect.html"},{"text":"测试","type":"link","path":"basic/test.html"},{"text":"并发编程","type":"label"},{"text":"goroutine","type":"link","path":"concurrent/goroutine.html"},{"text":"channel","type":"link","path":"concurrent/channel.html"},{"text":"同步和锁","type":"link","path":"concurrent/sync_lock.html"},{"text":"内存分配","type":"label"},{"text":"内存分配","type":"link","path":"advance/mm.html"},{"text":"垃圾回收","type":"label"},{"text":"垃圾回收","type":"link","path":"advance/gc.html"},{"text":"THEME","type":"label"},{"text":"使用文档主题","type":"link","path":"theme/theme-usage.html"},{"text":"SUPPORT AND FEEDBACK","type":"label"},{"text":"Raise an Issue on Github","type":"link","path":"https://github.com/shipengqi/golang-learn/issues/new"}]}},"config":{"timezone":"UTC","root":"/golang-learn/","time_format":"HH:mm:ss","theme":"../node_modules/hexo-theme-doc","theme_config":{"swagger_ui":{"version":2,"permalinks":true,"api_explorer":true,"download":"Download specification","show_extensions":false,"deep_linking":true,"display_operation_id":false,"doc_expansion":"none"},"search":{"skip":false,"background":false,"route":"/lunr.json"},"favicon":"images/favicon.ico"}}}</script>

    <div id="react-navigation-root"><div class="doc-navigation" data-reactroot><nav class="doc-navbar"><a href="/golang-learn/index.html" class="doc-navbar__logo"><img src="/golang-learn/images/logo.png" class="doc-navbar__logo__img"><span class="doc-navbar__logo__text">Golang Learn</span></a><i class="dc-icon dc-icon--close dc-icon--interactive doc-sidebar-close doc-navbar__sidebar-close doc-navbar__sidebar-close--desktop"></i><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-navbar__sidebar-toggle"></i></nav><nav class="doc-sidebar"><div class="doc-sidebar__vertical-menu"><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-sidebar-toggle--primary doc-sidebar__vertical-menu__item"></i><i class="dc-icon dc-icon--search dc-icon--interactive doc-sidebar__vertical-menu__item doc-sidebar__vertical-menu__item--primary"></i></div><div class="doc-sidebar-content"><div class="doc-sidebar__search-form"></div><ul class="doc-sidebar-list"></ul></div></nav></div></div>
    <div class="doc-content">
  <div class="dc-page">
    <div class="dc-card">
      <div id="react-search-results-root"></div>
      <div id="page-content" class="doc-formatting">
        <h1 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h1><h2 id="error-类型"><a href="#error-类型" class="headerlink" title="error 类型"></a>error 类型</h2><p><code>error</code> 类型是内置的接口类型。<code>error</code> 类型可能是 <code>nil</code> 或者 <code>non-nil</code>，<code>nil</code> 表示成功。</p>
<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>当函数调用返回错误时，最常用的处理方式是<strong>传播错误</strong>，如。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">resp, err := http.Get(url)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span>&#123; <span class="comment">// 将这个HTTP错误返回给调用者</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">doc, err := html.Parse(resp.Body)</span><br><span class="line">resp.Body.Close()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="comment">// fmt.Errorf函数使用fmt.Sprintf格式化错误信息并返回</span></span><br><span class="line">	<span class="comment">// 使用该函数前缀添加额外的上下文信息到原始错误信息。</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"parsing %s as HTML: %v"</span>, url,err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由于错误信息经常是以链式组合在一起的，所以错误信息中应避免大写和换行符。</p>
<p>编写错误信息时，我们要确保错误信息对问题细节的描述是详尽的。尤其是要注意错误信息表达的一致性，即相同的函数或同包内<br>的同一组函数返回的错误在构成和处理方式上是相似的。</p>
<p>根据不同的场景，我们可能要对错误做些特殊处理，比如错误重试机制，或者打印错误日志，或者直接忽略错误。</p>
<h3 id="文件结尾错误"><a href="#文件结尾错误" class="headerlink" title="文件结尾错误"></a>文件结尾错误</h3><p><code>io</code> 包在任何由文件结束引起的读取失败都返回同一个错误 <code>io.EOF</code>：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">in := bufio.NewReader(os.Stdin)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    r, _, err := in.ReadRune()</span><br><span class="line">    <span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">        <span class="keyword">break</span> <span class="comment">// finished reading</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">"read failed:%v"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...use r…</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Panic-异常"><a href="#Panic-异常" class="headerlink" title="Panic 异常"></a>Panic 异常</h2><p>Go 运行时错误会引起 <code>painc</code> 异常。<br>一般而言，当 <code>panic</code> 异常发生时，程序会中断运行，并立即执行在该 <code>goroutine</code> 中被延迟的函数（<code>defer</code> 机制）。随后，程序崩溃<br>并输出日志信息。</p>
<p>由于 <code>panic</code> 会引起程序的崩溃，因此 <code>panic</code> 一般用于严重错误，如程序内部的逻辑不一致。但是对于大部分漏洞，我们应该使<br>用 Go 提供的错误机制，而不是 <code>panic</code>，尽量避免程序的崩溃。</p>
<h3 id="panic-函数"><a href="#panic-函数" class="headerlink" title="panic 函数"></a>panic 函数</h3><p><code>panic</code> 函数接受任何值作为参数。当某些不应该发生的场景发生时，我们就应该调用 <code>panic</code>。</p>
<h3 id="panic-详情中都有什么"><a href="#panic-详情中都有什么" class="headerlink" title="panic 详情中都有什么"></a>panic 详情中都有什么</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">panic: runtime error: index out of range</span><br><span class="line"></span><br><span class="line">goroutine 1 [running]:</span><br><span class="line">main.main()</span><br><span class="line">/Users/haolin/GeekTime/Golang_Puzzlers/src/puzzlers/article19/q0/demo47.go:5 +0x3d</span><br><span class="line"><span class="built_in">exit</span> status 2</span><br></pre></td></tr></table></figure>
<p>第一行是 <code>panic: runtime error: index out of range</code>。其中的 <code>runtime error</code> 的含义是，这是一个 <code>runtime</code> 代码包中<br>抛出的<code>panic</code>。</p>
<p><code>goroutine 1 [running]</code>，它表示有一个 ID 为1的 <code>goroutine</code> 在此 <code>panic</code> 被引发的时候正在运行。这里的 ID 其实并不重要。</p>
<p><code>main.main()</code> 表明了这个 <code>goroutine</code> 包装的 go 函数就是命令源码文件中的那个<code>main</code>函数，也就是说这里的 <code>goroutine</code> 正<br>是<strong>主 goroutine</strong>。</p>
<p>再下面的一行，指出的就是这个 <code>goroutine</code> 中的哪一行代码在此 panic 被引发时正在执行。含了此行代码在其所属的源码文件中的行数，<br>以及这个源码文件的绝对路径。</p>
<p><code>+0x3d</code> 代表的是：此行代码相对于其所属函数的入口程序计数偏移量。用处并不大。</p>
<p><code>exit status 2</code> 表明我的这个程序是以退出状态码2结束运行的。<strong>在大多数操作系统中，只要退出状态码不是 0，都意味着程序运行的非正<br>常结束</strong>。在 Go 语言中，<strong>因 panic 导致程序结束运行的退出状态码一般都会是 2</strong>。</p>
<h3 id="从-panic-被引发到程序终止运行的大致过程是什么"><a href="#从-panic-被引发到程序终止运行的大致过程是什么" class="headerlink" title="从 panic 被引发到程序终止运行的大致过程是什么"></a>从 panic 被引发到程序终止运行的大致过程是什么</h3><p>此行代码所属函数的执行随即终止。紧接着，控制权并不会在此有片刻停留，它又会立即转移至再上一级的调用代码处。控制权如此一级一<br>级地沿着调用栈的反方向传播至顶端，<br>也就是我们编写的最外层函数那里。</p>
<p>这里的最外层函数指的是go函数，对于主 goroutine 来说就是 <code>main</code> 函数。但是控制权也不会停留在那里，而是被 Go 语言运行时系统收回。</p>
<p>随后，程序崩溃并终止运行，承载程序这次运行的进程也会随之死亡并消失。与此同时，在这个控制权传播的过程中，panic 详情会被逐<br>渐地积累和完善，并会在程序终止之前被打印出来。</p>
<h3 id="怎样让-panic-包含一个值，以及应该让它包含什么样的值"><a href="#怎样让-panic-包含一个值，以及应该让它包含什么样的值" class="headerlink" title="怎样让 panic 包含一个值，以及应该让它包含什么样的值"></a>怎样让 panic 包含一个值，以及应该让它包含什么样的值</h3><p>其实很简单，在调用 <code>panic</code> 函数时，把某个值作为参数传给该函数就可以了。<code>panic</code> 函数的唯一一个参数是空接口<br>（也就是<code>interface{}</code>）类型的，所以从语法上讲，它可以接受任何类型的值。</p>
<p>但是，我们<strong>最好传入 <code>error</code> 类型的错误值，或者其他的可以被有效序列化的值。这里的“有效序列化”指的是，可以更易读地去表示<br>形式转换</strong>。</p>
<h2 id="Recover-捕获异常"><a href="#Recover-捕获异常" class="headerlink" title="Recover 捕获异常"></a>Recover 捕获异常</h2><p>一般情况下，我们不能因为某个处理函数引发的 <code>panic</code> 异常，杀掉整个进程，可以使用 <code>recover</code> 函数恢复 <code>panic</code> 异常。</p>
<p><code>panic</code> 时会调用 <code>recover</code>，但是 <code>recover</code> 不能滥用，可能会引起资源泄漏或者其他问题。我们可以将 <code>panic value</code> 设置成特<br>殊类型，来标识某个 <code>panic</code> 是否应该被恢复。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">soleTitle</span><span class="params">(doc *html.Node)</span> <span class="params">(title <span class="keyword">string</span>, err error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">type</span> bailout <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">switch</span> p := <span class="built_in">recover</span>(); p &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="literal">nil</span>:       <span class="comment">// no panic</span></span><br><span class="line">            <span class="keyword">case</span> bailout&#123;&#125;: <span class="comment">// "expected" panic</span></span><br><span class="line">                err = fmt.Errorf(<span class="string">"multiple title elements"</span>)</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">panic</span>(p) <span class="comment">// unexpected panic; carry on panicking</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码，<code>deferred</code> 函数调用 <code>recover</code>，并检查 <code>panic value</code>。当 <code>panic value</code> 是 <code>bailout{}</code> 类型时，<code>deferred</code> 函数生<br>成一个 <code>error</code> 返回给调用者。<br>当 <code>panic value</code> 是其他 <code>non-nil</code> 值时，表示发生了未知的 <code>panic</code> 异常。</p>
<h3 id="正确调用-recover-函数"><a href="#正确调用-recover-函数" class="headerlink" title="正确调用 recover 函数"></a>正确调用 recover 函数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"errors"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"Enter function main."</span>)</span><br><span class="line">    <span class="comment">// 引发 panic。</span></span><br><span class="line">    <span class="built_in">panic</span>(errors.New(<span class="string">"something wrong"</span>))</span><br><span class="line">    p := <span class="built_in">recover</span>()</span><br><span class="line">    fmt.Printf(<span class="string">"panic: %s\n"</span>, p)</span><br><span class="line">    fmt.Println(<span class="string">"Exit function main."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码，<code>recover</code> 函数调用并不会起到任何作用，甚至都没有机会执行。因为 panic 一旦发生，控制权就会讯速地沿着调用栈的反方向<br>传播。所以，<strong>在 panic 函数调用之后的代码，根本就没有执行的机会</strong>。</p>
<p>先调用 <code>recover</code> 函数，再调用 <code>panic</code> 函数会怎么样呢？<br>如果在我们调用 <code>recover</code> 函数时未发生 panic，那么该函数就不会做任何事情，并且只会返回一个 <code>nil</code>。</p>
<p><strong><code>defer</code> 语句调用 <code>recover</code> 函数才是正确的打开方式</strong>。</p>
<p>无论函数结束执行的原因是什么，其中的 <code>defer</code> 函数调用都会在它即将结束执行的那一刻执行。即使导致它执行结束的原因是一<br>个 panic 也会是这样。</p>
<p>要注意，我们要<strong>尽量把 <code>defer</code> 语句写在函数体的开始处，因为在引发 panic 的语句之后的所有语句，都不会有任何执行机会</strong>。</p>

        <div id="react-support-footer-root"></div>
      </div>
    </div>
  </div>
</div>

    


    

    <!-- js vendors -->
    <script src="//code.jquery.com/jquery-3.2.1.min.js" crossorigin="anonymous"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/lunr.js/2.1.0/lunr.min.js"></script>

    <!-- js source  -->
    <script src="/golang-learn/script/doc.js"></script>

    

  </body>
</html>
