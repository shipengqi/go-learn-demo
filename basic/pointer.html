<!DOCTYPE html>
<html lang="en">
  <head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">

    <title>Golang learning | 指针 </title>
    <meta name="description" content>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    

    <!-- fonts -->
    <link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700" rel="stylesheet">
    <link href="//fonts.googleapis.com/css?family=Ubuntu:300,400,500,600,700" rel="stylesheet">

    <!-- stylesheets -->
    <link rel="stylesheet" href="/golang-learn/style/doc.css">

    <!-- favicon -->
    <link rel="icon" href="/golang-learn/images/favicon.ico">

    

  </head>
  <body>

   <script>window.__INITIAL_STATE__ = {"page":{"title":"指针","path":"basic/pointer.html"},"data":{"navigation":{"logo":{"text":"Golang Learn","type":"link","path":"index.html"},"main":[{"text":"Golang 基础","type":"label"},{"text":"Go 环境配置","type":"link","path":"basic/env_config.html"},{"text":"包","type":"link","path":"basic/package.html"},{"text":"基础数据类型","type":"link","path":"basic/basic_data.html"},{"text":"变量","type":"link","path":"basic/var.html"},{"text":"常量","type":"link","path":"basic/constant.html"},{"text":"控制语句","type":"link","path":"basic/flow.html"},{"text":"运算符","type":"link","path":"basic/operator.html"},{"text":"作用域","type":"link","path":"basic/scope.html"},{"text":"指针","type":"link","path":"basic/pointer.html"},{"text":"数组","type":"link","path":"basic/array.html"},{"text":"切片","type":"link","path":"basic/slice.html"},{"text":"字典","type":"link","path":"basic/map.html"},{"text":"函数","type":"link","path":"basic/function.html"},{"text":"结构体","type":"link","path":"basic/struct.html"},{"text":"接口","type":"link","path":"basic/interface.html"},{"text":"面向对象","type":"link","path":"basic/oop.html"},{"text":"错误","type":"link","path":"basic/error.html"},{"text":"序列化","type":"link","path":"basic/json.html"},{"text":"反射","type":"link","path":"basic/reflect.html"},{"text":"测试","type":"link","path":"basic/test.html"},{"text":"并发编程","type":"label"},{"text":"goroutine","type":"link","path":"concurrent/goroutine.html"},{"text":"channel","type":"link","path":"concurrent/channel.html"},{"text":"同步和锁","type":"link","path":"concurrent/sync_lock.html"},{"text":"内存分配","type":"label"},{"text":"内存分配","type":"link","path":"advance/mm.html"},{"text":"垃圾回收","type":"label"},{"text":"垃圾回收","type":"link","path":"advance/gc.html"},{"text":"标准库","type":"label"},{"text":"fmt","type":"link","path":"standards/io/fmt.html"},{"text":"io","type":"link","path":"standards/io/io.html"},{"text":"ioutil","type":"link","path":"standards/io/ioutil.html"},{"text":"bufio","type":"link","path":"standards/io/bufio.html"},{"text":"os","type":"link","path":"standards/os/os.html"},{"text":"filepath","type":"link","path":"standards/os/filepath.html"},{"text":"strings","type":"link","path":"standards/text/strings.html"},{"text":"strconv","type":"link","path":"standards/text/strconv.html"},{"text":"unicode","type":"link","path":"standards/text/unicode.html"},{"text":"log","type":"link","path":"standards/log.html"},{"text":"time","type":"link","path":"standards/time.html"},{"text":"http","type":"link","path":"standards/net/http.html"},{"text":"math","type":"link","path":"standards/data/math.html"},{"text":"sort","type":"link","path":"standards/data/sort.html"},{"text":"big","type":"link","path":"standards/data/big.html"},{"text":"container","type":"link","path":"standards/data/container.html"},{"text":"sql","type":"link","path":"standards/database/sql.html"},{"text":"THEME","type":"label"},{"text":"使用文档主题","type":"link","path":"theme/theme-usage.html"},{"text":"SUPPORT AND FEEDBACK","type":"label"},{"text":"Raise an Issue on Github","type":"link","path":"https://github.com/shipengqi/golang-learn/issues/new"}]}},"config":{"timezone":"UTC","root":"/golang-learn/","time_format":"HH:mm:ss","theme":"../node_modules/hexo-theme-doc","theme_config":{"swagger_ui":{"version":2,"permalinks":true,"api_explorer":true,"download":"Download specification","show_extensions":false,"deep_linking":true,"display_operation_id":false,"doc_expansion":"none"},"search":{"skip":false,"background":false,"route":"/lunr.json"},"favicon":"images/favicon.ico"}}}</script>

    <div id="react-navigation-root"><div class="doc-navigation" data-reactroot><nav class="doc-navbar"><a href="/golang-learn/index.html" class="doc-navbar__logo"><img src="/golang-learn/images/logo.png" class="doc-navbar__logo__img"><span class="doc-navbar__logo__text">Golang Learn</span></a><i class="dc-icon dc-icon--close dc-icon--interactive doc-sidebar-close doc-navbar__sidebar-close doc-navbar__sidebar-close--desktop"></i><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-navbar__sidebar-toggle"></i></nav><nav class="doc-sidebar"><div class="doc-sidebar__vertical-menu"><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-sidebar-toggle--primary doc-sidebar__vertical-menu__item"></i><i class="dc-icon dc-icon--search dc-icon--interactive doc-sidebar__vertical-menu__item doc-sidebar__vertical-menu__item--primary"></i></div><div class="doc-sidebar-content"><div class="doc-sidebar__search-form"></div><ul class="doc-sidebar-list"></ul></div></nav></div></div>
    <div class="doc-content">
  <div class="dc-page">
    <div class="dc-card">
      <div id="react-search-results-root"></div>
      <div id="page-content" class="doc-formatting">
        <h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><p><strong>指针和内存地址不能混为一谈</strong>。内存地址是内存中每个字节单元的唯一编号，而指针是一个实体。指针也会分配内存空间，相当于一个<br>保存内存地址的整形变量。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x := <span class="number">1</span></span><br><span class="line">p := &amp;x         <span class="comment">// p, of type *int, points to x</span></span><br><span class="line">fmt.Println(*p) <span class="comment">// "1"</span></span><br><span class="line">*p = <span class="number">2</span>          <span class="comment">// equivalent to x = 2</span></span><br><span class="line">fmt.Println(x)  <span class="comment">// "2"</span></span><br></pre></td></tr></table></figure>
<p>上面的代码，初始化一个变量 <code>x</code>，<code>&amp;</code> 是取地址操作，<code>&amp;x</code> 就是取变量 <code>x</code> 的内存地址，那么 <code>p</code> 就是一个指针，<br>类型是 <code>*int</code>，<code>p</code> 这个指针保存了变量 <code>x</code> 的内存地址。接下来 <code>*p</code> 表示读取指针指向的变量的值，也就是变量 <code>x</code> 的值 1。<br><code>*p</code>也可以被赋值。</p>
<p>任何类型的指针的零值都是 <code>nil</code>。当指针指向同一个变量或者 <code>nil</code> 时是相等的。<br>当一个指针被定义后没有分配到任何变量时，它的值为 <code>nil</code>。<code>nil</code> 指针也称为空指针。</p>
<h2 id="指向指针的指针"><a href="#指向指针的指针" class="headerlink" title="指向指针的指针"></a>指向指针的指针</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> ptr *<span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> pptr **<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">3000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 指针 ptr 地址 */</span></span><br><span class="line">ptr = &amp;a</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 指向指针 ptr 地址 */</span></span><br><span class="line">pptr = &amp;ptr</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取 pptr 的值 */</span></span><br><span class="line">fmt.Printf(<span class="string">"变量 a = %d\n"</span>, a )</span><br><span class="line">fmt.Printf(<span class="string">"指针变量 *ptr = %d\n"</span>, *ptr )</span><br><span class="line">fmt.Printf(<span class="string">"指向指针的指针变量 **pptr = %d\n"</span>, **pptr)</span><br></pre></td></tr></table></figure>
<h2 id="为什么需要指针"><a href="#为什么需要指针" class="headerlink" title="为什么需要指针"></a>为什么需要指针</h2><p>相比 Java，Python，Javascript 等引用类型的语言，Golang 拥有类似C语言的指针这个相对古老的特性。但不同于 C 语言，Golang 的指<br>针是单独的类型，而且也不能对指针做整数运算。从这一点看，Golang 的指针基本就是一种引用。</p>
<p>在学习引用类型语言的时候，总是要先搞清楚，当给一个 <code>函数/方法</code> 传参的时候，传进去的是值还是引用。实际上，在大部分引用型语言里，<br>参数为基本类型时，传进去的大都是值，也就是另外复制了一份参数到当前的函数调用栈。参数为高级类型时，传进去的基本都是引用。</p>
<p>内存管理中的内存区域一般包括 <code>heap</code> 和 <code>stack</code>，<code>stack</code> 主要用来存储当前调用栈用到的简单类型数据：<code>string</code>，<code>boolean</code>，<br><code>int</code>，<code>float</code> 等。这些类型的内存占用小，容易回收，基本上它们的值和指针占用的空间差不多，因此可以直接复制，<code>GC</code> 也比较容易做针对性的<br>优化。复杂的高级类型占用的内存往往相对较大，存储在 <code>heap</code> 中，<code>GC</code> 回收频率相对较低，代价也较大，因此传 <code>引用/指针</code> 可以避免进行成本较<br>高的复制操作，并且节省内存，提高程序运行效率。</p>
<p>因此，在下列情况可以考虑使用指针：</p>
<ol>
<li><strong>需要改变参数的值</strong></li>
<li><strong>避免复制操作</strong></li>
<li><strong>节省内存</strong></li>
</ol>
<p>而在 Golang 中，具体到高级类型 <code>struct</code>，<code>slice</code>，<code>map</code> 也各有不同。实际上，只有 <code>struct</code> 的使用有点复杂，<strong><code>slice</code>，<code>map</code>，<br><code>chan</code>都可以直接使用，不用考虑是值还是指针</strong>。</p>
<h3 id="struct"><a href="#struct" class="headerlink" title="struct"></a><code>struct</code></h3><p>对于函数（<code>function</code>），由函数的参数类型指定，传入的参数的类型不对会报错，例如：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">passValue</span><span class="params">(s <span class="keyword">struct</span>)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">passPointer</span><span class="params">(s *<span class="keyword">struct</span>)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于方法（<code>method</code>），接收者（<code>receiver</code>）可以是指针，也可以是值，Golang 会在传递参数前自动适配以符合参数的类型。也就是：如果方法的参数<br>是值，那么按照传值的方式 ，方法内部对 <code>struct</code> 的改动无法作用在外部的变量上，例如：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyPoint <span class="keyword">struct</span> &#123;</span><br><span class="line">    X <span class="keyword">int</span></span><br><span class="line">    Y <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printFuncValue</span><span class="params">(p MyPoint)</span></span>&#123;</span><br><span class="line">    p.X = <span class="number">1</span></span><br><span class="line">    p.Y = <span class="number">1</span></span><br><span class="line">    fmt.Printf(<span class="string">" -&gt; %v"</span>, p)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printFuncPointer</span><span class="params">(pp *MyPoint)</span></span>&#123;</span><br><span class="line">    pp.X = <span class="number">1</span> <span class="comment">// 实际上应该写做 (*pp).X，Golang 给了语法糖，减少了麻烦，但是也导致了 * 的不一致</span></span><br><span class="line">    pp.Y = <span class="number">1</span></span><br><span class="line">    fmt.Printf(<span class="string">" -&gt; %v"</span>, pp)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p MyPoint)</span> <span class="title">printMethodValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">    p.X += <span class="number">1</span></span><br><span class="line">    p.Y += <span class="number">1</span></span><br><span class="line">    fmt.Printf(<span class="string">" -&gt; %v"</span>, p)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建议使用指针作为方法（method：printMethodPointer）的接收者（receiver：*MyPoint），一是可以修改接收者的值，二是可以避免大对象的复制</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pp *MyPoint)</span> <span class="title">printMethodPointer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    pp.X += <span class="number">1</span></span><br><span class="line">    pp.Y += <span class="number">1</span></span><br><span class="line">    fmt.Printf(<span class="string">" -&gt; %v"</span>, pp)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    p := MyPoint&#123;<span class="number">0</span>, <span class="number">0</span>&#125;</span><br><span class="line">    pp := &amp;MyPoint&#123;<span class="number">0</span>, <span class="number">0</span>&#125;</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">"\n value to func(value): %v"</span>, p)</span><br><span class="line">    printFuncValue(p)</span><br><span class="line">    fmt.Printf(<span class="string">" --&gt; %v"</span>, p)</span><br><span class="line">    <span class="comment">// Output: value to func(value): &#123;0 0&#125; -&gt; &#123;1 1&#125; --&gt; &#123;0 0&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//printFuncValue(pp) // cannot use pp (type *MyPoint) as type MyPoint in argument to printFuncValue</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//printFuncPointer(p) // cannot use p (type MyPoint) as type *MyPoint in argument to printFuncPointer</span></span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">"\n pointer to func(pointer): %v"</span>, pp)</span><br><span class="line">    printFuncPointer(pp)</span><br><span class="line">    fmt.Printf(<span class="string">" --&gt; %v"</span>, pp)</span><br><span class="line">    <span class="comment">// Output: pointer to func(pointer): &amp;&#123;0 0&#125; -&gt; &amp;&#123;1 1&#125; --&gt; &amp;&#123;1 1&#125;</span></span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">"\n value to method(value): %v"</span>, p)</span><br><span class="line">    p.printMethodValue()</span><br><span class="line">    fmt.Printf(<span class="string">" --&gt; %v"</span>, p)</span><br><span class="line">    <span class="comment">// Output: value to method(value): &#123;0 0&#125; -&gt; &#123;1 1&#125; --&gt; &#123;0 0&#125;</span></span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">"\n value to method(pointer): %v"</span>, p)</span><br><span class="line">    p.printMethodPointer()</span><br><span class="line">    fmt.Printf(<span class="string">" --&gt; %v"</span>, p)</span><br><span class="line">    <span class="comment">// Output: value to method(pointer): &#123;0 0&#125; -&gt; &amp;&#123;1 1&#125; --&gt; &#123;1 1&#125;</span></span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">"\n pointer to method(value): %v"</span>, pp)</span><br><span class="line">    pp.printMethodValue()</span><br><span class="line">    fmt.Printf(<span class="string">" --&gt; %v"</span>, pp)</span><br><span class="line">    <span class="comment">// Output: pointer to method(value): &amp;&#123;1 1&#125; -&gt; &#123;2 2&#125; --&gt; &amp;&#123;1 1&#125;</span></span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">"\n pointer to method(pointer): %v"</span>, pp)</span><br><span class="line">    pp.printMethodPointer()</span><br><span class="line">    fmt.Printf(<span class="string">" --&gt; %v"</span>, pp)</span><br><span class="line">    <span class="comment">// Output: pointer to method(pointer): &amp;&#123;1 1&#125; -&gt; &amp;&#123;2 2&#125; --&gt; &amp;&#123;2 2&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="slice"><a href="#slice" class="headerlink" title="slice"></a><code>slice</code></h3><p><strong><code>slice</code> 实际上相当于对其依附的 <code>array</code> 的引用，它不存储数据，只是对 <code>array</code> 进行描述。因此，修改 <code>slice</code> 中的元素，<br>改变会体现在 <code>array</code> 上，当然也会体现在该 <code>array</code> 的所有 <code>slice</code> 上</strong>。</p>
<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p><strong>使用 <code>make(map[string]string)</code> 返回的本身是个引用，可以直接用来操作</strong>：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">map</span>[<span class="string">"name"</span>]=<span class="string">"Jason"</span></span><br></pre></td></tr></table></figure></p>
<p>而<strong>如果使用 <code>map</code> 的指针，反而会产生错误</strong>：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*<span class="keyword">map</span>[<span class="string">"name"</span>]=<span class="string">"Jason"</span>  <span class="comment">//  invalid indirect of m["title"] (type string)</span></span><br><span class="line">(*<span class="keyword">map</span>)[<span class="string">"name"</span>]=<span class="string">"Jason"</span>  <span class="comment">// invalid indirect of m (type map[string]string)</span></span><br></pre></td></tr></table></figure></p>
<h2 id="哪些值是不可寻址的"><a href="#哪些值是不可寻址的" class="headerlink" title="哪些值是不可寻址的"></a>哪些值是不可寻址的</h2><ol>
<li><strong>不可变的值不可寻址</strong>。常量、基本类型的值字面量、字符串变量的值、函数以及方法的字面量都是如此。<br>其实这样规定也有安全性方面的考虑。</li>
<li>绝大多数被视为<strong>临时结果的值都是不可寻址的</strong>。算术操作的结果值属于临时结果，针对值字面量的表达式结果值也属于临时结果。<br>但有一个例外，对切片字面量的索引结果值虽然也属于临时结果，但却是可寻址的。函数的返回值也是临时结果。<code>++</code> 和 <code>--</code> 并不属<br>于操作符。</li>
<li><strong>不安全的值不可寻址</strong>，若拿到某值的指针可能会破坏程序的一致性，那么就是不安全的。由于字典的内部机制，对字典的索<br>引结果值的取址操作都是不安全的。另外，获取由字面量或标识符代表的函数或方法的地址显然也是不安全的。</li>
</ol>

        <div id="react-support-footer-root"></div>
      </div>
    </div>
  </div>
</div>

    


    

    <!-- js vendors -->
    <script src="//code.jquery.com/jquery-3.2.1.min.js" crossorigin="anonymous"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/lunr.js/2.1.0/lunr.min.js"></script>

    <!-- js source  -->
    <script src="/golang-learn/script/doc.js"></script>

    

  </body>
</html>
