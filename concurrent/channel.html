<!DOCTYPE html>
<html lang="en">
  <head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">

    <title>Golang learning | channel </title>
    <meta name="description" content>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    

    <!-- fonts -->
    <link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700" rel="stylesheet">
    <link href="//fonts.googleapis.com/css?family=Ubuntu:300,400,500,600,700" rel="stylesheet">

    <!-- stylesheets -->
    <link rel="stylesheet" href="/golang-learn/style/doc.css">

    <!-- favicon -->
    <link rel="icon" href="/golang-learn/images/favicon.ico">

    

  </head>
  <body>

   <script>window.__INITIAL_STATE__ = {"page":{"title":"channel","path":"concurrent/channel.html"},"data":{"navigation":{"logo":{"text":"Golang Learn","type":"link","path":"index.html"},"main":[{"text":"Golang 基础","type":"label"},{"text":"Go 环境配置","type":"link","path":"basic/env_config.html"},{"text":"包","type":"link","path":"basic/package.html"},{"text":"基础数据类型","type":"link","path":"basic/basic_data.html"},{"text":"变量","type":"link","path":"basic/var.html"},{"text":"常量","type":"link","path":"basic/constant.html"},{"text":"控制语句","type":"link","path":"basic/flow.html"},{"text":"运算符","type":"link","path":"basic/operator.html"},{"text":"作用域","type":"link","path":"basic/scope.html"},{"text":"指针","type":"link","path":"basic/pointer.html"},{"text":"数组","type":"link","path":"basic/array.html"},{"text":"切片","type":"link","path":"basic/slice.html"},{"text":"字典","type":"link","path":"basic/map.html"},{"text":"函数","type":"link","path":"basic/function.html"},{"text":"结构体","type":"link","path":"basic/struct.html"},{"text":"接口","type":"link","path":"basic/interface.html"},{"text":"面向对象","type":"link","path":"basic/oop.html"},{"text":"错误","type":"link","path":"basic/error.html"},{"text":"序列化","type":"link","path":"basic/json.html"},{"text":"反射","type":"link","path":"basic/reflect.html"},{"text":"测试","type":"link","path":"basic/test.html"},{"text":"并发编程","type":"label"},{"text":"goroutine","type":"link","path":"concurrent/goroutine.html"},{"text":"channel","type":"link","path":"concurrent/channel.html"},{"text":"同步和锁","type":"link","path":"concurrent/sync_lock.html"},{"text":"内存分配","type":"label"},{"text":"内存分配","type":"link","path":"advance/mm.html"},{"text":"垃圾回收","type":"label"},{"text":"垃圾回收","type":"link","path":"advance/gc.html"},{"text":"THEME","type":"label"},{"text":"使用文档主题","type":"link","path":"theme/theme-usage.html"},{"text":"SUPPORT AND FEEDBACK","type":"label"},{"text":"Raise an Issue on Github","type":"link","path":"https://github.com/shipengqi/golang-learn/issues/new"}]}},"config":{"timezone":"UTC","root":"/golang-learn/","time_format":"HH:mm:ss","theme":"../node_modules/hexo-theme-doc","theme_config":{"swagger_ui":{"version":2,"permalinks":true,"api_explorer":true,"download":"Download specification","show_extensions":false,"deep_linking":true,"display_operation_id":false,"doc_expansion":"none"},"search":{"skip":false,"background":false,"route":"/lunr.json"},"favicon":"images/favicon.ico"}}}</script>

    <div id="react-navigation-root"><div class="doc-navigation" data-reactroot><nav class="doc-navbar"><a href="/golang-learn/index.html" class="doc-navbar__logo"><img src="/golang-learn/images/logo.png" class="doc-navbar__logo__img"><span class="doc-navbar__logo__text">Golang Learn</span></a><i class="dc-icon dc-icon--close dc-icon--interactive doc-sidebar-close doc-navbar__sidebar-close doc-navbar__sidebar-close--desktop"></i><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-navbar__sidebar-toggle"></i></nav><nav class="doc-sidebar"><div class="doc-sidebar__vertical-menu"><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-sidebar-toggle--primary doc-sidebar__vertical-menu__item"></i><i class="dc-icon dc-icon--search dc-icon--interactive doc-sidebar__vertical-menu__item doc-sidebar__vertical-menu__item--primary"></i></div><div class="doc-sidebar-content"><div class="doc-sidebar__search-form"></div><ul class="doc-sidebar-list"></ul></div></nav></div></div>
    <div class="doc-content">
  <div class="dc-page">
    <div class="dc-card">
      <div id="react-search-results-root"></div>
      <div id="page-content" class="doc-formatting">
        <h1 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Don’t communicate by sharing memory; share memory by communicating.</span><br><span class="line">（不要通过共享内存来通信，而应该通过通信来共享内存。）</span><br></pre></td></tr></table></figure>
<p>这是作为 Go 语言最重要的编程理念。</p>
<p>通道类型的值是<strong>并发安全</strong>的，这也是 <strong>Go 语言自带的、唯一一个可以满足并发安全性的类型</strong>。</p>
<p><code>channels</code> 是 <code>goroutine</code> 之间的通信机制。<code>goroutine</code> 通过 <code>channel</code> 向另一个 <code>goroutine</code> 发送消息<br><code>channel</code> 和 <code>goroutine</code> 结合，可以实现用通信代替共享内存的 <code>CSP</code> 模型。</p>
<p>创建 <code>channel</code>：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>) <span class="comment">// buffered channel with capacity 3</span></span><br></pre></td></tr></table></figure></p>
<p>上面的代码中，<code>int</code> 代表这个 <code>channel</code> 要发送的数据的类型。第二个参数代表创建一带缓存的 <code>channel</code>，容量为 <code>3</code>。</p>
<p><code>channel</code> 的零值是 <code>nil</code>。</p>
<p>发送和接收两个操作使用 <code>&lt;-</code> 运算符，一个左尖括号紧接着一个减号形象地代表了元素值的传输方向：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送一个值</span></span><br><span class="line">ch &lt;- x <span class="comment">// 我的理解就是这里将数据push到channel</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 接受一个值</span></span><br><span class="line">x = &lt;-ch <span class="comment">// 取出channel的值并复制给变量x</span></span><br><span class="line"></span><br><span class="line">&lt;-ch <span class="comment">// 接受的值会被丢弃</span></span><br></pre></td></tr></table></figure></p>
<h3 id="close"><a href="#close" class="headerlink" title="close"></a>close</h3><p>使用 <code>close</code> 函数关闭 <code>channel</code>，<code>channel</code> 关闭后不能再发送数据，但是可以接受已经发送成功的数据，<br>如果 <code>channel</code> 中没有数据，那么返回一个零值。</p>
<p>注意，<strong><code>close</code> 函数不是一个清理操作，而是一个控制操作</strong>，在确定这个 <code>channel</code> 不会继续发送数据时调用。</p>
<p><strong>因为关闭操作只用于断言不再向 <code>channel</code> 发送新的数据，所以只有在 “发送者” 所在的 <code>goroutine</code> 才会调用 <code>close</code> 函数</strong>，<br>因此对一个只接收的 <code>channel</code> 调用 <code>close</code> 将是一个编译错误。</p>
<p>使用 <code>range</code> 循环可直接在 <code>channels</code> 上面迭代。它依次从 <code>channel</code> 接收数据，当 <code>channel</code> 被关闭并且没有值可接收时<br>跳出循环。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">naturals := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">for</span> x := <span class="number">0</span>; x &lt; <span class="number">100</span>; x++ &#123;</span><br><span class="line">    naturals &lt;- x</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> x := <span class="keyword">range</span> naturals &#123;</span><br><span class="line">    fmt.Println(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>注意上面的代码会报 <code>fatal error: all goroutines are asleep - deadlock!</code>。这个是死锁的错误，因为 <code>range</code> 不等到信<br>道关闭是不会结束读取的。也就是如果 <code>channel</code> 没有数据了，那么 <code>range</code> 就会阻塞当前 <code>goroutine</code>, 直到信道关闭，所以导<br>致了死锁</strong>。</p>
<p>为了避免这种情况，对于有缓存的信道，显式地关闭信道:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>)</span><br><span class="line">ch &lt;- <span class="number">1</span></span><br><span class="line">ch &lt;- <span class="number">2</span></span><br><span class="line">ch &lt;- <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 显式地关闭信道</span></span><br><span class="line"><span class="built_in">close</span>(ch)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> v := <span class="keyword">range</span> ch &#123;</span><br><span class="line">    fmt.Println(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="无缓存-channel"><a href="#无缓存-channel" class="headerlink" title="无缓存 channel"></a>无缓存 channel</h3><p><strong>无缓存 <code>channel</code> 也叫做同步 <code>channel</code></strong>，这是因为<strong>如果一个 <code>goroutine</code> 基于一个无缓存 <code>channel</code> 发送数据，那么就会<br>阻塞，直到另一个 <code>goroutine</code> 在相同的 <code>channel</code> 上执行接收操作</strong>。同样的，<strong>如果一个 <code>goroutine</code> 基于一个无缓存 <code>channel</code><br>先执行了接受操作，也会阻塞，直到另一个 <code>goroutine</code> 在相同的 <code>channel</code> 上执行发送操作</strong>。在 <code>channel</code> 成功传输之后，两个<br><code>goroutine</code> 之后的语句才会继续执行。</p>
<h3 id="带缓存-channel"><a href="#带缓存-channel" class="headerlink" title="带缓存 channel"></a>带缓存 channel</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>带缓存的 <code>channel</code> 内部持有一个元素队列。<code>make</code> 函数创建 <code>channel</code> 时通过第二个参数指定队列的最大容量。</p>
<p>发送操作会向 <code>channel</code> 的缓存队列 <code>push</code> 元素，接收操作则是 <code>pop</code> 元素，如果队列被塞满了，那么发送操作将阻<br>塞直到另一个 <code>goroutine</code> 执行接收操作而释放了新的队列空间。<br>相反，如果 <code>channel</code> 是空的，接收操作将阻塞直到有另一个 <code>goroutine</code> 执行发送操作而向队列插入元素。</p>
<p>在大多数情况下，缓冲通道会作为收发双方的中间件。正如前文所述，元素值会先从发送方复制到缓冲通道，之后再由缓冲通道复制给接收方。</p>
<p>但是，当发送操作在执行的时候发现空的通道中，正好有等待的接收操作，那么它会直接把元素值复制给接收方。</p>
<h3 id="单向-channel"><a href="#单向-channel" class="headerlink" title="单向 channel"></a>单向 channel</h3><p>当一个 <code>channel</code> 作为一个函数参数时，它一般总是被专门用于<strong>只发送或者只接收</strong>。</p>
<p>类型 <code>chan&lt;- int</code> 表示一个只发送 <code>int</code> 的 <code>channel</code>。相反，类型 <code>&lt;-chan int</code> 表示一个只接收 <code>int</code> 的 <code>channel</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> uselessChan = <span class="built_in">make</span>(<span class="keyword">chan</span>&lt;- <span class="keyword">int</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h3 id="cap-和-len"><a href="#cap-和-len" class="headerlink" title="cap 和 len"></a>cap 和 len</h3><p><code>cap</code> 函数可以获取 <code>channel</code> 内部缓存的容量。<br><code>len</code> 函数可以获取 <code>channel</code> 内部缓存有效元素的个数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>)</span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(ch)) <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">ch &lt;- <span class="string">"A"</span></span><br><span class="line">ch &lt;- <span class="string">"B"</span></span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(ch)) <span class="comment">// 2</span></span><br><span class="line">fmt.Println(&lt;-ch) <span class="comment">// A</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(ch)) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<h3 id="通道的发送和接收操作的特性"><a href="#通道的发送和接收操作的特性" class="headerlink" title="通道的发送和接收操作的特性"></a>通道的发送和接收操作的特性</h3><ol>
<li>对于同一个通道，发送操作之间是互斥的，接收操作之间也是互斥的。Go 语言的运行时系统（以下简称运行时系统）只会执行对同一个通<br>道的任意个发送操作中的某一个。直到这个元素值被完全复制进该通道之后，其他针对该通道的发送操作才可能被执行。</li>
<li>发送操作和接收操作中对元素值的处理都是不可分割的。发送操作要么还没复制元素值，要么已经复制完毕，绝不会出现只复制了一部分<br>的情况。接收操作在准备好元素值的副本之后，一定会删除掉通道中的原值，绝不会出现通道中仍有残留的情况。</li>
<li>发送操作在完全完成之前会被阻塞。接收操作也是如此。</li>
</ol>
<p><strong>元素值从外界进入通道时会被复制。更具体地说，进入通道的并不是在接收操作符右边的那个元素值，而是它的副本</strong>。</p>
<p><strong>对于通道中的同一个元素值来说，发送操作和接收操作之间也是互斥的。例如，虽然会出现，正在被复制进通道但还未复制完成的元素值，<br>但是这时它绝不会被想接收它的一方看到和取走</strong>。</p>
<h3 id="发送操作和接收操作在什么时候可能被长时间的阻塞"><a href="#发送操作和接收操作在什么时候可能被长时间的阻塞" class="headerlink" title="发送操作和接收操作在什么时候可能被长时间的阻塞"></a>发送操作和接收操作在什么时候可能被长时间的阻塞</h3><ul>
<li>针对<strong>缓冲通道</strong>的情况。如果通道已满，那么对它的所有发送操作都会被阻塞，直到通道中有元素值被接收走。相对的，如果通道已空，<br>那么对它的所有接收操作都会被阻塞，直到通道中有新的元素值出现。这时，通道会通知最早等待的那个接收操作所在的 goroutine，<br>并使它再次执行接收操作。</li>
<li>对于<strong>非缓冲通道</strong>，情况要简单一些。无论是发送操作还是接收操作，一开始执行就会被阻塞，直到配对的操作也开始执行，才会继续传递。</li>
<li><strong>对于值为 <code>nil</code> 的通道，不论它的具体类型是什么，对它的发送操作和接收操作都会永久地处于阻塞状态</strong>。它们所属的 goroutine<br>中的任何代码，都不再会被执行。注意，由于通道类型是引用类型，所以它的零值就是 <code>nil</code>。<strong>当我们只声明该类型的变量但没<br>有用 <code>make</code> 函数对它进行初始化时，该变量的值就会是 <code>nil</code>。我们一定不要忘记初始化通道</strong>！</li>
</ul>
<h3 id="select-多路复用"><a href="#select-多路复用" class="headerlink" title="select 多路复用"></a>select 多路复用</h3><p><code>select</code> 语句是专为通道而设计的，<strong>所以每个 <code>case</code> 表达式中都只能包含操作通道的表达式</strong>，比如接收表达式。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> communication clause  :</span><br><span class="line">      ...     </span><br><span class="line">  <span class="keyword">case</span> communication clause  :</span><br><span class="line">      ... </span><br><span class="line">  <span class="keyword">default</span> : <span class="comment">/* 可选 */</span></span><br><span class="line">			... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果有多个 <code>channel</code> 需要接受消息，如果第一个 <code>channel</code> 没有消息发过来，那么程序会被阻塞，第二个 <code>channel</code> 的消息就也<br>无法接收了。这时候就需要使用 <code>select</code> 多路复用。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> &lt;-ch1:</span><br><span class="line">      ...     </span><br><span class="line">  <span class="keyword">case</span> x := &lt;-ch2:</span><br><span class="line">			... </span><br><span class="line">	<span class="keyword">case</span> ch3 &lt;- y:</span><br><span class="line">	    ...		</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">			... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>每一个 <code>case</code> 代表一个通信操作，发送或者接收。<strong>如果没有 <code>case</code> 可运行，它将阻塞，直到有 <code>case</code> 可运行</strong>。<br>如果多个 <code>case</code> 同时满足条件，<code>select</code> 会<strong>随机</strong>地选择一个执行。</p>
<p><strong>为了避免因为发送或者接收导致的阻塞，尤其是当 <code>channel</code> 没有准备好写或者读时。<code>default</code> 可以设置当其它的操作<br>都不能够马上被处理时程序需要执行哪些逻辑</strong>。</p>
<h3 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h3><p>我们可以利用 <code>select</code> 来设置超时，避免 <code>goroutine</code> 阻塞的情况：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	o := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">				<span class="keyword">case</span> v := &lt;- c:</span><br><span class="line">					fmt.<span class="built_in">println</span>(v)</span><br><span class="line">				<span class="keyword">case</span> &lt;- time.After(<span class="number">5</span> * time.Second):</span><br><span class="line">					fmt.<span class="built_in">println</span>(<span class="string">"timeout"</span>)</span><br><span class="line">					o &lt;- <span class="literal">true</span></span><br><span class="line">					<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	&lt;- o</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="使用-select-语句的时候，需要注意的事情"><a href="#使用-select-语句的时候，需要注意的事情" class="headerlink" title="使用 select 语句的时候，需要注意的事情"></a>使用 select 语句的时候，需要注意的事情</h4><ol>
<li>如果加入了默认分支，那么无论涉及通道操作的表达式是否有阻塞，<code>select</code> 语句都不会被阻塞。如果那几个表达式都阻塞了，或者<br>说都没有满足求值的条件，那么默认分支就会被选中并执行。</li>
<li>如果没有加入默认分支，那么一旦所有的 <code>case</code> 表达式都没有满足求值条件，那么 <code>select</code> 语句就会被阻塞。<br>直到至少有一个 <code>case</code> 表达式满足条件为止。</li>
<li>还记得吗？我们可能会因为通道关闭了，而直接从通道接收到一个其元素类型的零值。所以，在很多时候，我们需要通过接收表达式<br>的第二个结果值来判断通道是否已经关闭。一旦发现某个通道关闭了，我们就应该及时地屏蔽掉对应的分支或者采取其他措施。这对<br>于程序逻辑和程序性能都是有好处的。</li>
<li><code>select</code> 语句只能对其中的每一个 <code>case</code> 表达式各求值一次。所以，如果我们想连续或定时地操作其中的通道的话，就往往需要<br>通过在 <code>for</code> 语句中嵌入 <code>select</code> 语句的方式实现。但这时要注意，<strong>简单地在 <code>select</code> 语句的分支中使用 <code>break</code> 语句，只能结<br>束当前的 <code>select</code> 语句的执行，而并不会对外层的 <code>for</code> 语句产生作用。这种错误的用法可能会让这个 <code>for</code> 语句无休止地运行下去</strong>。</li>
</ol>
<p><code>break</code> 退出嵌套循环：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">I:</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">5</span>; j++ &#123;</span><br><span class="line">			<span class="keyword">if</span> j == <span class="number">2</span> &#123;</span><br><span class="line">				<span class="keyword">break</span> I</span><br><span class="line">			&#125;</span><br><span class="line">			fmt.Println(<span class="string">"hello"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println(<span class="string">"hi"</span>)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">intChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line"><span class="comment">// 一秒后关闭通道。</span></span><br><span class="line">time.AfterFunc(time.Second, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="built_in">close</span>(intChan)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> _, ok := &lt;-intChan:</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">      fmt.Println(<span class="string">"The candidate case is closed."</span>)</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"The candidate case is selected."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码 <code>select</code> 语句只有一个候选分支，我在其中利用接收表达式的第二个结果值对 <code>intChan</code> 通道是否已关闭做了判断，并在<br>得到肯定结果后，通过 <code>break</code> 语句立即结束当前 <code>select</code> 语句的执行。</p>

        <div id="react-support-footer-root"></div>
      </div>
    </div>
  </div>
</div>

    


    

    <!-- js vendors -->
    <script src="//code.jquery.com/jquery-3.2.1.min.js" crossorigin="anonymous"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/lunr.js/2.1.0/lunr.min.js"></script>

    <!-- js source  -->
    <script src="/golang-learn/script/doc.js"></script>

    

  </body>
</html>
