# 数据类型
Go 语言的四类数据类型
- 基础类型，数值、字符串和布尔型
- 复合类型，数组和结构体
- 引用类型，指针、切片、字典、函数、通道
- 接口类型

## 基础类型
### 数值类型
#### 整型
- `uint`，无符号 32 或 64 位整型
- `uint8`，无符号 8 位整型 (0 到 255)
- `uint16`，无符号 16 位整型 (0 到 65535)
- `uint32`，无符号 32 位整型 (0 到 4294967295)
- `uint64`，无符号 64 位整型 (0 到 18446744073709551615)
- `int`，有符号 32 或 64 位整型
- `int8`，有符号 8 位整型 (-128 到 127)
- `int16`，有符号 16 位整型 (-32768 到 32767)
- `int32`，有符号 32 位整型 (-2147483648 到 2147483647)
- `int64`，有符号 64 位整型 (-9223372036854775808 到 9223372036854775807)

`int`和`uint`对应的是 CPU 平台机器的字大小。

#### 浮点数
- `float32`，IEEE-754 32位浮点型数，`math.MaxFloat32`表示`float32`能表示的最大数值，大约是`3.4e38`。
- `float64`，IEEE-754 64位浮点型数，`math.MaxFloat64`表示`float64`能表示的最大数值，大约是`1.8e308`。

#### 复数
- `complex64`，对应`float32`浮点数精度。
- `complex128`，对应`float64`浮点数精度。

内置`complex`函数创建复数。`math/cmplx`包提供了复数处理的许多函数。

#### 其他数值类型
- `byte`，等价于`uint8`，通常用于表示一个`Unicode`码点。
- `rune`，等价于`int32`，一般用于强调数值是一个原始的数据而不是一个小的整数。
- `uintptr`，无符号整型，用于存放一个指针，没有指定具体的`bit`大小。

### 布尔类型
布尔类型的值只有两种：`true`和`false`。

### 字符串
字符串就是一串固定长度的字符连接起来的字符序列，不可改变。Go 的字符串是由单个字节连接起来的。Go 的字符串的字节使用`UTF-8`编码标识`Unicode`文本。

#### 字符串操作
- 内置函数`len`可以获取字符串的长度。
- 可以通过`string[index]`获取某个索引位置的字节值，字符串是不可修改的，不能使用`string[index] = "string2"`这种方式
改变字符串。
- `string[i, l]`获取`string`从第`i`个字节位置开始的`l`个字节，返回一个新的字符串。如：
	```go
	s := "hello, world"
	fmt.Println(s[0:5]) // "hello"

	fmt.Println(s[:5]) // "hello"
  fmt.Println(s[7:]) // "world"
  fmt.Println(s[:])  // "hello, world"
	```
- `+`拼接字符串，如`fmt.Println("goodbye" + s[5:])`输出`"goodbye, world"`。
- 使用`==`和`<`进行字符串比较。

一个原生的字符串面值形式是\`...\`，使用反引号代替双引号。在原生的字符串面值中，没有转义操作；全部的内容都是字面的意思，包含退格和换行。

## 复合数据类型
### 数组
数组是一个由固定长度的指定类型元素组成的序列。由于数组长度是固定的，所以使用`slice`会更灵活，`slice`是动态的，长度可以增加也可以减少。
数组的长度在编译阶段确定。

声明数组：
```go
var 变量名 [SIZE]类型
```

内置函数`len`获取数组长度。通过下标访问元素：
```go
var a [3]int             // array of 3 integers
fmt.Println(a[0])        // print the first element
fmt.Println(a[len(a)-1]) // print the last element, a[2]
```
默认情况下，数组的每个元素都被初始化为元素类型对应的零值。
初始化数组：
```go
var q [3]int = [3]int{1, 2, 3}
var r [3]int = [3]int{1, 2}
fmt.Println(r[2]) // "0"

q := [...]int{1, 2, 3}
fmt.Printf("%T\n", q) // "[3]int"
```
初始化数组中`{}`中的元素个数不能大于`[]`中的数字。
上面代码中的`...`省略号，表示数组的长度是根据初始化值的个数来计算。

#### 二维数组
```go
a = [3][4]int{  
 {0, 1, 2, 3} ,   /*  第一行索引为 0 */
 {4, 5, 6, 7} ,   /*  第二行索引为 1 */
 {8, 9, 10, 11},   /* 第三行索引为 2 */
}
fmt.Printf("a[%d][%d] = %d\n", 2, 3, a[2][3] )
```

`==`和`!=`比较运算符来比较两个数组，只有当两个数组的所有元素都是相等的时候数组才是相等的。

#### 数组传入函数
当调用函数时，函数的形参会被赋值，**所以函数参数变量接收的是一个复制的副本，并不是原始调用的变量。** 但是
这种机制，如果碰到传递一个大数组时，效率较低。这个时候可以显示的传入一个数组指针（其他语言其实是隐式的传递指针）。
```go
func test(ptr *[32]byte) {
	for i := range ptr {
			ptr[i] = 0
	}
}
```

### slice
### map
### 结构体