# 介绍
## 命名
所有命名只能以字母或者`_`开头，可以包含字母，数字或者`_`。区分大小写。
关键字不能定义变量名，如`func`，`default`。

注意：函数内部定义的，只能在函数内部使用（函数级），在函数外部定义的（包级），可以在当前包的所有文件中是使用。
并且，是在函数外定义的名字，如果以大写字母开头，那么会被导出，也就是在包的外部也可以访问，所以定义名字时，要注意大小写。

## 声明
- `var`声明变量
- `const`声明常量
- `type`声明类型
- `func`声明函数

每个文件以`package`声明语句。比如`package main`。

## 变量
`var`声明变量，必须使用空格隔开：
```go
var 变量名字 类型 = 表达式
```
类型 或者 表达式可以省略其中的一个。也就是如果没有类型，可以通过表达式推导出类型，**没有表达式，将会根据类型初始化为对应的零值**。
对应关系：
- 数值类型：`0`
- 布尔类型：`false`
- 字符串：`""`
- 接口或引用类型（包括slice、指针、map、chan和函数）：`nil`

### 声明一组变量
```go
var 变量名字 变量名字 变量名字 ... 类型 = 表达式, 表达式, 表达式, ...
```
比如：
```go
// 声明一组`int`类型
var i, j, k int                 // int, int, int

// 声明一组不同类型
var b, f, s = true, 2.3, "four" // bool, float64, string
```

### 简短声明
`:=`只能在函数内使用，也就是只能声明局部变量，Go 会自动推导出类型：
```go
变量名字 := 表达式
```

### 指针
```go
x := 1
p := &x         // p, of type *int, points to x
fmt.Println(*p) // "1"
*p = 2          // equivalent to x = 2
fmt.Println(x)  // "2"
```

上面的代码，初始化一个变量`x`，`&`是取地址操作，`&x`就是取变量`x`的内存地址，那么`p`就是一个指针，
类型是`*int`，`p`这个指针保存了变量`x`的内存地址。接下来`*p`表示读取指针指向的变量的值，也就是变量`x`的值`1`。
`*p`也可以被赋值。

任何类型的指针的零值都是`nil`。当指针指向同一个变量或者`nil`时是相等的。

### new
`new`函数可以创建变量，返回变量的地址。`new`函数很少使用，直接使用字面量语法创建更灵活。
```go
new(T)
```
返回指针类型为`*T`。
如：
```go
p := new(int)   // p, *int 类型, 指向匿名的 int 变量
fmt.Println(*p) // "0"
*p = 2          // 设置 int 匿名变量的值为 2
fmt.Println(*p) // "2"
```
### 生命周期
对于在包一级声明的变量，它们的生命周期和程序的运行周期是一致的。
局部变量（包括函数的参数和返回值也是局部变量）的生命周期则是动态的：每次从创建一个新变量的声明语句开始，
直到该变量不再被引用为止，然后变量的存储空间可能被回收。

## 赋值
常见的赋值的方式：
```go
x = 1                       // 命名变量的赋值
*p = true                   // 通过指针间接赋值
person.name = "bob"         // 结构体字段赋值
count[x] = count[x] * scale // 数组、slice或map的元素赋值
count[x] *= scale           // 等价于 count[x] = count[x] * scale，但是省去了对变量表达式的重复计算
x, y = y, x                 // 交换值
f, err = os.Open("foo.txt") // 左边变量的数目必须和右边一致，函数一般会返回一个`error`类型
v, ok = m[key]              // map查找，返回布尔值类表示操作是否成功
v = m[key]                  // map查找，也可以返回一个值，失败时返回零值
```

不管是隐式还是显式地赋值，在赋值语句左边的变量和右边最终的求到的值必须有相同的数据类型。这就是**可赋值性**。

## 类型
创建了一个新的类型名称，一般出现在包一级，与变量一样，如果类型名字的首字母是大写，则在包外部也可以使用：
```go
type 类型名字 底层类型
```

如不同温度单位分别定义为不同的类型：
```go
type Celsius float64    // 摄氏温度
type Fahrenheit float64 // 华氏温度

const (
    AbsoluteZeroC Celsius = -273.15 // 绝对零度
    FreezingC     Celsius = 0       // 结冰点温度
    BoilingC      Celsius = 100     // 沸水温度
)

func CToF(c Celsius) Fahrenheit { return Fahrenheit(c*9/5 + 32) }

func FToC(f Fahrenheit) Celsius { return Celsius((f - 32) * 5 / 9) }
```

## 包
Go 语言的包与其他语言的`modules`或者`libraries`类似。每个包都对应一个独立的名字空间，如：
`image`包和`unicode/utf16`包中都包含了`Decode`。要在外部引用该函数，必须显式使用image.Decode或utf16.Decode形式访问。

包内以大写字母开头定义的名字（包括变量，类型，函数等等），会被导出，可以在包的外部访问。

### 导入包

每个包都有一个全局唯一的导入路径，