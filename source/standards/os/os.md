## os包中的API
是os代码包中的 API。这个代码包可以让我们拥有操控计算机操作系统的能力。不论是 Linux、macOS、Windows，还是 FreeBSD、OpenBSD、Plan9，os代码包都可以为之提供统一的使用接口。

**os包中的 API 主要可以帮助我们使用操作系统中的文件系统、权限系统、环境变量、系统进程以及系统信号**。

### os.File类型
`os.File`类型拥有的都是指针方法，所以除了空接口之外，它本身没有实现任何接口。而它的指针类型则实现了很多io代码包中的接口。

对于io包中最核心的 3 个简单接口`io.Reader`、`io.Writer`和`io.Closer`，`*os.File`类型都实现了它们。

其他实现的接口：`io.ReaderAt`、`io.Seeker`和`io.WriterAt`。

### os.File类型怎样操作文件
os包中，有这样几个函数，即：`Create`、`NewFile`、`Open`和`OpenFile`。

- `os.Create`函数用于根据给定的路径创建一个新的文件。它会返回一个`File`值和一个错误值。我们可以在该函数返回的`File`值之上，对相应的文件进行读操作和写操作。
如果在我们给予`os.Create`函数的路径之上**已经存在了一个文件，那么该函数会先清空现有文件中的全部内容**，然后再把它作为第一个结果值返回。
- `os.NewFile`函数。该函数在被调用的时候需要接受一个代表文件描述符的、`uintptr`类型的值，以及一个用于表示文件名的字符串值。如果我们给定的文件描述符
并不是有效的，那么这个函数将会返回`nil`，否则，它将会返回一个代表了相应文件的`File`值。**注意，不要被这个函数的名称误导了，它的功能并不是创建一个新的文件，而是依据一个已经
存在的文件的描述符，来新建一个包装了该文件的File值**。
- `os.Open`函数会打开一个文件并返回包装了该文件的`File`值。然而，该函数只能以只读模式打开文件。换句话说，我们只能从该函数返回的`File`值中读取内容，而不能向它写入任何内容。
- `os.OpenFile`这个函数其实是`os.Create`函数和`os.Open`函数的底层支持，它最为灵活。这个函数有 3 个参数，分别名为`name`、`flag`和`perm`。其中的`name`指代的就是文件的路径。
而`flag`参数指的则是需要施加在文件描述符之上的模式，可选项。这个只读模式由常量`os.O_RDONLY`代表，它是`int`类型的。`perm`代表的也是模式，它的类型是`os.FileMode`，此类型是一个
基于`uint32`类型的再定义类型。`flag`指代的模式叫做操作模式，而把参数`perm`指代的模式叫做权限模式。前者限定了操作文件的方式，而后者则可以控制文件的访问权限。

可以像这样拿到一个包装了标准错误输出的`File`值：
```go
file3 := os.NewFile(uintptr(syscall.Stderr), "/dev/stderr")

if file3 != nil {
    defer file3.Close()
    file3.WriteString("The Go language program writes the contents into stderr.\n")
}
```

所谓的文件描述符，是由通常很小的非负整数代表的。它一般会由 I/O 相关的系统调用返回，并作为某个文件的一个标识存在。

从操作系统的层面看，针对任何文件的 I/O 操作都需要用到这个文件描述符。只不过，Go 语言中的一些数据类型，为我们隐匿掉了这个描述符，如此一来我们就无需时刻关注和辨别它了
（就像os.File类型这样）。

实际上，我们在调用前文所述的`os.Create`函数、`os.Open`函数以及将会提到的`os.OpenFile`函数的时候，它们都会执行同一个系统调用，并且在成功之后得到这样一个文件描述符。
这个文件描述符将会被储存在它们返回的File值中。

`os.File`类型有一个指针方法，名叫`Fd`。它在被调用之后将会返回一个`uintptr`类型的值。这个值就代表了当前的File值所持有的那个文件描述符。

不过，在os包中，除了`NewFile`函数需要用到它，它也没有什么别的用武之地了。所以，如果你操作的只是常规的文件或者目录，那么就无需特别地在意它了。

### 可应用于File值的操作模式
`File`值的操作模式主要有只读模式、只写模式和读写模式。**这些模式分别由常量`os.O_RDONLY`、`os.O_WRONLY`和`os.O_RDWR`代表**。

额外的操作模式，可选项如下所示：
- `os.O_APPEND`：当向文件中写入内容时，把新内容追加到现有内容的后边。
- `os.O_CREATE`：当给定路径上的文件不存在时，创建一个新文件。
- `os.O_EXCL`：需要与`os.O_CREATE`一同使用，表示在给定的路径上不能有已存在的文件。
- `os.O_SYNC`：在打开的文件之上实施同步 I/O。它会保证读写的内容总会与硬盘上的数据保持同步。
- `os.O_TRUNC`：如果文件已存在，并且是常规的文件，那么就先清空其中已经存在的任何内容。

操作模式的使用，os.Create函数和os.Open函数都是现成的例子：
```go
func Create(name string) (*File, error) {
    return OpenFile(name, O_RDWR|O_CREATE|O_TRUNC, 0666)
}
```
`os.Create`函数在调用`os.OpenFile`函数的时候，给予的操作模式是`os.O_RDWR`、`os.O_CREATE`和`os.O_TRUNC`的组合。

### 怎样设定常规文件的访问权限
`os.FileMode`是基于`uint32`类型的再定义类型，所以它的每个值都包含了 32 个比特位。在这 32 个比特位当中，每个比特位都有其特定的含义。

比如，如果在其最高比特位上的二进制数是1，那么该值表示的文件模式就等同于`os.ModeDir`，也就是说，相应的文件代表的是一个目录。

又比如，如果其中的第 26 个比特位上的是1，那么相应的值表示的文件模式就等同于`os.ModeNamedPipe`，也就是说，那个文件代表的是一个命名管道。

在一个**`os.FileMode`类型的值（以下简称FileMode值）中，只有最低的 9 个比特位才用于表示文件的权限**。

当我们拿到一个此类型的值时，可以把它**和`os.ModePerm`常量的值做按位与**操作。

这个常量的值是`0777`，是一个八进制的无符号整数，其最低的 9 个比特位上都是1，而更高的 23 个比特位上都是0。

所以，经过这样的按位与操作之后，我们即可得到这个FileMode值中所有用于表示文件权限的比特位，也就是该值所表示的权限模式。
