---
title: 内存分配
---
# 内存分配
## 基本策略
1. 每次从操作系统申请一大块内存（如 1MB），以减少系统调用。
2. 将申请到的大块内存按照特定大小切分成小块，够成链表。
3. 为对象分配内存时，只需从大小合适的链表提取一小块即可。
4. 回收对象内存时，将小块内存还给原链表，以便复用。
5. 如果闲置内存过多，则尝试把部分内存还给操作系统，降低开销。

> **内存分配器**只管理内存，不关心对象的状态，并且它不会主动回收内存，需要**垃圾回收器**在完成清理操作后，
触发内存分配器的回收操作。

## 内存块
内存分配器管理的内存分为两种：
- **span**：多个地址连续的**页**（page）组成的大块内存。
- **object**：将 span 按特定大小切分成多个小块，每个小块可存储一个对象。

分配器按页数区分大小不同的 span。例如，以页数为单位将 span 存放到管理数组中，需要时就以页数为索引进行查找。
span 的大小不是固定不变的。在获取闲置 span 时，如果没有找到大小合适的，那么会选择页数更多的 span，此时
就会引发**裁剪**，将 span 多余的部分构成一个新的小的 span 放回管理数组。另外，分配器还会把相邻的空闲的
 span 合并构建更大的内存块，减少碎片。
 
## tcmalloc
Go 的内存分配器采用的是 tcmalloc 架构。
 
由三种组件组成：
- **cache**：运行期的每个线程都会绑定一个 cache，用于给没有锁的 object 的分配。
- **central**：为所有 cache 提供切分好的后备 sapn 资源。
- **heap**：管理闲置的 span，需要的时候向操作系统申请新的内存。

## 回收
**内存回收的源头是垃圾清理操作**。**回收不是释放**，因为内存分配器的核心是**内存复用**。不再使用的内存，放到合适的位置等待再次
分配时使用。只有闲置内存过多时，才考虑释放。

回收操作以 span 为单位。

## 释放
监控线程 sysmon 每隔一段时间就会检查 heap 里的闲置内存块，如果闲置时间超过阈值，则释放其关联的物理内存。