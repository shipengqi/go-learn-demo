---
title: slice
---
# slice
`slice` 的语法和数组很像，由于数组长度是固定的，所以使用 `slice` 相比数组会更灵活，`slice` 是动态的，
长度可以增加也可以减少。还有一点与数组不同，切片不需要说明长度。

**切片（slice） 是对底层数组一个连续片段的引用，所以切片是一个引用类型**。

**定义切片，和定义数组的区别就是不需要指定 `SIZE`**：
```go
var 变量名 []类型
```
一个 `slice` 由三个部分构成：指针、长度和容量。长度不能超过容量。
一个切片在未初始化之前默认为 `nil`，长度为 `0`。

初始化切片：
```go
// 直接初始化切片，[] 表示是切片类型，{1,2,3} 初始化值依次是 1,2,3.其 cap=len=3
s :=[]int {1,2,3}

// 初始化切片 s,是数组 arr 的引用
s := arr[:]

// 将 arr 中从下标 startIndex 到 endIndex-1 下的元素创建为一个新的切片
s := arr[startIndex:endIndex] 

// 缺省 endIndex 时将表示一直到 arr 的最后一个元素
s := arr[startIndex:] 

// 缺省 startIndex 时将表示从 arr 的第一个元素开始
s := arr[:endIndex]

// 使用 make 函数来创建切片
// len 是数组的长度并且也是切片的初始长度
// capacity 为可选参数, 指定容量
s := make([]int, len, capacity)
```

## len() 和 cap()
- `len`获取切片长度。
- `cap`计算切片的最大容量

## append() 和 copy()
- `append` 向切片追加新元素
- `copy` 拷贝切片

## 截取切片
```go
/* 创建切片 */
numbers := []int{0,1,2,3,4,5,6,7,8}   

/* 打印子切片从索引 1 (包含) 到索引 4(不包含)*/
fmt.Println("numbers[1:4] ==", numbers[1:4]) // numbers[1:4] == [1 2 3]

/* 默认下限为 0*/
fmt.Println("numbers[:3] ==", numbers[:3]) // numbers[:3] == [0 1 2]

/* 默认上限为 len(s)*/
fmt.Println("numbers[4:] ==", numbers[4:]) // numbers[4:] == [4 5 6 7 8]

numbers1 := make([]int,0,5)

/* 打印子切片从索引  0 (包含) 到索引 2 (不包含) */
number2 := numbers[:2]
fmt.Printf("len=%d cap=%d slice=%v\n",len(number2),cap(number2),number2) // len=2 cap=9 slice=[0 1]
/* 打印子切片从索引 2 (包含) 到索引 5 (不包含) */
number3 := numbers[2:5]
fmt.Printf("len=%d cap=%d slice=%v\n",len(number3),cap(number3),number3) // len=3 cap=7 slice=[2 3 4]
```

## 怎样估算切片容量的增长

一旦**一个切片无法容纳更多的元素，Go 语言就会想办法扩容。但它并不会改变原来的切片，而是会生成一个容量更大的切片，
然后将把原有的元素和新元素一并拷贝到新切片中**。一般的情况下，你**可以简单地认为新切片的容量（以下简称新容量）将会是
原切片容量（以下简称原容量）的 2 倍**。

但是，当原切片的长度（以下简称原长度）大于或等于 1024 时，Go 语言将会以原容量的 1.25 倍作为新容量的基准（以下新容量基准）。
新容量基准会被调整（不断地与 1.25 相乘），直到结果不小于原长度与要追加的元素数量之和（以下简称新长度）。最终，新容量
往往会、比新长度大一些，当然，相等也是可能的。

一个切片的底层数组永远不会被替换。为什么？虽然在扩容的时候 Go 语言一定会生成新的底层数组，但是它也同时生成了新的切片。它是把新
的切片作为了新底层数组的窗口，而没有对原切片及其底层数组做任何改动。

**在无需扩容时，`append` 函数返回的是指向原底层数组的新切片，而在需要扩容时，`append` 函数返回的是指向新底层数组的新切片**。

## 长度和容量
`Slice` 有两个比较混淆的概念，就是长度和容量。这个长度跟数组的长度是一个概念，即在内存中进行了初始化实际存在的元素的个数。何谓容量？
如果通过 `make` 函数创建 `Slice` 的时候指定了容量参数，那内存管理器会根据指定的容量的值先划分一块内存空间，然后才在其中存放有数组元素，
多余部分处于空闲状态，在 `Slice` 上追加元素的时候，首先会放到这块空闲的内存中，如果添加的参数个数超过了容量值，内存管理器会重新划
分一块容量值为原容量值 `*2` 大小的内存空间，依次类推。这个机制的好处在能够提升运算性能，因为内存的重新划分会降低性能。