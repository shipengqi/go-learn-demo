<!DOCTYPE html>
<html lang="en">
  <head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">

    <title>Golang learning | time </title>
    <meta name="description" content>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    

    <!-- fonts -->
    <link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700" rel="stylesheet">
    <link href="//fonts.googleapis.com/css?family=Ubuntu:300,400,500,600,700" rel="stylesheet">

    <!-- stylesheets -->
    <link rel="stylesheet" href="/golang-learn/style/doc.css">

    <!-- favicon -->
    <link rel="icon" href="/golang-learn/images/favicon.ico">

    

  </head>
  <body>

   <script>window.__INITIAL_STATE__ = {"page":{"title":"time","path":"standards/time.html"},"data":{"navigation":{"logo":{"text":"Golang Learn","type":"link","path":"index.html"},"main":[{"text":"Golang 基础","type":"label"},{"text":"Go 环境配置","type":"link","path":"basic/env_config.html"},{"text":"包","type":"link","path":"basic/package.html"},{"text":"基础数据类型","type":"link","path":"basic/basic_data.html"},{"text":"变量","type":"link","path":"basic/var.html"},{"text":"常量","type":"link","path":"basic/constant.html"},{"text":"控制语句","type":"link","path":"basic/flow.html"},{"text":"运算符","type":"link","path":"basic/operator.html"},{"text":"作用域","type":"link","path":"basic/scope.html"},{"text":"指针","type":"link","path":"basic/pointer.html"},{"text":"数组","type":"link","path":"basic/array.html"},{"text":"切片","type":"link","path":"basic/slice.html"},{"text":"字典","type":"link","path":"basic/map.html"},{"text":"函数","type":"link","path":"basic/function.html"},{"text":"结构体","type":"link","path":"basic/struct.html"},{"text":"接口","type":"link","path":"basic/interface.html"},{"text":"面向对象","type":"link","path":"basic/oop.html"},{"text":"错误","type":"link","path":"basic/error.html"},{"text":"序列化","type":"link","path":"basic/json.html"},{"text":"反射","type":"link","path":"basic/reflect.html"},{"text":"测试","type":"link","path":"basic/test.html"},{"text":"并发编程","type":"label"},{"text":"goroutine","type":"link","path":"concurrent/goroutine.html"},{"text":"channel","type":"link","path":"concurrent/channel.html"},{"text":"同步和锁","type":"link","path":"concurrent/sync_lock.html"},{"text":"内存分配","type":"label"},{"text":"内存分配","type":"link","path":"advance/mm.html"},{"text":"垃圾回收","type":"label"},{"text":"垃圾回收","type":"link","path":"advance/gc.html"},{"text":"标准库","type":"label"},{"text":"fmt","type":"link","path":"standards/io/fmt.html"},{"text":"io","type":"link","path":"standards/io/io.html"},{"text":"ioutil","type":"link","path":"standards/io/ioutil.html"},{"text":"bufio","type":"link","path":"standards/io/bufio.html"},{"text":"os","type":"link","path":"standards/os/os.html"},{"text":"filepath","type":"link","path":"standards/os/filepath.html"},{"text":"strings","type":"link","path":"standards/text/strings.html"},{"text":"strconv","type":"link","path":"standards/text/strconv.html"},{"text":"unicode","type":"link","path":"standards/text/unicode.html"},{"text":"log","type":"link","path":"standards/log.html"},{"text":"time","type":"link","path":"standards/time.html"},{"text":"http","type":"link","path":"standards/net/http.html"},{"text":"math","type":"link","path":"standards/data/math.html"},{"text":"sort","type":"link","path":"standards/data/sort.html"},{"text":"big","type":"link","path":"standards/data/big.html"},{"text":"container","type":"link","path":"standards/data/container.html"},{"text":"sql","type":"link","path":"standards/database/sql.html"},{"text":"THEME","type":"label"},{"text":"使用文档主题","type":"link","path":"theme/theme-usage.html"},{"text":"SUPPORT AND FEEDBACK","type":"label"},{"text":"Raise an Issue on Github","type":"link","path":"https://github.com/shipengqi/golang-learn/issues/new"}]}},"config":{"timezone":"UTC","root":"/golang-learn/","time_format":"HH:mm:ss","theme":"../node_modules/hexo-theme-doc","theme_config":{"swagger_ui":{"version":2,"permalinks":true,"api_explorer":true,"download":"Download specification","show_extensions":false,"deep_linking":true,"display_operation_id":false,"doc_expansion":"none"},"search":{"skip":false,"background":false,"route":"/lunr.json"},"favicon":"images/favicon.ico"}}}</script>

    <div id="react-navigation-root"><div class="doc-navigation" data-reactroot><nav class="doc-navbar"><a href="/golang-learn/index.html" class="doc-navbar__logo"><img src="/golang-learn/images/logo.png" class="doc-navbar__logo__img"><span class="doc-navbar__logo__text">Golang Learn</span></a><i class="dc-icon dc-icon--close dc-icon--interactive doc-sidebar-close doc-navbar__sidebar-close doc-navbar__sidebar-close--desktop"></i><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-navbar__sidebar-toggle"></i></nav><nav class="doc-sidebar"><div class="doc-sidebar__vertical-menu"><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-sidebar-toggle--primary doc-sidebar__vertical-menu__item"></i><i class="dc-icon dc-icon--search dc-icon--interactive doc-sidebar__vertical-menu__item doc-sidebar__vertical-menu__item--primary"></i></div><div class="doc-sidebar-content"><div class="doc-sidebar__search-form"></div><ul class="doc-sidebar-list"></ul></div></nav></div></div>
    <div class="doc-content">
  <div class="dc-page">
    <div class="dc-card">
      <div id="react-search-results-root"></div>
      <div id="page-content" class="doc-formatting">
        <h1 id="time"><a href="#time" class="headerlink" title="time"></a>time</h1><p><code>time</code> 提供了一个数据类型 <code>time.Time</code>（作为值使用）以及显示和测量时间和日期的功能函数，比如：</p>
<ul>
<li><code>time.Now()</code> 获取当前时间。</li>
<li><code>t.Day()</code>、<code>t.Minute()</code> 获取时间的一部分。</li>
<li><code>time.After</code>、<code>time.Ticker</code> 在经过一定时间或周期执行某项任务（事件处理的特例）。</li>
<li><code>time.Sleep（Duration d）</code> 暂停某个进程（ goroutine），暂停时长为 <code>d</code>。</li>
<li><code>Duration</code> 代表两个时间点之间经过的时间，以<strong>纳秒</strong>为单位，类型为 <code>int64</code>。</li>
<li><code>Location</code> 类型映射某个时区的时间，UTC 表示通用协调世界时间。</li>
</ul>
<h2 id="时区"><a href="#时区" class="headerlink" title="时区"></a>时区</h2><p>Go 语言使用 <code>Location</code> 来表示地区相关的时区，一个 <code>Location</code> 可能表示多个时区。</p>
<p><code>time</code> 包提供了 <code>Location</code> 的两个实例：</p>
<ul>
<li><code>Local</code> 代表当前系统本地时区；</li>
<li><code>UTC</code> 代表通用协调时间，也就是零时区。<code>time</code> 包默认（为显示提供时区）使用 <code>UTC</code> 时区。</li>
</ul>
<h3 id="Local-是如何做到表示本地时区的？"><a href="#Local-是如何做到表示本地时区的？" class="headerlink" title="Local 是如何做到表示本地时区的？"></a>Local 是如何做到表示本地时区的？</h3><p>在初始化 <code>Local</code> 时，通过读取 <code>/etc/localtime</code> （这是一个符号链接，指向 <code>/usr/share/zoneinfo</code> 中某一个时区）可以获取到系统本地时区。</p>
<p>如果设置了<strong>环境变量 <code>TZ</code></strong>，则会优先使用它。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">tz, ok := syscall.Getenv(<span class="string">"TZ"</span>)</span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> !ok:</span><br><span class="line">	z, err := loadZoneFile(<span class="string">""</span>, <span class="string">"/etc/localtime"</span>)</span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">		localLoc = *z</span><br><span class="line">		localLoc.name = <span class="string">"Local"</span></span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">case</span> tz != <span class="string">""</span> &amp;&amp; tz != <span class="string">"UTC"</span>:</span><br><span class="line">	<span class="keyword">if</span> z, err := loadLocation(tz); err == <span class="literal">nil</span> &#123;</span><br><span class="line">		localLoc = *z</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="获得特定时区的实例"><a href="#获得特定时区的实例" class="headerlink" title="获得特定时区的实例"></a>获得特定时区的实例</h3><p>函数 <code>LoadLocation</code> 可以根据名称获取特定时区的实例：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LoadLocation</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(*Location, error)</span></span></span><br></pre></td></tr></table></figure></p>
<p>如果 <code>name</code> 是 “” 或 “UTC”，返回 UTC；<br>如果 <code>name</code> 是 “Local”，返回 <code>Local</code>；<br>否则 <code>name</code> 应该是 IANA 时区数据库里有记录的地点名（该数据库记录了地点和对应的时区），如 “America/New_York”。</p>
<h2 id="Time"><a href="#Time" class="headerlink" title="Time"></a>Time</h2><p><code>Time</code> 代表一个纳秒精度的时间点。程序中应使用 <code>time.Time</code> 类型值来保存和传递时间，而不是指针。<br>程序中应使用 Time 类型值来保存和传递时间，而不是指针。<br>一个 Time 类型值可以被多个 go 协程同时使用。时间点可以使用 Before、After 和 Equal 方法进行比较。Sub 方法让两个时间点相减，<br>生成一个 Duration 类型值（代表时间段）。Add 方法给一个时间点加上一个时间段，生成一个新的 Time 类型时间点。</p>
<p><code>Time</code> 零值代表时间点 <code>January 1, year 1, 00:00:00.000000000 UTC</code>。因为本时间点一般不会出现在使用中，<code>IsZero</code> 方法提供<br>了检验时间是否是显式初始化的一个简单途径。</p>
<p>每一个 <code>Time</code> 都具有一个地点信息（即对应地点的时区信息），当计算时间的表示格式时，如 Format、Hour 和 Year 等方法，<br>都会考虑该信息。Local、UTC 和 In 方法返回一个指定时区（但指向同一时间点）的 Time。修改地点 / 时区信息只是会改变其表示；不会修改被表<br>示的时间点，因此也不会影响其计算。</p>
<p>通过 <code>==</code> 比较 Time 时，Location 信息也会参与比较，因此 Time 不应该作为 map 的 key。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Time <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// sec gives the number of seconds elapsed since</span></span><br><span class="line">	<span class="comment">// January 1, year 1 00:00:00 UTC.</span></span><br><span class="line">	sec <span class="keyword">int64</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// nsec specifies a non-negative nanosecond</span></span><br><span class="line">	<span class="comment">// offset within the second named by Seconds.</span></span><br><span class="line">	<span class="comment">// It must be in the range [0, 999999999].</span></span><br><span class="line">	nsec <span class="keyword">int32</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// loc specifies the Location that should be used to</span></span><br><span class="line">	<span class="comment">// determine the minute, hour, month, day, and year</span></span><br><span class="line">	<span class="comment">// that correspond to this Time.</span></span><br><span class="line">	<span class="comment">// Only the zero Time has a nil Location.</span></span><br><span class="line">	<span class="comment">// In that case it is interpreted to mean UTC.</span></span><br><span class="line">	loc *Location</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先看 <code>time.Now()</code> 函数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Now returns the current local time.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Now</span><span class="params">()</span> <span class="title">Time</span></span> &#123;</span><br><span class="line">	sec, nsec := now()</span><br><span class="line">	<span class="keyword">return</span> Time&#123;sec + unixToInternal, nsec, Local&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>now()</code> 的具体实现在 <code>runtime</code> 包中。从 <code>Time{sec + unixToInternal, nsec, Local}</code> 可以看出，<code>Time</code> 结构的 <code>sec</code> 并非 Unix<br>时间戳，实际上，加上的 <code>unixToInternal</code> 是 <code>1-1-1</code> 到 <code>1970-1-1</code> 经历的秒数。也就是 <code>Time</code> 中的 <code>sec</code> 是从 <code>1-1-1</code> 算起的秒数，<br>而不是 Unix 时间戳。</p>
<p><code>Time</code> 的最后一个字段表示地点时区信息。本章后面会专门介绍。</p>
<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><ul>
<li><code>Time.IsZero()</code> 函数用于判断 Time 表示的时间是否是 0 值。表示 1 年 1 月 1 日。</li>
<li><code>time.Unix(sec, nsec int64</code>) 通过 Unix 时间戳生成 <code>time.Time</code> 实例；</li>
<li><code>time.Time.Unix()</code> 得到 Unix 时间戳；</li>
<li><code>time.Time.UnixNano()</code> 得到 Unix 时间戳的纳秒表示；</li>
<li><code>time.Parse</code> 和 <code>time.ParseInLocation</code></li>
<li><code>time.Time.Format</code></li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t, _ := time.Parse(<span class="string">"2006-01-02 15:04:05"</span>, <span class="string">"2016-06-13 09:14:00"</span>)</span><br><span class="line">fmt.Println(time.Now().Sub(t).Hours())</span><br></pre></td></tr></table></figure>
<p>这段代码的结果跟预期的不一样。原因是 <code>time.Now()</code> 的时区是 <code>time.Local</code>，而 <code>time.Parse</code> 解析出来的时区却是 <code>time.UTC</code><br>（可以通过 <code>Time.Location()</code> 函数知道是哪个时区）。在中国，它们相差 8 小时。</p>
<p>所以，一般的，我们应该总是使用 <code>time.ParseInLocation</code> 来解析时间，并给第三个参数传递 <code>time.Local</code>。</p>
<h4 id="为什么是-2006-01-02-15-04-05"><a href="#为什么是-2006-01-02-15-04-05" class="headerlink" title="为什么是 2006-01-02 15:04:05"></a>为什么是 2006-01-02 15:04:05</h4><p>可能你已经注意到：<code>2006-01-02 15:04:05</code> 这个字符串了。没错，这是固定写法，类似于其他语言中 <code>Y-m-d H:i:s</code> 等。为什么采用这种形式？<br>又为什么是这个时间点而不是其他时间点？</p>
<ul>
<li>官方说，使用具体的时间，比使用 <code>Y-m-d H:i:s</code> 更容易理解和记忆；</li>
<li>而选择这个时间点，也是出于好记的考虑，官方的例子：<code>Mon Jan 2 15:04:05 MST 2006</code>，很好记：2006 年 1 月 2 日 3 点 4 分 5 秒</li>
</ul>
<h4 id="Round-和-Truncate-方法"><a href="#Round-和-Truncate-方法" class="headerlink" title="Round 和 Truncate 方法"></a>Round 和 Truncate 方法</h4><p>比如，有这么个需求：获取当前时间整点的 <code>Time</code> 实例。例如，当前时间是 <code>15:54:23</code>，需要的是 <code>15:00:00</code>。我们可以这么做：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t, _ := time.ParseInLocation(&quot;2006-01-02 15:04:05&quot;, time.Now().Format(&quot;2006-01-02 15:00:00&quot;), time.Local)</span><br><span class="line">fmt.Println(t)</span><br></pre></td></tr></table></figure>
<p>实际上，<code>time</code> 包给我们提供了专门的方法，功能更强大，性能也更好，这就是 <code>Round</code> 和 <code>Trunate</code>，它们区别，一个是取最接近的，一个是向下取整。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">t, _ := time.ParseInLocation(<span class="string">"2006-01-02 15:04:05"</span>, <span class="string">"2016-06-13 15:34:39"</span>, time.Local)</span><br><span class="line"><span class="comment">// 整点（向下取整）</span></span><br><span class="line">fmt.Println(t.Truncate(<span class="number">1</span> * time.Hour))</span><br><span class="line"><span class="comment">// 整点（最接近）</span></span><br><span class="line">fmt.Println(t.Round(<span class="number">1</span> * time.Hour))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 整分（向下取整）</span></span><br><span class="line">fmt.Println(t.Truncate(<span class="number">1</span> * time.Minute))</span><br><span class="line"><span class="comment">// 整分（最接近）</span></span><br><span class="line">fmt.Println(t.Round(<span class="number">1</span> * time.Minute))</span><br><span class="line"></span><br><span class="line">t2, _ := time.ParseInLocation(<span class="string">"2006-01-02 15:04:05"</span>, t.Format(<span class="string">"2006-01-02 15:00:00"</span>), time.Local)</span><br><span class="line">fmt.Println(t2)</span><br></pre></td></tr></table></figure>
<h4 id="Format"><a href="#Format" class="headerlink" title="Format"></a>Format</h4><p>自定义时间格式化字符串，例如： <code>fmt.Printf(&quot;%02d.%02d.%4d\n&quot;, t.Day(), t.Month(), t.Year())</code> 将会输出 <code>21.07.2011</code>。</p>
<p>包中的一个预定义函数 <code>func (t Time) Format(layout string) string</code> 可以根据一个格式化字符串来将一个时间 t 转换为相应<br>格式的字符串，你可以使用一些预定义的格式，如：<code>time.ANSIC</code> 或 <code>time.RFC822</code>。</p>
<p>一般的格式化设计是通过对于一个标准时间的格式化描述来展现的，示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(t.Format(<span class="string">"02 Jan 2006 15:04"</span>)) <span class="comment">// 21 Jul 2011 10:31</span></span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> week time.Duration</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	t := time.Now()</span><br><span class="line">	fmt.Println(t) <span class="comment">// e.g. Wed Dec 21 09:52:14 +0100 RST 2011</span></span><br><span class="line">	fmt.Printf(<span class="string">"%02d.%02d.%4d\n"</span>, t.Day(), t.Month(), t.Year())</span><br><span class="line">	<span class="comment">// 21.12.2011</span></span><br><span class="line">	t = time.Now().UTC()</span><br><span class="line">	fmt.Println(t) <span class="comment">// Wed Dec 21 08:52:14 +0000 UTC 2011</span></span><br><span class="line">	fmt.Println(time.Now()) <span class="comment">// Wed Dec 21 09:52:14 +0100 RST 2011</span></span><br><span class="line">	<span class="comment">// calculating times:</span></span><br><span class="line">	week = <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span> * <span class="number">7</span> * <span class="number">1e9</span> <span class="comment">// must be in nanosec</span></span><br><span class="line">	week_from_now := t.Add(time.Duration(week))</span><br><span class="line">	fmt.Println(week_from_now) <span class="comment">// Wed Dec 28 08:52:14 +0000 UTC 2011</span></span><br><span class="line">	<span class="comment">// formatting times:</span></span><br><span class="line">	fmt.Println(t.Format(time.RFC822)) <span class="comment">// 21 Dec 11 0852 UTC</span></span><br><span class="line">	fmt.Println(t.Format(time.ANSIC)) <span class="comment">// Wed Dec 21 08:56:34 2011</span></span><br><span class="line">	fmt.Println(t.Format(<span class="string">"02 Jan 2006 15:04"</span>)) <span class="comment">// 21 Dec 2011 08:52</span></span><br><span class="line">	s := t.Format(<span class="string">"20060102"</span>)</span><br><span class="line">	fmt.Println(t, <span class="string">"=&gt;"</span>, s)</span><br><span class="line">	<span class="comment">// Wed Dec 21 08:52:14 +0000 UTC 2011 =&gt; 20111221</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例，计算函数执行时间：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">start := time.Now() <span class="comment">// 起始时间</span></span><br><span class="line">longCalculation()</span><br><span class="line">end := time.Now() <span class="comment">// 结束时间</span></span><br><span class="line">delta := end.Sub(start) <span class="comment">// 消耗时间</span></span><br><span class="line">fmt.Printf(<span class="string">"longCalculation took this amount of time: %s\n"</span>, delta)</span><br></pre></td></tr></table></figure></p>
<h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><p><code>time</code> 包有两种定时器：</p>
<ul>
<li><code>Timer</code>（到达指定时间触发且只触发一次）</li>
<li><code>Ticker</code>（间隔特定时间触发）。</li>
</ul>
<h3 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Timer <span class="keyword">struct</span> &#123;</span><br><span class="line">	C &lt;-<span class="keyword">chan</span> Time	 <span class="comment">// The channel on which the time is delivered.</span></span><br><span class="line">	r runtimeTimer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Timer</code> 的实例必须通过 <code>NewTimer</code> 或 <code>AfterFunc</code> 获得。<br><strong>当 <code>Timer</code> 到期时，当时的时间会被发送给 <code>C</code> (channel)，除非 <code>Timer</code> 是被 <code>AfterFunc</code> 函数创建的</strong>。</p>
<p><code>runtimeTimer</code> 定义在 <code>sleep.go</code> 文件中，必须和 <code>runtime</code> 包中 <code>time.go</code> 文件中的 <code>timer</code> 保持一致：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> timer <span class="keyword">struct</span> &#123;</span><br><span class="line">	i <span class="keyword">int</span> <span class="comment">// heap index</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Timer wakes up at when, and then at when+period, ... (period &gt; 0 only)</span></span><br><span class="line">	<span class="comment">// each time calling f(now, arg) in the timer goroutine, so f must be</span></span><br><span class="line">	<span class="comment">// a well-behaved function and not block.</span></span><br><span class="line">	when   <span class="keyword">int64</span></span><br><span class="line">	period <span class="keyword">int64</span></span><br><span class="line">	f      <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">interface</span>&#123;&#125;, <span class="keyword">uintptr</span>)</span></span></span><br><span class="line"><span class="function">	<span class="title">arg</span>    <span class="title">interface</span></span>&#123;&#125;</span><br><span class="line">	seq    <span class="keyword">uintptr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过 <code>NewTimer()</code> 来看这些字段：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewTimer creates a new Timer that will send</span></span><br><span class="line"><span class="comment">// the current time on its channel after at least duration d.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewTimer</span><span class="params">(d Duration)</span> *<span class="title">Timer</span></span> &#123;</span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> Time, <span class="number">1</span>)</span><br><span class="line">	t := &amp;Timer&#123;</span><br><span class="line">		C: c,</span><br><span class="line">		r: runtimeTimer&#123;</span><br><span class="line">			when: when(d),</span><br><span class="line">			f:    sendTime,</span><br><span class="line">			arg:  c,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	startTimer(&amp;t.r)</span><br><span class="line">	<span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>when</code> 表示的时间到时，会往 <code>Timer.C</code> 中发送当前时间。<code>when</code> 表示的时间是纳秒时间，正常通过 <code>runtimeNano() + int64(d)</code> 赋值。</p>
<p><code>f</code> 参数的值是 <code>sendTime</code>，定时器时间到时，会调用 <code>f</code>，并将 <code>arg</code> 和 <code>seq</code> 传给 <code>f</code>。</p>
<p>因为 <code>Timer</code> 是一次性的，所以 <code>period</code> 保留默认值 0。</p>
<h3 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h3><h4 id="time-After"><a href="#time-After" class="headerlink" title="time.After"></a>time.After</h4><p><code>time.After</code> 模拟超时：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// time.Sleep(1 * time.Second)</span></span><br><span class="line">	time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">	&lt;-c</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> c &lt;- <span class="number">1</span>:</span><br><span class="line">	fmt.Println(<span class="string">"channel..."</span>)</span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(<span class="number">2</span> * time.Second):</span><br><span class="line">	<span class="built_in">close</span>(c)</span><br><span class="line">	fmt.Println(<span class="string">"timeout..."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="time-Stop-和-time-Reset"><a href="#time-Stop-和-time-Reset" class="headerlink" title="time.Stop 和 time.Reset"></a>time.Stop 和 time.Reset</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">start := time.Now()</span><br><span class="line">timer := time.AfterFunc(<span class="number">2</span>*time.Second, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"after func callback, elaspe:"</span>, time.Now().Sub(start))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line"><span class="comment">// time.Sleep(3*time.Second)</span></span><br><span class="line"><span class="comment">// Reset 在 Timer 还未触发时返回 true；触发了或 Stop 了，返回 false</span></span><br><span class="line"><span class="keyword">if</span> timer.Reset(<span class="number">3</span> * time.Second) &#123;</span><br><span class="line">	fmt.Println(<span class="string">"timer has not trigger!"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"timer had expired or stop!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">time.Sleep(<span class="number">10</span> * time.Second)</span><br><span class="line"></span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// timer has not trigger!</span></span><br><span class="line"><span class="comment">// after func callback, elaspe: 4.00026461s</span></span><br></pre></td></tr></table></figure>
<p><code>timer.Stop()</code> 不会关闭 <code>Timer.C</code> 这个 channel，可以使用 <code>timer.Reset(0)</code> 代替 <code>timer.Stop()</code> 来停止定时器。</p>
<h4 id="Sleep"><a href="#Sleep" class="headerlink" title="Sleep"></a>Sleep</h4><p><code>Sleep</code> 的是通过 <code>Timer</code> 实现的（查看 <code>runtime/time.go</code> 文件）。用于暂停当前 <code>goroutine</code>。</p>
<h2 id="Ticker"><a href="#Ticker" class="headerlink" title="Ticker"></a>Ticker</h2><p><code>Ticker</code> 和 <code>Timer</code> 类似，区别是：<code>Ticker</code> 中的 <code>runtimeTimer</code> 字段的 <code>period</code> 字段会赋值为 <code>NewTicker(d Duration)</code> 中的 <code>d</code>，<br>表示每间隔 <code>d</code> 纳秒，定时器就会触发一次。</p>
<p>除非程序终止前定时器一直需要触发，否则，不需要时应该调用 <code>Ticker.Stop</code> 来释放相关资源。</p>
<p>如果程序终止前需要定时器一直触发，可以使用更简单方便的 <code>time.Tick</code> 函数，因为 <code>Ticker</code> 实例隐藏起来了，因此，该函数启动的定时器无法停止。</p>

        <div id="react-support-footer-root"></div>
      </div>
    </div>
  </div>
</div>

    


    

    <!-- js vendors -->
    <script src="//code.jquery.com/jquery-3.2.1.min.js" crossorigin="anonymous"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/lunr.js/2.1.0/lunr.min.js"></script>

    <!-- js source  -->
    <script src="/golang-learn/script/doc.js"></script>

    

  </body>
</html>
