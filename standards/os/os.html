<!DOCTYPE html>
<html lang="en">
  <head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">

    <title>Golang learning | os </title>
    <meta name="description" content>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    

    <!-- fonts -->
    <link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700" rel="stylesheet">
    <link href="//fonts.googleapis.com/css?family=Ubuntu:300,400,500,600,700" rel="stylesheet">

    <!-- stylesheets -->
    <link rel="stylesheet" href="/golang-learn/style/doc.css">

    <!-- favicon -->
    <link rel="icon" href="/golang-learn/images/favicon.ico">

    

  </head>
  <body>

   <script>window.__INITIAL_STATE__ = {"page":{"title":"os","path":"standards/os/os.html"},"data":{"navigation":{"logo":{"text":"Golang Learn","type":"link","path":"index.html"},"main":[{"text":"Golang 基础","type":"label"},{"text":"Go 环境配置","type":"link","path":"basic/env_config.html"},{"text":"包","type":"link","path":"basic/package.html"},{"text":"基础数据类型","type":"link","path":"basic/basic_data.html"},{"text":"变量","type":"link","path":"basic/var.html"},{"text":"常量","type":"link","path":"basic/constant.html"},{"text":"控制语句","type":"link","path":"basic/flow.html"},{"text":"运算符","type":"link","path":"basic/operator.html"},{"text":"作用域","type":"link","path":"basic/scope.html"},{"text":"指针","type":"link","path":"basic/pointer.html"},{"text":"数组","type":"link","path":"basic/array.html"},{"text":"切片","type":"link","path":"basic/slice.html"},{"text":"字典","type":"link","path":"basic/map.html"},{"text":"函数","type":"link","path":"basic/function.html"},{"text":"结构体","type":"link","path":"basic/struct.html"},{"text":"接口","type":"link","path":"basic/interface.html"},{"text":"面向对象","type":"link","path":"basic/oop.html"},{"text":"错误","type":"link","path":"basic/error.html"},{"text":"序列化","type":"link","path":"basic/json.html"},{"text":"反射","type":"link","path":"basic/reflect.html"},{"text":"测试","type":"link","path":"basic/test.html"},{"text":"并发编程","type":"label"},{"text":"goroutine","type":"link","path":"concurrent/goroutine.html"},{"text":"channel","type":"link","path":"concurrent/channel.html"},{"text":"同步和锁","type":"link","path":"concurrent/sync_lock.html"},{"text":"内存分配","type":"label"},{"text":"内存分配","type":"link","path":"advance/mm.html"},{"text":"垃圾回收","type":"label"},{"text":"垃圾回收","type":"link","path":"advance/gc.html"},{"text":"标准库","type":"label"},{"text":"fmt","type":"link","path":"standards/io/fmt.html"},{"text":"io","type":"link","path":"standards/io/io.html"},{"text":"ioutil","type":"link","path":"standards/io/ioutil.html"},{"text":"bufio","type":"link","path":"standards/io/bufio.html"},{"text":"os","type":"link","path":"standards/os/os.html"},{"text":"filepath","type":"link","path":"standards/os/filepath.html"},{"text":"strings","type":"link","path":"standards/text/strings.html"},{"text":"strconv","type":"link","path":"standards/text/strconv.html"},{"text":"unicode","type":"link","path":"standards/text/unicode.html"},{"text":"log","type":"link","path":"standards/log.html"},{"text":"time","type":"link","path":"standards/time.html"},{"text":"http","type":"link","path":"standards/net/http.html"},{"text":"math","type":"link","path":"standards/data/math.html"},{"text":"sort","type":"link","path":"standards/data/sort.html"},{"text":"big","type":"link","path":"standards/data/big.html"},{"text":"container","type":"link","path":"standards/data/container.html"},{"text":"sql","type":"link","path":"standards/database/sql.html"},{"text":"THEME","type":"label"},{"text":"使用文档主题","type":"link","path":"theme/theme-usage.html"},{"text":"SUPPORT AND FEEDBACK","type":"label"},{"text":"Raise an Issue on Github","type":"link","path":"https://github.com/shipengqi/golang-learn/issues/new"}]}},"config":{"timezone":"UTC","root":"/golang-learn/","time_format":"HH:mm:ss","theme":"../node_modules/hexo-theme-doc","theme_config":{"swagger_ui":{"version":2,"permalinks":true,"api_explorer":true,"download":"Download specification","show_extensions":false,"deep_linking":true,"display_operation_id":false,"doc_expansion":"none"},"search":{"skip":false,"background":false,"route":"/lunr.json"},"favicon":"images/favicon.ico"}}}</script>

    <div id="react-navigation-root"><div class="doc-navigation" data-reactroot><nav class="doc-navbar"><a href="/golang-learn/index.html" class="doc-navbar__logo"><img src="/golang-learn/images/logo.png" class="doc-navbar__logo__img"><span class="doc-navbar__logo__text">Golang Learn</span></a><i class="dc-icon dc-icon--close dc-icon--interactive doc-sidebar-close doc-navbar__sidebar-close doc-navbar__sidebar-close--desktop"></i><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-navbar__sidebar-toggle"></i></nav><nav class="doc-sidebar"><div class="doc-sidebar__vertical-menu"><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-sidebar-toggle--primary doc-sidebar__vertical-menu__item"></i><i class="dc-icon dc-icon--search dc-icon--interactive doc-sidebar__vertical-menu__item doc-sidebar__vertical-menu__item--primary"></i></div><div class="doc-sidebar-content"><div class="doc-sidebar__search-form"></div><ul class="doc-sidebar-list"></ul></div></nav></div></div>
    <div class="doc-content">
  <div class="dc-page">
    <div class="dc-card">
      <div id="react-search-results-root"></div>
      <div id="page-content" class="doc-formatting">
        <h1 id="os"><a href="#os" class="headerlink" title="os"></a>os</h1><p><code>os</code> 包提供了平台无关的操作系统功能接口。例如 Linux、macOS、Windows 等系统 <code>os</code> 包提供统一的使用接口。 </p>
<p>例子，打开一个文件并从中读取一些数据：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">file, err := os.Open(<span class="string">"file.go"</span>) <span class="comment">// For read access.</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	log.Fatal(err) <span class="comment">// `open file.go: no such file or directory`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="文件-I-O"><a href="#文件-I-O" class="headerlink" title="文件 I/O"></a>文件 I/O</h2><p>在 Go 中，文件描述符封装在 <code>os.File</code> 结构中，通过 <code>File.Fd()</code> 可以获得底层的文件描述符：<code>fd</code>。</p>
<p>大多数程序都期望能够使用 3 种标准的文件描述符：0- 标准输入；1- 标准输出；2- 标准错误。<code>os</code> 包提供了 3 个 <code>File</code> 对象，分别<br>代表这 3 种标准描述符：<code>Stdin</code>、<code>Stdout</code> 和 <code>Stderr</code>，它们对应的文件名分别是：<code>/dev/stdin</code>、<code>/dev/stdout</code> 和 <code>/dev/stderr</code>。<br>注意，这里说的文件名，并不一定存在，比如 Windows 下就没有。</p>
<h3 id="OpenFile"><a href="#OpenFile" class="headerlink" title="OpenFile"></a>OpenFile</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OpenFile</span><span class="params">(name <span class="keyword">string</span>, flag <span class="keyword">int</span>, perm FileMode)</span> <span class="params">(*File, error)</span></span></span><br></pre></td></tr></table></figure>
<p><code>OpenFile</code> 既能打开一个已经存在的文件，也能创建并打开一个新文件。</p>
<p><code>OpenFile</code> 是一个更一般性的文件打开函数，大多数调用者都应用 <code>Open</code> 或 <code>Create</code> 代替本函数。它会使用指定的选项（如 <code>O_RDONLY</code> 等）、<br>指定的模式（如 <code>0666</code> 等）打开指定名称的文件。如果操作成功，返回的文件对象可用于 I/O。如果出错，错误底层类型是 <code>*PathError</code>。</p>
<p>要打开的文件由参数 <code>name</code> 指定，它可以是绝对路径或相对路径（相对于进程当前工作目录），也可以是一个符号链接（会对其进行解引用）。</p>
<p>位掩码参数 <code>flag</code> 用于指定文件的访问模式，可用的值在 <code>os</code> 中定义为常量（以下值并非所有操作系统都可用）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    O_RDONLY <span class="keyword">int</span> = syscall.O_RDONLY <span class="comment">// 只读模式打开文件</span></span><br><span class="line">    O_WRONLY <span class="keyword">int</span> = syscall.O_WRONLY <span class="comment">// 只写模式打开文件</span></span><br><span class="line">    O_RDWR   <span class="keyword">int</span> = syscall.O_RDWR   <span class="comment">// 读写模式打开文件</span></span><br><span class="line">    O_APPEND <span class="keyword">int</span> = syscall.O_APPEND <span class="comment">// 写操作时将数据附加到文件尾部</span></span><br><span class="line">    O_CREATE <span class="keyword">int</span> = syscall.O_CREAT  <span class="comment">// 如果不存在将创建一个新文件</span></span><br><span class="line">    O_EXCL   <span class="keyword">int</span> = syscall.O_EXCL   <span class="comment">// 和 O_CREATE 配合使用，文件必须不存在</span></span><br><span class="line">    O_SYNC   <span class="keyword">int</span> = syscall.O_SYNC   <span class="comment">// 打开文件用于同步 I/O</span></span><br><span class="line">    O_TRUNC  <span class="keyword">int</span> = syscall.O_TRUNC  <span class="comment">// 如果可能，打开时清空文件</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>其中，<code>O_RDONLY</code>、<code>O_WRONLY</code>、<code>O_RDWR</code> 只指定一个，剩下的通过 <code>|</code> 操作符来指定。该函数内部会给 <code>flags</code> 加上 <code>syscall.O_CLOEXEC</code>，<br>在 <code>fork</code> 子进程时会关闭通过 <code>OpenFile</code> 打开的文件，即子进程不会重用该文件描述符。</p>
<p>位掩码参数 <code>perm</code> 指定了文件的模式和权限位，类型是 <code>os.FileMode</code>，文件模式位常量定义在 <code>os</code> 中：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    <span class="comment">// 单字符是被 String 方法用于格式化的属性缩写。</span></span><br><span class="line">    ModeDir        FileMode = <span class="number">1</span> &lt;&lt; (<span class="number">32</span> - <span class="number">1</span> - <span class="literal">iota</span>) <span class="comment">// d: 目录</span></span><br><span class="line">    ModeAppend                                     <span class="comment">// a: 只能写入，且只能写入到末尾</span></span><br><span class="line">    ModeExclusive                                  <span class="comment">// l: 用于执行</span></span><br><span class="line">    ModeTemporary                                  <span class="comment">// T: 临时文件（非备份文件）</span></span><br><span class="line">    ModeSymlink                                    <span class="comment">// L: 符号链接（不是快捷方式文件）</span></span><br><span class="line">    ModeDevice                                     <span class="comment">// D: 设备</span></span><br><span class="line">    ModeNamedPipe                                  <span class="comment">// p: 命名管道（FIFO）</span></span><br><span class="line">    ModeSocket                                     <span class="comment">// S: Unix 域 socket</span></span><br><span class="line">    ModeSetuid                                     <span class="comment">// u: 表示文件具有其创建者用户 id 权限</span></span><br><span class="line">    ModeSetgid                                     <span class="comment">// g: 表示文件具有其创建者组 id 的权限</span></span><br><span class="line">    ModeCharDevice                                 <span class="comment">// c: 字符设备，需已设置 ModeDevice</span></span><br><span class="line">    ModeSticky                                     <span class="comment">// t: 只有 root/ 创建者能删除 / 移动文件</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 覆盖所有类型位（用于通过 &amp; 获取类型位），对普通文件，所有这些位都不应被设置</span></span><br><span class="line">    ModeType = ModeDir | ModeSymlink | ModeNamedPipe | ModeSocket | ModeDevice</span><br><span class="line">    ModePerm FileMode = <span class="number">0777</span> <span class="comment">// 覆盖所有 Unix 权限位（用于通过 &amp; 获取类型位）</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>以上常量在所有操作系统都有相同的含义（可用时），因此文件的信息可以在不同的操作系统之间安全的移植。不是所有的位都能用于所有的系统，<br>唯一共有的是用于表示目录的 <code>ModeDir</code> 位。</p>
<p>以上这些被定义的位是 <code>FileMode</code> 最重要的位。另外 9 个位（权限位）为标准 Unix <code>rwxrwxrwx</code> 权限（所有人都可读、写、运行）。</p>
<p><code>FileMode</code> 还定义了几个方法，用于判断文件类型的 <code>IsDir()</code> 和 <code>IsRegular()</code>，用于获取权限的 <code>Perm()</code>。</p>
<p>返回的 <code>error</code>，具体实现是 <code>*os.PathError</code>，它会记录具体操作、文件路径和错误原因。</p>
<p>另外，在 <code>OpenFile</code> 内部会调用 <code>NewFile</code>，来得到 <code>File</code> 对象。</p>
<p><strong>使用方法</strong></p>
<p>打开一个文件，一般通过 <code>Open</code> 或 <code>Create</code>，这两个函数的实现。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(*File, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> OpenFile(name, O_RDONLY, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Create</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(*File, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> OpenFile(name, O_RDWR|O_CREATE|O_TRUNC, <span class="number">0666</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Read"><a href="#Read" class="headerlink" title="Read"></a>Read</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span> <span class="title">Read</span><span class="params">(b []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br></pre></td></tr></table></figure>
<p><code>Read</code> 方法从 <code>f</code> 中读取最多 <code>len(b)</code> 字节数据并写入 <code>b</code>。它返回读取的字节数和可能遇到的任何错误。文件终止标志是读取 0 个字节且返回<br>值 <code>err</code> 为 <code>io.EOF</code>。</p>
<p>对比下 <code>ReadAt</code> 方法：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span> <span class="title">ReadAt</span><span class="params">(b []<span class="keyword">byte</span>, off <span class="keyword">int64</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br></pre></td></tr></table></figure></p>
<p><code>ReadAt</code> 从指定的位置（相对于文件开始位置）读取长度为 <code>len(b)</code> 个字节数据并写入 <code>b</code>。它返回读取的字节数和可能遇到的任何错误。<br>当 <code>n&lt;len(b)</code> 时，本方法总是会返回错误；如果是因为到达文件结尾，返回值 <code>err</code> 会是 <code>io.EOF</code>。它对应的系统调用是 <code>pread</code>。</p>
<p><strong><code>Read</code> 和 <code>ReadAt</code> 的区别</strong>：前者从文件当前偏移量处读，且会改变文件当前的偏移量；而后者从 <code>off</code> 指定的位置开始读，且<strong>不会改变</strong>文件<br>当前偏移量。</p>
<h3 id="Write"><a href="#Write" class="headerlink" title="Write"></a>Write</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span> <span class="title">Write</span><span class="params">(b []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br></pre></td></tr></table></figure>
<p><code>Write</code> 向文件中写入 <code>len(b)</code> 字节数据。它返回写入的字节数和可能遇到的任何错误。如果返回值 <code>n != len(b)</code>，本方法会返回一个 <strong>非 nil</strong><br> 的错误。</p>
<p><code>Write</code> 与 <code>WriteAt</code> 的区别同 <code>Read</code> 与 <code>ReadAt</code> 的区别一样。为了方便，还提供了 <code>WriteString</code> 方法，它实际是对 <code>Write</code> 的封装。</p>
<p>注意：<code>Write</code> 调用成功并不能保证数据已经写入磁盘，因为内核会缓存磁盘的 I/O 操作。如果希望立刻将数据写入磁盘（一般场景不建议这么做，因为会<br>影响性能），有两种办法：</p>
<ol>
<li>打开文件时指定 <code>os.O_SYNC</code>；</li>
<li>调用 <code>File.Sync()</code> 方法。</li>
</ol>
<p>说明：<code>File.Sync()</code> 底层调用的是 <code>fsync</code> 系统调用，这会将数据和元数据都刷到磁盘；如果只想刷数据到磁盘（比如，文件大小没变，只是变了文件<br>数据），需要自己封装，调用 <code>fdatasync</code> 系统调用。（<code>syscall.Fdatasync</code>）</p>
<h3 id="Close"><a href="#Close" class="headerlink" title="Close"></a>Close</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span> <span class="title">Close</span><span class="params">()</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>
<p><code>close()</code> 系统调用关闭一个打开的文件描述符，并将其释放回调用进程，供该进程继续使用。当进程终止时，将自动关闭其已打开的所有文件描述符。</p>
<p><code>os.File.Close()</code> 是对 <code>close()</code> 的封装。文件描述符是资源，Go 的 gc 是针对内存的，并不会自动回收资源，如果不关闭文件描述符，<br>长期运行的服务可能会把文件描述符耗尽。</p>
<p>所以，通常的写法如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">file, err := os.Open(<span class="string">"/tmp/studygolang.txt"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="comment">// 错误处理，一般会阻止程序往下执行</span></span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> file.Close()</span><br></pre></td></tr></table></figure>
<p><strong>关于返回值 <code>error</code></strong></p>
<p>以下两种情况会导致 <code>Close</code> 返回错误：</p>
<ol>
<li>关闭一个未打开的文件；</li>
<li>两次关闭同一个文件；</li>
</ol>
<p>通常，不会去检查 <code>Close</code> 的错误。</p>
<h3 id="Seek"><a href="#Seek" class="headerlink" title="Seek"></a>Seek</h3><p>对于每个打开的文件，系统内核会记录其文件偏移量，有时也将文件偏移量称为读写偏移量或指针。文件偏移量是指执行下一个 <code>Read</code> 或 <code>Write</code> 操作<br>的文件真实位置，会以相对于文件头部起始点的文件当前位置来表示。文件第一个字节的偏移量为 0。</p>
<p>文件打开时，会将文件偏移量设置为指向文件开始，以后每次 <code>Read</code> 或 <code>Write</code> 调用将自动对其进行调整，以指向已读或已写数据后的下一个字节。因<br>此，连续的 <code>Read</code> 和 <code>Write</code> 调用将按顺序递进，对文件进行操作。</p>
<p><code>Seek</code> 可以调整文件偏移量：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span> <span class="title">Seek</span><span class="params">(offset <span class="keyword">int64</span>, whence <span class="keyword">int</span>)</span> <span class="params">(ret <span class="keyword">int64</span>, err error)</span></span></span><br></pre></td></tr></table></figure></p>
<p><code>Seek</code> 设置下一次读/写的位置。<code>offset</code> 为相对偏移量，而 <code>whence</code> 决定相对位置：0 为相对文件开头，1 为相对当前位置，2 为相对文件结尾。它<br>返回新的偏移量（相对开头）和可能的错误。</p>
<p>注意：<code>Seek</code> 只是调整内核中与文件描述符相关的文件偏移量记录，并没有访问任何物理设备。</p>
<p>一些 <code>Seek</code> 的使用例子（file 为打开的文件对象），注释说明了将文件偏移量移动到的具体位置：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">file.Seek(<span class="number">0</span>, os.SEEK_SET)	<span class="comment">// 文件开始处</span></span><br><span class="line">file.Seek(<span class="number">0</span>, SEEK_END)		<span class="comment">// 文件结尾处的下一个字节</span></span><br><span class="line">file.Seek(<span class="number">-1</span>, SEEK_END)		<span class="comment">// 文件最后一个字节</span></span><br><span class="line">file.Seek(<span class="number">-10</span>, SEEK_CUR) 	<span class="comment">// 当前位置前 10 个字节</span></span><br><span class="line">file.Seek(<span class="number">1000</span>, SEEK_END)	<span class="comment">// 文件结尾处的下 1001 个字节</span></span><br></pre></td></tr></table></figure>
<p>最后一个例子在文件中会产生“空洞”。</p>
<p><code>Seek</code> 对应系统调用 <code>lseek</code>。该系统调用并不适用于所有类型，不允许将 <code>lseek</code> 应用于管道、FIFO、socket 或 终端。</p>
<h2 id="截断文件"><a href="#截断文件" class="headerlink" title="截断文件"></a>截断文件</h2><p><code>trucate</code> 和 <code>ftruncate</code> 系统调用将文件大小设置为 <code>size</code> 参数指定的值；Go 语言中相应的包装函数是 <code>os.Truncate</code> 和<br><code>os.File.Truncate</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Truncate</span><span class="params">(name <span class="keyword">string</span>, size <span class="keyword">int64</span>)</span> <span class="title">error</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(f *File)</span> <span class="title">Truncate</span><span class="params">(size <span class="keyword">int64</span>)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>
<p>如果文件当前长度大于参数 <code>size</code>，调用将丢弃超出部分，若小于参数 <code>size</code>，调用将在文件尾部添加一系列空字节或是一个文件空洞。</p>
<p>它们之间的区别在于如何指定操作文件：</p>
<ol>
<li><code>Truncate</code> 以路径名称字符串来指定文件，并要求可访问该文件（即对组成路径名的各目录拥有可执行 (x) 权限），且对文件拥有写权限。<br>若文件名为符号链接，那么调用将对其进行解引用。</li>
<li>很明显，调用 <code>File.Truncate</code> 前，需要先以可写方式打开操作文件，该方法不会修改文件偏移量。</li>
</ol>
<h2 id="文件属性"><a href="#文件属性" class="headerlink" title="文件属性"></a>文件属性</h2><p>文件属性，也即文件元数据。在 Go 中，文件属性具体信息通过 <code>os.FileInfo</code> 接口获取。函数 <code>Stat</code>、<code>Lstat</code> 和 <code>File.Stat</code> 可以得到该接口<br>的实例。这三个函数对应三个系统调用：<code>stat</code>、<code>lstat</code> 和 <code>fstat</code>。</p>
<p>这三个函数的区别：</p>
<ol>
<li><code>stat</code> 会返回所命名文件的相关信息。</li>
<li><code>lstat</code> 与 <code>stat</code> 类似，区别在于如果文件是符号链接，那么所返回的信息针对的是符号链接自身（而非符号链接所指向的文件）。</li>
<li><code>fstat</code> 则会返回由某个打开文件描述符（Go 中则是当前打开文件 File）所指代文件的相关信息。</li>
</ol>
<p><code>Stat</code> 和 <code>Lstat</code> 无需对其所操作的文件本身拥有任何权限，但针对指定 <code>name</code>的父目录要有执行（搜索）权限。而只要 <code>File</code> 对象 <code>ok</code>，<br><code>File.Stat</code> 总是成功。</p>
<p><code>FileInfo</code> 接口如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> FileInfo <span class="keyword">interface</span> &#123;</span><br><span class="line">    Name() <span class="keyword">string</span>       <span class="comment">// 文件的名字（不含扩展名）</span></span><br><span class="line">    Size() <span class="keyword">int64</span>        <span class="comment">// 普通文件返回值表示其大小；其他文件的返回值含义各系统不同</span></span><br><span class="line">    Mode() FileMode     <span class="comment">// 文件的模式位</span></span><br><span class="line">    ModTime() time.Time <span class="comment">// 文件的修改时间</span></span><br><span class="line">    IsDir() <span class="keyword">bool</span>        <span class="comment">// 等价于 Mode().IsDir()</span></span><br><span class="line">    Sys() <span class="keyword">interface</span>&#123;&#125;   <span class="comment">// 底层数据来源（可以返回 nil）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Sys()</code> 底层数据的 C 语言 结构 <code>statbuf</code> 格式如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> stat &#123;</span><br><span class="line">	dev_t	st_dev;	<span class="comment">// 设备 ID</span></span><br><span class="line">	ino_t	st_ino;	<span class="comment">// 文件 i 节点号</span></span><br><span class="line">	mode_t	st_mode;	<span class="comment">// 位掩码，文件类型和文件权限</span></span><br><span class="line">	nlink_t	st_nlink;	<span class="comment">// 硬链接数</span></span><br><span class="line">	uid_t	st_uid;	<span class="comment">// 文件属主，用户 ID</span></span><br><span class="line">	gid_t	st_gid;	<span class="comment">// 文件属组，组 ID</span></span><br><span class="line">	dev_t	st_rdev;	<span class="comment">// 如果针对设备 i 节点，则此字段包含主、辅 ID</span></span><br><span class="line">	off_t	st_size;	<span class="comment">// 常规文件，则是文件字节数；符号链接，则是链接所指路径名的长度，字节为单位；对于共享内存对象，则是对象大小</span></span><br><span class="line">	blksize_t	st_blsize;	<span class="comment">// 分配给文件的总块数，块大小为 512 字节</span></span><br><span class="line">	blkcnt_t	st_blocks;	<span class="comment">// 实际分配给文件的磁盘块数量</span></span><br><span class="line">	time_t	st_atime;		<span class="comment">// 对文件上次访问时间</span></span><br><span class="line">	time_t	st_mtime;		<span class="comment">// 对文件上次修改时间</span></span><br><span class="line">	time_t	st_ctime;		<span class="comment">// 文件状态发生改变的上次时间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Go 中 <code>syscal.Stat_t</code> 与该结构对应。</p>
<p>如果我们要获取 <code>FileInfo</code> 接口没法直接返回的信息，比如想获取文件的上次访问时间，示例如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fileInfo, err := os.Stat(<span class="string">"test.log"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">sys := fileInfo.Sys()</span><br><span class="line">stat := sys.(*syscall.Stat_t)</span><br><span class="line">fmt.Println(time.Unix(stat.Atimespec.Unix()))</span><br></pre></td></tr></table></figure>
<h3 id="改变文件时间戳"><a href="#改变文件时间戳" class="headerlink" title="改变文件时间戳"></a>改变文件时间戳</h3><p>可以显式改变文件的访问时间和修改时间。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Chtimes</span><span class="params">(name <span class="keyword">string</span>, atime time.Time, mtime time.Time)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure></p>
<p><code>Chtimes</code> 修改 <code>name</code> 指定的文件对象的访问时间和修改时间，类似 Unix 的 <code>utime()</code> 或 <code>utimes()</code> 函数。底层的文件系统可能会截断/舍入<br>时间单位到更低的精确度。如果出错，会返回 <code>*PathError</code> 类型的错误。在 Unix 中，底层实现会调用 <code>utimenstat()</code>，它提供纳秒级别的精度。</p>
<h3 id="文件属主"><a href="#文件属主" class="headerlink" title="文件属主"></a>文件属主</h3><p>每个文件都有一个与之关联的用户 ID（UID）和组 ID（GID），籍此可以判定文件的属主和属组。系统调用 <code>chown</code>、<code>lchown</code> 和 <code>fchown</code> 可用来<br>改变文件的属主和属组，Go 中对应的函数或方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Chown</span><span class="params">(name <span class="keyword">string</span>, uid, gid <span class="keyword">int</span>)</span> <span class="title">error</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">Lchown</span><span class="params">(name <span class="keyword">string</span>, uid, gid <span class="keyword">int</span>)</span> <span class="title">error</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(f *File)</span> <span class="title">Chown</span><span class="params">(uid, gid <span class="keyword">int</span>)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>
<p>它们的区别和上文提到的 <code>Stat</code> 相关函数类似。</p>
<h3 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h3><p>这里介绍是应用于文件和目录的权限方案，尽管此处讨论的权限主要是针对普通文件和目录，但其规则可适用于所有文件类型，包括设备文件、FIFO 以<br>及 Unix 域套接字等。</p>
<h4 id="相关函数或方法"><a href="#相关函数或方法" class="headerlink" title="相关函数或方法"></a>相关函数或方法</h4><p>在文件相关操作报错时，可以通过 <code>os.IsPermission</code> 检查是否是权限的问题。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsPermission</span><span class="params">(err error)</span> <span class="title">bool</span></span></span><br></pre></td></tr></table></figure></p>
<p>返回一个布尔值说明该错误是否表示因权限不足要求被拒绝。<code>ErrPermission</code> 和一些系统调用错误会使它返回真。</p>
<p>另外，<code>syscall.Access</code> 可以获取文件的权限。这对应系统调用 <code>access</code>。</p>
<h4 id="Sticky-位"><a href="#Sticky-位" class="headerlink" title="Sticky 位"></a>Sticky 位</h4><p>除了 9 位用来表明属主、属组和其他用户的权限外，文件权限掩码还另设有 3 个附加位，分别是<br><code>set-user-ID</code>(bit 04000)、<code>set-group-ID</code>(bit 02000) 和 <code>sticky</code>(bit 01000) 位。</p>
<p>Sticky 位一般用于目录，起限制删除位的作用，表明仅当非特权进程具有对目录的写权限，且为文件或目录的属主时，才能对目录下的文件进行删除和重命名操<br>作。根据这个机制来创建为多个用户共享的一个目录，各个用户可在其下创建或删除属于自己的文件，但不能删除隶属于其他用户的文件。<code>/tmp</code> 目录就设<br>置了 sticky 位，正是出于这个原因。</p>
<p><code>chmod</code> 命令或系统调用可以设置文件的 sticky 位。若对某文件设置了 sticky 位，则 <code>ls -l</code> 显示文件时，会在其他用户执行权限字段上看到字<br>母 t（有执行权限时） 或 T（无执行权限时）。</p>
<p><code>os.Chmod</code> 和 <code>os.File.Chmod</code> 可以修改文件权限（包括 sticky 位），分别对应系统调用 <code>chmod</code> 和 <code>fchmod</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    file, err := os.Create(<span class="string">"studygolang.txt"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(<span class="string">"error:"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> file.Close()</span><br><span class="line"></span><br><span class="line">    fileMode := getFileMode(file)</span><br><span class="line">    log.Println(<span class="string">"file mode:"</span>, fileMode)</span><br><span class="line">    file.Chmod(fileMode | os.ModeSticky)</span><br><span class="line"></span><br><span class="line">    log.Println(<span class="string">"change after, file mode:"</span>, getFileMode(file))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getFileMode</span><span class="params">(file *os.File)</span> <span class="title">os</span>.<span class="title">FileMode</span></span> &#123;</span><br><span class="line">    fileInfo, err := file.Stat()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(<span class="string">"file stat error:"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fileInfo.Mode()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// 2016/06/18 15:59:06 file mode: -rw-rw-r--</span></span><br><span class="line"><span class="comment">// 2016/06/18 15:59:06 change after, file mode: trw-rw-r--</span></span><br><span class="line"><span class="comment">// ls -l 看到的 studygolang.tx 是：-rw-rw-r-T</span></span><br><span class="line"><span class="comment">// 当然这里是给文件设置了 sticky 位，对权限不起作用。系统会忽略它。</span></span><br></pre></td></tr></table></figure>
<h2 id="目录与链接"><a href="#目录与链接" class="headerlink" title="目录与链接"></a>目录与链接</h2><p>在 Unix 文件系统中，目录的存储方式类似于普通文件。目录和普通文件的区别有二：</p>
<ul>
<li>在其 <code>i-node</code> 条目中，会将目录标记为一种不同的文件类型。</li>
<li>目录是经特殊组织而成的文件。本质上说就是一个表格，包含文件名和 <code>i-node</code> 标号。</li>
</ul>
<h3 id="创建和移除（硬）链接"><a href="#创建和移除（硬）链接" class="headerlink" title="创建和移除（硬）链接"></a>创建和移除（硬）链接</h3><p>硬链接是针对文件而言的，目录不允许创建硬链接。</p>
<p><code>link</code> 和 <code>unlink</code> 系统调用用于创建和移除（硬）链接。Go 中 <code>os.Link</code> 对应 <code>link</code> 系统调用；但 <code>os.Remove</code> 的实现会先执行 <code>unlink</code><br>系统调用，如果要移除的是目录，则 <code>unlink</code> 会失败，这时 <code>Remove</code> 会再调用 <code>rmdir</code> 系统调用。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Link</span><span class="params">(oldname, newname <span class="keyword">string</span>)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure></p>
<p><code>Link</code> 创建一个名为 <code>newname</code> 指向 <code>oldname</code> 的硬链接。如果出错，会返回 <code>*LinkError</code> 类型的错误。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Remove</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure></p>
<p><code>Remove</code> 删除 <code>name</code> 指定的文件或目录。如果出错，会返回 <code>*PathError</code> 类型的错误。如果目录不为空，<code>Remove</code> 会返回失败。</p>
<h3 id="更改文件名"><a href="#更改文件名" class="headerlink" title="更改文件名"></a>更改文件名</h3><p>系统调用 <code>rename</code> 既可以重命名文件，又可以将文件移至同一个文件系统中的另一个目录。该系统调用既可以用于文件，也可以用于目录。相关细节，<br>请查阅相关资料。</p>
<p>Go 中的 <code>os.Rename</code> 是对应的封装函数。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Rename</span><span class="params">(oldpath, newpath <span class="keyword">string</span>)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure></p>
<p><code>Rename</code> 修改一个文件的名字或移动一个文件。如果 <code>newpath</code> 已经存在，则替换它。注意，可能会有一些个操作系统特定的限制。</p>
<h3 id="使用符号链接"><a href="#使用符号链接" class="headerlink" title="使用符号链接"></a>使用符号链接</h3><p><code>symlink</code> 系统调用用于为指定路径名创建一个新的符号链接（想要移除符号链接，使用 <code>unlink</code>）。Go 中的 <code>os.Symlink</code> 是对应的封装函数。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Symlink</span><span class="params">(oldname, newname <span class="keyword">string</span>)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure></p>
<p><code>Symlink</code> 创建一个名为 <code>newname</code> 指向 <code>oldname</code> 的符号链接。如果出错，会返回 <code>*LinkError</code> 类型的错误。</p>
<p>由 <code>oldname</code> 所命名的文件或目录在调用时无需存在。因为即便当时存在，也无法阻止后来将其删除。这时，<code>newname</code> 成为“悬空链接”，其他系统<br>调用试图对其进行解引用操作都将错误（通常错误号是 <code>ENOENT</code>）。</p>
<p>有时候，我们希望通过符号链接，能获取其所指向的路径名。系统调用 <code>readlink</code> 能做到，Go 的封装函数是 <code>os.Readlink</code>：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Readlink</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span></span><br></pre></td></tr></table></figure></p>
<p><code>Readlink</code> 获取 <code>name</code> 指定的符号链接指向的文件的路径。如果出错，会返回 <code>*PathError</code> 类型的错误。我们看看 <code>Readlink</code> 的实现。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Readlink</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> <span class="built_in">len</span> := <span class="number">128</span>; ; <span class="built_in">len</span> *= <span class="number">2</span> &#123;</span><br><span class="line">		b := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="built_in">len</span>)</span><br><span class="line">		n, e := fixCount(syscall.Readlink(name, b))</span><br><span class="line">		<span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="string">""</span>, &amp;PathError&#123;<span class="string">"readlink"</span>, name, e&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> n &lt; <span class="built_in">len</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">string</span>(b[<span class="number">0</span>:n]), <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里之所以用循环，是因为我们没法知道文件的路径到底多长，如果 <code>b</code> 长度不够，文件名会被截断，而 <code>readlink</code> 系统调用无非分辨所返回的字<br>符串到底是经过截断处理，还是恰巧将 <code>b</code> 填满。这里采用的验证方法是分配一个更大的（两倍）<code>b</code> 并再次调用 <code>readlink</code>。</p>
<h3 id="创建和移除目录"><a href="#创建和移除目录" class="headerlink" title="创建和移除目录"></a>创建和移除目录</h3><p><code>mkdir</code> 系统调用创建一个新目录，Go 中的 <code>os.Mkdir</code> 是对应的封装函数。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Mkdir</span><span class="params">(name <span class="keyword">string</span>, perm FileMode)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure></p>
<p><code>Mkdir</code> 使用指定的权限和名称创建一个目录。如果出错，会返回 <code>*PathError</code> 类型的错误。</p>
<p><code>name</code> 参数指定了新目录的路径名，可以是相对路径，也可以是绝对路径。如果已经存在，则调用失败并返回 <code>os.ErrExist</code> 错误。</p>
<p><code>perm</code> 参数指定了新目录的权限。对该位掩码值的指定方式和 <code>os.OpenFile</code> 相同，也可以直接赋予八进制数值。注意，<code>perm</code> 值还将于进程掩码相<br>与（&amp;）。如果 <code>perm</code> 中设置了 sticky 位，那么将对新目录设置该权限。</p>
<p>因为 <code>Mkdir</code> 所创建的只是路径名中的最后一部分，如果父目录不存在，创建会失败。<code>os.MkdirAll</code> 用于递归创建所有不存在的目录。</p>
<p>建议读者阅读下 <code>os.MkdirAll</code> 的源码，了解其实现方式、技巧。</p>
<p><code>rmdir</code> 系统调用移除一个指定的目录，目录可以是绝对路径或相对路径。在讲解 <code>unlink</code> 时，已经介绍了 Go 中的 <code>os.Remove</code>。注意，这里要求<br>目录必须为空。为了方便使用，Go 中封装了一个 <code>os.RemoveAll</code> 函数：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RemoveAll</span><span class="params">(path <span class="keyword">string</span>)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure></p>
<p><code>RemoveAll</code> 删除 <code>path</code> 指定的文件，或目录及它包含的任何下级对象。它会尝试删除所有东西，除非遇到错误并返回。如果 <code>path</code> 指定的对象不<br>存在，<code>RemoveAll</code> 会返回 <code>nil</code> 而不返回错误。</p>
<p><code>RemoveAll</code> 的内部实现逻辑如下：</p>
<ol>
<li>调用 <code>Remove</code> 尝试进行删除，如果成功或返回 <code>path</code> 不存在，则直接返回 nil；</li>
<li>调用 <code>Lstat</code> 获取 <code>path</code> 信息，以便判断是否是目录。注意，这里使用 <code>Lstat</code>，表示不对符号链接解引用；</li>
<li>调用 <code>Open</code> 打开目录，递归读取目录中内容，执行删除操作。</li>
</ol>
<h3 id="读目录"><a href="#读目录" class="headerlink" title="读目录"></a>读目录</h3><p><code>POSIX</code> 与 <code>SUS</code> 定义了读取目录相关的 C 语言标准，各个操作系统提供的系统调用却不尽相同。Go 没有基于 C 语言，而是自己通过系统调用实现<br>了读目录功能。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span> <span class="title">Readdirnames</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="params">(names []<span class="keyword">string</span>, err error)</span></span></span><br></pre></td></tr></table></figure></p>
<p><code>Readdirnames</code> 读取目录 <code>f</code> 的内容，返回一个最多有 <code>n</code> 个成员的 <code>[]string</code>，切片成员为目录中文件对象的名字，采用目录顺序。对本函数的下一<br>次调用会返回上一次调用未读取的内容的信息。</p>
<p>如果 <code>n&gt;0</code>，<code>Readdirnames</code> 函数会返回一个最多 <code>n</code> 个成员的切片。这时，如果 <code>Readdirnames</code> 返回一个空切片，它会返回一个非 <code>nil</code> 的错<br>误说明原因。如果到达了目录 <code>f</code> 的结尾，返回值 <code>err</code> 会是 <code>io.EOF</code>。</p>
<p>如果 <code>n&lt;=0</code>，<code>Readdirnames</code> 函数返回目录中剩余所有文件对象的名字构成的切片。此时，如果 <code>Readdirnames</code> 调用成功（读取所有内容直到结尾），<br>它会返回该切片和 <code>nil</code> 的错误值。如果在到达结尾前遇到错误，会返回之前成功读取的名字构成的切片和该错误。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span> <span class="title">Readdir</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="params">(fi []FileInfo, err error)</span></span></span><br></pre></td></tr></table></figure></p>
<p><code>Readdir</code> 内部会调用 <code>Readdirnames</code>，将得到的 <code>names</code> 构造路径，通过 <code>Lstat</code> 构造出 <code>[]FileInfo</code>。</p>
<p><code>ioutil.ReadDir</code> 也可以实现类似的功能。</p>

        <div id="react-support-footer-root"></div>
      </div>
    </div>
  </div>
</div>

    


    

    <!-- js vendors -->
    <script src="//code.jquery.com/jquery-3.2.1.min.js" crossorigin="anonymous"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/lunr.js/2.1.0/lunr.min.js"></script>

    <!-- js source  -->
    <script src="/golang-learn/script/doc.js"></script>

    

  </body>
</html>
