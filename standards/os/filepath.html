<!DOCTYPE html>
<html lang="en">
  <head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">

    <title>Golang learning | filepath </title>
    <meta name="description" content>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    

    <!-- fonts -->
    <link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700" rel="stylesheet">
    <link href="//fonts.googleapis.com/css?family=Ubuntu:300,400,500,600,700" rel="stylesheet">

    <!-- stylesheets -->
    <link rel="stylesheet" href="/golang-learn/style/doc.css">

    <!-- favicon -->
    <link rel="icon" href="/golang-learn/images/favicon.ico">

    

  </head>
  <body>

   <script>window.__INITIAL_STATE__ = {"page":{"title":"filepath","path":"standards/os/filepath.html"},"data":{"navigation":{"logo":{"text":"Golang Learn","type":"link","path":"index.html"},"main":[{"text":"Golang 基础","type":"label"},{"text":"Go 环境配置","type":"link","path":"basic/env_config.html"},{"text":"包","type":"link","path":"basic/package.html"},{"text":"基础数据类型","type":"link","path":"basic/basic_data.html"},{"text":"变量","type":"link","path":"basic/var.html"},{"text":"常量","type":"link","path":"basic/constant.html"},{"text":"控制语句","type":"link","path":"basic/flow.html"},{"text":"运算符","type":"link","path":"basic/operator.html"},{"text":"作用域","type":"link","path":"basic/scope.html"},{"text":"指针","type":"link","path":"basic/pointer.html"},{"text":"数组","type":"link","path":"basic/array.html"},{"text":"切片","type":"link","path":"basic/slice.html"},{"text":"字典","type":"link","path":"basic/map.html"},{"text":"函数","type":"link","path":"basic/function.html"},{"text":"结构体","type":"link","path":"basic/struct.html"},{"text":"接口","type":"link","path":"basic/interface.html"},{"text":"面向对象","type":"link","path":"basic/oop.html"},{"text":"错误","type":"link","path":"basic/error.html"},{"text":"序列化","type":"link","path":"basic/json.html"},{"text":"反射","type":"link","path":"basic/reflect.html"},{"text":"测试","type":"link","path":"basic/test.html"},{"text":"并发编程","type":"label"},{"text":"goroutine","type":"link","path":"concurrent/goroutine.html"},{"text":"channel","type":"link","path":"concurrent/channel.html"},{"text":"同步和锁","type":"link","path":"concurrent/sync_lock.html"},{"text":"内存分配","type":"label"},{"text":"内存分配","type":"link","path":"advance/mm.html"},{"text":"垃圾回收","type":"label"},{"text":"垃圾回收","type":"link","path":"advance/gc.html"},{"text":"标准库","type":"label"},{"text":"fmt","type":"link","path":"standards/io/fmt.html"},{"text":"io","type":"link","path":"standards/io/io.html"},{"text":"ioutil","type":"link","path":"standards/io/ioutil.html"},{"text":"bufio","type":"link","path":"standards/io/bufio.html"},{"text":"os","type":"link","path":"standards/os/os.html"},{"text":"filepath","type":"link","path":"standards/os/filepath.html"},{"text":"strings","type":"link","path":"standards/text/strings.html"},{"text":"strconv","type":"link","path":"standards/text/strconv.html"},{"text":"unicode","type":"link","path":"standards/text/unicode.html"},{"text":"log","type":"link","path":"standards/log.html"},{"text":"time","type":"link","path":"standards/time.html"},{"text":"http","type":"link","path":"standards/net/http.html"},{"text":"math","type":"link","path":"standards/data/math.html"},{"text":"sort","type":"link","path":"standards/data/sort.html"},{"text":"big","type":"link","path":"standards/data/big.html"},{"text":"container","type":"link","path":"standards/data/container.html"},{"text":"sql","type":"link","path":"standards/database/sql.html"},{"text":"THEME","type":"label"},{"text":"使用文档主题","type":"link","path":"theme/theme-usage.html"},{"text":"SUPPORT AND FEEDBACK","type":"label"},{"text":"Raise an Issue on Github","type":"link","path":"https://github.com/shipengqi/golang-learn/issues/new"}]}},"config":{"timezone":"UTC","root":"/golang-learn/","time_format":"HH:mm:ss","theme":"../node_modules/hexo-theme-doc","theme_config":{"swagger_ui":{"version":2,"permalinks":true,"api_explorer":true,"download":"Download specification","show_extensions":false,"deep_linking":true,"display_operation_id":false,"doc_expansion":"none"},"search":{"skip":false,"background":false,"route":"/lunr.json"},"favicon":"images/favicon.ico"}}}</script>

    <div id="react-navigation-root"><div class="doc-navigation" data-reactroot><nav class="doc-navbar"><a href="/golang-learn/index.html" class="doc-navbar__logo"><img src="/golang-learn/images/logo.png" class="doc-navbar__logo__img"><span class="doc-navbar__logo__text">Golang Learn</span></a><i class="dc-icon dc-icon--close dc-icon--interactive doc-sidebar-close doc-navbar__sidebar-close doc-navbar__sidebar-close--desktop"></i><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-navbar__sidebar-toggle"></i></nav><nav class="doc-sidebar"><div class="doc-sidebar__vertical-menu"><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-sidebar-toggle--primary doc-sidebar__vertical-menu__item"></i><i class="dc-icon dc-icon--search dc-icon--interactive doc-sidebar__vertical-menu__item doc-sidebar__vertical-menu__item--primary"></i></div><div class="doc-sidebar-content"><div class="doc-sidebar__search-form"></div><ul class="doc-sidebar-list"></ul></div></nav></div></div>
    <div class="doc-content">
  <div class="dc-page">
    <div class="dc-card">
      <div id="react-search-results-root"></div>
      <div id="page-content" class="doc-formatting">
        <h1 id="filepath"><a href="#filepath" class="headerlink" title="filepath"></a>filepath</h1><p><code>filepath</code> 的功能和 <code>path</code> 包类似，但是对于不同操作系统提供了更好的支持。<code>filepath</code> 包能够自动的根据不同的操作系统文件路径进行转换，<br>通常情况下应该总是使用 <code>filepath</code> 包，而不是 <code>path</code> 包。</p>
<p><code>path/filepath</code> 包涉及到路径操作时，路径分隔符使用 <code>os.PathSeparator</code>。不同系统，路径表示方式有所不同，比如 Unix 和 Windows 差别很大。</p>
<p>例如，在 Unix 中，路径的分隔符是 <code>/</code>，但 Windows 是 <code>\</code>。</p>
<p><code>path/filepath</code> 能够处理所有的文件路径，不管是什么系统。注意，路径操作函数并不会校验路径是否真实存在。</p>
<h2 id="解析路径名字符串"><a href="#解析路径名字符串" class="headerlink" title="解析路径名字符串"></a>解析路径名字符串</h2><p><code>Dir()</code> 和 <code>Base()</code> 函数将一个路径名字符串分解成目录和文件名两部分。（一般情况，这些函数与 Unix 中 dirname 和 basename 命令类似，但如果<br>路径以 <code>/</code> 结尾，<code>Dir</code> 的行为和 <code>dirname</code> 不太一致。）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Dir</span><span class="params">(path <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">Base</span><span class="params">(path <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br></pre></td></tr></table></figure>
<p><code>Dir</code> 返回路径中除去最后一个路径元素的部分，即该路径最后一个元素所在的目录。在使用 <code>Split</code> 去掉最后一个元素后，会简化路径并去掉末尾的斜杠。<br>如果路径是空字符串，会返回 <code>.</code>；如果路径由 1 到多个斜杠后跟 0 到多个非斜杠字符组成，会返回 <code>/</code>；其他任何情况下都不会返回以斜杠结尾的路径。</p>
<p><code>Base</code> 函数返回路径的最后一个元素。在提取元素前会去掉末尾的斜杠。如果路径是 “”，会返回 <code>.</code>；如果路径是只有一个斜杆构成的，会返回 <code>/</code>。</p>
<p>比如，给定路径名 <code>/home/polaris/learngo.go</code>，<code>Dir</code> 返回 <code>/home/polaris</code>，而 <code>Base</code> 返回 <code>learngo.go</code>。</p>
<p>如果给定路径名 <code>/home/polaris/learngo/</code>，<code>Dir</code> 返回 <code>/home/polaris/learngo</code><br>（这与 Unix 中的 <code>dirname</code> 不一致，<code>dirname</code> 会返回 <code>/home/polaris</code>），而 <code>Base</code> 返回 <code>learngo</code>。</p>
<p>如果需要和 <code>dirname</code> 一样的功能，应该自己处理，比如在调用 <code>Dir</code> 之前，先将末尾的 <code>/</code> 去掉。</p>
<p>此外，<code>Ext</code> 可以获得路径中文件名的扩展名。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Ext</span><span class="params">(path <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br></pre></td></tr></table></figure>
<p><code>Ext</code> 函数返回 <code>path</code> 文件扩展名。扩展名是路径中最后一个从 <code>.</code> 开始的部分，包括 <code>.</code>。如果该元素没有 <code>.</code> 会返回空字符串。</p>
<h2 id="相对路径和绝对路径"><a href="#相对路径和绝对路径" class="headerlink" title="相对路径和绝对路径"></a>相对路径和绝对路径</h2><p>某个进程都会有当前工作目录，一般的相对路径，就是针对进程<strong>当前工作目录</strong>而言的。当然，可以针对某个目录指定相对路径。</p>
<p>绝对路径，在 Unix 中，以 <code>/</code> 开始；在 Windows 下以某个盘符开始，比如 <code>C:\Program Files</code>。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsAbs</span><span class="params">(path <span class="keyword">string</span>)</span> <span class="title">bool</span></span></span><br></pre></td></tr></table></figure></p>
<p><code>IsAbs</code> 返回路径是否是一个绝对路径。而<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Abs</span><span class="params">(path <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span></span><br></pre></td></tr></table></figure></p>
<p><code>Abs</code> 函数返回 <code>path</code> 代表的绝对路径，如果 <code>path</code> 不是绝对路径，会加入当前工作目录以使之成为绝对路径。因为硬链接的存在，不能保证返<br>回的绝对路径是唯一指向该地址的绝对路径。在 <code>os.Getwd</code> 出错时，<code>Abs</code> 会返回该错误，一般不会出错，如果路径名长度超过系统限制，则会报错。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Rel</span><span class="params">(basepath, targpath <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span></span><br></pre></td></tr></table></figure>
<p><code>Rel</code> 函数返回一个相对路径，返回值是 <code>targpath</code> 相对于 <code>basepath</code> 的相对路径，<br>即使 <code>basepath</code> 和 <code>targpath</code> 没有共享的路径元素。如果两个参数一个是相对路径而另一个是绝对路径，或者 <code>targpath</code> 无法表示为相对<br>于 <code>basepath</code> 的路径，将返回错误。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(filepath.Rel(<span class="string">"/home/polaris/learngo"</span>, <span class="string">"/home/polaris/learngo/src/logic/topic.go"</span>))</span><br><span class="line">fmt.Println(filepath.Rel(<span class="string">"/home/polaris/learngo"</span>, <span class="string">"/data/learngo"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// src/logic/topic.go &lt;nil&gt;</span></span><br><span class="line"><span class="comment">// ../../../data/learngo &lt;nil&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="路径的切分和拼接"><a href="#路径的切分和拼接" class="headerlink" title="路径的切分和拼接"></a>路径的切分和拼接</h2><p>对于一个常规文件路径，我们可以通过 <code>Split</code> 函数得到它的目录路径和文件名：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Split</span><span class="params">(path <span class="keyword">string</span>)</span> <span class="params">(dir, file <span class="keyword">string</span>)</span></span></span><br></pre></td></tr></table></figure></p>
<p><code>Split</code> 函数根据最后一个路径分隔符将路径 <code>path</code> 分隔为目录和文件名两部分（<code>dir</code> 和 <code>file</code>）。如果路径中没有路径分隔符，函数返回<br>值 <code>dir</code> 为空字符串，<code>file</code> 等于 <code>path</code>；反之，如果路径中最后一个字符是 <code>/</code>，则 <code>dir</code> 等于 <code>path</code>，<code>file</code> 为空字符串。<br>返回值满足 <code>path == dir+file</code>。<code>dir</code> 非空时，最后一个字符总是 <code>/</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dir == /home/polaris/，file == learngo</span></span><br><span class="line">filepath.Split(<span class="string">"/home/polaris/learngo"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// dir == /home/polaris/learngo/，file == ""</span></span><br><span class="line">filepath.Split(<span class="string">"/home/polaris/learngo/"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// dir == ""，file == learngo</span></span><br><span class="line">filepath.Split(<span class="string">"learngo"</span>)</span><br></pre></td></tr></table></figure>
<p>相对路径到绝对路径的转变，需要经过路径的拼接。<code>Join</code> 用于将多个路径拼接起来，会根据情况添加路径分隔符。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Join</span><span class="params">(elem ...<span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br></pre></td></tr></table></figure></p>
<p><code>Join</code> 函数可以将任意数量的路径元素放入一个单一路径里，会根据需要添加路径分隔符。结果是经过 <code>Clean</code> 的，所有的空字符串元素会被忽略。<br>对于拼接路径的需求，我们应该总是使用 <code>Join</code> 函数来处理。</p>
<p>有时，我们需要分割 <code>PATH</code> 或 <code>GOPATH</code> 之类的环境变量（这些路径被特定于 <code>OS</code> 的列表分隔符连接起来），<code>filepath.SplitList</code> 就是这个用途：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SplitList</span><span class="params">(path <span class="keyword">string</span>)</span> []<span class="title">string</span></span></span><br></pre></td></tr></table></figure></p>
<p>注意，与 <code>strings.Split</code> 函数的不同之处是：对 “”，<code>SplitList</code> 返回 <code>[]string{}</code>，而 <code>strings.Split</code> 返回 <code>[]string{&quot;&quot;}</code>。<br><code>SplitList</code> 内部调用的是 <code>strings.Split</code>。</p>
<h2 id="规整化路径"><a href="#规整化路径" class="headerlink" title="规整化路径"></a>规整化路径</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Clean</span><span class="params">(path <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br></pre></td></tr></table></figure>
<p><code>Clean</code> 函数通过单纯的词法操作返回和 <code>path</code> 代表同一地址的最短路径。</p>
<p>它会不断的依次应用如下的规则，直到不能再进行任何处理：</p>
<ol>
<li>将连续的多个路径分隔符替换为单个路径分隔符</li>
<li>剔除每一个 <code>.</code> 路径名元素（代表当前目录）</li>
<li>剔除每一个路径内的 <code>..</code> 路径名元素（代表父目录）和它前面的非 <code>..</code> 路径名元素</li>
<li>剔除开始于根路径的 <code>..</code> 路径名元素，即将路径开始处的 <code>/..</code> 替换为 <code>/</code>（假设路径分隔符是 <code>/</code>）</li>
</ol>
<p>返回的路径只有其代表一个根地址时才以路径分隔符结尾，如 Unix 的 <code>/</code> 或 Windows 的 <code>C:\</code>。</p>
<p>如果处理的结果是空字符串，Clean 会返回 <code>.</code>，代表当前路径。</p>
<h2 id="符号链接指向的路径名"><a href="#符号链接指向的路径名" class="headerlink" title="符号链接指向的路径名"></a>符号链接指向的路径名</h2><p><code>filepath.EvalSymlinks</code> 会将所有路径的符号链接都解析出来。除此之外，它返回的路径，是直接可访问的。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">EvalSymlinks</span><span class="params">(path <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span></span><br></pre></td></tr></table></figure></p>
<p>如果 <code>path</code> 或返回值是相对路径，则是相对于进程当前工作目录。</p>
<p><code>os.Readlink</code> 和 <code>filepath.EvalSymlinks</code> 区别示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在当前目录下创建一个 learngo.txt 文件和一个 symlink 目录，在 symlink 目录下对 learngo.txt 建一个符号链接 learngo.txt.2</span></span><br><span class="line">fmt.Println(filepath.EvalSymlinks(<span class="string">"symlink/learngo.txt.2"</span>))</span><br><span class="line">fmt.Println(os.Readlink(<span class="string">"symlink/learngo.txt.2"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// Ouput:</span></span><br><span class="line"><span class="comment">// learngo.txt &lt;nil&gt;</span></span><br><span class="line"><span class="comment">// ../learngo.txt &lt;nil&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="文件路径匹配"><a href="#文件路径匹配" class="headerlink" title="文件路径匹配"></a>文件路径匹配</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Match</span><span class="params">(pattern, name <span class="keyword">string</span>)</span> <span class="params">(matched <span class="keyword">bool</span>, err error)</span></span></span><br></pre></td></tr></table></figure>
<p><code>Match</code> 指示 <code>name</code> 是否和 shell 的文件模式匹配。模式语法如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pattern:</span><br><span class="line">	&#123; term &#125;</span><br><span class="line">term:</span><br><span class="line">	<span class="string">'*'</span>         匹配 <span class="number">0</span> 或多个非路径分隔符的字符</span><br><span class="line">	<span class="string">'?'</span>         匹配 <span class="number">1</span> 个非路径分隔符的字符</span><br><span class="line">	<span class="string">'['</span> [ <span class="string">'^'</span> ] &#123; character-<span class="keyword">range</span> &#125; <span class="string">']'</span>  </span><br><span class="line">				  字符组（必须非空）</span><br><span class="line">	c           匹配字符 c（c != <span class="string">'*'</span>, <span class="string">'?'</span>, <span class="string">'\\', '</span>[<span class="string">'）</span></span><br><span class="line"><span class="string">	'</span>\\<span class="string">' c      匹配字符 c</span></span><br><span class="line"><span class="string">character-range:</span></span><br><span class="line"><span class="string">	c           匹配字符 c（c != '</span>\\<span class="string">', '</span>-<span class="string">', '</span>]<span class="string">'）</span></span><br><span class="line"><span class="string">	'</span>\\<span class="string">' c      匹配字符 c</span></span><br><span class="line"><span class="string">	lo '</span>-<span class="string">' hi   匹配区间[lo, hi]内的字符</span></span><br></pre></td></tr></table></figure>
<p>匹配要求 <code>pattern</code> 必须和 <code>name</code> 全匹配上，不只是子串。在 Windows 下转义字符被禁用。</p>
<p><code>Match</code> 函数很少使用，搜索了一遍，标准库没有用到这个函数。而 <code>Glob</code> 函数在模板标准库中被用到了。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Glob</span><span class="params">(pattern <span class="keyword">string</span>)</span> <span class="params">(matches []<span class="keyword">string</span>, err error)</span></span></span><br></pre></td></tr></table></figure></p>
<p><code>Glob</code> 函数返回所有匹配了 模式字符串 <code>pattern</code> 的文件列表或者 nil（如果没有匹配的文件）。<code>pattern</code> 的语法和 <code>Match</code> 函数相同。<br><code>pattern</code> 可以描述多层的名字，如 <code>/usr/*/bin/ed</code>（假设路径分隔符是 <code>/</code>）。</p>
<p>注意，<code>Glob</code> 会忽略任何文件系统相关的错误，如读目录引发的 I/O 错误。唯一的错误和 <code>Match</code> 一样，在 <code>pattern</code> 不合法时，<br>返回 <code>filepath.ErrBadPattern</code>。返回的结果是根据文件名字典顺序进行了排序的。</p>
<p><code>Glob</code> 的常见用法，是读取某个目录下所有的文件，比如写单元测试时，读取 <code>testdata</code> 目录下所有测试数据：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filepath.Glob(<span class="string">"testdata/*.input"</span>)</span><br></pre></td></tr></table></figure></p>
<h2 id="遍历目录"><a href="#遍历目录" class="headerlink" title="遍历目录"></a>遍历目录</h2><p>在 <code>filepath</code> 中，提供了 <code>Walk</code> 函数，用于遍历目录树。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Walk</span><span class="params">(root <span class="keyword">string</span>, walkFn WalkFunc)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure></p>
<p><code>Walk</code> 函数会遍历 <code>root</code> 指定的目录下的文件树，对每一个该文件树中的目录和文件都会调用 <code>walkFn</code>，包括 <code>root</code> 自身。所有访问文件 <code>/</code> 目录<br>时遇到的错误都会传递给 <code>walkFn</code> 过滤。文件是按字典顺序遍历的，这让输出更漂亮，但也导致处理非常大的目录时效率会降低。<code>Walk</code> 函数不会遍历<br>文件树中的符号链接（快捷方式）文件包含的路径。</p>
<p><code>walkFn</code> 的类型 <code>WalkFunc</code> 的定义如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> WalkFunc <span class="function"><span class="keyword">func</span><span class="params">(path <span class="keyword">string</span>, info os.FileInfo, err error)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure></p>
<p><code>Walk</code> 函数对每一个文件 <code>/</code> 目录都会调用 <code>WalkFunc</code> 函数类型值。调用时 <code>path</code> 参数会包含 <code>Walk</code> 的 <code>root</code> 参数作为前缀；就是说，<br>如果 <code>Walk</code> 函数的 <code>root</code> 为 “dir”，该目录下有文件 “a”，将会使用 “dir/a” 作为调用 <code>walkFn</code> 的参数。<code>walkFn</code> 参数被调用时的 <code>info</code><br>参数是 <code>path</code> 指定的地址（文件 / 目录）的文件信息，类型为 <code>os.FileInfo</code>。</p>
<p>如果遍历 <code>path</code> 指定的文件或目录时出现了问题，传入的参数 <code>err</code> 会描述该问题，<code>WalkFunc</code> 类型函数可以决定如何去处理该错误<br>（<code>Walk</code> 函数将不会深入该目录）；如果该函数返回一个错误，<code>Walk</code> 函数的执行会中止；只有一个例外，如果 <code>Walk</code> 的 <code>walkFn</code> 返回<br>值是 <code>SkipDir</code>，将会跳过该目录的内容而 <code>Walk</code> 函数照常执行处理下一个文件。</p>
<h2 id="Windows-起作用的函数"><a href="#Windows-起作用的函数" class="headerlink" title="Windows 起作用的函数"></a>Windows 起作用的函数</h2><p><code>filepath</code> 中有三个函数：<code>VolumeName</code>、<code>FromSlash</code> 和 <code>ToSlash</code>，针对非 Unix 平台的。</p>

        <div id="react-support-footer-root"></div>
      </div>
    </div>
  </div>
</div>

    


    

    <!-- js vendors -->
    <script src="//code.jquery.com/jquery-3.2.1.min.js" crossorigin="anonymous"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/lunr.js/2.1.0/lunr.min.js"></script>

    <!-- js source  -->
    <script src="/golang-learn/script/doc.js"></script>

    

  </body>
</html>
