<!DOCTYPE html>
<html lang="en">
  <head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">

    <title>Golang learning | sql </title>
    <meta name="description" content>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    

    <!-- fonts -->
    <link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700" rel="stylesheet">
    <link href="//fonts.googleapis.com/css?family=Ubuntu:300,400,500,600,700" rel="stylesheet">

    <!-- stylesheets -->
    <link rel="stylesheet" href="/golang-learn/style/doc.css">

    <!-- favicon -->
    <link rel="icon" href="/golang-learn/images/favicon.ico">

    

  </head>
  <body>

   <script>window.__INITIAL_STATE__ = {"page":{"title":"sql","path":"standards/database/sql.html"},"data":{"navigation":{"logo":{"text":"Golang Learn","type":"link","path":"index.html"},"main":[{"text":"Golang 基础","type":"label"},{"text":"Go 环境配置","type":"link","path":"basic/env_config.html"},{"text":"包","type":"link","path":"basic/package.html"},{"text":"基础数据类型","type":"link","path":"basic/basic_data.html"},{"text":"变量","type":"link","path":"basic/var.html"},{"text":"常量","type":"link","path":"basic/constant.html"},{"text":"控制语句","type":"link","path":"basic/flow.html"},{"text":"运算符","type":"link","path":"basic/operator.html"},{"text":"作用域","type":"link","path":"basic/scope.html"},{"text":"指针","type":"link","path":"basic/pointer.html"},{"text":"数组","type":"link","path":"basic/array.html"},{"text":"切片","type":"link","path":"basic/slice.html"},{"text":"字典","type":"link","path":"basic/map.html"},{"text":"函数","type":"link","path":"basic/function.html"},{"text":"结构体","type":"link","path":"basic/struct.html"},{"text":"接口","type":"link","path":"basic/interface.html"},{"text":"面向对象","type":"link","path":"basic/oop.html"},{"text":"错误","type":"link","path":"basic/error.html"},{"text":"序列化","type":"link","path":"basic/json.html"},{"text":"反射","type":"link","path":"basic/reflect.html"},{"text":"测试","type":"link","path":"basic/test.html"},{"text":"并发编程","type":"label"},{"text":"goroutine","type":"link","path":"concurrent/goroutine.html"},{"text":"channel","type":"link","path":"concurrent/channel.html"},{"text":"同步和锁","type":"link","path":"concurrent/sync_lock.html"},{"text":"内存分配","type":"label"},{"text":"内存分配","type":"link","path":"advance/mm.html"},{"text":"垃圾回收","type":"label"},{"text":"垃圾回收","type":"link","path":"advance/gc.html"},{"text":"标准库","type":"label"},{"text":"fmt","type":"link","path":"standards/io/fmt.html"},{"text":"io","type":"link","path":"standards/io/io.html"},{"text":"ioutil","type":"link","path":"standards/io/ioutil.html"},{"text":"bufio","type":"link","path":"standards/io/bufio.html"},{"text":"os","type":"link","path":"standards/os/os.html"},{"text":"filepath","type":"link","path":"standards/os/filepath.html"},{"text":"strings","type":"link","path":"standards/text/strings.html"},{"text":"strconv","type":"link","path":"standards/text/strconv.html"},{"text":"unicode","type":"link","path":"standards/text/unicode.html"},{"text":"log","type":"link","path":"standards/log.html"},{"text":"time","type":"link","path":"standards/time.html"},{"text":"http","type":"link","path":"standards/net/http.html"},{"text":"math","type":"link","path":"standards/data/math.html"},{"text":"sort","type":"link","path":"standards/data/sort.html"},{"text":"big","type":"link","path":"standards/data/big.html"},{"text":"container","type":"link","path":"standards/data/container.html"},{"text":"sql","type":"link","path":"standards/database/sql.html"},{"text":"THEME","type":"label"},{"text":"使用文档主题","type":"link","path":"theme/theme-usage.html"},{"text":"SUPPORT AND FEEDBACK","type":"label"},{"text":"Raise an Issue on Github","type":"link","path":"https://github.com/shipengqi/golang-learn/issues/new"}]}},"config":{"timezone":"UTC","root":"/golang-learn/","time_format":"HH:mm:ss","theme":"../node_modules/hexo-theme-doc","theme_config":{"swagger_ui":{"version":2,"permalinks":true,"api_explorer":true,"download":"Download specification","show_extensions":false,"deep_linking":true,"display_operation_id":false,"doc_expansion":"none"},"search":{"skip":false,"background":false,"route":"/lunr.json"},"favicon":"images/favicon.ico"}}}</script>

    <div id="react-navigation-root"><div class="doc-navigation" data-reactroot><nav class="doc-navbar"><a href="/golang-learn/index.html" class="doc-navbar__logo"><img src="/golang-learn/images/logo.png" class="doc-navbar__logo__img"><span class="doc-navbar__logo__text">Golang Learn</span></a><i class="dc-icon dc-icon--close dc-icon--interactive doc-sidebar-close doc-navbar__sidebar-close doc-navbar__sidebar-close--desktop"></i><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-navbar__sidebar-toggle"></i></nav><nav class="doc-sidebar"><div class="doc-sidebar__vertical-menu"><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-sidebar-toggle--primary doc-sidebar__vertical-menu__item"></i><i class="dc-icon dc-icon--search dc-icon--interactive doc-sidebar__vertical-menu__item doc-sidebar__vertical-menu__item--primary"></i></div><div class="doc-sidebar-content"><div class="doc-sidebar__search-form"></div><ul class="doc-sidebar-list"></ul></div></nav></div></div>
    <div class="doc-content">
  <div class="dc-page">
    <div class="dc-card">
      <div id="react-search-results-root"></div>
      <div id="page-content" class="doc-formatting">
        <h1 id="sql"><a href="#sql" class="headerlink" title="sql"></a>sql</h1><p><code>database/sql</code> 提供了操作 SQL/SQL-Like 数据库的通用接口，但 Go 标准库并没有提供具体数据库的实现，需要结合第三方的驱动来使用该接口。<br>例如 mysql 的驱动：<a href="https://github.com/go-sql-driver/mysql" target="_blank" rel="noopener">github.com/go-sql-driver/mysql</a>。</p>
<h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p><code>database/sql</code> 提供了一些类型：</p>
<ul>
<li><code>sql.DB</code> 类型代表了一个数据库。它并<strong>不代表一个到数据库的具体连接，而是一个能操作的数据库对象</strong>，具体的连接在内部通过连接池来管理，<br>对外不暴露。</li>
<li><code>sql.Rows</code>、<code>sql.Row</code> 和 <code>sql.Result</code>，分别用于获取多个多行结果、一行结果和修改数据库影响的行数（或其返回 <code>last insert id</code>）。</li>
<li><code>sql.Stmt</code> 代表一个语句，如：DDL、DML 等。</li>
<li><code>sql.Tx</code> 代表带有特定属性的一个事务。</li>
</ul>
<h2 id="sql-DB-的使用"><a href="#sql-DB-的使用" class="headerlink" title="sql.DB 的使用"></a>sql.DB 的使用</h2><p><code>sql.DB</code> 是一个数据库句柄，代表一个具有零到多个底层连接的连接池，它可以安全的被多个 goroutine 同时使用。  </p>
<blockquote>
<p>sql 包会自动创建和释放连接；它也会维护一个闲置连接的连接池。如果数据库具有单连接状态的概念，该状态只有在事务中被观察时才可信。<br>一旦调用了 <code>BD.Begin</code>，返回的 <code>Tx</code> 会绑定到单个连接。当调用事务 <code>Tx</code> 的 <code>Commit</code> 或 <code>Rollback</code> 后，该事务使用的连接会归还到 <code>DB</code> 的闲<br>置连接池中。连接池的大小可以用 <code>SetMaxIdleConns</code> 方法控制。</p>
</blockquote>
<p>由于 <code>DB</code> 并非一个实际的到数据库的连接，而且可以被多个 goroutine 并发使用，因此，程序中只需要拥有一个全局的实例即可：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">db, err := sql.Open(<span class="string">"mysql"</span>, <span class="string">"root:@tcp(localhost:3306)/test?charset=utf8"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> db.Close()</span><br></pre></td></tr></table></figure></p>
<p>通常情况下，<code>defer db.Close()</code> 可以不调用，因为 <code>DB</code> 句柄通常被多个 goroutine 共享，并长期活跃。当然，如果你确定 DB 只会被使用一次，<br>之后不会使用了，应该调用 <code>Close</code>。</p>
<p>所以，实际应用时，应该在一个 go 文件中的 <code>init</code> 函数中调用 <code>sql.Open</code> 初始化全局的 <code>sql.DB</code> 对象，供程序中所有需要进<br>行数据库操作的地方使用。</p>
<p>前面说过，<code>sql.DB</code> 并不是实际的数据库连接，因此，<code>sql.Open</code> 函数并没有进行数据库连接。</p>
<p>例如：<code>db, err := sql.Open(&quot;mysql&quot;, &quot;root:@tcp23(localhost233:3306)/test?charset=utf8&quot;)</code>。虽然这里的 dsn 是错误的，<br>但依然 <code>err == nil</code>，只有在实际操作数据库（查询、更新等）或调用 <code>Ping</code> 时才会报错。</p>
<p>关于 <code>Open</code> 函数的参数，第一个是驱动名，为了避免混淆，一般和驱动包名一致，在驱动实现中，会有类似这样的代码：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    sql.Register(<span class="string">"mysql"</span>, &amp;MySQLDriver&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中 <code>mysql</code> 即是注册的驱动名。由于注册驱动是在 <code>init</code> 函数中进行的，这也就是为什么采用 <code>_ &quot;github.com/go-sql-driver/mysql&quot;</code><br>这种方式引入驱动包。第二个参数是 DSN（数据源名称），这个是和具体驱动相关的，<code>database/sql</code> 包并没有规定，具体书写方式参见驱动文档。</p>
<h3 id="连接池的工作原理"><a href="#连接池的工作原理" class="headerlink" title="连接池的工作原理"></a>连接池的工作原理</h3><p>获取 <code>DB</code> 对象后，连接池是空的，第一个连接在需要的时候才会创建：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">db, _ := sql.Open(<span class="string">"mysql"</span>, <span class="string">"root:@tcp(localhost:3306)/test?charset=utf8"</span>)</span><br><span class="line">fmt.Println(<span class="string">"please exec show processlist"</span>)</span><br><span class="line">time.Sleep(<span class="number">10</span> * time.Second)</span><br><span class="line">fmt.Println(<span class="string">"please exec show processlist again"</span>)</span><br><span class="line">db.Ping()</span><br><span class="line">time.Sleep(<span class="number">10</span> * time.Second)</span><br></pre></td></tr></table></figure></p>
<p>在 <code>Ping</code> 执行之前和之后，<code>show processlist</code> 多了一条记录，即多了一个连接，<code>Command</code> 列是 <code>Sleep</code>。</p>
<p>连接池的工作方式：当调用一个函数，需要访问数据库时，该函数会请求从连接池中获取一个连接，如果连接池中存在一个空闲连接，它会将该空闲连接给<br>该函数；否则，会打开一个新的连接。当该函数结束时，该连接要么返回给连接池，要么传递给某个需要该连接的对象，知道该对象完成时，连接才会返回给连<br>接池。相关方法的处理说明（假设 <code>sql.DB</code> 的对象是 <code>db</code>）：</p>
<ul>
<li><strong>db.Ping()</strong> 会将连接立马返回给连接池。</li>
<li><strong>db.Exec()</strong> 会将连接立马返回给连接池，但是它返回的 <code>Result</code> 对象会引用该连接，所以，之后可能会再次被使用。</li>
<li><strong>db.Query()</strong> 会传递连接给 <code>sql.Rows</code> 对象，直到完全遍历了所有的行或 <code>Rows</code> 的 <code>Close</code> 方法被调用了，连接才会返回给连接池。</li>
<li><strong>db.QueryRow()</strong> 会传递连接给 <code>sql.Row</code> 对象，当该对象的 <code>Scan</code> 方法被调用时，连接会返回给连接池。</li>
<li><strong>db.Begin()</strong> 会传递连接给 <code>sql.Tx</code> 对象，当该对象的 <code>Commit</code> 或 <code>Rollback</code> 方法被调用时，该连接会返回给连接池。</li>
</ul>
<p>大部分时候，我们不需要关心连接不释放问题，它们会自动返回给连接池，只有 Query 方法有点特殊。</p>
<p>注意：如果某个连接有问题（broken connection)，database/sql 内部会进行<br><a href="http://docs.studygolang.com/src/database/sql/sql.go?s=22080:22097#L824" target="_blank" rel="noopener">最多 10 次</a> 的重试，从连接池中获取<br>或新开一个连接来服务，因此，你的代码中不需要重试的逻辑。</p>
<h3 id="控制连接池"><a href="#控制连接池" class="headerlink" title="控制连接池"></a>控制连接池</h3><p>Go1.2.1 之前，没法控制连接池，Go1.2.1 之后，提供了两个方法来控制连接池。</p>
<ul>
<li><strong>db.SetMaxOpenConns(n int)</strong> 设置连接池中最多保存打开多少个数据库连接。注意，它包括在使用的和空闲的。如果某个方法调用需要一个连接，<br>但连接池中没有空闲的可用，且打开的连接数达到了该方法设置的最大值，该方法调用将堵塞。默认限制是 0，表示最大打开数没有限制。</li>
<li><strong>db.SetMaxIdleConns(n int)</strong> 设置连接池中能够保持的最大空闲连接的数量。<br><a href="http://docs.studygolang.com/src/database/sql/sql.go?s=13724:13743#L501" target="_blank" rel="noopener">默认值是 2</a> </li>
</ul>
<p>验证 <code>MaxIdleConns</code> 是 2：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">db, _ := sql.Open(<span class="string">"mysql"</span>, <span class="string">"root:@tcp(localhost:3306)/test?charset=utf8"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 去掉注释，可以看看相应的空闲连接是不是变化了</span></span><br><span class="line"><span class="comment">// db.SetMaxIdleConns(3)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		db.Ping()</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">time.Sleep(<span class="number">20</span> * time.Second)</span><br></pre></td></tr></table></figure></p>
<p>通过 <code>show processlist</code> 命令，可以看到有两个是 <code>Sleep</code> 的连接。</p>

        <div id="react-support-footer-root"></div>
      </div>
    </div>
  </div>
</div>

    


    

    <!-- js vendors -->
    <script src="//code.jquery.com/jquery-3.2.1.min.js" crossorigin="anonymous"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/lunr.js/2.1.0/lunr.min.js"></script>

    <!-- js source  -->
    <script src="/golang-learn/script/doc.js"></script>

    

  </body>
</html>
