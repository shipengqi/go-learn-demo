<!DOCTYPE html>
<html lang="en">
  <head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">

    <title>Golang learning | container </title>
    <meta name="description" content>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    

    <!-- fonts -->
    <link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700" rel="stylesheet">
    <link href="//fonts.googleapis.com/css?family=Ubuntu:300,400,500,600,700" rel="stylesheet">

    <!-- stylesheets -->
    <link rel="stylesheet" href="/golang-learn/style/doc.css">

    <!-- favicon -->
    <link rel="icon" href="/golang-learn/images/favicon.ico">

    

  </head>
  <body>

   <script>window.__INITIAL_STATE__ = {"page":{"title":"container","path":"standards/data/container.html"},"data":{"navigation":{"logo":{"text":"Golang Learn","type":"link","path":"index.html"},"main":[{"text":"Golang 基础","type":"label"},{"text":"Go 环境配置","type":"link","path":"basic/env_config.html"},{"text":"包","type":"link","path":"basic/package.html"},{"text":"基础数据类型","type":"link","path":"basic/basic_data.html"},{"text":"变量","type":"link","path":"basic/var.html"},{"text":"常量","type":"link","path":"basic/constant.html"},{"text":"控制语句","type":"link","path":"basic/flow.html"},{"text":"运算符","type":"link","path":"basic/operator.html"},{"text":"作用域","type":"link","path":"basic/scope.html"},{"text":"指针","type":"link","path":"basic/pointer.html"},{"text":"数组","type":"link","path":"basic/array.html"},{"text":"切片","type":"link","path":"basic/slice.html"},{"text":"字典","type":"link","path":"basic/map.html"},{"text":"函数","type":"link","path":"basic/function.html"},{"text":"结构体","type":"link","path":"basic/struct.html"},{"text":"接口","type":"link","path":"basic/interface.html"},{"text":"面向对象","type":"link","path":"basic/oop.html"},{"text":"错误","type":"link","path":"basic/error.html"},{"text":"序列化","type":"link","path":"basic/json.html"},{"text":"反射","type":"link","path":"basic/reflect.html"},{"text":"测试","type":"link","path":"basic/test.html"},{"text":"并发编程","type":"label"},{"text":"goroutine","type":"link","path":"concurrent/goroutine.html"},{"text":"channel","type":"link","path":"concurrent/channel.html"},{"text":"同步和锁","type":"link","path":"concurrent/sync_lock.html"},{"text":"内存分配","type":"label"},{"text":"内存分配","type":"link","path":"advance/mm.html"},{"text":"垃圾回收","type":"label"},{"text":"垃圾回收","type":"link","path":"advance/gc.html"},{"text":"标准库","type":"label"},{"text":"fmt","type":"link","path":"standards/io/fmt.html"},{"text":"io","type":"link","path":"standards/io/io.html"},{"text":"ioutil","type":"link","path":"standards/io/ioutil.html"},{"text":"bufio","type":"link","path":"standards/io/bufio.html"},{"text":"os","type":"link","path":"standards/os/os.html"},{"text":"filepath","type":"link","path":"standards/os/filepath.html"},{"text":"strings","type":"link","path":"standards/text/strings.html"},{"text":"strconv","type":"link","path":"standards/text/strconv.html"},{"text":"unicode","type":"link","path":"standards/text/unicode.html"},{"text":"log","type":"link","path":"standards/log.html"},{"text":"time","type":"link","path":"standards/time.html"},{"text":"http","type":"link","path":"standards/net/http.html"},{"text":"math","type":"link","path":"standards/data/math.html"},{"text":"sort","type":"link","path":"standards/data/sort.html"},{"text":"big","type":"link","path":"standards/data/big.html"},{"text":"container","type":"link","path":"standards/data/container.html"},{"text":"sql","type":"link","path":"standards/database/sql.html"},{"text":"THEME","type":"label"},{"text":"使用文档主题","type":"link","path":"theme/theme-usage.html"},{"text":"SUPPORT AND FEEDBACK","type":"label"},{"text":"Raise an Issue on Github","type":"link","path":"https://github.com/shipengqi/golang-learn/issues/new"}]}},"config":{"timezone":"UTC","root":"/golang-learn/","time_format":"HH:mm:ss","theme":"../node_modules/hexo-theme-doc","theme_config":{"swagger_ui":{"version":2,"permalinks":true,"api_explorer":true,"download":"Download specification","show_extensions":false,"deep_linking":true,"display_operation_id":false,"doc_expansion":"none"},"search":{"skip":false,"background":false,"route":"/lunr.json"},"favicon":"images/favicon.ico"}}}</script>

    <div id="react-navigation-root"><div class="doc-navigation" data-reactroot><nav class="doc-navbar"><a href="/golang-learn/index.html" class="doc-navbar__logo"><img src="/golang-learn/images/logo.png" class="doc-navbar__logo__img"><span class="doc-navbar__logo__text">Golang Learn</span></a><i class="dc-icon dc-icon--close dc-icon--interactive doc-sidebar-close doc-navbar__sidebar-close doc-navbar__sidebar-close--desktop"></i><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-navbar__sidebar-toggle"></i></nav><nav class="doc-sidebar"><div class="doc-sidebar__vertical-menu"><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-sidebar-toggle--primary doc-sidebar__vertical-menu__item"></i><i class="dc-icon dc-icon--search dc-icon--interactive doc-sidebar__vertical-menu__item doc-sidebar__vertical-menu__item--primary"></i></div><div class="doc-sidebar-content"><div class="doc-sidebar__search-form"></div><ul class="doc-sidebar-list"></ul></div></nav></div></div>
    <div class="doc-content">
  <div class="dc-page">
    <div class="dc-card">
      <div id="react-search-results-root"></div>
      <div id="page-content" class="doc-formatting">
        <h1 id="container"><a href="#container" class="headerlink" title="container"></a>container</h1><p><code>container</code> 该包实现了三个复杂的数据结构：链表，环，堆。也就是说使用这三个数据结构的时候不需要再从头开始写算法了。</p>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>链表就是一个有 <code>prev</code> 和 <code>next</code> 指针的数组了。<br><code>container</code> 包中有两个公开的结构—— <code>List</code> 和 <code>Element</code>，<code>List</code> 实现了一个双向链表（简称链表），<br>而 <code>Element</code> 则代表了链表中元素的结构。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Element <span class="keyword">struct</span> &#123;</span><br><span class="line">	next, prev *Element  <span class="comment">// 上一个元素和下一个元素</span></span><br><span class="line">	list *List  <span class="comment">// 元素所在链表</span></span><br><span class="line">	Value <span class="keyword">interface</span>&#123;&#125;  <span class="comment">// 元素</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> List <span class="keyword">struct</span> &#123;</span><br><span class="line">	root Element  <span class="comment">// 链表的根元素</span></span><br><span class="line">	<span class="built_in">len</span>  <span class="keyword">int</span>      <span class="comment">// 链表的长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>List的四种方法:</p>
<ul>
<li><code>MoveBefore</code> 方法和 <code>MoveAfter</code> 方法，它们分别用于把给定的元素移动到另一个元素的前面和后面。</li>
<li><code>MoveToFront</code> 方法和 <code>MoveToBack</code> 方法，分别用于把给定的元素移动到链表的最前端和最后端。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// moves element "e" to its new position before "mark".</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *List)</span> <span class="title">MoveBefore</span><span class="params">(e, mark *Element)</span></span></span><br><span class="line"><span class="function">// <span class="title">moves</span> <span class="title">element</span> "<span class="title">e</span>" <span class="title">to</span> <span class="title">its</span> <span class="title">new</span> <span class="title">position</span> <span class="title">after</span> "<span class="title">mark</span>".</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(l *List)</span> <span class="title">MoveAfter</span><span class="params">(e, mark *Element)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// <span class="title">moves</span> <span class="title">element</span> "<span class="title">e</span>" <span class="title">to</span> <span class="title">the</span> <span class="title">front</span> <span class="title">of</span> <span class="title">list</span> "<span class="title">l</span>".</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(l *List)</span> <span class="title">MoveToFront</span><span class="params">(e *Element)</span></span></span><br><span class="line"><span class="function">// <span class="title">moves</span> <span class="title">element</span> "<span class="title">e</span>" <span class="title">to</span> <span class="title">the</span> <span class="title">back</span> <span class="title">of</span> <span class="title">list</span> "<span class="title">l</span>".</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(l *List)</span> <span class="title">MoveToBack</span><span class="params">(e *Element)</span></span></span><br></pre></td></tr></table></figure>
<p>“给定的元素”都是 <code>*Element</code> 类型。</p>
<p>如果我们自己生成这样的值，然后把它作为“给定的元素”传给链表的方法，那么会发生什么？链表会接受它吗？</p>
<p>不会接受，这些方法将不会对链表做出任何改动。因为我们自己生成的 <code>Element</code> 值并不在链表中，所以也就谈不上“在链表中移动元素”。</p>
<ul>
<li><code>InsertBefore</code> 和 <code>InsertAfter</code> 方法分别用于在指定的元素之前和之后插入新元素。</li>
<li><code>PushFront</code> 和 <code>PushBack</code> 方法则分别用于在链表的最前端和最后端插入新元素。</li>
</ul>
<p>示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"container/list"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    list := list.New()</span><br><span class="line">    list.PushBack(<span class="number">1</span>)</span><br><span class="line">    list.PushBack(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">"len: %v\n"</span>, list.Len())</span><br><span class="line">    fmt.Printf(<span class="string">"first: %#v\n"</span>, list.Front())</span><br><span class="line">    fmt.Printf(<span class="string">"second: %#v\n"</span>, list.Front().Next())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line"><span class="built_in">len</span>: <span class="number">2</span></span><br><span class="line">first: &amp;list.Element&#123;next:(*list.Element)(<span class="number">0x2081be1b0</span>), prev:(*list.Element)(<span class="number">0x2081be150</span>), list:(*list.List)(<span class="number">0x2081be150</span>), Value:<span class="number">1</span>&#125;</span><br><span class="line">second: &amp;list.Element&#123;next:(*list.Element)(<span class="number">0x2081be150</span>), prev:(*list.Element)(<span class="number">0x2081be180</span>), list:(*list.List)(<span class="number">0x2081be150</span>), Value:<span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure>
<p>List 的其他方法：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Element</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="params">(e *Element)</span> <span class="title">Next</span><span class="params">()</span> *<span class="title">Element</span></span></span><br><span class="line"><span class="function">    <span class="title">func</span> <span class="params">(e *Element)</span> <span class="title">Prev</span><span class="params">()</span> *<span class="title">Element</span></span></span><br><span class="line"><span class="function"><span class="title">type</span> <span class="title">List</span></span></span><br><span class="line"><span class="function">    <span class="title">func</span> <span class="title">New</span><span class="params">()</span> *<span class="title">List</span></span></span><br><span class="line"><span class="function">    <span class="title">func</span> <span class="params">(l *List)</span> <span class="title">Back</span><span class="params">()</span> *<span class="title">Element</span>   // 最后一个元素</span></span><br><span class="line"><span class="function">    <span class="title">func</span> <span class="params">(l *List)</span> <span class="title">Front</span><span class="params">()</span> *<span class="title">Element</span>  // 第一个元素</span></span><br><span class="line"><span class="function">    <span class="title">func</span> <span class="params">(l *List)</span> <span class="title">Init</span><span class="params">()</span> *<span class="title">List</span>  // 链表初始化</span></span><br><span class="line"><span class="function">    <span class="title">func</span> <span class="params">(l *List)</span> <span class="title">InsertAfter</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;, mark *Element)</span> *<span class="title">Element</span> // 在某个元素后插入</span></span><br><span class="line"><span class="function">    <span class="title">func</span> <span class="params">(l *List)</span> <span class="title">InsertBefore</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;, mark *Element)</span> *<span class="title">Element</span>  // 在某个元素前插入</span></span><br><span class="line"><span class="function">    <span class="title">func</span> <span class="params">(l *List)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span> // 在链表长度</span></span><br><span class="line"><span class="function">    <span class="title">func</span> <span class="params">(l *List)</span> <span class="title">PushBackList</span><span class="params">(other *List)</span>  // 在队列最后插入接上新队列</span></span><br><span class="line"><span class="function">    <span class="title">func</span> <span class="params">(l *List)</span> <span class="title">PushFrontList</span><span class="params">(other *List)</span> // 在队列头部插入接上新队列</span></span><br><span class="line"><span class="function">    <span class="title">func</span> <span class="params">(l *List)</span> <span class="title">Remove</span><span class="params">(e *Element)</span> <span class="title">interface</span></span>&#123;&#125; <span class="comment">// 删除某个元素</span></span><br></pre></td></tr></table></figure></p>
<h2 id="环"><a href="#环" class="headerlink" title="环"></a>环</h2><p>环的结构有点特殊，环的尾部就是头部，指向环形链表任一元素的指针都可以作为整个环形链表看待。<br>它不需要像 List 一样保持 List 和 Element 两个结构，只需要保持一个结构就行。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Ring <span class="keyword">struct</span> &#123;</span><br><span class="line">	next, prev *Ring</span><br><span class="line">	Value      <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始化环的时候，需要定义好环的大小，然后对环的每个元素进行赋值。环还提供一个 <code>Do</code> 方法，能遍历一遍环，对每个元素执行<br>一个 <code>function</code>。</p>
<p>示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"container/ring"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ring := ring.New(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++ &#123;</span><br><span class="line">        ring.Value = i</span><br><span class="line">        ring = ring.Next()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算 1+2+3</span></span><br><span class="line">    s := <span class="number">0</span></span><br><span class="line">    ring.Do(<span class="function"><span class="keyword">func</span><span class="params">(p <span class="keyword">interface</span>&#123;&#125;)</span></span>&#123;</span><br><span class="line">        s += p.(<span class="keyword">int</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    fmt.Println(<span class="string">"sum is"</span>, s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">sum is <span class="number">6</span></span><br></pre></td></tr></table></figure>
<p>ring 提供的方法有</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Ring</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(n <span class="keyword">int</span>)</span> *<span class="title">Ring</span> // 创建一个长度为 <span class="title">n</span> 的环形链表</span></span><br><span class="line"><span class="function">    <span class="title">func</span> <span class="params">(r *Ring)</span> <span class="title">Do</span><span class="params">(f <span class="keyword">func</span>(<span class="keyword">interface</span>&#123;&#125;)</span>) // 遍历环形链表中的每一个元素 <span class="title">x</span> 进行 <span class="title">f</span><span class="params">(x)</span> 操作</span></span><br><span class="line"><span class="function">    <span class="title">func</span> <span class="params">(r *Ring)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span> // 获取环形链表长度</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">    // 如果 <span class="title">r</span> 和 <span class="title">s</span> 在同一环形链表中，则删除 <span class="title">r</span> 和 <span class="title">s</span> 之间的元素，</span></span><br><span class="line"><span class="function">    // 被删除的元素组成一个新的环形链表，返回值为该环形链表的指针（即删除前，<span class="title">r</span>-&gt;<span class="title">Next</span><span class="params">()</span> 表示的元素）</span></span><br><span class="line"><span class="function">    // 如果 <span class="title">r</span> 和 <span class="title">s</span> 不在同一个环形链表中，则将 <span class="title">s</span> 插入到 <span class="title">r</span> 后面，返回值为</span></span><br><span class="line"><span class="function">    // 插入 <span class="title">s</span> 后，<span class="title">s</span> 最后一个元素的下一个元素（即插入前，<span class="title">r</span>-&gt;<span class="title">Next</span><span class="params">()</span> 表示的元素）</span></span><br><span class="line"><span class="function">    <span class="title">func</span> <span class="params">(r *Ring)</span> <span class="title">Link</span><span class="params">(s *Ring)</span> *<span class="title">Ring</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="title">func</span> <span class="params">(r *Ring)</span> <span class="title">Move</span><span class="params">(n <span class="keyword">int</span>)</span> *<span class="title">Ring</span> // 移动 <span class="title">n</span> % <span class="title">r</span>.<span class="title">Len</span><span class="params">()</span> 个位置，<span class="title">n</span> 正负均可</span></span><br><span class="line"><span class="function">    <span class="title">func</span> <span class="params">(r *Ring)</span> <span class="title">Next</span><span class="params">()</span> *<span class="title">Ring</span> // 返回下一个元素</span></span><br><span class="line"><span class="function">    <span class="title">func</span> <span class="params">(r *Ring)</span> <span class="title">Prev</span><span class="params">()</span> *<span class="title">Ring</span> // 返回前一个元素</span></span><br><span class="line"><span class="function">    <span class="title">func</span> <span class="params">(r *Ring)</span> <span class="title">Unlink</span><span class="params">(n <span class="keyword">int</span>)</span> *<span class="title">Ring</span> // 删除 <span class="title">r</span> 后面的 <span class="title">n</span> % <span class="title">r</span>.<span class="title">Len</span><span class="params">()</span> 个元素</span></span><br></pre></td></tr></table></figure>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><h3 id="什么是堆"><a href="#什么是堆" class="headerlink" title="什么是堆"></a>什么是堆</h3><p>堆（Heap，也叫优先队列）是计算机科学中一类特殊的数据结构的统称。<strong>堆通常是一个可以被看做一棵树的数组对象</strong>。</p>
<p>堆具有以下特性：</p>
<ul>
<li>任意节点小于（或大于）它的所有后裔，最小元（或最大元）在堆的根上（堆序性）。</li>
<li>堆总是一棵完全树。即除了最底层，其他层的节点都被元素填满，且最底层尽可能地从左到右填入。</li>
</ul>
<p>将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。</p>
<h3 id="Heap"><a href="#Heap" class="headerlink" title="Heap"></a>Heap</h3><p><code>heap</code> 使用的数据结构是最小堆，<code>heap</code> 包只是实现了一个接口：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">    sort.Interface</span><br><span class="line">    Push(x <span class="keyword">interface</span>&#123;&#125;) <span class="comment">// add x as element Len()</span></span><br><span class="line">    Pop() <span class="keyword">interface</span>&#123;&#125;   <span class="comment">// remove and return element Len() - 1.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个接口内嵌了 <code>sort.Interface</code>，那么要实现 <code>heap.Interface</code> 要实现下面的方法：</p>
<ul>
<li><code>Len() int</code></li>
<li><code>Less(i, j int) bool</code></li>
<li><code>Swap(i, j int)</code></li>
<li><code>Push(x interface{})</code></li>
<li><code>Pop() interface{}</code></li>
</ul>
<p>示例：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IntHeap []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(h) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> h[i] &lt; h[j] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span>      &#123; h[i], h[j] = h[j], h[i] &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *IntHeap)</span> <span class="title">Push</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    *h = <span class="built_in">append</span>(*h, x.(<span class="keyword">int</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *IntHeap)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">    old := *h</span><br><span class="line">    n := <span class="built_in">len</span>(old)</span><br><span class="line">    x := old[n<span class="number">-1</span>]</span><br><span class="line">    *h = old[<span class="number">0</span> : n<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="heap-提供的方法"><a href="#heap-提供的方法" class="headerlink" title="heap 提供的方法"></a>heap 提供的方法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">h := &amp;IntHeap&#123;<span class="number">3</span>, <span class="number">8</span>, <span class="number">6</span>&#125;  <span class="comment">// 创建 IntHeap 类型的原始数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Init</span><span class="params">(h Interface)</span>  // 对 <span class="title">heap</span> 进行初始化，生成小根堆（或大根堆）</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">Push</span><span class="params">(h Interface, x <span class="keyword">interface</span>&#123;&#125;)</span>  // 往堆里面插入内容</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">Pop</span><span class="params">(h Interface)</span> <span class="title">interface</span></span>&#123;&#125;  <span class="comment">// 从堆顶 pop 出内容</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Remove</span><span class="params">(h Interface, i <span class="keyword">int</span>)</span> <span class="title">interface</span></span>&#123;&#125;  <span class="comment">// 从指定位置删除数据，并返回删除的数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fix</span><span class="params">(h Interface, i <span class="keyword">int</span>)</span>  // 从 <span class="title">i</span> 位置数据发生改变后，对堆再平衡，优先级队列使用到了该方法</span></span><br></pre></td></tr></table></figure>
<h4 id="实现优先级队列"><a href="#实现优先级队列" class="headerlink" title="实现优先级队列"></a>实现优先级队列</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"container/heap"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Item <span class="keyword">struct</span> &#123;</span><br><span class="line">    value    <span class="keyword">string</span> <span class="comment">// 优先级队列中的数据，可以是任意类型，这里使用 string</span></span><br><span class="line">    priority <span class="keyword">int</span>    <span class="comment">// 优先级队列中节点的优先级</span></span><br><span class="line">    index    <span class="keyword">int</span>    <span class="comment">// index 是该节点在堆中的位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优先级队列需要实现 heap 的 Interface</span></span><br><span class="line"><span class="keyword">type</span> PriorityQueue []*Item</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq PriorityQueue)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(pq)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里用的是小于号，生成的是最小堆</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq PriorityQueue)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> pq[i].priority &lt; pq[j].priority</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq PriorityQueue)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    pq[i], pq[j] = pq[j], pq[i]</span><br><span class="line">    pq[i].index, pq[j].index = i, j</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 index 置为 -1 是为了标识该数据已经出了优先级队列了</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq *PriorityQueue)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">    old := *pq</span><br><span class="line">    n := <span class="built_in">len</span>(old)</span><br><span class="line">    item := old[n<span class="number">-1</span>]</span><br><span class="line">    *pq = old[<span class="number">0</span> : n<span class="number">-1</span>]</span><br><span class="line">    item.index = <span class="number">-1</span></span><br><span class="line">    <span class="keyword">return</span> item</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq *PriorityQueue)</span> <span class="title">Push</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(*pq)</span><br><span class="line">    item := x.(*Item)</span><br><span class="line">    item.index = n</span><br><span class="line">    *pq = <span class="built_in">append</span>(*pq, item)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新修改了优先级和值的 item 在优先级队列中的位置</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq *PriorityQueue)</span> <span class="title">update</span><span class="params">(item *Item, value <span class="keyword">string</span>, priority <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    item.value = value</span><br><span class="line">    item.priority = priority</span><br><span class="line">    heap.Fix(pq, item.index)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建节点并设计他们的优先级</span></span><br><span class="line">    items := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;<span class="string">"二毛"</span>: <span class="number">5</span>, <span class="string">"张三"</span>: <span class="number">3</span>, <span class="string">"狗蛋"</span>: <span class="number">9</span>&#125;</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    pq := <span class="built_in">make</span>(PriorityQueue, <span class="built_in">len</span>(items)) <span class="comment">// 创建优先级队列，并初始化</span></span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> items &#123;             <span class="comment">// 将节点放到优先级队列中</span></span><br><span class="line">        pq[i] = &amp;Item&#123;</span><br><span class="line">            value:    k,</span><br><span class="line">            priority: v,</span><br><span class="line">            index:    i&#125;</span><br><span class="line">        i++</span><br><span class="line">    &#125;</span><br><span class="line">    heap.Init(&amp;pq) <span class="comment">// 初始化堆</span></span><br><span class="line">    item := &amp;Item&#123; <span class="comment">// 创建一个 item</span></span><br><span class="line">        value:    <span class="string">"李四"</span>,</span><br><span class="line">        priority: <span class="number">1</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    heap.Push(&amp;pq, item)           <span class="comment">// 入优先级队列</span></span><br><span class="line">    pq.update(item, item.value, <span class="number">6</span>) <span class="comment">// 更新 item 的优先级</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(pq) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        item := heap.Pop(&amp;pq).(*Item)</span><br><span class="line">        fmt.Printf(<span class="string">"%.2d:%s index:%.2d\n"</span>, item.priority, item.value, item.index)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果：</span></span><br><span class="line"><span class="comment">// 03:张三 index:-01</span></span><br><span class="line"><span class="comment">// 05:二毛 index:-01</span></span><br><span class="line"><span class="comment">// 06:李四 index:-01</span></span><br><span class="line"><span class="comment">// 09:狗蛋 index:-01</span></span><br></pre></td></tr></table></figure>
        <div id="react-support-footer-root"></div>
      </div>
    </div>
  </div>
</div>

    


    

    <!-- js vendors -->
    <script src="//code.jquery.com/jquery-3.2.1.min.js" crossorigin="anonymous"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/lunr.js/2.1.0/lunr.min.js"></script>

    <!-- js source  -->
    <script src="/golang-learn/script/doc.js"></script>

    

  </body>
</html>
