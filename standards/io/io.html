<!DOCTYPE html>
<html lang="en">
  <head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">

    <title>Golang learning | io </title>
    <meta name="description" content>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    

    <!-- fonts -->
    <link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700" rel="stylesheet">
    <link href="//fonts.googleapis.com/css?family=Ubuntu:300,400,500,600,700" rel="stylesheet">

    <!-- stylesheets -->
    <link rel="stylesheet" href="/golang-learn/style/doc.css">

    <!-- favicon -->
    <link rel="icon" href="/golang-learn/images/favicon.ico">

    

  </head>
  <body>

   <script>window.__INITIAL_STATE__ = {"page":{"title":"io","path":"standards/io/io.html"},"data":{"navigation":{"logo":{"text":"Golang Learn","type":"link","path":"index.html"},"main":[{"text":"Golang 基础","type":"label"},{"text":"Go 环境配置","type":"link","path":"basic/env_config.html"},{"text":"包","type":"link","path":"basic/package.html"},{"text":"基础数据类型","type":"link","path":"basic/basic_data.html"},{"text":"变量","type":"link","path":"basic/var.html"},{"text":"常量","type":"link","path":"basic/constant.html"},{"text":"控制语句","type":"link","path":"basic/flow.html"},{"text":"运算符","type":"link","path":"basic/operator.html"},{"text":"作用域","type":"link","path":"basic/scope.html"},{"text":"指针","type":"link","path":"basic/pointer.html"},{"text":"数组","type":"link","path":"basic/array.html"},{"text":"切片","type":"link","path":"basic/slice.html"},{"text":"字典","type":"link","path":"basic/map.html"},{"text":"函数","type":"link","path":"basic/function.html"},{"text":"结构体","type":"link","path":"basic/struct.html"},{"text":"接口","type":"link","path":"basic/interface.html"},{"text":"面向对象","type":"link","path":"basic/oop.html"},{"text":"错误","type":"link","path":"basic/error.html"},{"text":"序列化","type":"link","path":"basic/json.html"},{"text":"反射","type":"link","path":"basic/reflect.html"},{"text":"测试","type":"link","path":"basic/test.html"},{"text":"并发编程","type":"label"},{"text":"goroutine","type":"link","path":"concurrent/goroutine.html"},{"text":"channel","type":"link","path":"concurrent/channel.html"},{"text":"同步和锁","type":"link","path":"concurrent/sync_lock.html"},{"text":"内存分配","type":"label"},{"text":"内存分配","type":"link","path":"advance/mm.html"},{"text":"垃圾回收","type":"label"},{"text":"垃圾回收","type":"link","path":"advance/gc.html"},{"text":"标准库","type":"label"},{"text":"fmt","type":"link","path":"standards/io/fmt.html"},{"text":"io","type":"link","path":"standards/io/io.html"},{"text":"ioutil","type":"link","path":"standards/io/ioutil.html"},{"text":"bufio","type":"link","path":"standards/io/bufio.html"},{"text":"os","type":"link","path":"standards/os/os.html"},{"text":"filepath","type":"link","path":"standards/os/filepath.html"},{"text":"strings","type":"link","path":"standards/text/strings.html"},{"text":"strconv","type":"link","path":"standards/text/strconv.html"},{"text":"unicode","type":"link","path":"standards/text/unicode.html"},{"text":"log","type":"link","path":"standards/log.html"},{"text":"time","type":"link","path":"standards/time.html"},{"text":"http","type":"link","path":"standards/net/http.html"},{"text":"math","type":"link","path":"standards/data/math.html"},{"text":"sort","type":"link","path":"standards/data/sort.html"},{"text":"big","type":"link","path":"standards/data/big.html"},{"text":"container","type":"link","path":"standards/data/container.html"},{"text":"sql","type":"link","path":"standards/database/sql.html"},{"text":"THEME","type":"label"},{"text":"使用文档主题","type":"link","path":"theme/theme-usage.html"},{"text":"SUPPORT AND FEEDBACK","type":"label"},{"text":"Raise an Issue on Github","type":"link","path":"https://github.com/shipengqi/golang-learn/issues/new"}]}},"config":{"timezone":"UTC","root":"/golang-learn/","time_format":"HH:mm:ss","theme":"../node_modules/hexo-theme-doc","theme_config":{"swagger_ui":{"version":2,"permalinks":true,"api_explorer":true,"download":"Download specification","show_extensions":false,"deep_linking":true,"display_operation_id":false,"doc_expansion":"none"},"search":{"skip":false,"background":false,"route":"/lunr.json"},"favicon":"images/favicon.ico"}}}</script>

    <div id="react-navigation-root"><div class="doc-navigation" data-reactroot><nav class="doc-navbar"><a href="/golang-learn/index.html" class="doc-navbar__logo"><img src="/golang-learn/images/logo.png" class="doc-navbar__logo__img"><span class="doc-navbar__logo__text">Golang Learn</span></a><i class="dc-icon dc-icon--close dc-icon--interactive doc-sidebar-close doc-navbar__sidebar-close doc-navbar__sidebar-close--desktop"></i><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-navbar__sidebar-toggle"></i></nav><nav class="doc-sidebar"><div class="doc-sidebar__vertical-menu"><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-sidebar-toggle--primary doc-sidebar__vertical-menu__item"></i><i class="dc-icon dc-icon--search dc-icon--interactive doc-sidebar__vertical-menu__item doc-sidebar__vertical-menu__item--primary"></i></div><div class="doc-sidebar-content"><div class="doc-sidebar__search-form"></div><ul class="doc-sidebar-list"></ul></div></nav></div></div>
    <div class="doc-content">
  <div class="dc-page">
    <div class="dc-card">
      <div id="react-search-results-root"></div>
      <div id="page-content" class="doc-formatting">
        <h1 id="io"><a href="#io" class="headerlink" title="io"></a>io</h1><p><code>io</code> 是对输入输出设备的抽象。<code>io</code> 库对这些功能进行了抽象，通过统一的接口对输入输出设备进行操作。<br>最重要的是两个接口：<code>Reader</code> 和 <code>Writer</code>。</p>
<h2 id="Reader"><a href="#Reader" class="headerlink" title="Reader"></a>Reader</h2><p>Reader 接口：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123;</span><br><span class="line">    Read(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>Read</code> 将 <code>len(p)</code> 个字节读取到 <code>p</code> 中。它返回读取的字节数 <code>n</code>（<code>0 &lt;= n &lt;= len(p)</code>） 以及任何遇到的错误。<br>即使 <code>Read</code> 返回的 <code>n &lt; len(p)</code>，它也会在调用过程中占用 <code>len(p)</code> 个字节作为暂存空间。若可读取的数据不到 <code>len(p)</code> 个<br>字节，<code>Read</code> 会返回可用数据，而不是等待更多数据。</p>
</blockquote>
<blockquote>
<p>当 <code>Read</code> 在成功读取 <code>n &gt; 0</code> 个字节后遇到一个错误或 <code>EOF</code> (<code>end-of-file</code>)，它会返回读取的字节数。它可能会同时在本次的调<br>用中返回一个 <code>non-nil</code> 错误,或在下一次的调用中返回这个错误（且 <code>n</code> 为 0）。 一般情况下, <code>Reader</code> 会返回一个 非 0 字节数 <code>n</code>,<br>若 <code>n = len(p)</code> 个字节从输入源的结尾处由 <code>Read</code> 返回，<code>Read</code> 可能返回 <code>err == EOF</code> 或者 <code>err == nil</code>。并且之后的 <code>Read</code><br>都应该返回 (<code>n:0, err:EOF</code>)。</p>
</blockquote>
<blockquote>
<p>调用者在考虑错误之前应当首先处理返回的数据。这样做可以正确地处理在读取一些字节后产生的 I/O 错误，同时允许 <code>EOF</code> 的出现。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadFrom</span><span class="params">(reader io.Reader, num <span class="keyword">int</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">	p := <span class="built_in">make</span>([]<span class="keyword">byte</span>, num)</span><br><span class="line">	n, err := reader.Read(p)</span><br><span class="line">	<span class="keyword">if</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> p[:n], <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ReadFrom</code> 函数将 <code>io.Reader</code> 作为参数，也就是说，<code>ReadFrom</code> 可以从任意的地方读取数据，只要来源实现了 <code>io.Reader</code> 接口。<br>比如，我们可以从标准输入、文件、字符串等读取数据，示例代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从标准输入读取</span></span><br><span class="line">data, err = ReadFrom(os.Stdin, <span class="number">11</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从普通文件读取，其中 file 是 os.File 的实例</span></span><br><span class="line">data, err = ReadFrom(file, <span class="number">9</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从字符串读取</span></span><br><span class="line">data, err = ReadFrom(strings.NewReader(<span class="string">"from string"</span>), <span class="number">12</span>)</span><br></pre></td></tr></table></figure>
<p><code>io.EOF</code> 变量的定义：<code>var EOF = errors.New(&quot;EOF&quot;)</code>，是 <code>error</code> 类型。根据 <code>reader</code> 接口的说明，在 <code>n &gt; 0</code> 且数据被读完了<br>的情况下，当次返回的 <code>error</code> 有可能是 <code>EOF</code> 也有可能是 <code>nil</code>。</p>
<h2 id="Writer"><a href="#Writer" class="headerlink" title="Writer"></a>Writer</h2><p>Writer 接口：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> &#123;</span><br><span class="line">    Write(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>Write</code> 将 <code>len(p)</code> 个字节从 <code>p</code> 中写入到基本数据流中。它返回从 <code>p</code> 中被写入的字节数 <code>n</code>（<code>0 &lt;= n &lt;= len(p)</code>）以及任何遇到的引<br>起写入提前停止的错误。若 <code>Write</code> 返回的 <code>n &lt; len(p)</code>，它就必须返回一个 <strong>非 nil</strong> 的错误。</p>
</blockquote>
<p>以 <code>fmt.Fprintln</code> 为例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Println</span><span class="params">(a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> Fprintln(os.Stdout, a...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出 <code>fmt.Println</code> 会将内容输出到标准输出中。</p>
<h2 id="实现了-io-Reader-接口或-io-Writer-接口的类型"><a href="#实现了-io-Reader-接口或-io-Writer-接口的类型" class="headerlink" title="实现了 io.Reader 接口或 io.Writer 接口的类型"></a>实现了 io.Reader 接口或 io.Writer 接口的类型</h2><p>标准库中有哪些类型实现了 <code>io.Reader</code> 或 <code>io.Writer</code> 接口？</p>
<p>例如 <code>os.Stdin/Stdout</code>，它们分别实现了 <code>io.Reader/io.Writer</code> 接口：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    Stdin  = NewFile(<span class="keyword">uintptr</span>(syscall.Stdin), <span class="string">"/dev/stdin"</span>)</span><br><span class="line">    Stdout = NewFile(<span class="keyword">uintptr</span>(syscall.Stdout), <span class="string">"/dev/stdout"</span>)</span><br><span class="line">    Stderr = NewFile(<span class="keyword">uintptr</span>(syscall.Stderr), <span class="string">"/dev/stderr"</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>上面的代码可以看出，<code>Stdin/Stdout/Stderr</code> 只是三个特殊的文件类型的标识（都是 <code>os.File</code> 的实例），<code>os.File</code> 实现<br>了 <code>io.Reader</code> 和 <code>io.Writer</code>。</p>
<p>实现了 <code>io.Reader</code> 或 <code>io.Writer</code> 接口的类型：</p>
<ul>
<li><code>os.File</code> 同时实现了 <code>io.Reader</code> 和 <code>io.Writer</code></li>
<li><code>strings.Reader</code> 实现了 <code>io.Reader</code></li>
<li><code>bufio.Reader/Writer</code> 分别实现了 <code>io.Reader</code> 和 <code>io.Writer</code></li>
<li><code>bytes.Buffer</code> 同时实现了 <code>io.Reader</code> 和 <code>io.Writer</code></li>
<li><code>bytes.Reader</code> 实现了 <code>io.Reader</code></li>
<li><code>compress/gzip.Reader/Writer</code> 分别实现了 <code>io.Reader</code> 和 <code>io.Writer</code></li>
<li><code>crypto/cipher.StreamReader/StreamWriter</code> 分别实现了 <code>io.Reader</code> 和 <code>io.Writer</code></li>
<li><code>crypto/tls.Conn</code> 同时实现了 <code>io.Reader</code> 和 <code>io.Writer</code></li>
<li><code>encoding/csv.Reader/Writer</code> 分别实现了 <code>io.Reader</code> 和 <code>io.Writer</code></li>
<li><code>mime/multipart.Part</code> 实现了 <code>io.Reader</code></li>
<li><code>net/conn</code> 分别实现了 <code>io.Reader</code> 和 <code>io.Writer</code>(Conn接口定义了Read/Write)</li>
</ul>
<p><strong>io 包本身实现这两个接口的类型</strong>：</p>
<ul>
<li>实现了 <code>Reader</code> 的类型：<code>LimitedReader</code>、<code>PipeReader</code>、<code>SectionReader</code></li>
<li>实现了 <code>Writer</code> 的类型：<code>PipeWriter</code></li>
</ul>
<h2 id="ReaderAt-和-WriterAt"><a href="#ReaderAt-和-WriterAt" class="headerlink" title="ReaderAt 和 WriterAt"></a>ReaderAt 和 WriterAt</h2><p><strong><code>ReaderAt</code> 接口</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReaderAt <span class="keyword">interface</span> &#123;</span><br><span class="line">    ReadAt(p []<span class="keyword">byte</span>, off <span class="keyword">int64</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>ReadAt</code> 从基本输入源的偏移量 <code>off</code> 处开始，将 <code>len(p)</code> 个字节读到 <code>p</code> 中。它返回读取的字节数 <code>n</code>（<code>0 &lt;= n &lt;= len(p)</code>）以及任<br>何遇到的错误。</p>
</blockquote>
<blockquote>
<p>当 <code>ReadAt</code> 返回的 <code>n &lt; len(p)</code> 时，它就会返回一个 <strong>非 nil</strong> 的错误来解释为什么没有返回更多的字节。</p>
</blockquote>
<blockquote>
<p>即使 <code>ReadAt</code> 返回的 <code>n &lt; len(p)</code>，它也会在调用过程中使用 <code>p</code> 的全部作为暂存空间。若可读取的数据不到 <code>len(p)</code> 字节，<code>ReadAt</code> 就会<br>阻塞,直到所有数据都可用或一个错误发生。</p>
</blockquote>
<blockquote>
<p>若 <code>n = len(p)</code> 个字节从输入源的结尾处由 <code>ReadAt</code> 返回，<code>Read</code> 可能返回 <code>err == EOF</code> 或者 <code>err == nil</code></p>
</blockquote>
<blockquote>
<p>若 <code>ReadAt</code> 携带一个偏移量从输入源读取，<code>ReadAt</code> 应当既不影响偏移量也不被它所影响。</p>
</blockquote>
<blockquote>
<p>可对相同的输入源并行执行 <code>ReadAt</code> 调用。</p>
</blockquote>
<p>可见，<code>ReadAt</code> 接口使得可以从指定偏移量处开始读取数据。</p>
<p>简单示例代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">reader := strings.NewReader(<span class="string">"Hello world"</span>)</span><br><span class="line">p := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">6</span>)</span><br><span class="line">n, err := reader.ReadAt(p, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%s, %d\n"</span>, p, n) <span class="comment">// llo wo, 6</span></span><br></pre></td></tr></table></figure>
<p><strong><code>WriterAt</code> 接口</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> WriterAt <span class="keyword">interface</span> &#123;</span><br><span class="line">    WriteAt(p []<span class="keyword">byte</span>, off <span class="keyword">int64</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>WriteAt</code> 从 <code>p</code> 中将 <code>len(p)</code> 个字节写入到偏移量 <code>off</code> 处的基本数据流中。它返回从 <code>p</code> 中被写入的字节数 <code>n</code>（<code>0 &lt;= n &lt;= len(p)</code>）<br>以及任何遇到的引起写入提前停止的错误。若 <code>WriteAt</code> 返回的 <code>n &lt; len(p)</code>，它就必须返回一个 <strong>非 nil</strong> 的错误。</p>
</blockquote>
<blockquote>
<p>若 <code>WriteAt</code> 携带一个偏移量写入到目标中，<code>WriteAt</code> 应当既不影响偏移量也不被它所影响。</p>
</blockquote>
<blockquote>
<p>若被写区域没有重叠，可对相同的目标并行执行 <code>WriteAt</code> 调用。</p>
</blockquote>
<p>我们可以通过该接口将数据写入到数据流的特定偏移量之后。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">file, err := os.Create(<span class="string">"writeAt.txt"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> file.Close()</span><br><span class="line">_, _ = file.WriteString(<span class="string">"Hello world----ignore"</span>)</span><br><span class="line">n, err := file.WriteAt([]<span class="keyword">byte</span>(<span class="string">"Golang"</span>), <span class="number">15</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(n)</span><br></pre></td></tr></table></figure>
<p>打开文件 <code>WriteAt.txt</code>，内容是：<code>Hello world----Golang</code>。</p>
<p>分析：</p>
<p><code>file.WriteString(&quot;Hello world----ignore&quot;)</code> 往文件中写入 <code>Hello world----ignore</code>，之后<br><code>file.WriteAt([]byte(&quot;Golang&quot;), 15)</code> 在文件流的 <code>offset=15</code> 处写入 <code>Golang</code>（会覆盖该位置的内容）。</p>
<h2 id="ReaderFrom-和-WriterTo"><a href="#ReaderFrom-和-WriterTo" class="headerlink" title="ReaderFrom 和 WriterTo"></a>ReaderFrom 和 WriterTo</h2><p>这两个接口实现了<strong>一次性从某个地方读或写到某个地方去</strong>。<br><strong>ReaderFrom</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReaderFrom <span class="keyword">interface</span> &#123;</span><br><span class="line">    ReadFrom(r Reader) (n <span class="keyword">int64</span>, err error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>ReadFrom</code> 从 <code>r</code> 中读取数据，直到 <code>EOF</code> 或发生错误。其返回值 <code>n</code> 为读取的字节数。除 <code>io.EOF</code> 之外，在读取过程中遇到的任何错误也<br>将被返回。</p>
</blockquote>
<blockquote>
<p>如果 <code>ReaderFrom</code> 可用，<code>Copy</code> 函数就会使用它。</p>
</blockquote>
<p>注意：<code>ReadFrom</code> 方法不会返回 <code>err == EOF</code>。</p>
<p>将文件中的数据全部读取（显示在标准输出）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">file, err := os.Open(<span class="string">"writeAt.txt"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> file.Close()</span><br><span class="line">writer := bufio.NewWriter(os.Stdout)</span><br><span class="line">writer.ReadFrom(file)</span><br><span class="line">writer.Flush()</span><br></pre></td></tr></table></figure>
<p>也可以通过 <code>ioutil</code> 包的 <code>ReadFile</code> 函数获取文件全部内容。其实，跟踪一下 <code>ioutil.ReadFile</code> 的源码，会发现其实也是通过 <code>ReadFrom</code> 方<br>法实现（用的是 <code>bytes.Buffer</code>，它实现了 <code>ReaderFrom</code> 接口）。</p>
<p><strong>WriterTo</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> WriterTo <span class="keyword">interface</span> &#123;</span><br><span class="line">    WriteTo(w Writer) (n <span class="keyword">int64</span>, err error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>WriteTo</code> 将数据写入 <code>w</code> 中，直到没有数据可写或发生错误。其返回值 <code>n</code> 为写入的字节数。 在写入过程中遇到的任何错误也将被返回。</p>
</blockquote>
<blockquote>
<p>如果 <code>WriterTo</code> 可用，<code>Copy</code> 函数就会使用它。</p>
</blockquote>
<p>将一段文本输出到标准输出：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reader := bytes.NewReader([]<span class="keyword">byte</span>(<span class="string">"Hello world"</span>))</span><br><span class="line">reader.WriteTo(os.Stdout)</span><br></pre></td></tr></table></figure>
<h2 id="Seeker"><a href="#Seeker" class="headerlink" title="Seeker"></a>Seeker</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Seeker <span class="keyword">interface</span> &#123;</span><br><span class="line">    Seek(offset <span class="keyword">int64</span>, whence <span class="keyword">int</span>) (ret <span class="keyword">int64</span>, err error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>Seek</code> 设置下一次 <code>Read</code> 或 <code>Write</code> 的偏移量为 <code>offset</code>，它的解释取决于 <code>whence</code>：  <strong>0 表示相对于文件的起始处，1 表示相对<br>于当前的偏移，而 2 表示相对于其结尾处</strong>。 <code>Seek</code> 返回新的偏移量和一个错误，如果有的话。</p>
</blockquote>
<p>也就是说，<code>Seek</code> 方法是用于设置偏移量的，这样可以从某个特定位置开始操作数据流。听起来和 <code>ReaderAt/WriteAt</code> 接口有些类似，<br>不过 <code>Seeker</code> 接口更灵活，可以更好的控制读写数据流的位置。</p>
<p>获取倒数第二个字符（需要考虑 UTF-8 编码，这里的代码只是一个示例）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">reader := strings.NewReader(<span class="string">"Hello world"</span>)</span><br><span class="line">reader.Seek(<span class="number">-6</span>, io.SeekEnd)</span><br><span class="line">r, _, _ := reader.ReadRune()</span><br><span class="line">fmt.Printf(<span class="string">"%c\n"</span>, r)</span><br></pre></td></tr></table></figure>
<p><code>whence</code> 的值，在 io 包中定义了相应的常量，应该使用这些常量</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  SeekStart   = <span class="number">0</span> <span class="comment">// seek relative to the origin of the file</span></span><br><span class="line">  SeekCurrent = <span class="number">1</span> <span class="comment">// seek relative to the current offset</span></span><br><span class="line">  SeekEnd     = <span class="number">2</span> <span class="comment">// seek relative to the end</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>而原先 <code>os</code> 包中的常量已经被标注为 Deprecated</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Deprecated: Use io.SeekStart, io.SeekCurrent, and io.SeekEnd.</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  SEEK_SET <span class="keyword">int</span> = <span class="number">0</span> <span class="comment">// seek relative to the origin of the file</span></span><br><span class="line">  SEEK_CUR <span class="keyword">int</span> = <span class="number">1</span> <span class="comment">// seek relative to the current offset</span></span><br><span class="line">  SEEK_END <span class="keyword">int</span> = <span class="number">2</span> <span class="comment">// seek relative to the end</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h2 id="Closer"><a href="#Closer" class="headerlink" title="Closer"></a>Closer</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Closer <span class="keyword">interface</span> &#123;</span><br><span class="line">    Close() error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该接口比较简单，只有一个 <code>Close()</code> 方法，用于关闭数据流。</p>
<p>文件 (<code>os.File</code>)、归档（压缩包）、数据库连接、<code>Socket</code> 等需要手动关闭的资源都实现了 <code>Closer</code> 接口。</p>
<p>实际编程中，经常将 <code>Close</code> 方法的调用放在 <code>defer</code> 语句中。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">file, err := os.Open(<span class="string">"studygolang.txt"</span>)</span><br><span class="line"><span class="keyword">defer</span> file.Close()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当文件 <code>studygolang.txt</code> 不存在或找不到时，<code>file.Close()</code> 会返回错误，因为 <code>file</code> 是 <code>nil</code>。<br>因此，应该<strong>将 <code>defer file.Close()</code> 放在错误检查之后</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span> <span class="title">Close</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> f == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> ErrInvalid</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> f.file.<span class="built_in">close</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="其他接口"><a href="#其他接口" class="headerlink" title="其他接口"></a>其他接口</h2><h3 id="ByteReader-和-ByteWriter"><a href="#ByteReader-和-ByteWriter" class="headerlink" title="ByteReader 和 ByteWriter"></a>ByteReader 和 ByteWriter</h3><p>读或写一个字节：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ByteReader <span class="keyword">interface</span> &#123;</span><br><span class="line">    ReadByte() (c <span class="keyword">byte</span>, err error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ByteWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">    WriteByte(c <span class="keyword">byte</span>) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面类型都实现了这两个接口:</p>
<ul>
<li><code>bufio.Reader/Writer</code> 分别实现了 <code>io.ByteReader</code> 和 <code>io.ByteWriter</code></li>
<li><code>bytes.Buffer</code> 同时实现了 <code>io.ByteReader</code> 和 <code>io.ByteWriter</code></li>
<li><code>bytes.Reader</code> 实现了 <code>io.ByteReader</code></li>
<li><code>strings.Reader</code> 实现了 <code>io.ByteReader</code></li>
</ul>
<p>通过 <code>bytes.Buffer</code> 来一次读取或写入一个字节：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ch <span class="keyword">byte</span></span><br><span class="line">fmt.Scanf(<span class="string">"%c\n"</span>, &amp;ch)</span><br><span class="line"></span><br><span class="line">buffer := <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">err := buffer.WriteByte(ch)</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"写入一个字节成功！准备读取该字节……"</span>)</span><br><span class="line">	newCh, _ := buffer.ReadByte()</span><br><span class="line">	fmt.Printf(<span class="string">"读取的字节：%c\n"</span>, newCh)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"写入错误"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序从标准输入接收一个字节（ASCII 字符），调用 <code>buffer</code> 的 <code>WriteByte</code> 将该字节写入 <code>buffer</code> 中，之后通过 <code>ReadByte</code> 读取该字节。</p>
<h3 id="ByteScanner、RuneReader-和-RuneScanner"><a href="#ByteScanner、RuneReader-和-RuneScanner" class="headerlink" title="ByteScanner、RuneReader 和 RuneScanner"></a>ByteScanner、RuneReader 和 RuneScanner</h3><p><code>ByteScanner</code> 接口：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ByteScanner <span class="keyword">interface</span> &#123;</span><br><span class="line">    ByteReader</span><br><span class="line">    UnreadByte() error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内嵌了 <code>ByteReader</code> 接口，<code>UnreadByte</code> 方法的意思是：将上一次 <code>ReadByte</code> 的字节还原，使得再次调用 <code>ReadByte</code> 返回的结果和上一次调<br>用相同，也就是说，<code>UnreadByte</code> 是重置上一次的 <code>ReadByte</code>。注意，<strong><code>UnreadByte</code> 调用之前必须调用了 <code>ReadByte</code>，且不能连续调<br>用 <code>UnreadByte</code></strong>。即：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">buffer := bytes.NewBuffer([]<span class="keyword">byte</span>&#123;<span class="string">'a'</span>, <span class="string">'b'</span>&#125;)</span><br><span class="line">err := buffer.UnreadByte()</span><br></pre></td></tr></table></figure>
<p>和</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">buffer := bytes.NewBuffer([]<span class="keyword">byte</span>&#123;<span class="string">'a'</span>, <span class="string">'b'</span>&#125;)</span><br><span class="line">buffer.ReadByte()</span><br><span class="line">err := buffer.UnreadByte()</span><br><span class="line">err = buffer.UnreadByte()</span><br></pre></td></tr></table></figure>
<p><code>err</code> 都 <strong>非 nil</strong>，错误为：<code>bytes.Buffer: UnreadByte: previous operation was not a read</code></p>
<p><code>RuneReader</code> 接口和 <code>ByteReader</code> 类似，只是 <code>ReadRune</code> 方法读取单个 UTF-8 字符，返回其 <code>rune</code> 和该字符占用的字节数。</p>
<p><code>RuneScanner</code> 接口和 <code>ByteScanner</code> 类似。</p>
<h3 id="ReadCloser、ReadSeeker、ReadWriteCloser、ReadWriteSeeker、ReadWriter、WriteCloser-和-WriteSeeker"><a href="#ReadCloser、ReadSeeker、ReadWriteCloser、ReadWriteSeeker、ReadWriter、WriteCloser-和-WriteSeeker" class="headerlink" title="ReadCloser、ReadSeeker、ReadWriteCloser、ReadWriteSeeker、ReadWriter、WriteCloser 和 WriteSeeker"></a>ReadCloser、ReadSeeker、ReadWriteCloser、ReadWriteSeeker、ReadWriter、WriteCloser 和 WriteSeeker</h3><p>这些接口是上面介绍的接口的两个或三个组合而成的新接口。<code>ReadWriter</code> 接口：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReadWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">    Reader</span><br><span class="line">    Writer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Reader</code> 和 <code>Writer</code> 接口的组合。</p>
<p>这些接口的作用是：有些时候同时需要某两个接口的所有功能，即必须同时实现了某两个接口的类型才能够被传入使用。</p>
<h2 id="SectionReader-类型"><a href="#SectionReader-类型" class="headerlink" title="SectionReader 类型"></a>SectionReader 类型</h2><p><code>SectionReader</code> 是一个 <code>struct</code>，实现了 <code>Read</code>, <code>Seek</code> 和 <code>ReadAt</code>，同时，内嵌了 <code>ReaderAt</code> 接口。结构定义如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SectionReader <span class="keyword">struct</span> &#123;</span><br><span class="line">	r     ReaderAt	<span class="comment">// 该类型最终的 Read/ReadAt 最终都是通过 r 的 ReadAt 实现</span></span><br><span class="line">	base  <span class="keyword">int64</span>		<span class="comment">// NewSectionReader 会将 base 设置为 off</span></span><br><span class="line">	off   <span class="keyword">int64</span>		<span class="comment">// 从 r 中的 off 偏移处开始读取数据</span></span><br><span class="line">	limit <span class="keyword">int64</span>		<span class="comment">// limit - off = SectionReader 流的长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该类型读取数据流中部分数据。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSectionReader</span><span class="params">(r ReaderAt, off <span class="keyword">int64</span>, n <span class="keyword">int64</span>)</span> *<span class="title">SectionReader</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>NewSectionReader</code> 返回一个 <code>SectionReader</code>，它从 <code>r</code> 中的偏移量 <code>off</code> 处读取 <code>n</code> 个字节后以 <code>EOF</code> 停止。</p>
</blockquote>
<p>也就是说，SectionReader 只是内部 ReaderAt 表示的数据流的一部分：从 off 开始后的 n 个字节。</p>
<p>这个类型的作用是：方便重复操作某一段 (section) 数据流；或者同时需要 ReadAt 和 Seek 的功能。</p>
<p>由于该类型所支持的操作，前面都有介绍，因此不提供示例代码了。</p>
<h2 id="LimitedReader-类型"><a href="#LimitedReader-类型" class="headerlink" title="LimitedReader 类型"></a>LimitedReader 类型</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LimitedReader <span class="keyword">struct</span> &#123;</span><br><span class="line">    R Reader <span class="comment">// underlying reader，最终的读取操作通过 R.Read 完成</span></span><br><span class="line">    N <span class="keyword">int64</span>  <span class="comment">// max bytes remaining</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>从 <code>R</code> 读取但将返回的数据量限制为 <code>N</code> 字节。每调用一次 <code>Read</code> 都将更新 <code>N</code> 来反应新的剩余数量。</p>
</blockquote>
<p>也就是说，最多只能返回 <code>N</code> 字节数据。</p>
<p><code>LimitedReader</code> 只实现了 <code>Read</code> 方法。</p>
<p>示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">content := <span class="string">"This Is LimitReader Example"</span></span><br><span class="line">reader := strings.NewReader(content)</span><br><span class="line">limitReader := &amp;io.LimitedReader&#123;R: reader, N: <span class="number">8</span>&#125;</span><br><span class="line"><span class="keyword">for</span> limitReader.N &gt; <span class="number">0</span> &#123;</span><br><span class="line">	tmp := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">2</span>)</span><br><span class="line">	limitReader.Read(tmp)</span><br><span class="line">	fmt.Printf(<span class="string">"%s"</span>, tmp) <span class="comment">// This Is</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过该类型可以达到 <strong>只允许读取一定长度数据</strong> 的目的。</p>
<p>在 <code>io</code> 包中，<code>LimitReader</code> 函数的实现其实就是调用 <code>LimitedReader</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LimitReader</span><span class="params">(r Reader, n <span class="keyword">int64</span>)</span> <span class="title">Reader</span></span> &#123; <span class="keyword">return</span> &amp;LimitedReader&#123;r, n&#125; &#125;</span><br></pre></td></tr></table></figure>
<h2 id="PipeReader-和-PipeWriter-类型"><a href="#PipeReader-和-PipeWriter-类型" class="headerlink" title="PipeReader 和 PipeWriter 类型"></a>PipeReader 和 PipeWriter 类型</h2><p><code>PipeReader</code> 是管道的读取端。它实现了 <code>io.Reader</code> 和 <code>io.Closer</code> 接口：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PipeReader <span class="keyword">struct</span> &#123;</span><br><span class="line">	p *pipe</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>从管道中读取数据。该方法会堵塞，直到管道写入端开始写入数据或写入端被关闭。如果写入端关闭时带有 <code>error</code>（即调用 <code>CloseWithError</code> 关闭），<br>该 <code>Read</code> 返回的 <code>err</code> 就是写入端传递的 <code>error</code>；否则 <code>err</code> 为 <code>EOF</code>。</p>
</blockquote>
<p><code>PipeWriter</code> 是管道的写入端。它实现了 <code>io.Writer</code> 和 <code>io.Closer</code> 接口：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PipeWriter <span class="keyword">struct</span> &#123;</span><br><span class="line">	p *pipe</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>写数据到管道中。该方法会堵塞，直到管道读取端读完所有数据或读取端被关闭。如果读取端关闭时<br>带有 <code>error</code>（即调用 <code>CloseWithError</code> 关闭），该 <code>Write</code> 返回的 <code>err</code> 就是读取端传递的 <code>error</code>；否则 <code>err</code> 为 <code>ErrClosedPipe</code>。</p>
</blockquote>
<p>示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    pipeReader, pipeWriter := io.Pipe()</span><br><span class="line">    <span class="keyword">go</span> PipeWrite(pipeWriter)</span><br><span class="line">    <span class="keyword">go</span> PipeRead(pipeReader)</span><br><span class="line">    time.Sleep(<span class="number">30</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PipeWrite</span><span class="params">(writer *io.PipeWriter)</span></span>&#123;</span><br><span class="line">	data := []<span class="keyword">byte</span>(<span class="string">"Go语言中文网"</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++&#123;</span><br><span class="line">		n, err := writer.Write(data)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">			fmt.Println(err)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Printf(<span class="string">"写入字节 %d\n"</span>,n)</span><br><span class="line">	&#125;</span><br><span class="line">	writer.CloseWithError(errors.New(<span class="string">"写入段已关闭"</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PipeRead</span><span class="params">(reader *io.PipeReader)</span></span>&#123;</span><br><span class="line">	buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">128</span>)</span><br><span class="line">	<span class="keyword">for</span>&#123;</span><br><span class="line">		fmt.Println(<span class="string">"接口端开始阻塞5秒钟..."</span>)</span><br><span class="line">		time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">		fmt.Println(<span class="string">"接收端开始接受"</span>)</span><br><span class="line">		n, err := reader.Read(buf)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">			fmt.Println(err)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Printf(<span class="string">"收到字节: %d\n buf内容: %s\n"</span>,n,buf)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>io.Pipe()</code> 用于创建一个同步的内存管道：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Pipe</span><span class="params">()</span> <span class="params">(*PipeReader, *PipeWriter)</span></span></span><br></pre></td></tr></table></figure>
<p>它将 <code>io.Reader</code> 连接到 <code>io.Writer</code>。一端的读取匹配另一端的写入，直接在这两端之间复制数据；它没有内部缓存。它对于并行调用 <code>Read</code><br> 和 <code>Write</code> 以及其它函数或 <code>Close</code> 来说都是安全的。一旦等待的 I/O 结束，<code>Close</code> 就会完成。并行调用 <code>Read</code> 或并行调用 <code>Write</code> 也<br>同样安全：同种类的调用将按顺序进行控制。</p>
<p>正因为是<strong>同步</strong>的，因此不能在一个 goroutine 中进行读和写。</p>
<p>另外，对于管道的 <code>close</code> 方法（非 <code>CloseWithError</code> 时），<code>err</code> 会被置为 <code>EOF</code>。</p>
<h2 id="Copy-和-CopyN-函数"><a href="#Copy-和-CopyN-函数" class="headerlink" title="Copy 和 CopyN 函数"></a>Copy 和 CopyN 函数</h2><p><strong>Copy 函数</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Copy</span><span class="params">(dst Writer, src Reader)</span> <span class="params">(written <span class="keyword">int64</span>, err error)</span></span></span><br></pre></td></tr></table></figure>
<p>函数文档：</p>
<blockquote>
<p><code>Copy</code> 将 <code>src</code> 复制到 <code>dst</code>，直到在 <code>src</code> 上到达 <code>EOF</code> 或发生错误。它返回复制的字节数，如果有错误的话，还会返回在复制时遇到的第一<br>个错误。</p>
</blockquote>
<blockquote>
<p>成功的 <code>Copy</code> 返回 <code>err == nil</code>，而非 <code>err == EOF</code>。由于 <code>Copy</code> 被定义为从 <code>src</code> 读取直到 <code>EOF</code> 为止，因此它不会将来<br>自 <code>Read</code> 的 <code>EOF</code> 当做错误来报告。</p>
</blockquote>
<blockquote>
<p>若 <code>dst</code> 实现了 <code>ReaderFrom</code> 接口，其复制操作可通过调用 <code>dst.ReadFrom(src)</code> 实现。此外，若 <code>src</code> 实现了 <code>WriterTo</code> 接口，其复<br>制操作可通过调用 <code>src.WriteTo(dst)</code> 实现。</p>
</blockquote>
<p>代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">io.Copy(os.Stdout, strings.NewReader(<span class="string">"Go语言中文网"</span>))</span><br></pre></td></tr></table></figure>
<p>直接将内容输出（写入 Stdout 中）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"io"</span></span><br><span class="line">	<span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	_, _ = io.Copy(os.Stdout, os.Stdin)</span><br><span class="line">	fmt.Println(<span class="string">"Got EOF -- bye"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行：<code>echo &quot;Hello, World&quot; | go run main.go</code></p>
<p><strong>CopyN 函数</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CopyN</span><span class="params">(dst Writer, src Reader, n <span class="keyword">int64</span>)</span> <span class="params">(written <span class="keyword">int64</span>, err error)</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>CopyN</code> 将 <code>n</code> 个字节(或到一个 <code>error</code>)从 <code>src</code> 复制到 <code>dst</code>。 它返回复制的字节数以及在复制时遇到的最早的错误。<br>当且仅当 <code>err == nil</code> 时,<code>written == n</code> 。</p>
</blockquote>
<blockquote>
<p>若 <code>dst</code> 实现了 <code>ReaderFrom</code> 接口，复制操作也就会使用它来实现。</p>
</blockquote>
<p>代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">io.CopyN(os.Stdout, strings.NewReader(<span class="string">"Go语言中文网"</span>), <span class="number">8</span>) <span class="comment">// Go语言</span></span><br></pre></td></tr></table></figure>
<h2 id="ReadAtLeast-和-ReadFull-函数"><a href="#ReadAtLeast-和-ReadFull-函数" class="headerlink" title="ReadAtLeast 和 ReadFull 函数"></a>ReadAtLeast 和 ReadFull 函数</h2><p><strong>ReadAtLeast 函数</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadAtLeast</span><span class="params">(r Reader, buf []<span class="keyword">byte</span>, min <span class="keyword">int</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br></pre></td></tr></table></figure>
<p>函数文档：</p>
<blockquote>
<p><code>ReadAtLeast</code> 将 <code>r</code> 读取到 <code>buf</code> 中，直到读了最少 <code>min</code> 个字节为止。它返回复制的字节数，如果读取的字节较少，还会返回一个错误。<br>若没有读取到字节，错误就只是 <code>EOF</code>。如果一个 <code>EOF</code> 发生在读取了少于 <code>min</code> 个字节之后，<code>ReadAtLeast</code> 就会返回 <code>ErrUnexpectedEOF</code>。<br>若 <code>min</code> 大于 <code>buf</code> 的长度，<code>ReadAtLeast</code> 就会返回 <code>ErrShortBuffer</code>。对于返回值，当且仅当 <code>err == nil</code> 时，才有 <code>n &gt;= min</code>。</p>
</blockquote>
<p><strong>ReadFull 函数</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadFull</span><span class="params">(r Reader, buf []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br></pre></td></tr></table></figure>
<p>函数文档：</p>
<blockquote>
<p><code>ReadFull</code> 精确地从 <code>r</code> 中将 <code>len(buf)</code> 个字节读取到 <code>buf</code> 中。它返回复制的字节数，如果读取的字节较少，还会返回一个错误。若没有读<br>取到字节，错误就只是 <code>EOF</code>。如果一个 <code>EOF</code> 发生在读取了一些但不是所有的字节后，<code>ReadFull</code> 就会返回 <code>ErrUnexpectedEOF</code>。对于返回值，<br>当且仅当 <code>err == nil</code> 时，才有 <code>n == len(buf)</code>。</p>
</blockquote>
<p>注意该函数和 <code>ReadAtLeast</code> 的区别：</p>
<ul>
<li><code>ReadFull</code> 将 <code>buf</code> 读满</li>
<li><code>ReadAtLeast</code> 是最少读取 <code>min</code> 个字节。</li>
</ul>
<h2 id="WriteString-函数"><a href="#WriteString-函数" class="headerlink" title="WriteString 函数"></a>WriteString 函数</h2><p>这是为了方便写入 <code>string</code> 类型提供的函数，函数签名：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteString</span><span class="params">(w Writer, s <span class="keyword">string</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br></pre></td></tr></table></figure>
<p>函数文档：</p>
<blockquote>
<p><code>WriteString</code> 将 <code></code>s 的内容写入 <code>w</code> 中，当 <code>w</code> 实现了 <code>WriteString</code> 方法时，会直接调用该方法，否则执行 <code>w.Write([]byte(s))</code>。</p>
</blockquote>
<h2 id="MultiReader-和-MultiWriter-函数"><a href="#MultiReader-和-MultiWriter-函数" class="headerlink" title="MultiReader 和 MultiWriter 函数"></a>MultiReader 和 MultiWriter 函数</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MultiReader</span><span class="params">(readers ...Reader)</span> <span class="title">Reader</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">MultiWriter</span><span class="params">(writers ...Writer)</span> <span class="title">Writer</span></span></span><br></pre></td></tr></table></figure>
<p>它们接收多个 <code>Reader</code> 或 <code>Writer</code>，返回一个 <code>Reader</code> 或 <code>Writer</code>。我们可以猜想到这两个函数就是操作多个 <code>Reader</code> 或 <code>Writer</code> 就像<br>操作一个。</p>
<p>事实上，在 <code>io</code> 包中定义了两个非导出类型：<code>mutilReader</code> 和 <code>multiWriter</code>，它们分别实现了 <code>io.Reader</code> 和 <code>io.Writer</code> 接口：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> multiReader <span class="keyword">struct</span> &#123;</span><br><span class="line">	readers []Reader</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> multiWriter <span class="keyword">struct</span> &#123;</span><br><span class="line">	writers []Writer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于这两种类型对应的实现方法（<code>Read</code> 和 <code>Write</code> 方法）的使用，示例：</p>
<p><strong>MultiReader 的使用</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">readers := []io.Reader&#123;</span><br><span class="line">	strings.NewReader(<span class="string">"from strings reader"</span>),</span><br><span class="line">	bytes.NewBufferString(<span class="string">"from bytes buffer"</span>),</span><br><span class="line">&#125;</span><br><span class="line">reader := io.MultiReader(readers...)</span><br><span class="line">data := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">0</span>, <span class="number">128</span>)</span><br><span class="line">buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">10</span>)</span><br><span class="line">	</span><br><span class="line"><span class="keyword">for</span> n, err := reader.Read(buf); err != io.EOF ; n, err = reader.Read(buf)&#123;</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	data = <span class="built_in">append</span>(data,buf[:n]...)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%s\n"</span>, data) <span class="comment">// from strings readerfrom bytes buffer</span></span><br></pre></td></tr></table></figure>
<p>代码中首先构造了一个 <code>io.Reader</code> 的 <code>slice</code>，然后通过 <code>MultiReader</code> 得到新的 <code>Reader</code>，循环读取新 <code>Reader</code> 中的内容。从输出结果<br>可以看到，第一次调用 <code>Reader</code> 的 <code>Read</code> 方法获取到的是 <code>slice</code> 中第一个元素的内容……也就是说，<code>MultiReader</code> 只是逻辑上将多<br>个 <code>Reader</code> 组合起来，并不能通过调用一次 <code>Read</code> 方法获取所有 <code>Reader</code> 的内容。在所有的 <code>Reader</code> 内容都被读<br>完后，<code>Reader</code> 会返回 <code>EOF</code>。</p>
<p><strong>MultiWriter 的使用</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">file, err := os.Create(<span class="string">"tmp.txt"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> file.Close()</span><br><span class="line">writers := []io.Writer&#123;</span><br><span class="line">	file,</span><br><span class="line">	os.Stdout,</span><br><span class="line">&#125;</span><br><span class="line">writer := io.MultiWriter(writers...)</span><br><span class="line">writer.Write([]<span class="keyword">byte</span>(<span class="string">"Go语言中文网"</span>))</span><br></pre></td></tr></table></figure>
<p>这段程序执行后在生成 <code>tmp.txt</code> 文件，同时在文件和屏幕中都输出：<code>Go语言中文网</code>。这和 Unix 中的 tee 命令类似。</p>
<h2 id="TeeReader-函数"><a href="#TeeReader-函数" class="headerlink" title="TeeReader 函数"></a>TeeReader 函数</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TeeReader</span><span class="params">(r Reader, w Writer)</span> <span class="title">Reader</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>TeeReader</code> 返回一个 <code>Reader</code>，它将从 <code>r</code> 中读到的数据写入 <code>w</code> 中。所有经由它处理的从 <code>r</code> 的读取都匹配于对应的对 <code>w</code> 的写入。它没<br>有内部缓存，即写入必须在读取完成前完成。任何在写入时遇到的错误都将作为读取错误返回。</p>
</blockquote>
<p>也就是说，我们通过 <code>Reader</code> 读取内容后，会自动写入到 <code>Writer</code> 中去。例子代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reader := io.TeeReader(strings.NewReader(<span class="string">"Go语言中文网"</span>), os.Stdout)</span><br><span class="line">reader.Read(<span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">20</span>)) <span class="comment">// Go语言中文网</span></span><br></pre></td></tr></table></figure>
<p>这种功能的实现其实挺简单，无非是在 <code>Read</code> 完后执行 <code>Write</code>。</p>

        <div id="react-support-footer-root"></div>
      </div>
    </div>
  </div>
</div>

    


    

    <!-- js vendors -->
    <script src="//code.jquery.com/jquery-3.2.1.min.js" crossorigin="anonymous"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/lunr.js/2.1.0/lunr.min.js"></script>

    <!-- js source  -->
    <script src="/golang-learn/script/doc.js"></script>

    

  </body>
</html>
