<!DOCTYPE html>
<html lang="en">
  <head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">

    <title>Golang learning | bufio </title>
    <meta name="description" content>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    

    <!-- fonts -->
    <link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700" rel="stylesheet">
    <link href="//fonts.googleapis.com/css?family=Ubuntu:300,400,500,600,700" rel="stylesheet">

    <!-- stylesheets -->
    <link rel="stylesheet" href="/golang-learn/style/doc.css">

    <!-- favicon -->
    <link rel="icon" href="/golang-learn/images/favicon.ico">

    

  </head>
  <body>

   <script>window.__INITIAL_STATE__ = {"page":{"title":"bufio","path":"standards/io/bufio.html"},"data":{"navigation":{"logo":{"text":"Golang Learn","type":"link","path":"index.html"},"main":[{"text":"Golang 基础","type":"label"},{"text":"Go 环境配置","type":"link","path":"basic/env_config.html"},{"text":"包","type":"link","path":"basic/package.html"},{"text":"基础数据类型","type":"link","path":"basic/basic_data.html"},{"text":"变量","type":"link","path":"basic/var.html"},{"text":"常量","type":"link","path":"basic/constant.html"},{"text":"控制语句","type":"link","path":"basic/flow.html"},{"text":"运算符","type":"link","path":"basic/operator.html"},{"text":"作用域","type":"link","path":"basic/scope.html"},{"text":"指针","type":"link","path":"basic/pointer.html"},{"text":"数组","type":"link","path":"basic/array.html"},{"text":"切片","type":"link","path":"basic/slice.html"},{"text":"字典","type":"link","path":"basic/map.html"},{"text":"函数","type":"link","path":"basic/function.html"},{"text":"结构体","type":"link","path":"basic/struct.html"},{"text":"接口","type":"link","path":"basic/interface.html"},{"text":"面向对象","type":"link","path":"basic/oop.html"},{"text":"错误","type":"link","path":"basic/error.html"},{"text":"序列化","type":"link","path":"basic/json.html"},{"text":"反射","type":"link","path":"basic/reflect.html"},{"text":"测试","type":"link","path":"basic/test.html"},{"text":"并发编程","type":"label"},{"text":"goroutine","type":"link","path":"concurrent/goroutine.html"},{"text":"channel","type":"link","path":"concurrent/channel.html"},{"text":"同步和锁","type":"link","path":"concurrent/sync_lock.html"},{"text":"内存分配","type":"label"},{"text":"内存分配","type":"link","path":"advance/mm.html"},{"text":"垃圾回收","type":"label"},{"text":"垃圾回收","type":"link","path":"advance/gc.html"},{"text":"标准库","type":"label"},{"text":"fmt","type":"link","path":"standards/io/fmt.html"},{"text":"io","type":"link","path":"standards/io/io.html"},{"text":"ioutil","type":"link","path":"standards/io/ioutil.html"},{"text":"bufio","type":"link","path":"standards/io/bufio.html"},{"text":"os","type":"link","path":"standards/os/os.html"},{"text":"filepath","type":"link","path":"standards/os/filepath.html"},{"text":"strings","type":"link","path":"standards/text/strings.html"},{"text":"strconv","type":"link","path":"standards/text/strconv.html"},{"text":"unicode","type":"link","path":"standards/text/unicode.html"},{"text":"log","type":"link","path":"standards/log.html"},{"text":"time","type":"link","path":"standards/time.html"},{"text":"http","type":"link","path":"standards/net/http.html"},{"text":"math","type":"link","path":"standards/data/math.html"},{"text":"sort","type":"link","path":"standards/data/sort.html"},{"text":"big","type":"link","path":"standards/data/big.html"},{"text":"container","type":"link","path":"standards/data/container.html"},{"text":"sql","type":"link","path":"standards/database/sql.html"},{"text":"THEME","type":"label"},{"text":"使用文档主题","type":"link","path":"theme/theme-usage.html"},{"text":"SUPPORT AND FEEDBACK","type":"label"},{"text":"Raise an Issue on Github","type":"link","path":"https://github.com/shipengqi/golang-learn/issues/new"}]}},"config":{"timezone":"UTC","root":"/golang-learn/","time_format":"HH:mm:ss","theme":"../node_modules/hexo-theme-doc","theme_config":{"swagger_ui":{"version":2,"permalinks":true,"api_explorer":true,"download":"Download specification","show_extensions":false,"deep_linking":true,"display_operation_id":false,"doc_expansion":"none"},"search":{"skip":false,"background":false,"route":"/lunr.json"},"favicon":"images/favicon.ico"}}}</script>

    <div id="react-navigation-root"><div class="doc-navigation" data-reactroot><nav class="doc-navbar"><a href="/golang-learn/index.html" class="doc-navbar__logo"><img src="/golang-learn/images/logo.png" class="doc-navbar__logo__img"><span class="doc-navbar__logo__text">Golang Learn</span></a><i class="dc-icon dc-icon--close dc-icon--interactive doc-sidebar-close doc-navbar__sidebar-close doc-navbar__sidebar-close--desktop"></i><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-navbar__sidebar-toggle"></i></nav><nav class="doc-sidebar"><div class="doc-sidebar__vertical-menu"><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-sidebar-toggle--primary doc-sidebar__vertical-menu__item"></i><i class="dc-icon dc-icon--search dc-icon--interactive doc-sidebar__vertical-menu__item doc-sidebar__vertical-menu__item--primary"></i></div><div class="doc-sidebar-content"><div class="doc-sidebar__search-form"></div><ul class="doc-sidebar-list"></ul></div></nav></div></div>
    <div class="doc-content">
  <div class="dc-page">
    <div class="dc-card">
      <div id="react-search-results-root"></div>
      <div id="page-content" class="doc-formatting">
        <h1 id="bufio"><a href="#bufio" class="headerlink" title="bufio"></a>bufio</h1><p>bufio 包实现了缓存 IO。提供了数据缓冲功能，能够一定程度减少大块数据读写带来的开销。封装了 <code>io.Reader</code> 和 <code>io.Writer</code> 对象。</p>
<h2 id="bufio包中的数据类型"><a href="#bufio包中的数据类型" class="headerlink" title="bufio包中的数据类型"></a>bufio包中的数据类型</h2><p>bufio包中的数据类型主要有：</p>
<ul>
<li><code>Reader</code>；</li>
<li><code>Scanner</code>；</li>
<li><code>Writer</code> 和 <code>ReadWriter</code>。</li>
</ul>
<h2 id="bufio-Reader"><a href="#bufio-Reader" class="headerlink" title="bufio.Reader"></a>bufio.Reader</h2><p>两个用于初始化 <code>bufio.Reader</code> 的函数：</p>
<ul>
<li><code>NewReader</code> 函数初始化的 <code>Reader</code> 值会拥有一个默认尺寸的缓冲区。这个默认尺寸是 <code>4096</code> 个字节，即：<code>4 KB</code>。</li>
<li><code>NewReaderSize</code> 函数则将缓冲区尺寸的决定权抛给了使用方。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewReader</span><span class="params">(rd io.Reader)</span> *<span class="title">Reader</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">NewReaderSize</span><span class="params">(rd io.Reader, size <span class="keyword">int</span>)</span> *<span class="title">Reader</span> // 可以配置缓冲区的大小</span></span><br></pre></td></tr></table></figure>
<h3 id="bufio-Reader-类型值中的缓冲区的作用"><a href="#bufio-Reader-类型值中的缓冲区的作用" class="headerlink" title="bufio.Reader 类型值中的缓冲区的作用"></a>bufio.Reader 类型值中的缓冲区的作用</h3><p>缓冲区其实就是一个<strong>数据存储中介，它介于底层读取器与读取方法及其调用方之间</strong>。所谓的底层读取器是指 <code>io.Reader</code>。</p>
<p><code>Reader</code> 值的读取方法一般都会先从其所属值的缓冲区中读取数据。同时，在必要的时候，它们还会预先从底层读取器那里读出一部分数据，并暂<br>存于缓冲区之中以备后用。</p>
<p>缓冲区的好处是，可以在大多数的时候降低读取方法的执行时间。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Reader <span class="keyword">struct</span> &#123;</span><br><span class="line">    buf          []<span class="keyword">byte</span></span><br><span class="line">    rd           io.Reader</span><br><span class="line">    r, w         <span class="keyword">int</span></span><br><span class="line">    err          error</span><br><span class="line">    lastByte     <span class="keyword">int</span></span><br><span class="line">    lastRuneSize <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>bufio.Reader</code> 字段：</p>
<ul>
<li><code>buf</code>：<code>[]byte</code> 类型的字段，即字节切片，代表缓冲区。虽然它是切片类型的，但是其长度却会在初始化的时候指定，并在之后保持不变。</li>
<li><code>rd</code>：<code>io.Reader</code> 类型的字段，代表底层读取器。缓冲区中的数据就是从这里拷贝来的。</li>
<li><code>r</code>：<code>int</code> 类型的字段，代表对缓冲区进行下一次读取时的开始索引。我们可以称它为已读计数。</li>
<li><code>w</code>：<code>int</code> 类型的字段，代表对缓冲区进行下一次写入时的开始索引。我们可以称之为已写计数。</li>
<li><code>err</code>：<code>error</code> 类型的字段。它的值用于表示在从底层读取器获得数据时发生的错误。这里的值在被读取或忽略之后，该字段会被置为 <code>nil</code>。</li>
<li><code>lastByte</code>：<code>int</code> 类型的字段，用于记录缓冲区中最后一个被读取的字节。读回退时会用到它的值。</li>
<li><code>lastRuneSize</code>：<code>int</code> 类型的字段，用于记录缓冲区中最后一个被读取的 Unicode 字符所占用的字节数。读回退的时候会用到它的值。这个字<br>段只会在其所属值的 <code>ReadRune</code> 方法中才会被赋予有意义的值。在其他情况下，它都会被置为 <code>-1</code>。</li>
</ul>
<h3 id="bufio-Reader-类型读取方法"><a href="#bufio-Reader-类型读取方法" class="headerlink" title="bufio.Reader 类型读取方法"></a>bufio.Reader 类型读取方法</h3><h4 id="ReadSlice、ReadBytes、ReadString-和-ReadLine"><a href="#ReadSlice、ReadBytes、ReadString-和-ReadLine" class="headerlink" title="ReadSlice、ReadBytes、ReadString 和 ReadLine"></a>ReadSlice、ReadBytes、ReadString 和 ReadLine</h4><p>后三个方法最终都是调用 <code>ReadSlice</code> 来实现的。所以，我们先来看看 <code>ReadSlice</code> 方法。</p>
<p><strong>ReadSlice方法</strong>：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span> <span class="title">ReadSlice</span><span class="params">(delim <span class="keyword">byte</span>)</span> <span class="params">(line []<span class="keyword">byte</span>, err error)</span></span></span><br></pre></td></tr></table></figure></p>
<p><code>ReadSlice</code> 从输入中读取，直到遇到第一个界定符（delim）为止，返回一个指向缓存中字节的 <code>slice</code>，在下次调用读操作（<code>read</code>）时，这些字节会<br>无效：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">reader := bufio.NewReader(strings.NewReader(<span class="string">"Hello \nworld"</span>))</span><br><span class="line">line, _ := reader.ReadSlice(<span class="string">'\n'</span>)</span><br><span class="line">fmt.Printf(<span class="string">"the line:%s\n"</span>, line) <span class="comment">// the line:Hello</span></span><br><span class="line">n, _ := reader.ReadSlice(<span class="string">'\n'</span>)</span><br><span class="line">fmt.Printf(<span class="string">"the line:%s\n"</span>, line) <span class="comment">// the line:world</span></span><br><span class="line">fmt.Println(<span class="keyword">string</span>(n)) <span class="comment">// world</span></span><br></pre></td></tr></table></figure></p>
<p>从结果可以看出，第一次 <code>ReadSlice</code> 的结果 <strong>line</strong>，在第二次调用读操作后，内容发生了变化。也就是说，<code>ReadSlice</code> 返回的 <code>[]byte</code> 是指<br>向 <code>Reader</code> 中的 <code>buffer</code> ，而不是 <code>copy</code> 一份返回。正因为 <code>ReadSlice</code> 返回的数据会被下次的 I/O 操作重写，因此许多的客户端会选择<br>使用 <code>ReadBytes</code> 或者 <code>ReadString</code> 来代替。</p>
<p>注意，这里的界定符可以是任意的字符。同时，返回的结果是包含界定符本身的。</p>
<p>如果 <code>ReadSlice</code> 在找到界定符之前遇到了 <code>error</code>，它就会返回缓存中所有的数据和错误本身（经常是 <code>io.EOF</code>）。如果在找到界定符之前缓存已经<br>满了，<code>ReadSlice</code> 会返回 <code>bufio.ErrBufferFull</code> 错误。当且仅当返回的结果（<code>line</code>）没有以界定符结束的时候，<code>ReadSlice</code> 返<br>回 <code>err != nil</code>，也就是说，如果 <code>ReadSlice</code> 返回的结果 <code>line</code> 不是以界定符 <code>delim</code> 结尾，那么返回的 <code>err</code> 也一定不等于 <code>nil</code>。</p>
<p><strong>ReadBytes 方法</strong>：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span> <span class="title">ReadBytes</span><span class="params">(delim <span class="keyword">byte</span>)</span> <span class="params">(line []<span class="keyword">byte</span>, err error)</span></span></span><br></pre></td></tr></table></figure></p>
<p>该方法的参数和返回值类型与 <code>ReadSlice</code> 都一样。 <code>ReadBytes</code> 从输入中读取直到遇到界定符（delim）为止，返回的 <code>slice</code> 包含了从当前到<br>界定符的内容 <strong>（包括界定符）</strong>。</p>
<p><code>ReadBytes</code> 源码：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span> <span class="title">ReadBytes</span><span class="params">(delim <span class="keyword">byte</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// Use ReadSlice to look for array,</span></span><br><span class="line">	<span class="comment">// accumulating full buffers.</span></span><br><span class="line">	<span class="keyword">var</span> frag []<span class="keyword">byte</span></span><br><span class="line">	<span class="keyword">var</span> full [][]<span class="keyword">byte</span></span><br><span class="line">	<span class="keyword">var</span> err error</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">var</span> e error</span><br><span class="line">		frag, e = b.ReadSlice(delim)</span><br><span class="line">		<span class="keyword">if</span> e == <span class="literal">nil</span> &#123; <span class="comment">// got final fragment</span></span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> e != ErrBufferFull &#123; <span class="comment">// unexpected error</span></span><br><span class="line">			err = e</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Make a copy of the buffer.</span></span><br><span class="line">		buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="built_in">len</span>(frag)) <span class="comment">// 这里把 ReadSlice 的返回值 copy 了一份，不再是指向 Reader 中的 buffer</span></span><br><span class="line">		<span class="built_in">copy</span>(buf, frag)</span><br><span class="line">		full = <span class="built_in">append</span>(full, buf)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Allocate new buffer to hold the full pieces and the fragment.</span></span><br><span class="line">	n := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> full &#123;</span><br><span class="line">		n += <span class="built_in">len</span>(full[i])</span><br><span class="line">	&#125;</span><br><span class="line">	n += <span class="built_in">len</span>(frag)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Copy full pieces and fragment in.</span></span><br><span class="line">	buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, n)</span><br><span class="line">	n = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> full &#123;</span><br><span class="line">		n += <span class="built_in">copy</span>(buf[n:], full[i])</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">copy</span>(buf[n:], frag)</span><br><span class="line">	<span class="keyword">return</span> buf, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>ReadString 方法</strong></p>
<p><code>ReadString</code> 源码：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span> <span class="title">ReadString</span><span class="params">(delim <span class="keyword">byte</span>)</span> <span class="params">(line <span class="keyword">string</span>, err error)</span></span> &#123;</span><br><span class="line">    bytes, err := b.ReadBytes(delim)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">string</span>(bytes), err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>调用了 <code>ReadBytes</code> 方法，并将结果的 <code>[]byte</code> 转为 <code>string</code> 类型。</p>
<p><strong>ReadLine 方法</strong><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span> <span class="title">ReadLine</span><span class="params">()</span> <span class="params">(line []<span class="keyword">byte</span>, isPrefix <span class="keyword">bool</span>, err error)</span></span></span><br></pre></td></tr></table></figure></p>
<p><code>ReadLine</code> 是一个底层的原始行读取命令。可以使用 <code>ReadBytes(&#39;\n&#39;)</code> 或者 <code>ReadString(&#39;\n&#39;)</code> 来代替这个方法。</p>
<p><strong><code>ReadLine</code> 尝试返回单独的行，不包括行尾的换行符</strong>。如果一行大于缓存，<code>isPrefix</code> 会被设置为 <code>true</code>，同时返回该行的开始部分<br>（等于缓存大小的部分）。该行剩余的部分就会在下次调用的时候返回。当下次调用返回该行剩余部分时，<code>isPrefix</code> 将会是 <code>false</code> 。<br>跟 <code>ReadSlice</code> 一样，<strong>返回的 <code>line</code> 是 <code>buffer</code> 的引用</strong>，在下次执行 IO 操作时，<code>line</code> 会无效。</p>
<p>建议读取一行使用下面的方式：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">line, err := reader.ReadBytes(<span class="string">'\n'</span>)</span><br><span class="line">line = bytes.TrimRight(line, <span class="string">"\r\n"</span>)</span><br></pre></td></tr></table></figure></p>
<h3 id="Peek-方法"><a href="#Peek-方法" class="headerlink" title="Peek 方法"></a>Peek 方法</h3><p><code>Peek</code> 是 “窥视” 的意思，<code>Peek</code> 一个鲜明的特点，就是：即使它读取了缓冲区中的数据，也不会更改已读计数的值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span> <span class="title">Peek</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span></span><br></pre></td></tr></table></figure>
<p><strong>返回的 <code>[]byte</code> 是 <code>buffer</code> 中的引用</strong>，该切片引用缓存中前 <code>n</code> 字节数据。</p>
<p><strong><code>Peek</code> 方法、<code>ReadSlice</code> 方法和 <code>ReadLine</code> 方法都有可能会造成内容泄露。这主要是因为它们在正常的情况下都会返回直接基于缓冲区的字节切片，<br>也因为为这个原因对多 goroutine 是不安全的，也就是在多并发环境下，不能依赖其结果。</strong>。</p>
<p>另外，Reader 的 Peek 方法如果返回的 []byte 长度小于 n，这时返回的 <code>err != nil</code> ，用于解释为啥会小于 n。如果 n 大于 reader 的 buffer 长度，err 会是 ErrBufferFull。</p>
<h3 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span> <span class="title">Read</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(b *Reader)</span> <span class="title">ReadByte</span><span class="params">()</span> <span class="params">(c <span class="keyword">byte</span>, err error)</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(b *Reader)</span> <span class="title">ReadRune</span><span class="params">()</span> <span class="params">(r <span class="keyword">rune</span>, size <span class="keyword">int</span>, err error)</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(b *Reader)</span> <span class="title">UnreadByte</span><span class="params">()</span> <span class="title">error</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(b *Reader)</span> <span class="title">UnreadRune</span><span class="params">()</span> <span class="title">error</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(b *Reader)</span> <span class="title">WriteTo</span><span class="params">(w io.Writer)</span> <span class="params">(n <span class="keyword">int64</span>, err error)</span></span></span><br></pre></td></tr></table></figure>
<h2 id="bufio-Writer"><a href="#bufio-Writer" class="headerlink" title="bufio.Writer"></a>bufio.Writer</h2><p><code>bufio.Writer</code> 结构封装了一个 <code>io.Writer</code> 对象。同时实现了 <code>io.Writer</code> 接口。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Writer <span class="keyword">struct</span> &#123;</span><br><span class="line">    err error		<span class="comment">// 写过程中遇到的错误</span></span><br><span class="line">    buf []<span class="keyword">byte</span>		<span class="comment">// 缓存</span></span><br><span class="line">    n   <span class="keyword">int</span>			<span class="comment">// 当前缓存中的字节数</span></span><br><span class="line">    wr  io.Writer	<span class="comment">// 底层的 io.Writer 对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>bufio.Writer</code> 类型的字段:</p>
<ul>
<li><code>err</code>：<code>error</code> 类型的字段。它的值用于表示在向底层写入器写数据时发生的错误。</li>
<li><code>buf</code>：<code>[]byte</code> 类型的字段，代表缓冲区。在初始化之后，它的长度会保持不变。</li>
<li><code>n</code>：<code>int</code> 类型的字段，代表对缓冲区进行下一次写入时的开始索引。我们可以称之为已写计数。</li>
<li><code>wr</code>：<code>io.Writer</code> 类型的字段，代表底层写入器。</li>
</ul>
<p>两个用于初始化 <code>bufio.Writer</code> 的函数：</p>
<ul>
<li><code>NewWriter</code> 函数初始化的 <code>Writer</code> 值会拥有一个默认尺寸的缓冲区。这个默认尺寸是 <code>4096</code> 个字节，即：<code>4 KB</code>。</li>
<li><code>NewWriterSize</code> 函数则将缓冲区尺寸的决定权抛给了使用方。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewWriter</span><span class="params">(wr io.Writer)</span> *<span class="title">Writer</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">NewWriterSize</span><span class="params">(wr io.Writer, size <span class="keyword">int</span>)</span> *<span class="title">Writer</span> // 可以配置缓冲区的大小</span></span><br></pre></td></tr></table></figure>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul>
<li><code>Available</code> 方法获取缓存中还未使用的字节数（缓存大小 - 字段 n 的值）</li>
<li><code>Buffered</code> 方法获取写入当前缓存中的字节数（字段 n 的值）</li>
<li><code>Flush</code> 方法将缓存中的所有数据写入底层的 io.Writer 对象中。</li>
</ul>
<p>其他实现了 <code>io</code> 包的接口方法：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现了 io.ReaderFrom 接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Writer)</span> <span class="title">ReadFrom</span><span class="params">(r io.Reader)</span> <span class="params">(n <span class="keyword">int64</span>, err error)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 实现了 <span class="title">io</span>.<span class="title">Writer</span> 接口</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(b *Writer)</span> <span class="title">Write</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(nn <span class="keyword">int</span>, err error)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 实现了 <span class="title">io</span>.<span class="title">ByteWriter</span> 接口</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(b *Writer)</span> <span class="title">WriteByte</span><span class="params">(c <span class="keyword">byte</span>)</span> <span class="title">error</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// <span class="title">io</span> 中没有该方法的接口，它用于写入单个 <span class="title">Unicode</span> 码点，返回写入的字节数（码点占用的字节），内部实现会根据当前 <span class="title">rune</span> 的范围调用 <span class="title">WriteByte</span> 或 <span class="title">WriteString</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(b *Writer)</span> <span class="title">WriteRune</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="params">(size <span class="keyword">int</span>, err error)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 写入字符串，如果返回写入的字节数比 <span class="title">len</span><span class="params">(s)</span> 小，返回的<span class="title">error</span>会解释原因</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(b *Writer)</span> <span class="title">WriteString</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span></span><br></pre></td></tr></table></figure></p>
<h3 id="bufio-Writer-类型值中缓冲的数据什么时候会被写到它的底层写入器"><a href="#bufio-Writer-类型值中缓冲的数据什么时候会被写到它的底层写入器" class="headerlink" title="bufio.Writer 类型值中缓冲的数据什么时候会被写到它的底层写入器"></a>bufio.Writer 类型值中缓冲的数据什么时候会被写到它的底层写入器</h3><p><code>bufio.Writer</code> 类型有一个名为 <code>Flush</code> 的方法，它的主要功能是把相应缓冲区中暂存的所有数据，都写到底层写入器中。数据一旦被写进底层写入器，<br>该方法就会把它们从缓冲区中删除掉。</p>
<p><code>bufio.Writer</code> 类型值（以下简称 <code>Writer</code> 值）拥有的所有数据写入方法都会在必要的时候调用它的 <code>Flush</code> 方法。</p>
<p>比如，<code>Write</code> 方法有时候会在把数据写进缓冲区之后，调用 <code>Flush</code> 方法，以便为后续的新数据腾出空间。<code>WriteString</code> 方法的行为与之类似。</p>
<p><code>WriteByte</code> 方法和 <code>WriteRune</code> 方法，都会在发现缓冲区中的可写空间不足以容纳新的字节，或 Unicode 字符的时候，调用 <code>Flush</code> 方法。</p>
<p>在<strong>通常情况下，只要缓冲区中的可写空间无法容纳需要写入的新数据，<code>Flush</code> 方法就一定会被调用</strong>。</p>
<h2 id="ReadWriter"><a href="#ReadWriter" class="headerlink" title="ReadWriter"></a>ReadWriter</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReadWriter <span class="keyword">struct</span> &#123;</span><br><span class="line">    *Reader</span><br><span class="line">    *Writer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过调用 <code>bufio.NewReadWriter</code> 函数来初始化：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewReadWriter</span><span class="params">(r *Reader, w *Writer)</span> *<span class="title">ReadWriter</span></span></span><br></pre></td></tr></table></figure></p>

        <div id="react-support-footer-root"></div>
      </div>
    </div>
  </div>
</div>

    


    

    <!-- js vendors -->
    <script src="//code.jquery.com/jquery-3.2.1.min.js" crossorigin="anonymous"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/lunr.js/2.1.0/lunr.min.js"></script>

    <!-- js source  -->
    <script src="/golang-learn/script/doc.js"></script>

    

  </body>
</html>
