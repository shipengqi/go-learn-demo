<!DOCTYPE html>
<html lang="en">
  <head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">

    <title>Golang learning | http </title>
    <meta name="description" content>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    

    <!-- fonts -->
    <link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700" rel="stylesheet">
    <link href="//fonts.googleapis.com/css?family=Ubuntu:300,400,500,600,700" rel="stylesheet">

    <!-- stylesheets -->
    <link rel="stylesheet" href="/golang-learn/style/doc.css">

    <!-- favicon -->
    <link rel="icon" href="/golang-learn/images/favicon.ico">

    

  </head>
  <body>

   <script>window.__INITIAL_STATE__ = {"page":{"title":"http","path":"standards/net/http.html"},"data":{"navigation":{"logo":{"text":"Golang Learn","type":"link","path":"index.html"},"main":[{"text":"Golang 基础","type":"label"},{"text":"Go 环境配置","type":"link","path":"basic/env_config.html"},{"text":"包","type":"link","path":"basic/package.html"},{"text":"基础数据类型","type":"link","path":"basic/basic_data.html"},{"text":"变量","type":"link","path":"basic/var.html"},{"text":"常量","type":"link","path":"basic/constant.html"},{"text":"控制语句","type":"link","path":"basic/flow.html"},{"text":"运算符","type":"link","path":"basic/operator.html"},{"text":"作用域","type":"link","path":"basic/scope.html"},{"text":"指针","type":"link","path":"basic/pointer.html"},{"text":"数组","type":"link","path":"basic/array.html"},{"text":"切片","type":"link","path":"basic/slice.html"},{"text":"字典","type":"link","path":"basic/map.html"},{"text":"函数","type":"link","path":"basic/function.html"},{"text":"结构体","type":"link","path":"basic/struct.html"},{"text":"接口","type":"link","path":"basic/interface.html"},{"text":"面向对象","type":"link","path":"basic/oop.html"},{"text":"错误","type":"link","path":"basic/error.html"},{"text":"序列化","type":"link","path":"basic/json.html"},{"text":"反射","type":"link","path":"basic/reflect.html"},{"text":"测试","type":"link","path":"basic/test.html"},{"text":"并发编程","type":"label"},{"text":"goroutine","type":"link","path":"concurrent/goroutine.html"},{"text":"channel","type":"link","path":"concurrent/channel.html"},{"text":"同步和锁","type":"link","path":"concurrent/sync_lock.html"},{"text":"内存分配","type":"label"},{"text":"内存分配","type":"link","path":"advance/mm.html"},{"text":"垃圾回收","type":"label"},{"text":"垃圾回收","type":"link","path":"advance/gc.html"},{"text":"标准库","type":"label"},{"text":"fmt","type":"link","path":"standards/io/fmt.html"},{"text":"io","type":"link","path":"standards/io/io.html"},{"text":"ioutil","type":"link","path":"standards/io/ioutil.html"},{"text":"bufio","type":"link","path":"standards/io/bufio.html"},{"text":"os","type":"link","path":"standards/os/os.html"},{"text":"filepath","type":"link","path":"standards/os/filepath.html"},{"text":"strings","type":"link","path":"standards/text/strings.html"},{"text":"strconv","type":"link","path":"standards/text/strconv.html"},{"text":"unicode","type":"link","path":"standards/text/unicode.html"},{"text":"log","type":"link","path":"standards/log.html"},{"text":"time","type":"link","path":"standards/time.html"},{"text":"http","type":"link","path":"standards/net/http.html"},{"text":"math","type":"link","path":"standards/data/math.html"},{"text":"sort","type":"link","path":"standards/data/sort.html"},{"text":"big","type":"link","path":"standards/data/big.html"},{"text":"container","type":"link","path":"standards/data/container.html"},{"text":"sql","type":"link","path":"standards/database/sql.html"},{"text":"THEME","type":"label"},{"text":"使用文档主题","type":"link","path":"theme/theme-usage.html"},{"text":"SUPPORT AND FEEDBACK","type":"label"},{"text":"Raise an Issue on Github","type":"link","path":"https://github.com/shipengqi/golang-learn/issues/new"}]}},"config":{"timezone":"UTC","root":"/golang-learn/","time_format":"HH:mm:ss","theme":"../node_modules/hexo-theme-doc","theme_config":{"swagger_ui":{"version":2,"permalinks":true,"api_explorer":true,"download":"Download specification","show_extensions":false,"deep_linking":true,"display_operation_id":false,"doc_expansion":"none"},"search":{"skip":false,"background":false,"route":"/lunr.json"},"favicon":"images/favicon.ico"}}}</script>

    <div id="react-navigation-root"><div class="doc-navigation" data-reactroot><nav class="doc-navbar"><a href="/golang-learn/index.html" class="doc-navbar__logo"><img src="/golang-learn/images/logo.png" class="doc-navbar__logo__img"><span class="doc-navbar__logo__text">Golang Learn</span></a><i class="dc-icon dc-icon--close dc-icon--interactive doc-sidebar-close doc-navbar__sidebar-close doc-navbar__sidebar-close--desktop"></i><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-navbar__sidebar-toggle"></i></nav><nav class="doc-sidebar"><div class="doc-sidebar__vertical-menu"><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-sidebar-toggle--primary doc-sidebar__vertical-menu__item"></i><i class="dc-icon dc-icon--search dc-icon--interactive doc-sidebar__vertical-menu__item doc-sidebar__vertical-menu__item--primary"></i></div><div class="doc-sidebar-content"><div class="doc-sidebar__search-form"></div><ul class="doc-sidebar-list"></ul></div></nav></div></div>
    <div class="doc-content">
  <div class="dc-page">
    <div class="dc-card">
      <div id="react-search-results-root"></div>
      <div id="page-content" class="doc-formatting">
        <h1 id="http"><a href="#http" class="headerlink" title="http"></a>http</h1><p><code>net/http</code> 可以用来处理 HTTP 协议，包括 HTTP 服务器和 HTTP 客户端，主要组成：</p>
<ul>
<li>Request，HTTP 请求对象</li>
<li>Response，HTTP 响应对象</li>
<li>Client，HTTP 客户端</li>
<li>Server，HTTP 服务端</li>
</ul>
<p>创建一个 server ：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MyHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	_, _ = fmt.Fprintf(w, <span class="string">"hello"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	http.HandleFunc(<span class="string">"/"</span>, MyHandler)</span><br><span class="line">	_ = http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发送请求：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">resp, err := http.Get(<span class="string">"http://example.com/"</span>) <span class="comment">// GET </span></span><br><span class="line"></span><br><span class="line">resp, err := http.Post(<span class="string">"http://example.com/"</span>) <span class="comment">// POST</span></span><br><span class="line"></span><br><span class="line">resp, err := http.PostForm(<span class="string">"http://example.com/"</span>, url.Values&#123;<span class="string">"foo"</span>: <span class="string">"bar"</span>&#125;) <span class="comment">// 提交表单</span></span><br></pre></td></tr></table></figure></p>
<h2 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h2><p><code>Request</code> 对象是对 http 请求报文的抽象。包括起始行, <code>Headers</code>, <code>Body</code> 等。</p>
<p>使用 <code>http.NewRequest</code> 函数创建一个 <code>Request</code> 请求对象：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewRequest</span><span class="params">(method, url <span class="keyword">string</span>, body io.Reader)</span> <span class="params">(*Request, error)</span></span></span><br></pre></td></tr></table></figure></p>
<p><code>Request</code> 对象主要用于数据的存储，结构：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Request <span class="keyword">struct</span> &#123;</span><br><span class="line">    Method <span class="keyword">string</span> <span class="comment">// HTTP方法</span></span><br><span class="line">    URL *url.URL <span class="comment">// URL</span></span><br><span class="line">    </span><br><span class="line">    Proto      <span class="keyword">string</span> <span class="comment">// "HTTP/1.0"</span></span><br><span class="line">    ProtoMajor <span class="keyword">int</span>    <span class="comment">// 1</span></span><br><span class="line">    ProtoMinor <span class="keyword">int</span>    <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">    Header Header <span class="comment">// 报文头</span></span><br><span class="line">    Body io.ReadCloser <span class="comment">// 报文体</span></span><br><span class="line">    GetBody <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(io.ReadCloser, error)</span></span></span><br><span class="line"><span class="function">    <span class="title">ContentLength</span> <span class="title">int64</span> // 报文长度</span></span><br><span class="line"><span class="function">    <span class="title">TransferEncoding</span> []<span class="title">string</span> // 传输编码</span></span><br><span class="line"><span class="function">    <span class="title">Close</span> <span class="title">bool</span> // 关闭连接</span></span><br><span class="line"><span class="function">    <span class="title">Host</span> <span class="title">string</span> // 主机名</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">    <span class="title">Form</span> <span class="title">url</span>.<span class="title">Values</span> // </span></span><br><span class="line"><span class="function">    <span class="title">PostForm</span> <span class="title">url</span>.<span class="title">Values</span> // <span class="title">POST</span>表单信息</span></span><br><span class="line"><span class="function">    <span class="title">MultipartForm</span> *<span class="title">multipart</span>.<span class="title">Form</span> // <span class="title">multipart</span>，</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="title">Trailer</span> <span class="title">Header</span></span></span><br><span class="line"><span class="function">    <span class="title">RemoteAddr</span> <span class="title">string</span></span></span><br><span class="line"><span class="function">    <span class="title">RequestURI</span> <span class="title">string</span></span></span><br><span class="line"><span class="function">    <span class="title">TLS</span> *<span class="title">tls</span>.<span class="title">ConnectionState</span></span></span><br><span class="line"><span class="function">    <span class="title">Cancel</span> &lt;-<span class="title">chan</span> <span class="title">struct</span></span>&#123;&#125;</span><br><span class="line">    Response *Response</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从 b 中读取和解析一个请求. </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadRequest</span><span class="params">(b *bufio.Reader)</span> <span class="params">(req *Request, err error)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 给 <span class="title">request</span> 添加 <span class="title">cookie</span>, <span class="title">AddCookie</span> 向请求中添加一个 <span class="title">cookie</span>.按照<span class="title">RFC</span> 6265 </span></span><br><span class="line"><span class="function">// <span class="title">section</span> 5.4的规则, <span class="title">AddCookie</span> 不会添加超过一个 <span class="title">Cookie</span> 头字段.</span></span><br><span class="line"><span class="function">// 这表示所有的 <span class="title">cookie</span> 都写在同一行, 用分号分隔（<span class="title">cookie</span> 内部用逗号分隔属性） </span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(r *Request)</span> <span class="title">AddCookie</span><span class="params">(c *Cookie)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 返回 <span class="title">request</span> 中指定名 <span class="title">name</span> 的 <span class="title">cookie</span>，如果没有发现，返回 <span class="title">ErrNoCookie</span> </span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(r *Request)</span> <span class="title">Cookie</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(*Cookie, error)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 返回该请求的所有<span class="title">cookies</span> </span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(r *Request)</span> <span class="title">Cookies</span><span class="params">()</span> []*<span class="title">Cookie</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 利用提供的用户名和密码给 <span class="title">http</span> 基本权限提供具有一定权限的 <span class="title">header</span>。</span></span><br><span class="line"><span class="function">// 当使用 <span class="title">http</span> 基本授权时，用户名和密码是不加密的 </span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(r *Request)</span> <span class="title">SetBasicAuth</span><span class="params">(username, password <span class="keyword">string</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 如果在 <span class="title">request</span> 中发送，该函数返回客户端的 <span class="title">user</span>-<span class="title">Agent</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(r *Request)</span> <span class="title">UserAgent</span><span class="params">()</span> <span class="title">string</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 对于指定格式的 <span class="title">key</span>，<span class="title">FormFile</span> 返回符合条件的第一个文件，如果有必要的话，</span></span><br><span class="line"><span class="function">// 该函数会调用 <span class="title">ParseMultipartForm</span> 和 <span class="title">ParseForm</span>。 </span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(r *Request)</span> <span class="title">FormFile</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="params">(multipart.File, *multipart.FileHeader, error)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 返回 <span class="title">key</span> 获取的队列中第一个值。在查询过程中 <span class="title">post</span> 和 <span class="title">put</span> 中的主题参数优先级</span></span><br><span class="line"><span class="function">// 高于 <span class="title">url</span> 中的 <span class="title">value</span>。为了访问相同 <span class="title">key</span> 的多个值，调用 <span class="title">ParseForm</span> 然后直接</span></span><br><span class="line"><span class="function">// 检查 <span class="title">RequestForm</span>。 </span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(r *Request)</span> <span class="title">FormValue</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 如果这是一个有多部分组成的 <span class="title">post</span> 请求，该函数将会返回一个 <span class="title">MIME</span> 多部分 <span class="title">reader</span>，</span></span><br><span class="line"><span class="function">// 否则的话将会返回一个 <span class="title">nil</span> 和 <span class="title">error</span>。使用本函数代替 <span class="title">ParseMultipartForm</span></span></span><br><span class="line"><span class="function">// 可以将请求 <span class="title">body</span> 当做流 <span class="title">stream</span> 来处理。 </span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(r *Request)</span> <span class="title">MultipartReader</span><span class="params">()</span> <span class="params">(*multipart.Reader, error)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 解析<span class="title">URL</span>中的查询字符串，并将解析结果更新到 <span class="title">r</span>.<span class="title">Form</span> 字段。对于<span class="title">POST</span> 或 <span class="title">PUT</span></span></span><br><span class="line"><span class="function">// 请求，<span class="title">ParseForm</span> 还会将 <span class="title">body</span> 当作表单解析，并将结果既更新到 <span class="title">r</span>.<span class="title">PostForm</span> 也</span></span><br><span class="line"><span class="function">// 更新到 <span class="title">r</span>.<span class="title">Form</span>。解析结果中，<span class="title">POST</span> 或 <span class="title">PUT</span> 请求主体要优先于 <span class="title">URL</span> 查询字符串</span></span><br><span class="line"><span class="function">// （同名变量，主体的值在查询字符串的值前面）。如果请求的主体的大小没有被</span></span><br><span class="line"><span class="function">// <span class="title">MaxBytesReader</span> 函数设定限制，其大小默认限制为开头 10<span class="title">MB</span>。</span></span><br><span class="line"><span class="function">// <span class="title">ParseMultipartForm</span> 会自动调用 <span class="title">ParseForm</span>。重复调用本方法是无意义的。</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(r *Request)</span> <span class="title">ParseForm</span><span class="params">()</span> <span class="title">error</span> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// <span class="title">ParseMultipartForm</span> 将请求的主体作为 <span class="title">multipart</span>/<span class="title">form</span>-<span class="title">data</span> 解析。</span></span><br><span class="line"><span class="function">// 请求的整个主体都会被解析，得到的文件记录最多 <span class="title">maxMemery</span> 字节保存在内存，</span></span><br><span class="line"><span class="function">// 其余部分保存在硬盘的 <span class="title">temp</span> 文件里。如果必要，<span class="title">ParseMultipartForm</span> 会</span></span><br><span class="line"><span class="function">// 自行调用 <span class="title">ParseForm</span>。重复调用本方法是无意义的。</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(r *Request)</span> <span class="title">ParseMultipartForm</span><span class="params">(maxMemory <span class="keyword">int64</span>)</span> <span class="title">error</span> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 返回 <span class="title">post</span> 或者 <span class="title">put</span> 请求 <span class="title">body</span> 指定元素的第一个值，其中 <span class="title">url</span> 中的参数被忽略。</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(r *Request)</span> <span class="title">PostFormValue</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">string</span> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 检测在 <span class="title">request</span> 中使用的 <span class="title">http</span> 协议是否至少是 <span class="title">major</span>.<span class="title">minor</span> </span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(r *Request)</span> <span class="title">ProtoAtLeast</span><span class="params">(major, minor <span class="keyword">int</span>)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 如果 <span class="title">request</span> 中有 <span class="title">refer</span>，那么 <span class="title">refer</span> 返回相应的 <span class="title">url</span>。<span class="title">Referer</span> 在 <span class="title">request</span></span></span><br><span class="line"><span class="function">// 中是拼错的<span class="params">(Referrer)</span>，这个错误从 <span class="title">http</span> 初期就已经存在了。该值也可以从 <span class="title">Headermap</span> 中</span></span><br><span class="line"><span class="function">// 利用 <span class="title">Header</span>["<span class="title">Referer</span>"] 获取；在使用过程中利用 <span class="title">Referer</span> 这个方法而</span></span><br><span class="line"><span class="function">// 不是 <span class="title">map</span> 的形式的好处是在编译过程中可以检查方法的错误，而无法检查 <span class="title">map</span> 中</span></span><br><span class="line"><span class="function">// <span class="title">key</span> 的错误。</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(r *Request)</span> <span class="title">Referer</span><span class="params">()</span> <span class="title">string</span> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// <span class="title">Write</span> 方法以有线格式将 <span class="title">HTTP</span>/1.1 请求写入 <span class="title">w</span>（用于将请求写入下层 <span class="title">TCPConn</span> 等）</span></span><br><span class="line">// 。本方法会考虑请求的如下字段：Host URL Method (defaults to "GET")</span><br><span class="line"><span class="comment">//  Header ContentLength TransferEncoding Body如果存在Body，</span></span><br><span class="line"><span class="comment">// ContentLength字段&lt;= 0且TransferEncoding字段未显式设置为</span></span><br><span class="line"><span class="comment">// ["identity"]，Write 方法会显式添加 ”Transfer-Encoding: chunked”</span></span><br><span class="line"><span class="comment">// 到请求的头域。Body 字段会在发送完请求后关闭。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Request)</span> <span class="title">Write</span><span class="params">(w io.Writer)</span> <span class="title">error</span> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 该函数与 <span class="title">Write</span> 方法类似，但是该方法写的 <span class="title">request</span> 是按照 <span class="title">http</span> 代理的格式去写。</span></span><br><span class="line"><span class="function">// 尤其是，按照 <span class="title">RFC</span> 2616 <span class="title">Section</span> 5.1.2，<span class="title">WriteProxy</span> 会使用绝对 <span class="title">URI</span></span></span><br><span class="line"><span class="function">// （包括协议和主机名）来初始化请求的第1行（<span class="title">Request</span>-<span class="title">URI</span>行）。无论何种情况，</span></span><br><span class="line"><span class="function">// <span class="title">WriteProxy</span> 都会使用 <span class="title">r</span>.<span class="title">Host</span> 或 <span class="title">r</span>.<span class="title">URL</span>.<span class="title">Host</span> 设置 <span class="title">Host</span> 头。</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(r *Request)</span> <span class="title">WriteProxy</span><span class="params">(w io.Writer)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>
<h2 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h2><p>Response 也是一个数据对象，描述 HTTP 响应：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Response <span class="keyword">struct</span> &#123;</span><br><span class="line">    Status     <span class="keyword">string</span> <span class="comment">// HTTP 状态码</span></span><br><span class="line">    StatusCode <span class="keyword">int</span>    <span class="comment">// 状态码 200</span></span><br><span class="line">    Proto      <span class="keyword">string</span> <span class="comment">// 版本号 "HTTP/1.0"</span></span><br><span class="line">    ProtoMajor <span class="keyword">int</span>    <span class="comment">// 主版本号 </span></span><br><span class="line">    ProtoMinor <span class="keyword">int</span>    <span class="comment">// 次版本号</span></span><br><span class="line"></span><br><span class="line">    Header Header <span class="comment">// 响应报文头</span></span><br><span class="line">    Body io.ReadCloser <span class="comment">// 响应报文体</span></span><br><span class="line">    ContentLength <span class="keyword">int64</span> <span class="comment">// 报文长度</span></span><br><span class="line">    TransferEncoding []<span class="keyword">string</span> <span class="comment">// 报文编码</span></span><br><span class="line">    Close <span class="keyword">bool</span> </span><br><span class="line">    Trailer Header</span><br><span class="line">    Request *Request <span class="comment">// 请求对象</span></span><br><span class="line">    TLS *tls.ConnectionState</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReadResponse 从 r 读取并返回一个 HTTP 回复。req 参数是可选的，指定该回复</span></span><br><span class="line"><span class="comment">// 对应的请求（即是对该请求的回复）。如果是 nil，将假设请 求是 GET 请求。</span></span><br><span class="line"><span class="comment">// 客户端必须在结束 resp.Body 的读取后关闭它。读取完毕并关闭后，客户端可以</span></span><br><span class="line"><span class="comment">// 检查 resp.Trailer 字段获取回复的 trailer 的键值对。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadResponse</span><span class="params">(r *bufio.Reader, req *Request)</span> <span class="params">(*Response, error)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 解析 <span class="title">cookie</span> 并返回在 <span class="title">header</span> 中利用 <span class="title">set</span>-<span class="title">Cookie</span> 设定的 <span class="title">cookie</span> 值。</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(r *Response)</span> <span class="title">Cookies</span><span class="params">()</span> []*<span class="title">Cookie</span> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 返回 <span class="title">response</span> 中 <span class="title">Location</span> 的 <span class="title">header</span> 值的 <span class="title">url</span>。如果该值存在的话，则对于</span></span><br><span class="line"><span class="function">// 请求问题可以解决相对重定向的问题，如果该值为<span class="title">nil</span>，则返回<span class="title">ErrNOLocation</span>。</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(r *Response)</span> <span class="title">Location</span><span class="params">()</span> <span class="params">(*url.URL, error)</span> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 判定在 <span class="title">response</span> 中使用的 <span class="title">http</span> 协议是否至少是 <span class="title">major</span>.<span class="title">minor</span> 的形式。</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(r *Response)</span> <span class="title">ProtoAtLeast</span><span class="params">(major, minor <span class="keyword">int</span>)</span> <span class="title">bool</span> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 将 <span class="title">response</span> 中信息按照线性格式写入 <span class="title">w</span> 中。</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(r *Response)</span> <span class="title">Write</span><span class="params">(w io.Writer)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>
<h2 id="client"><a href="#client" class="headerlink" title="client"></a>client</h2><p>前面以 <code>http.Get(&quot;http://example.com/&quot;)</code> <code>Get</code> 或 <code>Post</code> 函数发送请求，就是通过绑定一个默认 <code>Client</code> 实现的。<br>使用 <code>Client</code> 要先初始化一个 <code>Client</code> 对象。<code>Client</code> 具有 <code>Do</code>，<code>Get</code>，<code>Head</code>，<code>Post</code> 以及 <code>PostForm</code> 等方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"net/http"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    client := http.Client()</span><br><span class="line">    res, err := client.Get(<span class="string">"http://www.google.com"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于常用 HTTP 动词，<code>Client</code> 对象对应的函数，下面的这些方法与 <code>http.Get</code> 等方法一致：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span> <span class="title">Get</span><span class="params">(url <span class="keyword">string</span>)</span> <span class="params">(resp *Response, err error)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(c *Client)</span> <span class="title">Head</span><span class="params">(url <span class="keyword">string</span>)</span> <span class="params">(resp *Response, err error)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(c *Client)</span> <span class="title">Post</span><span class="params">(url <span class="keyword">string</span>, contentType <span class="keyword">string</span>, body io.Reader)</span> <span class="params">(resp *Response, err error)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(c *Client)</span> <span class="title">PostForm</span><span class="params">(url <span class="keyword">string</span>, data url.Values)</span> <span class="params">(resp *Response, err error)</span></span></span><br></pre></td></tr></table></figure></p>
<p>但是在很多情况下，需要支持对 headers，cookies 等的设定，上面提供的方法就不能满足需求了。就需要使用 <code>Do</code> 方法，<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span> <span class="title">Do</span><span class="params">(req *Request)</span> <span class="params">(resp *Response, err error)</span></span></span><br></pre></td></tr></table></figure></p>
<p><code>http.NewRequest</code> 可以灵活的对 <code>Request</code> 进行配置，然后再使用 <code>http.Client</code> 的 <code>Do</code> 方法发送这个 <code>Request</code> 请求。</p>
<p><strong>模拟 HTTP Request</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简式声明一个 http.Client</span></span><br><span class="line">client := &amp;http.Client&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建 Request</span></span><br><span class="line">request, err := http.NewRequest(<span class="string">"GET"</span>, <span class="string">"http://www.baidu.com"</span>, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 http.Cookie 结构体初始化一个 cookie 键值对</span></span><br><span class="line">cookie := &amp;http.Cookie&#123;Name: <span class="string">"userId"</span>, Value: strconv.Itoa(<span class="number">12345</span>)&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AddCookie</span></span><br><span class="line">request.AddCookie(cookie)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置 Header</span></span><br><span class="line">request.Header.Set(<span class="string">"Accept"</span>, <span class="string">"text/html, application/xhtml+xml, application/xml;q=0.9, */*;q=0.8"</span>)</span><br><span class="line">request.Header.Set(<span class="string">"Accept-Charset"</span>, <span class="string">"GBK, utf-8;q=0.7, *;q=0.3"</span>)</span><br><span class="line">request.Header.Set(<span class="string">"Accept-Encoding"</span>, <span class="string">"gzip, deflate, sdch"</span>)</span><br><span class="line">request.Header.Set(<span class="string">"Accept-Language"</span>, <span class="string">"zh-CN, zh;q=0.8"</span>)</span><br><span class="line">request.Header.Set(<span class="string">"Cache-Control"</span>, <span class="string">"max-age=0"</span>)</span><br><span class="line">request.Header.Set(<span class="string">"Connection"</span>, <span class="string">"keep-alive"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Do 方法发送请求</span></span><br><span class="line">response, err := client.Do(request)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 程序结束时关闭 response.Body 响应流</span></span><br><span class="line"><span class="keyword">defer</span> response.Body.Close()</span><br><span class="line"></span><br><span class="line"><span class="comment">// http Response 状态值</span></span><br><span class="line">fmt.Println(response.StatusCode)</span><br><span class="line"><span class="keyword">if</span> response.StatusCode == <span class="number">200</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// gzip.NewReader对压缩的返回信息解压（考虑网络传输量，http Server</span></span><br><span class="line">    <span class="comment">// 一般都会对响应压缩后再返回）</span></span><br><span class="line">    body, err := gzip.NewReader(response.Body)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">defer</span> body.Close()</span><br><span class="line"></span><br><span class="line">    r, err := ioutil.ReadAll(body)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 打印出http Server返回的http Response信息</span></span><br><span class="line">    fmt.Println(<span class="keyword">string</span>(r))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Ge请求</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// http.Get 实际上是 DefaultClient.Get(url)</span></span><br><span class="line">response, err := http.Get(<span class="string">"http://www.baidu.com"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 程序在使用完回复后必须关闭回复的主体</span></span><br><span class="line"><span class="keyword">defer</span> response.Body.Close()</span><br><span class="line"></span><br><span class="line">body, _ := ioutil.ReadAll(response.Body)</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(body))</span><br></pre></td></tr></table></figure>
<p><strong>Post 请求</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// application/x-www-form-urlencoded：为 POST 的 contentType</span></span><br><span class="line">resp, err := http.Post(<span class="string">"http://localhost:8080/login.do"</span>,</span><br><span class="line">    <span class="string">"application/x-www-form-urlencoded"</span>, strings.NewReader(<span class="string">"mobile=xxxxxxxxxx&amp;isRemberPwd=1"</span>))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">body, err := ioutil.ReadAll(resp.Body)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(body))</span><br></pre></td></tr></table></figure>
<p><strong>http.PostForm 请求</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"io/ioutil"</span></span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line">	<span class="string">"net/url"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	postParam := url.Values&#123;</span><br><span class="line">		<span class="string">"mobile"</span>:      &#123;<span class="string">"xxxxxx"</span>&#125;,</span><br><span class="line">		<span class="string">"isRemberPwd"</span>: &#123;<span class="string">"1"</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 数据的键值会经过 URL 编码后作为请求的 body 传递</span></span><br><span class="line">	resp, err := http.PostForm(<span class="string">"http://localhost：8080/login.do"</span>, postParam)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">	body, err := ioutil.ReadAll(resp.Body)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="keyword">string</span>(body))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="HTTP-Server"><a href="#HTTP-Server" class="headerlink" title="HTTP Server"></a>HTTP Server</h2><p><code>server.go</code> 文件中定义了一个非常重要的接口：<code>Handler</code>，另外还有一个结构体 <code>response</code>，这和 <code>http.Response</code> 结构体只有首字母大小<br>写不一致，这个 <code>response</code> 也是响应，只不过是专门用在服务端，和 <code>http.Response</code> 结构体是完全两回事。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Handler <span class="keyword">interface</span> &#123;</span><br><span class="line">	ServeHTTP(ResponseWriter, *Request)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听 srv.Addr 然后调用 Serve 来处理接下来连接的请求</span></span><br><span class="line"><span class="comment">// 如果 srv.Addr 是空的话，则使用 ":http"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(srv *Server)</span> <span class="title">ListenAndServe</span><span class="params">()</span> <span class="title">error</span> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 监听 <span class="title">srv</span>.<span class="title">Addr</span> ，调用 <span class="title">Serve</span> 来处理接下来连接的请求</span></span><br><span class="line"><span class="function">// 必须提供证书文件和对应的私钥文件。如果证书是由</span></span><br><span class="line"><span class="function">// 权威机构签发的，<span class="title">certFile</span> 参数必须是顺序串联的服务端证书和 <span class="title">CA</span> 证书。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(srv *Server)</span> <span class="title">ListenAndServeTLS</span><span class="params">(certFile, keyFile <span class="keyword">string</span>)</span> <span class="title">error</span> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 接受 <span class="title">l</span> <span class="title">Listener</span> 的连接，创建一个新的服务协程。该服务协程读取请求然后调用</span></span><br><span class="line"><span class="function">// <span class="title">srv</span>.<span class="title">Handler</span> 来应答。实际上就是实现了对某个端口进行监听，然后创建相应的连接。 </span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(srv *Server)</span> <span class="title">Serve</span><span class="params">(l net.Listener)</span> <span class="title">error</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 该函数控制是否 <span class="title">http</span> 的 <span class="title">keep</span>-<span class="title">alives</span> 能够使用，默认情况下，<span class="title">keep</span>-<span class="title">alives</span> 总是可用的。</span></span><br><span class="line"><span class="function">// 只有资源非常紧张的环境或者服务端在关闭进程中时，才应该关闭该功能。 </span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(s *Server)</span> <span class="title">SetKeepAlivesEnabled</span><span class="params">(v <span class="keyword">bool</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 是一个 <span class="title">http</span> 请求多路复用器，它将每一个请求的 <span class="title">URL</span> 和</span></span><br><span class="line"><span class="function">// 一个注册模式的列表进行匹配，然后调用和 <span class="title">URL</span> 最匹配的模式的处理器进行后续操作。</span></span><br><span class="line"><span class="function"><span class="title">type</span> <span class="title">ServeMux</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 初始化一个新的 <span class="title">ServeMux</span> </span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">NewServeMux</span><span class="params">()</span> *<span class="title">ServeMux</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 将 <span class="title">handler</span> 注册为指定的模式，如果该模式已经有了 <span class="title">handler</span>，则会出错 <span class="title">panic</span>。</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">Handle</span><span class="params">(pattern <span class="keyword">string</span>, handler Handler)</span> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 将 <span class="title">handler</span> 注册为指定的模式 </span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">HandleFunc</span><span class="params">(pattern <span class="keyword">string</span>, handler <span class="keyword">func</span>(ResponseWriter, *Request)</span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 根据指定的 <span class="title">r</span>.<span class="title">Method</span>, <span class="title">r</span>.<span class="title">Host</span> 以及 <span class="title">r</span>.<span class="title">RUL</span>.<span class="title">Path</span> 返回一个用来处理给定请求的 <span class="title">handler</span>。</span></span><br><span class="line"><span class="function">// 该函数总是返回一个 非 <span class="title">nil</span> 的 <span class="title">handler</span>，如果 <span class="title">path</span> 不是一个规范格式，则 <span class="title">handler</span> 会</span></span><br><span class="line"><span class="function">// 重定向到其规范 <span class="title">path</span>。<span class="title">Handler</span> 总是返回匹配该请求的的已注册模式；在内建重定向</span></span><br><span class="line"><span class="function">// 处理器的情况下，<span class="title">pattern</span> 会在重定向后进行匹配。如果没有已注册模式可以应用于该请求，</span></span><br><span class="line"><span class="function">// 本方法将返回一个内建的 ”404 <span class="title">page</span> <span class="title">not</span> <span class="title">found</span>” 处理器和一个空字符串模式。</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">Handler</span><span class="params">(r *Request)</span> <span class="params">(h Handler, pattern <span class="keyword">string</span>)</span> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 该函数用于将最接近请求 <span class="title">url</span> 模式的 <span class="title">handler</span> 分配给指定的请求。 </span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">ServeHTTP</span><span class="params">(w ResponseWriter, r *Request)</span></span></span><br></pre></td></tr></table></figure>
<p><code>Handler</code> 接口是 <code>server.go</code> 中最关键的接口，如果我们仔细看这个文件的源代码，将会发现很多结构体实现了这个接口的 <code>ServeHTTP</code> 方法。</p>
<p>注意这个接口的注释：<code>Handler</code> 响应 HTTP 请求。没错，最终我们的 HTTP 服务是通过实现 <code>ServeHTTP(ResponseWriter, *Request)</code> 来达<br>到服务端接收客户端请求并响应。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	http.HandleFunc(<span class="string">"/"</span>, MyHandler)</span><br><span class="line">	_ = http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上两行代码，就成功启动了一个 HTTP 服务器。我们通过 <code>net/http</code> 包源代码分析发现，调用 <code>Http.HandleFunc</code>，按顺序做了几件事：</p>
<ol>
<li><code>Http.HandleFunc</code> 调用了 <code>DefaultServeMux</code> 的 <code>HandleFunc</code></li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandleFunc</span><span class="params">(pattern <span class="keyword">string</span>, handler <span class="keyword">func</span>(ResponseWriter, *Request)</span>)</span> &#123;</span><br><span class="line">    DefaultServeMux.HandleFunc(pattern, handler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><code>DefaultServeMux.HandleFunc</code> 调用了 <code>DefaultServeMux</code> 的 <code>Handle</code>，<code>DefaultServeMux</code> 是一个 <code>ServeMux</code> 指针变量。<br>而 <code>ServeMux</code> 是 Go 语言中的 <code>Multiplexer</code>（多路复用器），通过 <code>Handle</code> 匹配 <code>pattern</code> 和我们定义的 <code>handler</code><br>（其实就是 <code>http.HandlerFunc</code> 函数类型变量）。</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ServeMux <span class="keyword">struct</span> &#123;</span><br><span class="line">	mu    sync.RWMutex</span><br><span class="line">	m     <span class="keyword">map</span>[<span class="keyword">string</span>]muxEntry <span class="comment">// 保存路由规则 和 handler</span></span><br><span class="line">	hosts <span class="keyword">bool</span> <span class="comment">// whether any patterns contain hostnames</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> muxEntry <span class="keyword">struct</span> &#123;</span><br><span class="line">	h       Handler</span><br><span class="line">	pattern <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> DefaultServeMux = &amp;defaultServeMux</span><br><span class="line"><span class="keyword">var</span> defaultServeMux ServeMux</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">HandleFunc</span><span class="params">(pattern <span class="keyword">string</span>, handler <span class="keyword">func</span>(ResponseWriter, *Request)</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> handler == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">"http: nil handler"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	mux.Handle(pattern, HandlerFunc(handler)) <span class="comment">// 这个 handler 就是 MyHandler</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：<br>上面的方法命名 <code>Handle</code>，<code>HandleFunc</code> 和 <code>HandlerFunc</code>，<code>Handler</code>（接口），他们很相似，容易混淆。记住 <strong><code>Handle</code> 和 <code>HandleFunc</code><br>和 <code>pattern</code> 匹配有关，也即往 <code>DefaultServeMux</code> 的 <code>map[string]muxEntry</code> 中增加对应的 <code>handler</code> 和路由规则</strong>。</p>
<p>接着我们看看 <code>MyHandler</code> 的声明和定义：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MyHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	fmt.Fprintf(w, <span class="string">"hello"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而 <code>type HandlerFunc func(ResponseWriter, *Request)</code> 是一个函数类型，而我们定义的 <code>MyHandler</code> 的函数签名刚好符合这个函数类型。</p>
<p>所以 <code>http.HandleFunc(&quot;/&quot;, MyHandler)</code>，实际上是 <code>mux.Handle(&quot;/&quot;, HandlerFunc(MyHandler))</code>。</p>
<p><code>HandlerFunc(MyHandler)</code> 让 <code>MyHandler</code> 成为了 <code>HandlerFunc</code> 类型，我们称 <code>MyHandler</code> 为 <code>handler</code>。而 <code>HandlerFunc</code> 类型是<br>具有 <code>ServeHTTP</code> 方法的，而有了 <code>ServeHTTP</code> 方法也就是实现了 <code>Handler</code> 接口。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f HandlerFunc)</span> <span class="title">ServeHTTP</span><span class="params">(w ResponseWriter, r *Request)</span></span> &#123;</span><br><span class="line">	f(w, r) <span class="comment">// 这相当于自身的调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在 <code>ServeMux</code> 和 <code>Handler</code> 都和我们的 <code>MyHandler</code> 联系上了，<code>MyHandler</code> 是一个 <code>Handler</code> 接口变量也是 <code>HandlerFunc</code> 类型变量，<br>接下来和结构体 <code>server</code> 有关了。</p>
<p>从 <code>http.ListenAndServe</code> 的源码可以看出，它创建了一个 <code>server</code> 对象，并调用 <code>server</code> 对象的 <code>ListenAndServe</code> 方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListenAndServe</span><span class="params">(addr <span class="keyword">string</span>, handler Handler)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    server := &amp;Server&#123;Addr: addr, Handler: handler&#125;</span><br><span class="line">    <span class="keyword">return</span> server.ListenAndServe()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而我们 HTTP 服务器中第二行代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>
<p>创建了一个 <code>server</code> 对象，并调用 <code>server</code> 对象的 <code>ListenAndServe</code> 方法，这里没有直接传递 <code>Handler</code>，而是默认<br>使用 <code>DefautServeMux</code> 作为 <code>multiplexer</code>。</p>
<p><code>Server</code> 的 <code>ListenAndServe</code> 方法中，会初始化监听地址 <code>Addr</code>，同时调用 <code>Listen</code> 方法设置监听。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    rw, e := l.Accept()</span><br><span class="line">    <span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-srv.getDoneChan():</span><br><span class="line">            <span class="keyword">return</span> ErrServerClosed</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ne, ok := e.(net.Error); ok &amp;&amp; ne.Temporary() &#123;</span><br><span class="line">            <span class="keyword">if</span> tempDelay == <span class="number">0</span> &#123;</span><br><span class="line">                tempDelay = <span class="number">5</span> * time.Millisecond</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tempDelay *= <span class="number">2</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> max := <span class="number">1</span> * time.Second; tempDelay &gt; max &#123;</span><br><span class="line">                tempDelay = max</span><br><span class="line">            &#125;</span><br><span class="line">            srv.logf(<span class="string">"http: Accept error: %v; retrying in %v"</span>, e, tempDelay)</span><br><span class="line">            time.Sleep(tempDelay)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> e</span><br><span class="line">    &#125;</span><br><span class="line">    tempDelay = <span class="number">0</span></span><br><span class="line">    c := srv.newConn(rw)</span><br><span class="line">    c.setState(c.rwc, StateNew) <span class="comment">// before Serve can return</span></span><br><span class="line">    <span class="keyword">go</span> c.serve(ctx)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>监听开启之后，一旦客户端请求过来，Go 就开启一个协程 <code>go c.serve(ctx)</code> 处理请求，主要逻辑都在 <code>serve</code> 方法之中。</p>
<p><code>func (c *conn) serve(ctx context.Context)</code>，这个方法很长，里面主要的一句：<code>serverHandler{c.server}.ServeHTTP(w, w.req)</code>。<br>其中 <code>w</code> 由 <code>w, err := c.readRequest(ctx)</code> 得到，因为有传递 <code>context</code>。</p>
<p>还是来看源代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// serverHandler delegates to either the server's Handler or</span></span><br><span class="line"><span class="comment">// DefaultServeMux and also handles "OPTIONS *" requests.</span></span><br><span class="line"><span class="keyword">type</span> serverHandler <span class="keyword">struct</span> &#123;</span><br><span class="line">	srv *Server</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sh serverHandler)</span> <span class="title">ServeHTTP</span><span class="params">(rw ResponseWriter, req *Request)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 此 handler 即为 http.ListenAndServe 中的第二个参数</span></span><br><span class="line">    handler := sh.srv.Handler </span><br><span class="line">    <span class="keyword">if</span> handler == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 如果 handler 为空则使用内部的 DefaultServeMux 进行处理</span></span><br><span class="line">        handler = DefaultServeMux</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> req.RequestURI == <span class="string">"*"</span> &amp;&amp; req.Method == <span class="string">"OPTIONS"</span> &#123;</span><br><span class="line">        handler = globalOptionsHandler&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里就开始处理 http 请求</span></span><br><span class="line">    <span class="comment">// 如果需要使用自定义的 mux，就需要实现 ServeHTTP 方法，即实现 Handler 接口。</span></span><br><span class="line">    <span class="comment">// ServeHTTP(rw, req) 默认情况下是 func (mux *ServeMux) ServeHTTP(w ResponseWriter, r *Request)</span></span><br><span class="line">    handler.ServeHTTP(rw, req)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从 <code>http.ListenAndServe(&quot;:8080&quot;, nil)</code> 开始，<code>handler</code> 是 <code>nil</code>，所以最后实际 <code>ServeHTTP</code> 方法<br>是 <code>DefaultServeMux.ServeHTTP(rw, req)</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">ServeHTTP</span><span class="params">(w ResponseWriter, r *Request)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> r.RequestURI == <span class="string">"*"</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> r.ProtoAtLeast(<span class="number">1</span>, <span class="number">1</span>) &#123;</span><br><span class="line">			w.Header().Set(<span class="string">"Connection"</span>, <span class="string">"close"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		w.WriteHeader(StatusBadRequest)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	h, _ := mux.Handler(r) <span class="comment">// 会匹配路由，h 就是 MyHandler</span></span><br><span class="line">	h.ServeHTTP(w, r) <span class="comment">// 调用自己</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">Handler</span><span class="params">(r *Request)</span> <span class="params">(h Handler, pattern <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// CONNECT requests are not canonicalized.</span></span><br><span class="line">	<span class="keyword">if</span> r.Method == <span class="string">"CONNECT"</span> &#123;</span><br><span class="line">		<span class="comment">// If r.URL.Path is /tree and its handler is not registered,</span></span><br><span class="line">		<span class="comment">// the /tree -&gt; /tree/ redirect applies to CONNECT requests</span></span><br><span class="line">		<span class="comment">// but the path canonicalization does not.</span></span><br><span class="line">		<span class="keyword">if</span> u, ok := mux.redirectToPathSlash(r.URL.Host, r.URL.Path, r.URL); ok &#123;</span><br><span class="line">			<span class="keyword">return</span> RedirectHandler(u.String(), StatusMovedPermanently), u.Path</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> mux.handler(r.Host, r.URL.Path)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// All other requests have any port stripped and path cleaned</span></span><br><span class="line">	<span class="comment">// before passing to mux.handler.</span></span><br><span class="line">	host := stripHostPort(r.Host)</span><br><span class="line">	path := cleanPath(r.URL.Path)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If the given path is /tree and its handler is not registered,</span></span><br><span class="line">	<span class="comment">// redirect for /tree/.</span></span><br><span class="line">	<span class="keyword">if</span> u, ok := mux.redirectToPathSlash(host, path, r.URL); ok &#123;</span><br><span class="line">		<span class="keyword">return</span> RedirectHandler(u.String(), StatusMovedPermanently), u.Path</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> path != r.URL.Path &#123;</span><br><span class="line">		_, pattern = mux.handler(host, path)</span><br><span class="line">		url := *r.URL</span><br><span class="line">		url.Path = path</span><br><span class="line">		<span class="keyword">return</span> RedirectHandler(url.String(), StatusMovedPermanently), pattern</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> mux.handler(host, r.URL.Path)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// handler is the main implementation of Handler.</span></span><br><span class="line"><span class="comment">// The path is known to be in canonical form, except for CONNECT methods.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">handler</span><span class="params">(host, path <span class="keyword">string</span>)</span> <span class="params">(h Handler, pattern <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	mux.mu.RLock()</span><br><span class="line">	<span class="keyword">defer</span> mux.mu.RUnlock()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Host-specific pattern takes precedence over generic ones</span></span><br><span class="line">	<span class="keyword">if</span> mux.hosts &#123;</span><br><span class="line">		h, pattern = mux.match(host + path)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> h == <span class="literal">nil</span> &#123;</span><br><span class="line">		h, pattern = mux.match(path)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> h == <span class="literal">nil</span> &#123;</span><br><span class="line">		h, pattern = NotFoundHandler(), <span class="string">""</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过 <code>func (mux *ServeMux) Handler(r *Request) (h Handler, pattern string)</code>，我们得到 <code>Handler h</code>，然后执<br>行 <code>h.ServeHTTP(w, r)</code> 方法，也就是执行我们的 <code>MyHandler</code> 函数（别忘了 <code>MyHandler</code> 是HandlerFunc类型，而他的 <code>ServeHTTP(w, r)</code><br>方法这里其实就是自己调用自己），把 <code>response</code> 写到 <code>http.ResponseWriter</code> 对象返回给客户端，<code>fmt.Fprintf(w, &quot;hello&quot;)</code>，我们在客<br>户端会接收到 “hello” 。至此整个 HTTP 服务执行完成。</p>
<p>总结下，HTTP 服务整个过程大概是这样：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Request -&gt; ServeMux(Multiplexer) -&gt; handler-&gt; Response</span><br></pre></td></tr></table></figure></p>
<p>我们再看下面代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListenAndServe</span><span class="params">(addr <span class="keyword">string</span>, handler Handler)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    server := &amp;Server&#123;Addr: addr, Handler: handler&#125;</span><br><span class="line">    <span class="keyword">return</span> server.ListenAndServe()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码实际上就是 <code>server.ListenAndServe()</code> 执行的实际效果，只不过简单声明了一个结构体 <code>Server{Addr: addr, Handler: handler}</code> 实例。<br>如果我们声明一个 <code>Server</code> 实例，完全可以达到深度自定义 <code>http.Server</code> 的目的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MyHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	_, _ = fmt.Fprintf(w, <span class="string">"hi"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 更多http.Server的字段可以根据情况初始化</span></span><br><span class="line">	server := http.Server&#123;</span><br><span class="line">		Addr:         <span class="string">":8080"</span>,</span><br><span class="line">		ReadTimeout:  <span class="number">0</span>,</span><br><span class="line">		WriteTimeout: <span class="number">0</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	http.HandleFunc(<span class="string">"/"</span>, MyHandler)</span><br><span class="line">	_ = server.ListenAndServe()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们完全可以根据情况来自定义我们的 <code>Server</code>。</p>
<p>还可以指定 <code>Servemux</code> 的用法:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MyHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	_, _ = fmt.Fprintf(w, <span class="string">"hi"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	mux := http.NewServeMux()</span><br><span class="line"></span><br><span class="line">	mux.HandleFunc(<span class="string">"/"</span>, MyHandler)</span><br><span class="line">	_ = http.ListenAndServe(<span class="string">":8080"</span>, mux)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果既指定 <code>Servemux</code> 又自定义 <code>http.Server</code>，因为 <code>Server</code> 中有字段 <code>Handler</code>，所以我们可以直接把 <code>Servemux</code> 变量作<br>为 <code>Server.Handler</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MyHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	_, _ = fmt.Fprintf(w, <span class="string">"hi"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	server := http.Server&#123;</span><br><span class="line">		Addr:         <span class="string">":8080"</span>,</span><br><span class="line">		ReadTimeout:  <span class="number">0</span>,</span><br><span class="line">		WriteTimeout: <span class="number">0</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	mux := http.NewServeMux()</span><br><span class="line">	server.Handler = mux</span><br><span class="line"></span><br><span class="line">	mux.HandleFunc(<span class="string">"/"</span>, MyHandler)</span><br><span class="line">	_ = server.ListenAndServe()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="自定义处理器"><a href="#自定义处理器" class="headerlink" title="自定义处理器"></a>自定义处理器</h2><p>自定义的 <code>Handler</code>：</p>
<p>标准库 http 提供了 <code>Handler</code> 接口，用于开发者实现自己的 <code>handler</code>。只要实现接口的 <code>ServeHTTP</code> 方法即可。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"log"</span></span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> timeHandler <span class="keyword">struct</span> &#123;</span><br><span class="line">	format <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(th *timeHandler)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	tm := time.Now().Format(th.format)</span><br><span class="line">	_, _ = w.Write([]<span class="keyword">byte</span>(<span class="string">"The time is: "</span> + tm))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	mux := http.NewServeMux()</span><br><span class="line"></span><br><span class="line">	th := &amp;timeHandler&#123;format: time.RFC1123&#125;</span><br><span class="line">	mux.Handle(<span class="string">"/time"</span>, th)</span><br><span class="line"></span><br><span class="line">	log.Println(<span class="string">"Listening..."</span>)</span><br><span class="line">	_ = http.ListenAndServe(<span class="string">":3000"</span>, mux)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们知道，<code>NewServeMux</code> 可以创建一个 <code>ServeMux</code> 实例，<code>ServeMux</code> 同时也实现了 <code>ServeHTTP</code> 方法，因此代码中的 <code>mux</code> 也是<br>一种 <code>handler</code>。把它当成参数传给 <code>http.ListenAndServe</code> 方法，后者会把 <code>mux</code> 传给 <code>Server</code> 实例。因为指定了 <code>handler</code>，<br>因此整个 <code>http</code> 服务就不再是 <code>DefaultServeMux</code>，而是 <code>mux</code>，无论是在注册路由还是提供请求服务的时候。</p>
<p>任何有 <code>func(http.ResponseWriter，*http.Request)</code> 签名的函数都能转化为一个 <code>HandlerFunc</code> 类型。这很有用，因为 <code>HandlerFunc</code> 对象<br>内置了 <code>ServeHTTP</code> 方法，后者可以聪明又方便的调用我们最初提供的函数内容。</p>
<h2 id="中间件-Middleware"><a href="#中间件-Middleware" class="headerlink" title="中间件 Middleware"></a>中间件 Middleware</h2><p>所谓中间件，就是连接上下级不同功能的函数或者软件，通常进行一些包裹函数的行为，为被包裹函数提供添加一些功能或行为。前文的 <code>HandleFunc</code> 就<br>能把签名为 <code>func(w http.ResponseWriter, r *http.Reqeust)</code> 的函数包裹成 <code>handler</code>。这个函数也算是中间件。</p>
<p>Go 的 HTTP 中间件很简单，只要实现一个函数签名为 <code>func(http.Handler) http.Handler</code> 的函数即可。<code>http.Handler</code> 是一个接口，<br>接口方法我们熟悉的为 <code>serveHTTP</code>。返回也是一个 <code>handler</code>。因为 Go 中的函数也可以当成变量传递或者或者返回，因此也可以在中间件函数<br>中传递定义好的函数，只要这个函数是一个 <code>handler</code> 即可，即实现或者被 <code>handlerFunc</code> 包裹成为 <code>handler</code> 处理器。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">index</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    w.Header().Set(<span class="string">"Content-Type"</span>, <span class="string">"text/html"</span>)</span><br><span class="line"></span><br><span class="line">    html := <span class="string">`&lt;doctype html&gt;</span></span><br><span class="line"><span class="string">        &lt;html&gt;</span></span><br><span class="line"><span class="string">        &lt;head&gt;</span></span><br><span class="line"><span class="string">          &lt;title&gt;Hello World&lt;/title&gt;</span></span><br><span class="line"><span class="string">        &lt;/head&gt;</span></span><br><span class="line"><span class="string">        &lt;body&gt;</span></span><br><span class="line"><span class="string">        &lt;p&gt;</span></span><br><span class="line"><span class="string">          Welcome</span></span><br><span class="line"><span class="string">        &lt;/p&gt;</span></span><br><span class="line"><span class="string">        &lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;`</span></span><br><span class="line">    fmt.Fprintln(w, html)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">middlewareHandler</span><span class="params">(next http.Handler)</span> <span class="title">http</span>.<span class="title">Handler</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> http.HandlerFunc(<span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 执行 handler 之前的逻辑</span></span><br><span class="line">        next.ServeHTTP(w, r)</span><br><span class="line">        <span class="comment">// 执行完毕 handler 后的逻辑</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">loggingHandler</span><span class="params">(next http.Handler)</span> <span class="title">http</span>.<span class="title">Handler</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> http.HandlerFunc(<span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">        start := time.Now()</span><br><span class="line">        log.Printf(<span class="string">"Started %s %s"</span>, r.Method, r.URL.Path)</span><br><span class="line">        next.ServeHTTP(w, r)</span><br><span class="line">        log.Printf(<span class="string">"Completed %s in %v"</span>, r.URL.Path, time.Since(start))</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    http.Handle(<span class="string">"/"</span>, loggingHandler(http.HandlerFunc(index)))</span><br><span class="line"></span><br><span class="line">    http.ListenAndServe(<span class="string">":8000"</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="静态站点"><a href="#静态站点" class="headerlink" title="静态站点"></a>静态站点</h2><p>下面代码通过指定目录，作为静态站点：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	http.Handle(<span class="string">"/"</span>, http.FileServer(http.Dir(<span class="string">"D:/html/static/"</span>)))</span><br><span class="line">	_ = http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

        <div id="react-support-footer-root"></div>
      </div>
    </div>
  </div>
</div>

    


    

    <!-- js vendors -->
    <script src="//code.jquery.com/jquery-3.2.1.min.js" crossorigin="anonymous"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/lunr.js/2.1.0/lunr.min.js"></script>

    <!-- js source  -->
    <script src="/golang-learn/script/doc.js"></script>

    

  </body>
</html>
